From gpt-commit-noreply at mail.berlios.de  Mon Dec  3 16:53:38 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 3 Dec 2007 16:53:38 +0100
Subject: [gpt-commit] r406 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712031553.lB3FrcSf023707@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-03 16:53:35 +0100 (Mon, 03 Dec 2007)
New Revision: 406

Added:
   trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm
Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/common/src/Tools.hpp
   trunk/gpt2/gptasm/src/main.cpp
   trunk/gpt2/gptvm/src/CBytecode.cpp
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/main.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
Log:
DEVNULL:
* Melhorias e correcoes no suporte a strings (literais) na VM
* Correcoes no suporte ao tipo real
* Na GptVM, as areas de dados globais e locais foram unificadas


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -79,6 +79,12 @@
    value = getByte(pos);
 }
 
+void CBinString::setByte(const int &pos, const char &value)
+{
+   (*this)[pos] = value;
+}
+
+
 int CBinString::getInt(int pos)
 {
    int result = *((int*)(data()+pos));
@@ -162,6 +168,23 @@
 }
 
 
+void CBinString::pushByte(const char &value)
+{
+   writeByte(value);
+}
+
+
+char CBinString::popByte()
+{
+   int pos = size()-sizeof(char);
+   char result = *((char*)(data()+pos));
+
+   erase(pos,sizeof(char));
+
+   return result;
+}
+
+
 void CBinString::pushReal(const double &value)
 {
    writeReal(value);

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -18,6 +18,7 @@
    void readReal(double &value);
    char getByte(const int &pos);
    void getByte(const int &pos, char &value);
+   void setByte(const int &pos, const char &value);
    int getInt(int pos);
    double getReal(int pos);
    void readString(std::string &value);
@@ -41,6 +42,8 @@
    bool removeIfEqual(const std::string &value);
    std::string getCString(const int &address);
    std::string::find;
+   void pushByte(const char &value);
+   char popByte();
 private:
    void writeData(const void *value, const size_t &size);
 };

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -19,10 +19,10 @@
 const int UNSET_NEG_BIT   = 0xDFFFFFFF; // 11011111 (binario)
 
 #define IS_LOCAL_ADDRESS(address) \
-   (address) & SET_LOCAL_BIT
+   ( (address) & SET_LOCAL_BIT )
 
 #define IS_NEG_ADDRESS(address) \
-   (address) & SET_NEG_BIT
+   ( (address) & SET_NEG_BIT )
 
 enum opcode {
    OP_NOP         = 0,

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -177,48 +177,7 @@
     return str;
 }
 
-/* CRAP!  --felipek
-string& getStringWithTab(string _data, string _tab) {
-	cout << "begin getStringWithTab" << endl;
-	cout << "tab=\"" << _tab << "\"" << endl;
-	cout << "begin datae" << endl;
-	cout << _data << endl;
-	cout << "end datae" << endl;
-	int pos = -1;
- 
-	// test too another new line sequences
-	while( ( pos = _data.find( "\n", pos + 1 ) ) != -1 ) {
-		_data.insert( pos + 1, _tab );
-	}
- 
-	cout << "begin datas" << endl;
-	cout << _data << endl;
-	cout << "end datas" << endl;
-	return( _data );
-}
-*/
 
-bool streamtoken(istringstream& stream, string& key, string& val) {
-     /* FIXME: leak, --felipek */
-     char buffer[8192];
-     unsigned int delim;
-     string entry;
-//     bool ret;
-
-     /* FIXME: ret type, -- felipek */
-     stream.getline(buffer, 8192 - 1);
-     entry = string(buffer);
-     delim = entry.find(' ', 0);
-
-     if (delim != entry.npos) {
-         key = entry.substr(0, delim);
-         val = entry.substr(delim + 1);
-     }
-
-     return !stream.eof();
-}
-
-
 /*const string typeToText(const int &type)
 {
    if (type == PortugolParserTokenTypes::T_INT_LIT) {
@@ -297,21 +256,7 @@
    return 0;
 }
 
-//struct SBits {
-//   int signal : 1;
-//   int localbit : 1;
-//   int others : 30;
-//}
 
-//int setLocalBit(const int &value, const bool &state)
-//{
-//   SBits result;
-//   memcpy(result, value, sizeof(int));
-//  result.localbit = state;
-//
-//   return (int) result;
-//}
-
 int realAddress(int address)
 {
    if (IS_LOCAL_ADDRESS(address)) {
@@ -343,3 +288,29 @@
    return result;
 }
 
+/*
+int sumAddress(int address, int value)
+{
+   bool localAddress = false;
+   bool negAddress = false;
+
+   if (IS_LOCAL_ADDRESS(address)) {
+      address = address & UNSET_LOCAL_BIT;
+      localAddress = true;
+   }
+   if (IS_NEG_ADDRESS(address)) {
+      address = address & UNSET_NEG_BIT;
+      address *= -1;
+      negAddress = true;
+   }
+   address += value;
+   if (localAddress) {
+      address |= SET_LOCAL_BIT;
+   }
+   if (negAddress) {
+      address |= SET_NEG_BIT;
+   }
+   return address;
+}
+*/
+

Modified: trunk/gpt2/common/src/Tools.hpp
===================================================================
--- trunk/gpt2/common/src/Tools.hpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/common/src/Tools.hpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -38,5 +38,6 @@
 int getTypeSize(const int &type);
 int realAddress(int address);
 std::string realAddressString(int address);
+//int sumAddress(int address, int value);
 
 #endif

Modified: trunk/gpt2/gptasm/src/main.cpp
===================================================================
--- trunk/gpt2/gptasm/src/main.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptasm/src/main.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -16,7 +16,7 @@
    int i;
    COptions options;
 
-   cout << "GptAsm, release 0.1.0 (development release)" << endl;
+   cout << "GptAsm - GEPETO - Release 0.1.0 (development release)" << endl;
 
    while ((i = getopt(argc, argv, "h")) != -1) {
       switch (i) {

Added: trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm	2007-12-03 15:53:35 UTC (rev 406)
@@ -0,0 +1,55 @@
+program exemplo
+
+proc main
+    var v string
+
+    salloc v
+
+    sset v, "0"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    sset v, v
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    ssum v, "12", "34"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    ssum v, v, v
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    ssum v, v, "10"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    ssum v, "10", v
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+	
+    pushsv "10"
+    pushst
+    pushiv 1
+    lcall imprima
+	
+    sfree v
+
+    exit 0
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/CBytecode.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -15,7 +15,7 @@
 
 char CBytecode::fetchByte()
 {
-   if (_IP >= size()) {
+   if ((size_t)_IP >= size()) {
       std::cout << "Erro limite em fetchByte()" << std::endl;
       abort();
    }

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -3,6 +3,7 @@
 #include "Common.hpp"
 
 #include "Tools.hpp"
+#include "CSymbol.hpp"
 
 
 
@@ -22,29 +23,53 @@
 
 void CDataStack::setInt(const int &address, const int &value)
 {
-//   std::cout << "setInt ";
    if (IS_LOCAL_ADDRESS(address)) {
-//      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
       CBinString::setInt(_BS + realAddress(address), value);
    } else {
-      std::cout << "ERRO !!! Invocando setInt com global address: " << address << std::endl;
+      CBinString::setInt(realAddress(address), value);
    }
+//   CBinString::setInt(_BS * IS_LOCAL_ADDRESS(address) + realAddress(address), value);
 }
 
 
+
 int CDataStack::getInt(const int &address)
 {
-//   std::cout << "getInt ";
    if (IS_LOCAL_ADDRESS(address)) {
-//      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
       return CBinString::getInt(_BS + realAddress(address));
    } else {
-      std::cout << "ERRO !!! Invocando getInt com global address: " << address << std::endl;
-      return -1;
+      return CBinString::getInt(realAddress(address));
    }
+//   return CBinString::getInt(_BS * IS_LOCAL_ADDRESS(address) + realAddress(address));
 }
 
 
+//void CDataStack::setInt(const int &address, const int &value)
+//{
+////   std::cout << "setInt ";
+//   if (IS_LOCAL_ADDRESS(address)) {
+////      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
+//      CBinString::setInt(_BS + realAddress(address), value);
+//   } else {
+//      std::cout << "ERRO !!! Invocando setInt com global address: " << address << std::endl;
+//   }
+//}
+
+
+
+//int CDataStack::getInt(const int &address)
+//{
+////   std::cout << "getInt ";
+//   if (IS_LOCAL_ADDRESS(address)) {
+////      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
+//      return CBinString::getInt(_BS + realAddress(address));
+//   } else {
+//      std::cout << "ERRO !!! Invocando getInt com global address: " << address << std::endl;
+//      return -1;
+//   }
+//}
+
+
 void CDataStack::pushInt(const int &value)
 {
    CBinString::pushInt(value);
@@ -60,12 +85,27 @@
 }
 
 
+void CDataStack::pushByte(const char &value)
+{
+   CBinString::pushByte(value);
+   _SP+=sizeof(char);
+}
+
+
+char CDataStack::popByte()
+{
+   char result = CBinString::popByte();
+   _SP-=sizeof(char);
+   return result;
+}
+
+
 void CDataStack::setReal(const int &address, const double &value)
 {
    if (IS_LOCAL_ADDRESS(address)) {
       CBinString::setReal(_BS + realAddress(address), value);
    } else {
-      std::cout << "ERRO !!! Invocando setReal com global address: " << address << std::endl;
+      CBinString::setReal(realAddress(address), value);
    }
 }
 
@@ -75,8 +115,7 @@
    if (IS_LOCAL_ADDRESS(address)) {
       return CBinString::getReal(_BS + realAddress(address));
    } else {
-      std::cout << "ERRO !!! Invocando getReal com global address: " << address << std::endl;
-      return -1;
+      return CBinString::getReal(realAddress(address));
    }
 }
 
@@ -96,6 +135,45 @@
 }
 
 
+void CDataStack::setString(int address, const std::string &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      address = _BS + realAddress(address);
+   } else {
+      address = realAddress(address);
+   }
+
+   char type = getByte(address);
+   address++;
+
+   if (type == CSymbol::CONST) {
+      CBinString::setCString(address, value);
+   } else {
+      *((std::string*)(CBinString::getInt(address))) = value;
+   }
+}
+
+
+std::string CDataStack::getString(int address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      address = _BS + realAddress(address);
+   } else {
+      address = realAddress(address);
+   }
+
+   char type = CBinString::getByte(address);
+   address++;
+
+   if (type == CSymbol::CONST) {
+      return CBinString::getCString(address);
+//      return CBinString::getCString(CBinString::getInt(address)+1);
+   } else {
+      return *((std::string*)CBinString::getInt(address));
+   }
+}
+
+
 void CDataStack::pushBytes(const int &number)
 {
    CBinString::pushBytes(number);
@@ -133,3 +211,28 @@
    return _SP;
 }
 
+void CDataStack::readString(std::string &value)
+{
+   CBinString::readString(value);
+   setBS(size());
+}
+
+
+void CDataStack::setByte(const int &address, const char &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      CBinString::setByte(_BS + realAddress(address), value);
+   } else {
+      CBinString::setByte(realAddress(address), value);
+   }
+}
+
+
+char CDataStack::getByte(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return CBinString::getByte(_BS + realAddress(address));
+   } else {
+      return CBinString::getByte(realAddress(address));
+   }
+}

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -24,6 +24,13 @@
    void setSP(const int &value);
    int getBS() const;
    int getSP() const;
+   void readString(std::string &value);
+   std::string getString(int address);
+   void setString(int address, const std::string &value);
+   void setByte(const int &address, const char &value);
+   char getByte(const int &address);
+   void pushByte(const char &value);
+   char popByte();
 private:
    int _BS;
    int _SP; // TODO: SP eh equivalente a size() ???

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -3,7 +3,12 @@
 #include <sstream>
 #include <iostream>
 
+#include "Tools.hpp"
 
+
+// TODO: ao somar dados em address os limites deveriam ser testados
+// TODO: Armazenar todas as strings em memoria com o tamanho na frente ???
+
 CRunBytecode::CRunBytecode()
    : _returnCode(0)
 {
@@ -25,7 +30,9 @@
    _header.readFromBinary(bin) &&
          _symbolTable.readFromBinary(bin);
 
-   bin.readString(_globalData);
+   _dataStack.assign(bin.readString());
+   _dataStack.setBS(_dataStack.size());
+   _dataStack.setSP(_dataStack.size());
 
    _code.assign(bin.readString());
 
@@ -216,8 +223,8 @@
       int boolValue;
       switch (type) {
          case CSymbol::STRING:
-            address += sizeof(int);
-            std::cout << getStringData(_dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT));
+            address += sizeof(char) + sizeof(int);
+            std::cout << _dataStack.getString(address|SET_LOCAL_BIT|SET_NEG_BIT);
             break;
          case CSymbol::INT:
             address += sizeof(int);
@@ -252,43 +259,6 @@
 }
 
 
-//void CRunBytecode::procImprima()
-//{
-//   int argNumber = _dataStack.popInt();
-//
-//   for (int arg=0; arg < argNumber; arg++) {
-//      int type = _dataStack.popInt();
-//      int boolValue;
-//      switch (type) {
-//         case CSymbol::STRING:
-//            std::cout << getStringData(_dataStack.popInt());
-//            break;
-//         case CSymbol::INT:
-//            std::cout << _dataStack.popInt();
-//            break;
-//         case CSymbol::CHAR:
-////            std::cout << (char)_dataStack.popInt();
-//            std::cout << "char [" << (int)_dataStack.popInt() << "]";
-//            break;
-//         case CSymbol::BOOL:
-//            boolValue = _dataStack.popInt();
-//            if (boolValue == 0) {
-//               std::cout << "false";
-//            } else {
-//               std::cout << "true";
-//            }
-//            break;
-//         case CSymbol::REAL:
-//         case CSymbol::MATRIX:
-//         default:
-//            std::cout << "Tipo ainda nao suportado !!!" << std::endl;
-//            abort();
-//      }
-//   }
-//   std::cout << std::endl;
-//}
-
-
 void CRunBytecode::procLeia()
 {
    int type = _dataStack.popInt();
@@ -326,102 +296,6 @@
 }
 
 
-void CRunBytecode::setIntData(const int &address, const int &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      _dataStack.setInt(address, value);
-   } else {
-//      std::cout << "setIntData global address: " << address << std::endl;
-      _globalData.setInt(address, value);
-   }
-}
-
-
-int CRunBytecode::getIntData(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return _dataStack.getInt(address);
-   } else {
-//      std::cout << "global address: " << address << std::endl;
-      return _globalData.getInt(address);
-   }
-}
-
-
-void CRunBytecode::setRealData(const int &address, const double &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      _dataStack.setReal(address, value);
-   } else {
-      _globalData.setReal(address, value);
-   }
-}
-
-
-double CRunBytecode::getRealData(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return _dataStack.getReal(address);
-   } else {
-      return _globalData.getReal(address);
-   }
-}
-
-
-void CRunBytecode::setStringData(const int &address, const std::string &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      char type = _dataStack.getByte(address);
-
-      if (type == CSymbol::CONST) {
-         _dataStack.setCString(address+1, value);
-      } else {
-         *((std::string*)_dataStack.getInt(address+1)) = value;
-      }
-   } else {
-      char type = _globalData.getByte(address);
-
-      if (type == CSymbol::CONST) {
-         _globalData.setCString(address+1, value);
-      } else {
-         *((std::string*)_globalData.getInt(address+1)) = value;
-      }
-   }
-}
-
-
-std::string CRunBytecode::getStringData(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      char type = _dataStack.getByte(address);
-
-      if (type == CSymbol::CONST) {
-         return _dataStack.getCString(address+1);
-      } else {
-         return *((std::string*)_dataStack.getInt(address+1));
-      }
-   } else {
-      char type = _globalData.getByte(address);
-
-      if (type == CSymbol::CONST) {
-         return _globalData.getCString(address+1);
-      } else {
-         return *((std::string*)_globalData.getInt(address+1));
-      }
-   }
-}
-
-//std::string CRunBytecode::getStringData(const int &address)
-//{
-//   if (IS_LOCAL_ADDRESS(address)) {
-//      return _dataStack.getCString(address);
-//   } else {
-////      std::cout << "global address: " << address << std::endl;
-//      return _globalData.getCString(address);
-//   }
-//}
-
-
 /////////////
 // opcodes //
 /////////////
@@ -464,15 +338,15 @@
 
    int address = _code.fetchInt();
 
-   if (_globalData[address] != CSymbol::CONST) {
+   if (_dataStack[address] != CSymbol::CONST) {
       error( "Endereco para lcall deve conter uma string constante !!!" );
    }
 
    address++;
 
-   if (_globalData.getCString(address) == "imprima") {
+   if (_dataStack.getCString(address) == "imprima") {
       procImprima();
-   } else if (_globalData.getCString(address) == "leia") {
+   } else if (_dataStack.getCString(address) == "leia") {
       procLeia();
    } else {
       error("lcall invocando subrotina desconhecida !!!");
@@ -487,7 +361,7 @@
 {
    trace ("exit opcode");
 
-   _returnCode = getIntData(_code.fetchInt());
+   _returnCode = _dataStack.getInt(_code.fetchInt());
    _stop       = true;
 }
 
@@ -525,7 +399,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) + getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) + _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::ssumOpcode()
@@ -536,7 +410,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setStringData(varAddress, getStringData(val1Address) + getStringData(val2Address));
+   _dataStack.setString(varAddress, _dataStack.getString(val1Address) + _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rsumOpcode()
@@ -547,7 +421,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) + getRealData(val2Address));
+   _dataStack.setReal(varAddress, _dataStack.getReal(val1Address) + _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::isubOpcode()
@@ -558,7 +432,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) - getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) - _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::ssubOpcode()
@@ -574,7 +448,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) - getRealData(val2Address));
+   _dataStack.setReal(varAddress, _dataStack.getReal(val1Address) - _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::imulOpcode()
@@ -585,7 +459,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) * getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) * _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::rmulOpcode()
@@ -596,7 +470,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) * getRealData(val2Address));
+   _dataStack.setReal(varAddress, _dataStack.getReal(val1Address) * _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::idivOpcode()
@@ -607,7 +481,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) / getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) / _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::rdivOpcode()
@@ -618,7 +492,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) / getRealData(val2Address));
+   _dataStack.setReal(varAddress, _dataStack.getReal(val1Address) / _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::imodOpcode()
@@ -629,7 +503,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) % getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) % _dataStack.getInt(val2Address));
 }
 
 
@@ -641,7 +515,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) >= getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) >= _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::sgeOpcode()
@@ -652,7 +526,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) >= getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) >= _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rgeOpcode()
@@ -663,7 +537,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) >= getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) >= _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::ileOpcode()
@@ -674,7 +548,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) <= getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) <= _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::sleOpcode()
@@ -685,7 +559,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) <= getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) <= _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rleOpcode()
@@ -696,7 +570,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) <= getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) <= _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::ineOpcode()
@@ -707,7 +581,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) != getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) != _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::sneOpcode()
@@ -718,7 +592,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) != getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) != _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rneOpcode()
@@ -729,7 +603,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) != getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) != _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::igtOpcode()
@@ -740,7 +614,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) > getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) > _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::sgtOpcode()
@@ -751,7 +625,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) > getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) > _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rgtOpcode()
@@ -762,7 +636,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) > getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) > _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::iltOpcode()
@@ -773,7 +647,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) < getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) < _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::sltOpcode()
@@ -784,7 +658,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) < getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) < _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::rltOpcode()
@@ -795,7 +669,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) < getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) < _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::ieqOpcode()
@@ -806,7 +680,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) == getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) == _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::seqOpcode()
@@ -817,7 +691,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getStringData(val1Address) == getStringData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getString(val1Address) == _dataStack.getString(val2Address));
 }
 
 void CRunBytecode::reqOpcode()
@@ -828,7 +702,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getRealData(val1Address) == getRealData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getReal(val1Address) == _dataStack.getReal(val2Address));
 }
 
 void CRunBytecode::orOpcode()
@@ -839,7 +713,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) || getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) || _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::andOpcode()
@@ -850,7 +724,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(val1Address) && getIntData(val2Address));
+   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) && _dataStack.getInt(val2Address));
 }
 
 void CRunBytecode::xorOpcode()
@@ -880,7 +754,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(varAddress) + getIntData(valAddress));
+   _dataStack.setInt(varAddress, _dataStack.getInt(varAddress) + _dataStack.getInt(valAddress));
 }
 
 void CRunBytecode::idecOpcode()
@@ -890,7 +764,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(varAddress) - getIntData(valAddress));
+   _dataStack.setInt(varAddress, _dataStack.getInt(varAddress) - _dataStack.getInt(valAddress));
 }
 
 void CRunBytecode::i2cOpcode()
@@ -920,7 +794,7 @@
    int var1Address = _code.fetchInt();
    int var2Address = _code.fetchInt();
 
-   setRealData(var1Address, (double)getIntData(var2Address));
+   _dataStack.setReal(var1Address, (double)_dataStack.getInt(var2Address));
 }
 
 void CRunBytecode::c2rOpcode()
@@ -995,7 +869,7 @@
    int var1Address = _code.fetchInt();
    int var2Address = _code.fetchInt();
 
-   setIntData(var1Address, (int)getRealData(var2Address));
+   _dataStack.setInt(var1Address, (int)_dataStack.getReal(var2Address));
 }
 
 void CRunBytecode::s2iOpcode()
@@ -1015,7 +889,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   setIntData(varAddress, getIntData(valAddress));
+   _dataStack.setInt(varAddress, _dataStack.getInt(valAddress));
 }
 
 
@@ -1026,7 +900,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   setStringData(varAddress, getStringData(valAddress));
+   _dataStack.setString(varAddress, _dataStack.getString(valAddress));
 }
 
 void CRunBytecode::rsetOpcode()
@@ -1036,7 +910,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(valAddress));
+   _dataStack.setReal(varAddress, _dataStack.getReal(valAddress));
 }
 
 void CRunBytecode::getaOpcode()
@@ -1090,7 +964,7 @@
    int varAddress = _code.fetchInt();
    int labelAddress = _code.fetchInt();
 
-   if (getIntData(varAddress)) {
+   if (_dataStack.getInt(varAddress)) {
       _code.setIP(labelAddress);
    }
 }
@@ -1102,7 +976,7 @@
    int varAddress = _code.fetchInt();
    int labelAddress = _code.fetchInt();
 
-   if (!getIntData(varAddress)) {
+   if (!_dataStack.getInt(varAddress)) {
       _code.setIP(labelAddress);
    }
 }
@@ -1118,7 +992,7 @@
 
    int address = _code.fetchInt();
 
-   setIntData(address, _dataStack.popInt());
+   _dataStack.setInt(address, _dataStack.popInt());
 }
 
 void CRunBytecode::poprvOpcode()
@@ -1127,7 +1001,7 @@
 
    int address = _code.fetchInt();
 
-   setRealData(address, _dataStack.popReal());
+   _dataStack.setReal(address, _dataStack.popReal());
 }
 
 void CRunBytecode::popmvOpcode()
@@ -1140,7 +1014,7 @@
    trace ("incsp opcode");
 
    int valAddress = _code.fetchInt();
-   int size = getIntData(valAddress);
+   int size = _dataStack.getInt(valAddress);
 
    _dataStack.pushBytes(size);
 }
@@ -1149,7 +1023,7 @@
 {
    trace ("decsp opcode");
 
-   int size = getIntData(_code.fetchInt());
+   int size = _dataStack.getInt(_code.fetchInt());
 
    _dataStack.popBytes(size);
 }
@@ -1203,23 +1077,57 @@
 }
 
 
+
 void CRunBytecode::pushsvOpcode()
 {
    trace ("pushsv opcode");
 
    int address = _code.fetchInt();
 
-   _dataStack.pushInt(address);
+   _dataStack.pushByte(CSymbol::VAR);
+
+   std::string *value = new std::string(); // TODO: quando eh desalocado ??? 
+   _dataStack.pushInt((int)value);
+
+   *value = _dataStack.getString(address);
 }
 
 
+//void CRunBytecode::pushsvOpcode()
+//{
+//   // TODO: pushsv nao deveria empilhar uma copia do tipo e endereco da variavel ???
+//   // e como empilhar uma constante global string, uma variavel local e uma variavel global ???
+//   // Acho que sempre que empilhado, tudo deveria virar variavel. Ou seja, para empilhar uma
+//   // constante, deveria ser criado uma variavel string com uma copia da constante.
+//   // Se for empilhar uma variavel entao criar uma string e copiar o valor da outra variavel
+//
+//   trace ("pushsv opcode");
+//
+//   int address = _code.fetchInt();
+//
+////   _dataStack.pushByte(_dataStack.getByte(address));
+//
+//   // Quando uma variavel local eh empilhada o endereco empilhado nao pode ser
+//   // o relativo, mas sim o absoluto (global). Caso contrario qdo a outra funcao
+//   // tentar acessar o endereco ela vai usar o seu BS e nao o BS de quando o 
+//   // endereco foi empilhado
+//
+//   if (IS_LOCAL_ADDRESS(address)) {
+//      _dataStack.pushInt(_dataStack.getBS()+realAddress(address));
+//   } else {
+//      _dataStack.pushInt(address);
+//   }
+//}
+
+
 void CRunBytecode::pushivOpcode()
 {
    trace ("pushiv opcode");
 
    int address = _code.fetchInt();
 
-   _dataStack.pushInt(getIntData(address));
+   // Empilha o conteudo para que o formato dos dados globais e locais sejam o mesmo
+   _dataStack.pushInt(_dataStack.getInt(address));
 }
 
 void CRunBytecode::pushrvOpcode()
@@ -1228,7 +1136,7 @@
 
    int address = _code.fetchInt();
 
-   _dataStack.pushReal(getRealData(address));
+   _dataStack.pushReal(_dataStack.getReal(address));
 }
 
 void CRunBytecode::pushmvOpcode()
@@ -1314,61 +1222,25 @@
    _code.setIP(_executionStack.top());
    _executionStack.pop();
 
-//   _dataStack.setSP(_executionStack.top());
-//   _executionStack.pop();
-
    _dataStack.setBS(_executionStack.top());
    _executionStack.pop();
-
-//   // Ajusta o tamanho correto de _dataStack
-//   _dataStack.resize(_dataStack.getSP());
 }
 
-// TODO: ao inves de termos global e local, quem sabe as globais nao poderiam estar no inicio do que hj sao as locais ?
-// Isso simplificaria e muito a implementacao...
-
 void CRunBytecode::sallocOpcode()
 {
    trace ("salloc opcode");
 
    int address = _code.fetchInt();
 
-   if (IS_LOCAL_ADDRESS(address)) {
-      char type = _dataStack.getByte(address);
+   _dataStack.setByte(address, CSymbol::VAR);
+   char type = _dataStack.getByte(address);
 
-      if (type != CSymbol::VAR) {
-         error( "salloc apenas com variaveis !!!" );
-      }
-
-//      std::string *vvv = new std::string();
-      std::string *value = new std::string();
-      _dataStack.setInt(address+1, (int)value);
-
-
-//      (std::string*)(_dataStack.data()+address+1) = "aaa";
-//      (std::string*)(_dataStack.data()+address+1) = new std::string;
-//      value =  (std::string*)_dataStack.data()+address+1;
-//      *value = "aaa";
-//      *value = new std::string;
-//
-//
-//      std::string *v = new std::string;
-
-//      int x = 1;
-//      (std::string*)x = v;
-//      *(std::string*)(_dataStack.getInt(address+1)) = v;
-//      *((std::string*)_dataStack.getInt(address+1)) = new std::string("");
-   } else {
-      char type = _globalData.getByte(address);
-
-      if (type != CSymbol::VAR) {
-         error( "salloc apenas com variaveis !!!" );
-      }
-
-      std::string *value = new std::string();
-      _globalData.setInt(address+1, (int)value);
-      //*((std::string*)_globalData.getInt(address+1)) = new std::string("");
+   if (type != CSymbol::VAR) {
+      error( "salloc apenas com variaveis !!!" );
    }
+
+   std::string *value = new std::string();
+   _dataStack.setInt(address+1, (int)value);
 }
 
 void CRunBytecode::sfreeOpcode()
@@ -1377,27 +1249,15 @@
 
    int address = _code.fetchInt();
 
-   if (IS_LOCAL_ADDRESS(address)) {
-      char type = _dataStack.getByte(address);
+   char type = _dataStack.getByte(address);
 
-      if (type != CSymbol::VAR) {
-         error( "sfree apenas com variaveis !!!" );
-      }
-
-      std::string *value = (std::string*)_dataStack.getInt(address+1);
-      delete value;
-      _dataStack.setInt(address+1, 0);
-   } else {
-      char type = _globalData.getByte(address);
-
-      if (type != CSymbol::VAR) {
-         error( "sfree apenas com variaveis !!!" );
-      }
-
-      std::string *value = (std::string*)_globalData.getInt(address+1);
-      delete value;
-      _globalData.setInt(address+1, 0);
+   if (type != CSymbol::VAR) {
+      error( "sfree apenas com variaveis !!!" );
    }
+
+   std::string *value = (std::string*)_dataStack.getInt(address+1);
+   delete value;
+   _dataStack.setInt(address+1, 0);
 }
 
 void CRunBytecode::ssetcOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -32,8 +32,8 @@
    void step();
    void procImprima();
    void procLeia();
-   void setIntData(const int &address, const int &value);
-   int  getIntData(const int &address);
+//   void setIntData(const int &address, const int &value);
+//   int  getIntData(const int &address);
    void setRealData(const int &address, const double &value);
    double getRealData(const int &address);
    void setStringData(const int &address, const std::string &value);
@@ -165,15 +165,15 @@
    void mgetSize2Opcode();
 
 
-   CHeader       _header;
-   CSymbolTable  _symbolTable;
-   CBinString    _globalData;
-   CBytecode     _code;
-   OpcodePointer _opcodePointer[OPCODE_NUMBER];
-   bool          _stop;
-   int           _returnCode;
-   CDataStack    _dataStack;
-   std::stack<int>   _executionStack;
+   CHeader         _header;
+   CSymbolTable    _symbolTable;
+//   CBinString      _globalData;
+   CBytecode       _code;
+   OpcodePointer   _opcodePointer[OPCODE_NUMBER];
+   bool            _stop;
+   int             _returnCode;
+   CDataStack      _dataStack;
+   std::stack<int> _executionStack;
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/main.cpp
===================================================================
--- trunk/gpt2/gptvm/src/main.cpp	2007-11-30 18:58:48 UTC (rev 405)
+++ trunk/gpt2/gptvm/src/main.cpp	2007-12-03 15:53:35 UTC (rev 406)
@@ -15,7 +15,7 @@
    int i;
    COptions options;
 
-   cout << "GptVM, release 0.1.0 (development release)" << endl;
+   cout << "GptVM - GEPETO - Release 0.1.0 (development release)" << endl;
 
    while ((i = getopt(argc, argv, "h")) != -1) {
       switch (i) {

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Mon Dec  3 22:50:40 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 3 Dec 2007 22:50:40 +0100
Subject: [gpt-commit] r407 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712032150.lB3Loe1Q005846@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-03 22:50:36 +0100 (Mon, 03 Dec 2007)
New Revision: 407

Added:
   trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/CSymbol.cpp
   trunk/gpt2/common/src/CSymbol.hpp
   trunk/gpt2/common/src/CSymbolTable.cpp
   trunk/gpt2/common/src/CSymbolTable.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/common/src/Tools.hpp
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/CData.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* Suporte a estruturas (tipo byte) no GptASM e GptVM
* Enderecamento com igetv e isetv


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -235,7 +235,7 @@
 }
 
 
-void CBinString::popBytes(const int &number)
+void CBinString::discardBytes(const int &number)
 {
    int pos = size()-number;
    erase(pos,number);
@@ -293,3 +293,29 @@
    }
 }
 
+
+void CBinString::setBytes(const int &address, const std::string &value)
+{
+   replace(address, value.size(), value);
+}
+
+
+std::string CBinString::getBytes(const int &address, const int &size)
+{
+   return substr(address, size);
+}
+
+
+void CBinString::pushBytes(const std::string &value)
+{
+   append(value);
+}
+
+
+std::string CBinString::popBytes(const int &sizeToPop)
+{
+   std::string result = substr(size()-sizeToPop, sizeToPop);
+   erase(size()-sizeToPop, sizeToPop);
+   return result;
+}
+

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -36,7 +36,7 @@
    void pushCString(const std::string &value);
    std::string popCString();
    void pushBytes(const int &number);
-   void popBytes(const int &number);
+   void discardBytes(const int &number);
    bool removeIfEqual(const int &value);
    bool removeIfEqual(const char &value);
    bool removeIfEqual(const std::string &value);
@@ -44,6 +44,10 @@
    std::string::find;
    void pushByte(const char &value);
    char popByte();
+   void setBytes(const int &address, const std::string &value);
+   std::string getBytes(const int &address, const int &size);
+   void pushBytes(const std::string &value);
+   std::string popBytes(const int &size);
 private:
    void writeData(const void *value, const size_t &size);
 };

Modified: trunk/gpt2/common/src/CSymbol.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CSymbol.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -10,23 +10,25 @@
 }
 
 
-CSymbol::CSymbol (const int &scope, const std::string &name, const char &type, const char &category, const int &address)
+CSymbol::CSymbol (const int &scope, const std::string &name, const char &type, int size, const char &category, const int &address)
    : _scope(scope)
    , _name(name)
    , _type(type)
+   , _size(size)
    , _category(category)
    , _address(address)
 {
 }
 
 
-CSymbol::CSymbol (const std::string &name, const char &type, 
+CSymbol::CSymbol (const std::string &name, const char &type,
                   const int &address, const bool &hasVarArguments, 
                   const int &staticParameters, 
                   std::vector<CSymbol> parameters)
    : _scope(GLOBAL)
    , _name(name)
    , _type(type)
+   , _size(0)
    , _category(PROC)
    , _address(address)
    , _hasVarArguments(hasVarArguments)
@@ -43,7 +45,8 @@
 
 int CSymbol::getTypeSize() const
 {
-   return ::getTypeSize(_type);
+//   return ::getTypeSize(_type);
+   return _size;
 }
 
 
@@ -55,12 +58,14 @@
 
    if (_category == CSymbol::VAR || _category == CSymbol::CONST) {
       bin.readByte(_type);
+      bin.readInt(_size);
       bin.readString(_name);
 //      std::cout << "var ou const, type=" << _type << " name=" << _name << std::endl;
    } else { // PROC
       bool _hasVariableArguments;// TODO
       char _staticParameters;// TODO
       bin.readByte(_type);
+      bin.readInt(_size);
       bin.readString(_name);
       bin.readBool(_hasVariableArguments);
       bin.readByte(_staticParameters);

Modified: trunk/gpt2/common/src/CSymbol.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CSymbol.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -24,13 +24,14 @@
       STRING  = 'S',
       INT     = 'I',
       CHAR    = 'C',
-      BOOL    = 'B',
+      LOGICAL = 'L',
       REAL    = 'R',
       MATRIX  = 'M',
-      POINTER = 'P'
+      POINTER = 'P',
+      BYTE    = 'B'
    };
    CSymbol ();
-   CSymbol (const int &scope, const std::string &name, const char &type, 
+   CSymbol (const int &scope, const std::string &name, const char &type, int size,
             const char &category, const int &address);
    CSymbol (const std::string &name, const char &type, const int &address,
             const bool &hasVarArguments, const int &staticParameters,
@@ -74,6 +75,7 @@
    int                  _scope;
    std::string          _name;
    char                 _type;
+   int                  _size;
    char                 _category;
    int                  _address;
    bool                 _hasVarArguments;

Modified: trunk/gpt2/common/src/CSymbolTable.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CSymbolTable.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -27,6 +27,7 @@
    writeInt( address );
    writeByte( CSymbol::PROC ); // procedure
    writeByte( type ); // tipo do retorno // TODO: em asm proc tem retorno ???
+   writeInt( 0 ); // size
    writeString( name ); // nome da procedure
    writeBool( hasVarArguments );
    writeByte( staticParameters );
@@ -36,10 +37,14 @@
 }
 
 
-CSymbol* CSymbolTable::addParameter (const std::string &name, const int &type, const int &address)
+CSymbol* CSymbolTable::addParameter (const std::string &name, const int &type, int size, const int &address)
 {
-   CSymbol *symbol = new CSymbol(CSymbol::LOCAL, name, type, CSymbol::PARAM, address|SET_LOCAL_BIT|SET_NEG_BIT);
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
 
+   CSymbol *symbol = new CSymbol(CSymbol::LOCAL, name, type, size, CSymbol::PARAM, address|SET_LOCAL_BIT|SET_NEG_BIT);
+
    _symbols.push_back(symbol);
 
    //_data += symbol->getBinary();
@@ -48,10 +53,14 @@
 }
 
 
-CSymbol* CSymbolTable::addConstant (const std::string &name, const int &type, const int &address)
+CSymbol* CSymbolTable::addConstant (const std::string &name, const int &type, int size, const int &address)
 {
-   CSymbol *symbol = new CSymbol(CSymbol::GLOBAL, name, type, CSymbol::CONST, address);
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
 
+   CSymbol *symbol = new CSymbol(CSymbol::GLOBAL, name, type, size, CSymbol::CONST, address);
+
    _symbols.push_back(symbol);
 
    // Endere?o 0000 (data), constante, string, 8 bytes ???, nome "c1"
@@ -59,20 +68,25 @@
    writeInt( address );
    writeByte( CSymbol::CONST ); // categoria: constante
    writeByte( type );           // tipo
+   writeInt( size );            // tamanho
    writeString( name );         // nome da constante
 
    return symbol;
 }
 
 
-CSymbol* CSymbolTable::addVariable (const int &scope, const std::string &name, const int &type, const int &address)
+CSymbol* CSymbolTable::addVariable (const int &scope, const std::string &name, const int &type, int size, const int &address)
 {
    CSymbol *symbol = NULL;
 
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
+
    if (scope == CSymbol::GLOBAL) {
-      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address);
+      symbol = new CSymbol(scope, name, type, size, CSymbol::VAR, address);
    } else {
-      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address | SET_LOCAL_BIT);
+      symbol = new CSymbol(scope, name, type, size, CSymbol::VAR, address | SET_LOCAL_BIT);
    }
 
    _symbols.push_back(symbol);
@@ -83,6 +97,7 @@
       writeInt( address );
       writeByte( CSymbol::VAR ); // categoria: variavel
       writeByte( type );         // tipo
+      writeInt( size );          // tamanho
       writeString( name );       // nome da variavel
    }
 

Modified: trunk/gpt2/common/src/CSymbolTable.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/CSymbolTable.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -14,9 +14,9 @@
    CSymbolTable();
    ~CSymbolTable();
    CSymbol* addProcedure (const std::string &name, const int &type, const int &address, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
-   CSymbol* addParameter (const std::string &name, const int &type, const int &address);
-   CSymbol* addConstant (const std::string &name, const int &type, const int &address);
-   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, const int &address);
+   CSymbol* addParameter (const std::string &name, const int &type, int size, const int &address);
+   CSymbol* addConstant (const std::string &name, const int &type, int size, const int &address);
+   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, int size, const int &address);
    CSymbol* add(CSymbol *symbol);
    bool readFromBinary(CBinString &bin);
    void clearLocalSymbols();

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -39,112 +39,115 @@
    OP_IDIV        = 11,
    OP_RDIV        = 12,
    OP_IMOD        = 13,
-   OP_IGE         = 15,
-   OP_SGE         = 16,
-   OP_RGE         = 17,
-   OP_ILE         = 18,
-   OP_SLE         = 19,
-   OP_RLE         = 20,
-   OP_INE         = 21,
-   OP_SNE         = 22,
-   OP_RNE         = 23,
-   OP_IGT         = 24,
-   OP_SGT         = 25,
-   OP_RGT         = 26,
-   OP_ILT         = 27,
-   OP_SLT         = 28,
-   OP_RLT         = 29,
-   OP_IEQ         = 30,
-   OP_SEQ         = 31,
-   OP_REQ         = 32,
-   OP_OR          = 33,
-   OP_AND         = 34,
-   OP_XOR         = 35,
-   OP_INEG        = 36,
-   OP_RNEG        = 37,
-   OP_NOT         = 38,
-   OP_IINC        = 39,
-   OP_IDEC        = 40,
-   OP_I2C         = 41,
-   OP_R2C         = 42,
-   OP_S2C         = 43,
-   OP_B2C         = 44,
-   OP_I2R         = 45,
-   OP_C2R         = 46,
-   OP_S2R         = 47,
-   OP_B2R         = 48,
-   OP_I2B         = 49,
-   OP_C2B         = 50,
-   OP_R2B         = 51,
-   OP_S2B         = 52,
-   OP_I2S         = 53,
-   OP_C2S         = 54,
-   OP_R2S         = 55,
-   OP_B2S         = 56,
-   OP_P2S         = 57,
-   OP_C2I         = 58,
-   OP_R2I         = 59,
-   OP_S2I         = 60,
-   OP_B2I         = 61,
-   OP_ISET        = 62,
-   OP_SSET        = 63,
-   OP_RSET        = 64,
-   OP_GETA        = 65,
-   OP_IGETV       = 66,
-   OP_SGETV       = 67,
-   OP_RGETV       = 68,
-   OP_ISETV       = 69,
-   OP_SSETV       = 70,
-   OP_RSETV       = 71,
-   OP_JMP         = 72,
-   OP_IF          = 73,
-   OP_IFNOT       = 74,
-   OP_INCSP       = 77,
-   OP_DECSP       = 78,
-   OP_PUSHIV      = 79,
-   OP_PUSHSV      = 80,
-   OP_PUSHRV      = 81,
-   OP_PUSHMV      = 84,
-   OP_INCSP_4     = 87,
-   OP_INCSP_8     = 88,
-   OP_DECSP_4     = 89,
-   OP_DECSP_8     = 90,
-   OP_PCALL       = 91,
-   OP_RET         = 92,
-   OP_LCALL       = 93,
-   OP_SALLOC      = 94,
-   OP_SFREE       = 95,
-   OP_SSETC       = 96,
-   OP_SGETC       = 97,
-   OP_M1ALLOC     = 98,
-   OP_M2ALLOC     = 99,
-   OP_MFREE       = 100,
-   OP_M1SET       = 101,
-   OP_M1GET       = 102,
-   OP_M2SET       = 103,
-   OP_M2GET       = 104,
-   OP_MCOPY       = 105,
-   OP_MGETSIZE1   = 106,
-   OP_MGETSIZE2   = 107,
-   OP_PUSHIT      = 108,
-   OP_PUSHST      = 109,
-   OP_PUSHRT      = 110,
-   OP_PUSHCT      = 111,
-   OP_PUSHBT      = 112,
-   OP_PUSHMT      = 113,
-   OP_POPIV       = 114,
-   OP_POPRV       = 115,
-   OP_POPSV       = 116,
-   OP_POPMV       = 117,
-   OP_PUSH_0      = 118,
-   OP_PUSH_1      = 119,
-   OP_PUSH_2      = 120,
-   OP_PUSH_3      = 121,
-   OP_PUSH_4      = 122,
-   OP_PUSH_5      = 123,
-   OP_EXIT_0      = 124,
-   OP_EXIT_1      = 125,
-   OPCODE_NUMBER  = 125
+   OP_IGE         = 14,
+   OP_SGE         = 15,
+   OP_RGE         = 16,
+   OP_ILE         = 17,
+   OP_SLE         = 18,
+   OP_RLE         = 19,
+   OP_INE         = 20,
+   OP_SNE         = 21,
+   OP_RNE         = 22,
+   OP_IGT         = 23,
+   OP_SGT         = 24,
+   OP_RGT         = 25,
+   OP_ILT         = 26,
+   OP_SLT         = 27,
+   OP_RLT         = 28,
+   OP_IEQ         = 29,
+   OP_SEQ         = 30,
+   OP_REQ         = 31,
+   OP_OR          = 32,
+   OP_AND         = 33,
+   OP_XOR         = 34,
+   OP_INEG        = 35,
+   OP_RNEG        = 36,
+   OP_NOT         = 37,
+   OP_IINC        = 38,
+   OP_IDEC        = 39,
+   OP_I2C         = 40,
+   OP_R2C         = 41,
+   OP_S2C         = 42,
+   OP_B2C         = 43,
+   OP_I2R         = 44,
+   OP_C2R         = 45,
+   OP_S2R         = 46,
+   OP_B2R         = 47,
+   OP_I2B         = 48,
+   OP_C2B         = 49,
+   OP_R2B         = 50,
+   OP_S2B         = 51,
+   OP_I2S         = 52,
+   OP_C2S         = 53,
+   OP_R2S         = 54,
+   OP_B2S         = 55,
+   OP_P2S         = 56,
+   OP_C2I         = 57,
+   OP_R2I         = 58,
+   OP_S2I         = 59,
+   OP_B2I         = 60,
+   OP_ISET        = 61,
+   OP_SSET        = 62,
+   OP_RSET        = 63,
+   OP_GETA        = 64,
+   OP_IGETV       = 65,
+   OP_SGETV       = 66,
+   OP_RGETV       = 67,
+   OP_ISETV       = 68,
+   OP_SSETV       = 69,
+   OP_RSETV       = 70,
+   OP_JMP         = 71,
+   OP_IF          = 72,
+   OP_IFNOT       = 73,
+   OP_INCSP       = 74,
+   OP_DECSP       = 75,
+   OP_PUSHIV      = 76,
+   OP_PUSHSV      = 77,
+   OP_PUSHRV      = 78,
+   OP_PUSHBV      = 79,
+   OP_PUSHMV      = 80,
+   OP_INCSP_4     = 81,
+   OP_INCSP_8     = 82,
+   OP_DECSP_4     = 83,
+   OP_DECSP_8     = 84,
+   OP_PCALL       = 85,
+   OP_RET         = 86,
+   OP_LCALL       = 87,
+   OP_SALLOC      = 88,
+   OP_SFREE       = 89,
+   OP_SSETC       = 90,
+   OP_SGETC       = 91,
+   OP_M1ALLOC     = 92,
+   OP_M2ALLOC     = 93,
+   OP_MFREE       = 94,
+   OP_M1SET       = 95,
+   OP_M1GET       = 96,
+   OP_M2SET       = 97,
+   OP_M2GET       = 98,
+   OP_MCOPY       = 99,
+   OP_MGETSIZE1   = 100,
+   OP_MGETSIZE2   = 101,
+   OP_PUSHIT      = 102,
+   OP_PUSHST      = 103,
+   OP_PUSHRT      = 104,
+   OP_PUSHCT      = 105,
+   OP_PUSHLT      = 106,
+   OP_PUSHBT      = 107,
+   OP_PUSHMT      = 108,
+   OP_POPIV       = 109,
+   OP_POPRV       = 110,
+   OP_POPSV       = 111,
+   OP_POPBV       = 112,
+   OP_POPMV       = 113,
+   OP_PUSH_0      = 114,
+   OP_PUSH_1      = 115,
+   OP_PUSH_2      = 116,
+   OP_PUSH_3      = 117,
+   OP_PUSH_4      = 118,
+   OP_PUSH_5      = 119,
+   OP_EXIT_0      = 120,
+   OP_EXIT_1      = 121,
+   OPCODE_NUMBER  = 121
 };
 
 #endif

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -244,7 +244,7 @@
    switch(type) {
    case CSymbol::INT:
    case CSymbol::CHAR:
-   case CSymbol::BOOL:
+   case CSymbol::LOGICAL:
       return sizeof(int);
    case CSymbol::REAL:
       return sizeof(double);
@@ -288,7 +288,6 @@
    return result;
 }
 
-/*
 int sumAddress(int address, int value)
 {
    bool localAddress = false;
@@ -305,12 +304,11 @@
    }
    address += value;
    if (localAddress) {
-      address |= SET_LOCAL_BIT;
+      address = abs(address) | SET_LOCAL_BIT;
    }
    if (negAddress) {
-      address |= SET_NEG_BIT;
+      address = abs(address) | SET_NEG_BIT;
    }
    return address;
 }
-*/
 

Modified: trunk/gpt2/common/src/Tools.hpp
===================================================================
--- trunk/gpt2/common/src/Tools.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/common/src/Tools.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -38,6 +38,6 @@
 int getTypeSize(const int &type);
 int realAddress(int address);
 std::string realAddressString(int address);
-//int sumAddress(int address, int value);
+int sumAddress(int address, int value);
 
 #endif

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -1,4 +1,5 @@
 #include "CData.hpp"
+#include "Tools.hpp"
 
 
 CData::CData()
@@ -19,10 +20,14 @@
 }
 
 
-CSymbol* CData::addVariable (const int &scope, const std::string &name, const int &type, const int &address)
+CSymbol* CData::addVariable (const int &scope, const std::string &name, const int &type, int size, const int &address)
 {
-   CSymbol *symbol = new CSymbol (scope, name, type, CSymbol::VAR, address);
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
 
+   CSymbol *symbol = new CSymbol (scope, name, type, size, CSymbol::VAR, address);
+
    _symbols.push_back(symbol);
 
    if (type == CSymbol::STRING) {
@@ -40,10 +45,14 @@
 }
 
 
-CSymbol* CData::addConstant (const std::string &name, const int &type, const int &address)
+CSymbol* CData::addConstant (const std::string &name, const int &type, int size, const int &address)
 {
-   CSymbol *symbol = new CSymbol (CSymbol::GLOBAL, name, type, CSymbol::CONST, address);
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
 
+   CSymbol *symbol = new CSymbol (CSymbol::GLOBAL, name, type, size, CSymbol::CONST, address);
+
    _symbols.push_back(symbol);
 
    //_data += symbol->getBinary();

Modified: trunk/gpt2/gptasm/src/CData.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/CData.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -13,8 +13,8 @@
    CData();
    ~CData();
    CSymbol* add(CSymbol *symbol);
-   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, const int &address);
-   CSymbol* addConstant (const std::string &name, const int &type, const int &address);
+   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, int size, const int &address);
+   CSymbol* addConstant (const std::string &name, const int &type, int size, const int &address);
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -85,6 +85,8 @@
    _opcodes[ "ifnot"       ] = OP_IFNOT;
    _opcodes[ "popiv"       ] = OP_POPIV;
    _opcodes[ "poprv"       ] = OP_POPRV;
+   _opcodes[ "popsv"       ] = OP_POPSV;
+   _opcodes[ "popbv"       ] = OP_POPBV;
    _opcodes[ "popmv"       ] = OP_POPMV;
    _opcodes[ "incsp"       ] = OP_INCSP;
    _opcodes[ "decsp"       ] = OP_DECSP;
@@ -97,11 +99,13 @@
    _opcodes[ "pushiv"      ] = OP_PUSHIV;
    _opcodes[ "pushsv"      ] = OP_PUSHSV;
    _opcodes[ "pushrv"      ] = OP_PUSHRV;
+   _opcodes[ "pushbv"      ] = OP_PUSHBV;
    _opcodes[ "pushmv"      ] = OP_PUSHMV;
    _opcodes[ "pushit"      ] = OP_PUSHIT;
    _opcodes[ "pushst"      ] = OP_PUSHST;
    _opcodes[ "pushrt"      ] = OP_PUSHRT;
    _opcodes[ "pushct"      ] = OP_PUSHCT;
+   _opcodes[ "pushlt"      ] = OP_PUSHLT;
    _opcodes[ "pushbt"      ] = OP_PUSHBT;
    _opcodes[ "pushmt"      ] = OP_PUSHMT;
    _opcodes[ "incsp_4"     ] = OP_INCSP_4;
@@ -161,28 +165,35 @@
 }
 
 
-void CGenBytecode::makeVarDefinition(const std::string &lexeme, const int &type)
+void CGenBytecode::makeVarDefinition(const std::string &lexeme, const int &type, int size)
 {
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
+
    if (_currentProcedure.empty()) {
       // variavel global
-      _symbolTable.addVariable (CSymbol::GLOBAL, lexeme, type, _data.getDataSize());
-      std::cout << "var global " << lexeme << " address " << _data.getDataSize() << std::endl;
-      _data.addVariable (CSymbol::GLOBAL, lexeme, type, _data.getDataSize());
+      _symbolTable.addVariable (CSymbol::GLOBAL, lexeme, type, size, _data.getDataSize());
+      std::cout << "var global " << lexeme << " size " << size << " address " << _data.getDataSize() << std::endl;
+      _data.addVariable (CSymbol::GLOBAL, lexeme, type, size, _data.getDataSize());
    } else {
       // variavel local
-      CSymbol *symbol = _symbolTable.addVariable (CSymbol::LOCAL, lexeme, type, _currentSP);
-      std::cout << "var local " << lexeme << " address " << _currentSP << std::endl;
+      CSymbol *symbol = _symbolTable.addVariable (CSymbol::LOCAL, lexeme, type, size,  _currentSP);
+      std::cout << "var local " << lexeme << " size " << size << " address " << _currentSP << std::endl;
       _currentSP += symbol->getTypeSize();
       // gera incsp XXX
       _code.writeByte(OP_INCSP);
-      addAddress(itoa(symbol->getTypeSize()), CSymbol::CONST, CSymbol::INT);
+      addAddress(itoa(symbol->getTypeSize()), CSymbol::CONST, CSymbol::INT, size);
    }
 }
 
 
-void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
+void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type, int size)
 {
-   _parameters.push_back(std::pair<std::string,int>(lexeme, type));
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
+   _parameters.push_back(SParameter(lexeme, type, size));
 //   _parametersSize += getTypeSize(type);
 //   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
 //   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
@@ -193,10 +204,11 @@
 void CGenBytecode::finishParDefinition()
 {
    _currentSP = 0;
-   for (std::list<std::pair<std::string,int> >::reverse_iterator par = _parameters.rbegin();
+   for (std::list<SParameter>::reverse_iterator par = _parameters.rbegin();
          par != _parameters.rend(); par++) {
-      _currentSP -= getTypeSize(par->second);
-      CSymbol *symbol = _symbolTable.addParameter(par->first, par->second, abs(_currentSP));
+      _currentSP -= par->_size;
+//      _currentSP -= getTypeSize(par->second);
+      CSymbol *symbol = _symbolTable.addParameter(par->_name, par->_type, par->_size, abs(_currentSP));
 //      std::cout << "par " << par->first << " address " << _currentSP << std::endl;
       std::cout << "param=" << symbol->getName() << " address=" << symbol->getAddress() << std::endl;
       std::cout << "\t" << realAddressString(symbol->getAddress()) << std::endl;
@@ -238,11 +250,14 @@
 }
 
 
-void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type)
+void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type, int size)
 {
+   if (size == 0) {
+      size = getTypeSize(type);
+   }
    int address = _symbolTable.getAddress(id);
    if (address == -1) {
-      address = _data.addConstant (id, type, _data.getDataSize())->getAddress();
+      address = _data.addConstant (id, type, size, _data.getDataSize())->getAddress();
    }
    _code.writeInt(address);
 }

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -10,6 +10,18 @@
 #include "CData.hpp"
 #include "CBinString.hpp"
 
+struct SParameter
+{
+   std::string _name;
+   int         _type;
+   int         _size;
+   SParameter(std::string name, int type, int size)
+      : _name(name)
+      , _type(type)
+      , _size(size)
+   { }
+};
+
 class CGenBytecode
 {
 public:
@@ -17,12 +29,12 @@
    ~CGenBytecode();
    void initProcedure(const std::string &procedureName, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
    void finishProcedure();
-   void makeVarDefinition(const std::string &lexeme, const int &type);
-   void makeParDefinition(const std::string &lexeme, const int &type);
+   void makeVarDefinition(const std::string &lexeme, const int &type, int size);
+   void makeParDefinition(const std::string &lexeme, const int &type, int size);
    void finishParDefinition();
    void registryLabel(const std::string &labelName);
    void addOpcode(const std::string &mn);
-   void addAddress(const std::string &id, const int &category, const int &type);
+   void addAddress(const std::string &id, const int &category, const int &type, int size = 0);
    CBinString getBinary();
    void unsolvedLabel(const std::string &label);
    void translateLabelsToAddress();
@@ -38,7 +50,8 @@
 //   int                        _parametersSize;
    std::list<std::pair<std::string, int> > _unsolvedLabels;
    std::map<std::string, int> _solvedLabels;
-   std::list<std::pair<std::string, int> > _parameters;
+//   std::list<std::pair<std::string,int> > _parameters;
+   std::list<SParameter> _parameters;
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-03 21:50:36 UTC (rev 407)
@@ -35,6 +35,7 @@
    T_KW_BOOL="bool";
    T_KW_POINTER="pointer";
    T_KW_MATRIX="matrix";
+   T_KW_BYTE="byte";
    T_KW_PROC="proc";
    T_KW_ENDPROC="endproc";
    T_KW_PARAM="param";
@@ -113,6 +114,7 @@
    T_KW_POPIV="popiv";
    T_KW_POPSV="popsv";
    T_KW_POPRV="poprv";
+   T_KW_POPBV="popbv";
    T_KW_POPMV="popmv";
    T_KW_INCSP="incsp";
    T_KW_DECSP="decsp";
@@ -125,11 +127,13 @@
    T_KW_PUSHIV="pushiv";
    T_KW_PUSHSV="pushsv";
    T_KW_PUSHRV="pushrv";
+   T_KW_PUSHBV="pushbv";
    T_KW_PUSHMV="pushmv";
    T_KW_PUSHIT="pushit";
    T_KW_PUSHST="pushst";
    T_KW_PUSHRT="pushrt";
    T_KW_PUSHCT="pushct";
+   T_KW_PUSHLT="pushlt";
    T_KW_PUSHBT="pushbt";
    T_KW_PUSHMT="pushmt";
    T_KW_INCSP_4="incsp_4";
@@ -282,6 +286,21 @@
 //  : '.'
 //  ;
 
+T_ABREC
+options {
+  paraphrase = "'['";
+}
+  : '['
+  ;
+
+T_FECHAC
+options {
+  paraphrase = "']'";
+}
+  : ']'
+  ;
+
+
 T_WS_ : (' '
    | '\t'
    | '\n' { newline(); }

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-03 21:50:36 UTC (rev 407)
@@ -76,21 +76,23 @@
 //---------------
 {
   char tk_type;
+  int byteSize = 0;
 }
-  : "var" tk_id:T_ID tk_type=primitive_type
-    { bytecode.makeVarDefinition(tk_id->getText(), tk_type); }
+  : "var" tk_id:T_ID tk_type=primitive_type[byteSize]
+    { bytecode.makeVarDefinition(tk_id->getText(), tk_type, byteSize); }
   ;
 
 //--------------------------------
-  primitive_type returns [char ret]
+  primitive_type [int &byteSize] returns [char ret]
 //--------------------------------
   : "int"     {ret=CSymbol::INT;    }
   | "real"    {ret=CSymbol::REAL;   }
   | "char"    {ret=CSymbol::CHAR;   }
   | "string"  {ret=CSymbol::STRING; }
-  | "bool"    {ret=CSymbol::BOOL;   }
+  | "bool"    {ret=CSymbol::LOGICAL;   }
   | "pointer" {ret=CSymbol::POINTER;}
   | "matrix"  {ret=CSymbol::MATRIX; }
+  | "byte"    T_ABREC T_INT_VALUE {byteSize = atoi(getLastTokenText().c_str());} T_FECHAC {ret=CSymbol::BYTE; }
   ;
 
 //#################################
@@ -116,9 +118,10 @@
 //---------------------
 {
   int tk_type;
+  int byteSize = 0;
 }
-  : "param" ("ref")? tk_id:T_ID tk_type=primitive_type
-    { bytecode.makeParDefinition(tk_id->getText(), tk_type); }
+  : "param" ("ref")? tk_id:T_ID tk_type=primitive_type[byteSize]
+    { bytecode.makeParDefinition(tk_id->getText(), tk_type, byteSize); }
   ;
 
 //#####################
@@ -218,7 +221,7 @@
       identifier T_COMMA identifier
    |  ("igetv"|"sgetv"|"rgetv")
       {bytecode.addOpcode(getLastTokenText());}
-      identifier T_COMMA element T_COLON element
+      identifier T_COMMA identifier T_COLON element
    |  ("isetv"|"ssetv"|"rsetv")
       {bytecode.addOpcode(getLastTokenText());}
       identifier T_COLON element T_COMMA element
@@ -241,12 +244,24 @@
    :  ("pushiv"|"pushsv"|"pushrv"|"pushmv")
       {bytecode.addOpcode(getLastTokenText());}
       element
-   |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushmt")
+   |  "pushbv"
       {bytecode.addOpcode(getLastTokenText());}
-//   |  "pop"
+      element
+      T_COMMA
+      T_INT_VALUE
+      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
+   |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushlt"|"pushbt"|"pushmt")
+      {bytecode.addOpcode(getLastTokenText());}
    |  ("popiv"|"popsv"|"poprv"|"popmv")
       {bytecode.addOpcode(getLastTokenText());}
       identifier
+   |  "popbv"
+      {bytecode.addOpcode(getLastTokenText());}
+      identifier
+      T_COMMA
+      T_INT_VALUE
+      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
    |  ("incsp"|"decsp")
       {bytecode.addOpcode(getLastTokenText());}
       T_INT_VALUE

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-03 21:50:36 UTC (rev 407)
@@ -1,6 +1,6 @@
 program exemplo
 
-//var c byte[8] // sizeof c
+var c byte[8] // sizeof c
 
 proc main
     var t1 int

Added: trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-03 21:50:36 UTC (rev 407)
@@ -0,0 +1,46 @@
+program exemplo
+
+var c byte[8] // sizeof c
+
+proc main
+    // c.x := 10;
+    isetv c:0, 10 // *( c + 0 ) := 10
+
+    // c.y := 20;
+    isetv c:4, 20 // *(c + 4 ) := 20
+
+    pushbv c, 8
+    pcall exibe
+
+    exit_0
+endproc
+
+proc exibe
+    param est byte[8]
+
+    var t1 int
+
+    // imprima( "est.x=", est.x );
+    igetv t1, est:0 // t1 := *( est + 0)
+    pushiv t1
+    pushit
+    pushsv "est.x="
+    pushst
+    push_2
+    lcall imprima
+
+    // imprima( "est.y=", est.y );
+    igetv t1, est:4 // t1 := *(est + 4)
+    pushiv t1
+    pushit
+    pushsv "est.y="
+    pushst
+    push_2
+    lcall imprima
+
+    decsp 12
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-03 21:50:36 UTC (rev 407)
@@ -8,17 +8,17 @@
     iset v, v
 
     pushiv true
-    pushbt
+    pushlt
     pushiv 1
     lcall imprima
 
     pushiv false
-    pushbt
+    pushlt
     pushiv 1
     lcall imprima
 
     pushiv v
-    pushbt
+    pushlt
     pushiv 1
     lcall imprima
 

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -135,6 +135,41 @@
 }
 
 
+void CDataStack::setBytes(const int &address, const std::string &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      CBinString::setBytes(_BS + realAddress(address), value);
+   } else {
+      CBinString::setBytes(realAddress(address), value);
+   }
+}
+
+
+void CDataStack::pushBytes(const std::string &value)
+{
+   CBinString::pushBytes(value);
+   _SP+=value.size();
+}
+
+
+std::string CDataStack::popBytes(const int &size)
+{
+   std::string result = CBinString::popBytes(size);
+   _SP-=size;
+   return result;
+}
+
+
+std::string CDataStack::getBytes(const int &address, const int &size)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return CBinString::getBytes(_BS + realAddress(address), size);
+   } else {
+      return CBinString::getBytes(realAddress(address), size);
+   }
+}
+
+
 void CDataStack::setString(int address, const std::string &value)
 {
    if (IS_LOCAL_ADDRESS(address)) {
@@ -181,7 +216,7 @@
 }
 
 
-void CDataStack::popBytes(const int &number)
+void CDataStack::discardBytes(const int &number)
 {
    CBinString::popBytes(number);
    _SP -= number;

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -18,8 +18,12 @@
    double getReal(const int &address);
    void pushReal(const double &value);
    double popReal();
+   void setBytes(const int &address, const std::string &value);
+   std::string getBytes(const int &address, const int &size);
+   void pushBytes(const std::string &value);
+   std::string popBytes(const int &size);
    void pushBytes(const int &number);
-   void popBytes(const int &number);
+   void discardBytes(const int &number);
    void setBS(const int &value);
    void setSP(const int &value);
    int getBS() const;

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -128,6 +128,7 @@
    _opcodePointer[OP_POPSV      ] = &CRunBytecode::popsvOpcode;
    _opcodePointer[OP_POPIV      ] = &CRunBytecode::popivOpcode;
    _opcodePointer[OP_POPRV      ] = &CRunBytecode::poprvOpcode;
+   _opcodePointer[OP_POPBV      ] = &CRunBytecode::popbvOpcode;
    _opcodePointer[OP_POPMV      ] = &CRunBytecode::popmvOpcode;
    _opcodePointer[OP_INCSP      ] = &CRunBytecode::incspOpcode;
    _opcodePointer[OP_DECSP      ] = &CRunBytecode::decspOpcode;
@@ -140,12 +141,14 @@
    _opcodePointer[OP_PUSHSV     ] = &CRunBytecode::pushsvOpcode;
    _opcodePointer[OP_PUSHIV     ] = &CRunBytecode::pushivOpcode;
    _opcodePointer[OP_PUSHRV     ] = &CRunBytecode::pushrvOpcode;
+   _opcodePointer[OP_PUSHBV     ] = &CRunBytecode::pushbvOpcode;
    _opcodePointer[OP_PUSHMV     ] = &CRunBytecode::pushmvOpcode;
 
    _opcodePointer[OP_PUSHST     ] = &CRunBytecode::pushstOpcode;
    _opcodePointer[OP_PUSHIT     ] = &CRunBytecode::pushitOpcode;
    _opcodePointer[OP_PUSHRT     ] = &CRunBytecode::pushrtOpcode;
    _opcodePointer[OP_PUSHCT     ] = &CRunBytecode::pushctOpcode;
+   _opcodePointer[OP_PUSHLT     ] = &CRunBytecode::pushltOpcode;
    _opcodePointer[OP_PUSHBT     ] = &CRunBytecode::pushbtOpcode;
    _opcodePointer[OP_PUSHMT     ] = &CRunBytecode::pushmtOpcode;
 
@@ -235,7 +238,7 @@
             address += sizeof(int);
             std::cout << "char [" << (int)_dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT) << "]";
             break;
-         case CSymbol::BOOL:
+         case CSymbol::LOGICAL:
             address += sizeof(int);
             boolValue = _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
             if (boolValue == 0) {
@@ -255,7 +258,7 @@
       }
    }
    std::cout << std::endl;
-   _dataStack.popBytes(address);
+   _dataStack.discardBytes(address);
 }
 
 
@@ -342,7 +345,7 @@
       error( "Endereco para lcall deve conter uma string constante !!!" );
    }
 
-   address++;
+   address=sumAddress(address,1);
 
    if (_dataStack.getCString(address) == "imprima") {
       procImprima();
@@ -920,7 +923,13 @@
 
 void CRunBytecode::igetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("igetv opcode");
+
+   int resultAddress = _code.fetchInt();
+   int varAddress    = _code.fetchInt();
+   int offset        = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.setInt(resultAddress, _dataStack.getInt(sumAddress(varAddress,offset)));
 }
 
 void CRunBytecode::sgetvOpcode()
@@ -935,7 +944,13 @@
 
 void CRunBytecode::isetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("isetv opcode");
+
+   int varAddress    = _code.fetchInt();
+   int offset        = _dataStack.getInt(_code.fetchInt());
+   int value         = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.setInt(sumAddress(varAddress,offset), value);
 }
 
 void CRunBytecode::ssetvOpcode()
@@ -1004,6 +1019,16 @@
    _dataStack.setReal(address, _dataStack.popReal());
 }
 
+void CRunBytecode::popbvOpcode()
+{
+   trace ("popbv opcode");
+
+   int varAddress  = _code.fetchInt();
+   int sizeAddress = _code.fetchInt();
+
+   _dataStack.setBytes(varAddress, _dataStack.popBytes(_dataStack.getInt(sizeAddress)));
+}
+
 void CRunBytecode::popmvOpcode()
 {
    invalidOpcode(__FUNCTION__);
@@ -1025,7 +1050,7 @@
 
    int size = _dataStack.getInt(_code.fetchInt());
 
-   _dataStack.popBytes(size);
+   _dataStack.discardBytes(size);
 }
 
 
@@ -1139,6 +1164,16 @@
    _dataStack.pushReal(_dataStack.getReal(address));
 }
 
+void CRunBytecode::pushbvOpcode()
+{
+   trace ("pushbv opcode");
+
+   int varAddress  = _code.fetchInt();
+   int sizeAddress = _code.fetchInt();
+
+   _dataStack.pushBytes(_dataStack.getBytes(varAddress, _dataStack.getInt(sizeAddress)));
+}
+
 void CRunBytecode::pushmvOpcode()
 {
    invalidOpcode(__FUNCTION__);
@@ -1172,11 +1207,18 @@
    _dataStack.pushInt(CSymbol::CHAR);
 }
 
+void CRunBytecode::pushltOpcode()
+{
+   trace ("pushlt opcode");
+
+   _dataStack.pushInt(CSymbol::LOGICAL);
+}
+
 void CRunBytecode::pushbtOpcode()
 {
    trace ("pushbt opcode");
 
-   _dataStack.pushInt(CSymbol::BOOL);
+   _dataStack.pushInt(CSymbol::BYTE);
 }
 
 void CRunBytecode::pushmtOpcode()
@@ -1240,7 +1282,7 @@
    }
 
    std::string *value = new std::string();
-   _dataStack.setInt(address+1, (int)value);
+   _dataStack.setInt(sumAddress(address,1), (int)value);
 }
 
 void CRunBytecode::sfreeOpcode()
@@ -1250,14 +1292,15 @@
    int address = _code.fetchInt();
 
    char type = _dataStack.getByte(address);
+   address=sumAddress(address,1);
 
    if (type != CSymbol::VAR) {
       error( "sfree apenas com variaveis !!!" );
    }
 
-   std::string *value = (std::string*)_dataStack.getInt(address+1);
+   std::string *value = (std::string*)_dataStack.getInt(address);
    delete value;
-   _dataStack.setInt(address+1, 0);
+   _dataStack.setInt(address, 0);
 }
 
 void CRunBytecode::ssetcOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-03 15:53:35 UTC (rev 406)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-03 21:50:36 UTC (rev 407)
@@ -122,6 +122,7 @@
    void popsvOpcode();
    void popivOpcode();
    void poprvOpcode();
+   void popbvOpcode();
    void popmvOpcode();
    void incspOpcode();
    void decspOpcode();
@@ -134,12 +135,14 @@
    void pushsvOpcode();
    void pushivOpcode();
    void pushrvOpcode();
+   void pushbvOpcode();
    void pushmvOpcode();
 
    void pushstOpcode();
    void pushitOpcode();
    void pushrtOpcode();
    void pushctOpcode();
+   void pushltOpcode();
    void pushbtOpcode();
    void pushmtOpcode();
 

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Tue Dec  4 12:37:51 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 4 Dec 2007 12:37:51 +0100
Subject: [gpt-commit] r408 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712041137.lB4BbpwY015338@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-04 12:37:49 +0100 (Tue, 04 Dec 2007)
New Revision: 408

Modified:
   trunk/gpt2/common/src/CSymbol.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* Troca de prefixos/sufixos de opcodes
  - B indica BOOL
  - D indica DATA
* Estruturas sao definidas com o tipo data


Modified: trunk/gpt2/common/src/CSymbol.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.hpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/common/src/CSymbol.hpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -24,11 +24,11 @@
       STRING  = 'S',
       INT     = 'I',
       CHAR    = 'C',
-      LOGICAL = 'L',
+      BOOL    = 'B',
       REAL    = 'R',
+      DATA    = 'D',
       MATRIX  = 'M',
-      POINTER = 'P',
-      BYTE    = 'B'
+      POINTER = 'P'
    };
    CSymbol ();
    CSymbol (const int &scope, const std::string &name, const char &type, int size,

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -104,7 +104,7 @@
    OP_PUSHIV      = 76,
    OP_PUSHSV      = 77,
    OP_PUSHRV      = 78,
-   OP_PUSHBV      = 79,
+   OP_PUSHDV      = 79,
    OP_PUSHMV      = 80,
    OP_INCSP_4     = 81,
    OP_INCSP_8     = 82,
@@ -131,13 +131,13 @@
    OP_PUSHST      = 103,
    OP_PUSHRT      = 104,
    OP_PUSHCT      = 105,
-   OP_PUSHLT      = 106,
-   OP_PUSHBT      = 107,
+   OP_PUSHBT      = 106,
+   OP_PUSHDT      = 107,
    OP_PUSHMT      = 108,
    OP_POPIV       = 109,
    OP_POPRV       = 110,
    OP_POPSV       = 111,
-   OP_POPBV       = 112,
+   OP_POPDV       = 112,
    OP_POPMV       = 113,
    OP_PUSH_0      = 114,
    OP_PUSH_1      = 115,

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -239,12 +239,12 @@
 }
 */
 
-int getTypeSize(const int &type)
+int getTypeSize(const int &type) // TODO: para o tipo DATA essa funcao deveria receber o size tambem...
 {
    switch(type) {
    case CSymbol::INT:
    case CSymbol::CHAR:
-   case CSymbol::LOGICAL:
+   case CSymbol::BOOL:
       return sizeof(int);
    case CSymbol::REAL:
       return sizeof(double);

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -86,7 +86,7 @@
    _opcodes[ "popiv"       ] = OP_POPIV;
    _opcodes[ "poprv"       ] = OP_POPRV;
    _opcodes[ "popsv"       ] = OP_POPSV;
-   _opcodes[ "popbv"       ] = OP_POPBV;
+   _opcodes[ "popdv"       ] = OP_POPDV;
    _opcodes[ "popmv"       ] = OP_POPMV;
    _opcodes[ "incsp"       ] = OP_INCSP;
    _opcodes[ "decsp"       ] = OP_DECSP;
@@ -99,14 +99,14 @@
    _opcodes[ "pushiv"      ] = OP_PUSHIV;
    _opcodes[ "pushsv"      ] = OP_PUSHSV;
    _opcodes[ "pushrv"      ] = OP_PUSHRV;
-   _opcodes[ "pushbv"      ] = OP_PUSHBV;
+   _opcodes[ "pushdv"      ] = OP_PUSHDV;
    _opcodes[ "pushmv"      ] = OP_PUSHMV;
    _opcodes[ "pushit"      ] = OP_PUSHIT;
    _opcodes[ "pushst"      ] = OP_PUSHST;
    _opcodes[ "pushrt"      ] = OP_PUSHRT;
    _opcodes[ "pushct"      ] = OP_PUSHCT;
-   _opcodes[ "pushlt"      ] = OP_PUSHLT;
    _opcodes[ "pushbt"      ] = OP_PUSHBT;
+   _opcodes[ "pushdt"      ] = OP_PUSHDT;
    _opcodes[ "pushmt"      ] = OP_PUSHMT;
    _opcodes[ "incsp_4"     ] = OP_INCSP_4;
    _opcodes[ "incsp_8"     ] = OP_INCSP_8;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-04 11:37:49 UTC (rev 408)
@@ -35,7 +35,7 @@
    T_KW_BOOL="bool";
    T_KW_POINTER="pointer";
    T_KW_MATRIX="matrix";
-   T_KW_BYTE="byte";
+   T_KW_DATA="data";
    T_KW_PROC="proc";
    T_KW_ENDPROC="endproc";
    T_KW_PARAM="param";
@@ -114,7 +114,7 @@
    T_KW_POPIV="popiv";
    T_KW_POPSV="popsv";
    T_KW_POPRV="poprv";
-   T_KW_POPBV="popbv";
+   T_KW_POPDV="popdv";
    T_KW_POPMV="popmv";
    T_KW_INCSP="incsp";
    T_KW_DECSP="decsp";
@@ -127,14 +127,14 @@
    T_KW_PUSHIV="pushiv";
    T_KW_PUSHSV="pushsv";
    T_KW_PUSHRV="pushrv";
-   T_KW_PUSHBV="pushbv";
+   T_KW_PUSHDV="pushdv";
    T_KW_PUSHMV="pushmv";
    T_KW_PUSHIT="pushit";
    T_KW_PUSHST="pushst";
    T_KW_PUSHRT="pushrt";
    T_KW_PUSHCT="pushct";
-   T_KW_PUSHLT="pushlt";
    T_KW_PUSHBT="pushbt";
+   T_KW_PUSHDT="pushdt";
    T_KW_PUSHMT="pushmt";
    T_KW_INCSP_4="incsp_4";
    T_KW_INCSP_8="incsp_8";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-04 11:37:49 UTC (rev 408)
@@ -89,10 +89,10 @@
   | "real"    {ret=CSymbol::REAL;   }
   | "char"    {ret=CSymbol::CHAR;   }
   | "string"  {ret=CSymbol::STRING; }
-  | "bool"    {ret=CSymbol::LOGICAL;   }
+  | "bool"    {ret=CSymbol::BOOL;   }
   | "pointer" {ret=CSymbol::POINTER;}
   | "matrix"  {ret=CSymbol::MATRIX; }
-  | "byte"    T_ABREC T_INT_VALUE {byteSize = atoi(getLastTokenText().c_str());} T_FECHAC {ret=CSymbol::BYTE; }
+  | "data"    T_ABREC T_INT_VALUE {byteSize = atoi(getLastTokenText().c_str());} T_FECHAC {ret=CSymbol::DATA; }
   ;
 
 //#################################
@@ -244,19 +244,19 @@
    :  ("pushiv"|"pushsv"|"pushrv"|"pushmv")
       {bytecode.addOpcode(getLastTokenText());}
       element
-   |  "pushbv"
+   |  "pushdv"
       {bytecode.addOpcode(getLastTokenText());}
       element
       T_COMMA
       T_INT_VALUE
       { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
       // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
-   |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushlt"|"pushbt"|"pushmt")
+   |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushdt"|"pushmt")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("popiv"|"popsv"|"poprv"|"popmv")
       {bytecode.addOpcode(getLastTokenText());}
       identifier
-   |  "popbv"
+   |  "popdv"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-04 11:37:49 UTC (rev 408)
@@ -1,6 +1,6 @@
 program exemplo
 
-var c byte[8] // sizeof c
+var c data[8] // sizeof c
 
 proc main
     var t1 int

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-04 11:37:49 UTC (rev 408)
@@ -1,6 +1,6 @@
 program exemplo
 
-var c byte[8] // sizeof c
+var c data[8] // sizeof c
 
 proc main
     // c.x := 10;
@@ -9,14 +9,14 @@
     // c.y := 20;
     isetv c:4, 20 // *(c + 4 ) := 20
 
-    pushbv c, 8
+    pushdv c, 8
     pcall exibe
 
     exit_0
 endproc
 
 proc exibe
-    param est byte[8]
+    param est data[8]
 
     var t1 int
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-04 11:37:49 UTC (rev 408)
@@ -8,17 +8,17 @@
     iset v, v
 
     pushiv true
-    pushlt
+    pushbt
     pushiv 1
     lcall imprima
 
     pushiv false
-    pushlt
+    pushbt
     pushiv 1
     lcall imprima
 
     pushiv v
-    pushlt
+    pushbt
     pushiv 1
     lcall imprima
 

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -128,7 +128,7 @@
    _opcodePointer[OP_POPSV      ] = &CRunBytecode::popsvOpcode;
    _opcodePointer[OP_POPIV      ] = &CRunBytecode::popivOpcode;
    _opcodePointer[OP_POPRV      ] = &CRunBytecode::poprvOpcode;
-   _opcodePointer[OP_POPBV      ] = &CRunBytecode::popbvOpcode;
+   _opcodePointer[OP_POPDV      ] = &CRunBytecode::popdvOpcode;
    _opcodePointer[OP_POPMV      ] = &CRunBytecode::popmvOpcode;
    _opcodePointer[OP_INCSP      ] = &CRunBytecode::incspOpcode;
    _opcodePointer[OP_DECSP      ] = &CRunBytecode::decspOpcode;
@@ -141,15 +141,15 @@
    _opcodePointer[OP_PUSHSV     ] = &CRunBytecode::pushsvOpcode;
    _opcodePointer[OP_PUSHIV     ] = &CRunBytecode::pushivOpcode;
    _opcodePointer[OP_PUSHRV     ] = &CRunBytecode::pushrvOpcode;
-   _opcodePointer[OP_PUSHBV     ] = &CRunBytecode::pushbvOpcode;
+   _opcodePointer[OP_PUSHDV     ] = &CRunBytecode::pushdvOpcode;
    _opcodePointer[OP_PUSHMV     ] = &CRunBytecode::pushmvOpcode;
 
    _opcodePointer[OP_PUSHST     ] = &CRunBytecode::pushstOpcode;
    _opcodePointer[OP_PUSHIT     ] = &CRunBytecode::pushitOpcode;
    _opcodePointer[OP_PUSHRT     ] = &CRunBytecode::pushrtOpcode;
    _opcodePointer[OP_PUSHCT     ] = &CRunBytecode::pushctOpcode;
-   _opcodePointer[OP_PUSHLT     ] = &CRunBytecode::pushltOpcode;
    _opcodePointer[OP_PUSHBT     ] = &CRunBytecode::pushbtOpcode;
+   _opcodePointer[OP_PUSHDT     ] = &CRunBytecode::pushdtOpcode;
    _opcodePointer[OP_PUSHMT     ] = &CRunBytecode::pushmtOpcode;
 
    _opcodePointer[OP_INCSP_4     ] = &CRunBytecode::incsp_4Opcode;
@@ -238,7 +238,7 @@
             address += sizeof(int);
             std::cout << "char [" << (int)_dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT) << "]";
             break;
-         case CSymbol::LOGICAL:
+         case CSymbol::BOOL:
             address += sizeof(int);
             boolValue = _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
             if (boolValue == 0) {
@@ -251,6 +251,7 @@
             address += sizeof(double);
             std::cout << _dataStack.getReal(address|SET_LOCAL_BIT|SET_NEG_BIT);
             break;
+         case CSymbol::DATA:
          case CSymbol::MATRIX:
          default:
             std::cout << "Tipo ainda nao suportado !!!" << std::endl;
@@ -1019,9 +1020,9 @@
    _dataStack.setReal(address, _dataStack.popReal());
 }
 
-void CRunBytecode::popbvOpcode()
+void CRunBytecode::popdvOpcode()
 {
-   trace ("popbv opcode");
+   trace ("popdv opcode");
 
    int varAddress  = _code.fetchInt();
    int sizeAddress = _code.fetchInt();
@@ -1164,9 +1165,9 @@
    _dataStack.pushReal(_dataStack.getReal(address));
 }
 
-void CRunBytecode::pushbvOpcode()
+void CRunBytecode::pushdvOpcode()
 {
-   trace ("pushbv opcode");
+   trace ("pushdv opcode");
 
    int varAddress  = _code.fetchInt();
    int sizeAddress = _code.fetchInt();
@@ -1207,18 +1208,18 @@
    _dataStack.pushInt(CSymbol::CHAR);
 }
 
-void CRunBytecode::pushltOpcode()
+void CRunBytecode::pushbtOpcode()
 {
-   trace ("pushlt opcode");
+   trace ("pushbt opcode");
 
-   _dataStack.pushInt(CSymbol::LOGICAL);
+   _dataStack.pushInt(CSymbol::BOOL);
 }
 
-void CRunBytecode::pushbtOpcode()
+void CRunBytecode::pushdtOpcode()
 {
-   trace ("pushbt opcode");
+   trace ("pushdt opcode");
 
-   _dataStack.pushInt(CSymbol::BYTE);
+   _dataStack.pushInt(CSymbol::DATA);
 }
 
 void CRunBytecode::pushmtOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-03 21:50:36 UTC (rev 407)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-04 11:37:49 UTC (rev 408)
@@ -122,7 +122,7 @@
    void popsvOpcode();
    void popivOpcode();
    void poprvOpcode();
-   void popbvOpcode();
+   void popdvOpcode();
    void popmvOpcode();
    void incspOpcode();
    void decspOpcode();
@@ -135,15 +135,15 @@
    void pushsvOpcode();
    void pushivOpcode();
    void pushrvOpcode();
-   void pushbvOpcode();
+   void pushdvOpcode();
    void pushmvOpcode();
 
    void pushstOpcode();
    void pushitOpcode();
    void pushrtOpcode();
    void pushctOpcode();
-   void pushltOpcode();
    void pushbtOpcode();
+   void pushdtOpcode();
    void pushmtOpcode();
 
    void incsp_4Opcode();

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Tue Dec  4 12:57:29 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 4 Dec 2007 12:57:29 +0100
Subject: [gpt-commit] r409 - in trunk/gpt2: gptasm/test/wikki gptvm/src
Message-ID: <200712041157.lB4BvTMc008706@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-04 12:57:22 +0100 (Tue, 04 Dec 2007)
New Revision: 409

Added:
   trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
Modified:
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
Log:
DEVNUL:
* Implementado opcodes de enderecamento para os tipos real e string


Added: trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-04 11:37:49 UTC (rev 408)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-04 11:57:22 UTC (rev 409)
@@ -0,0 +1,47 @@
+program exemplo
+
+var c data[12] // sizeof real + sizeof int
+
+proc main
+    // c.x := 10.2;
+    rsetv c:0, 10.2 // *( c + 0 ) := 10.2
+
+    // c.y := 20;
+    isetv c:8, 20 // *(c + 4 ) := 20
+
+    pushdv c, 12
+    pcall exibe
+
+    exit_0
+endproc
+
+proc exibe
+    param est data[12]
+
+    var t1 real
+    var t2 int
+
+    // imprima( "est.x=", est.x );
+    rgetv t1, est:0 // t1 := *( est + 0)
+    pushrv t1
+    pushrt
+    pushsv "est.x="
+    pushst
+    push_2
+    lcall imprima
+
+    // imprima( "est.y=", est.y );
+    igetv t2, est:8 // t2 := *(est + 8)
+    pushiv t2
+    pushit
+    pushsv "est.y="
+    pushst
+    push_2
+    lcall imprima
+
+    decsp 20
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 11:37:49 UTC (rev 408)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 11:57:22 UTC (rev 409)
@@ -935,12 +935,24 @@
 
 void CRunBytecode::sgetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sgetv opcode");
+
+   int resultAddress = _code.fetchInt();
+   int varAddress    = _code.fetchInt();
+   int offset        = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.setBytes(resultAddress, _dataStack.getBytes(sumAddress(varAddress,offset), 5));
 }
 
 void CRunBytecode::rgetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rgetv opcode");
+
+   int resultAddress = _code.fetchInt();
+   int varAddress    = _code.fetchInt();
+   int offset        = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.setReal(resultAddress, _dataStack.getReal(sumAddress(varAddress,offset)));
 }
 
 void CRunBytecode::isetvOpcode()
@@ -956,12 +968,24 @@
 
 void CRunBytecode::ssetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ssetv opcode");
+
+   int varAddress    = _code.fetchInt();
+   int offset        = _dataStack.getInt(_code.fetchInt());
+   int valueAddress  = _code.fetchInt();
+
+   _dataStack.setBytes(sumAddress(varAddress,offset), _dataStack.getBytes(valueAddress, 5));
 }
 
 void CRunBytecode::rsetvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rsetv opcode");
+
+   int varAddress = _code.fetchInt();
+   int offset     = _dataStack.getInt(_code.fetchInt());
+   double value   = _dataStack.getReal(_code.fetchInt());
+
+   _dataStack.setReal(sumAddress(varAddress,offset), value);
 }
 
 void CRunBytecode::jmpOpcode()



From gpt-commit-noreply at mail.berlios.de  Tue Dec  4 15:10:49 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 4 Dec 2007 15:10:49 +0100
Subject: [gpt-commit] r410 - in trunk/gpt2: gptasm/test/wikki gptvm/src
	gptvm/test/gerados_pelo_gptasm
Message-ID: <200712041410.lB4EAn81001521@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-04 15:10:49 +0100 (Tue, 04 Dec 2007)
New Revision: 410

Added:
   trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
Modified:
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
Log:
DEVNULL:
* Suporte a matrizes de uma dimensao (vetores) parcialmente implementado
  - Falta o opcode popmv


Added: trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm	2007-12-04 11:57:22 UTC (rev 409)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm	2007-12-04 14:10:49 UTC (rev 410)
@@ -0,0 +1,59 @@
+program exemplo
+
+var m matrix
+var i int
+
+proc main
+    var t1 int
+
+    // aloca espa?o para a matriz m
+    // m armazena dados de 4 bytes e tem 10 elementos iniciais
+    m1alloc m, 4, 10
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste:
+    ile t1, i, 9
+    ifnot t1, proximo
+
+    // m[i] := i * 10;
+    imul t1, i, 10
+    m1set m, i, t1
+
+    // fim-para
+    iinc i, 1
+    jmp teste
+    proximo:
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste2:
+    ile t1, i, 9
+    ifnot t1, proximo2
+
+    // imprima( m[i] );
+    m1get t1, m, i
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // fim-para
+    iinc i, 1
+    jmp teste2
+    proximo2:
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-04 11:57:22 UTC (rev 409)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-04 14:10:49 UTC (rev 410)
@@ -0,0 +1,69 @@
+program exemplo
+
+var m matrix
+var i int
+
+proc main
+    var t1 int
+
+    // aloca espa?o para a matriz m
+    // m armazena dados de 4 bytes e tem 10 elementos iniciais
+    m1alloc m, 4, 10
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste:
+    ile t1, i, 9
+    ifnot t1, proximo
+
+    // m[i] := i * 10;
+    imul t1, i, 10
+    m1set m, i, t1
+
+    // fim-para
+    iinc i, 1
+    jmp teste
+    proximo:
+
+    pushmv m
+    pcall mostra
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+proc mostra
+    param mat matrix
+    var t1 int
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste2:
+    ile t1, i, 9
+    ifnot t1, proximo2
+
+    // imprima( mat[i] );
+    m1get t1, mat, i
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // fim-para
+    iinc i, 1
+    jmp teste2
+    proximo2:
+
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-04 11:57:22 UTC (rev 409)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-04 14:10:49 UTC (rev 410)
@@ -271,3 +271,14 @@
       return CBinString::getByte(realAddress(address));
    }
 }
+
+
+void *CDataStack::getPointer(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return (void*)(data() + _BS + realAddress(address));
+   } else {
+      return (void*)(data() + realAddress(address));
+   }
+}
+

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-04 11:57:22 UTC (rev 409)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-04 14:10:49 UTC (rev 410)
@@ -35,6 +35,7 @@
    char getByte(const int &address);
    void pushByte(const char &value);
    char popByte();
+   void *getPointer(const int &address);
 private:
    int _BS;
    int _SP; // TODO: SP eh equivalente a size() ???

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 11:57:22 UTC (rev 409)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 14:10:49 UTC (rev 410)
@@ -1056,7 +1056,21 @@
 
 void CRunBytecode::popmvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("popmv opcode");
+
+   char *matrix    = (char*) _dataStack.getInt(_code.fetchInt());
+
+   char *retMatrix = (char*) _dataStack.popInt();
+   int elementSize = *((int*)(retMatrix+0));
+   int elements    = *((int*)(retMatrix+sizeof(int)));
+
+   int size = sizeof(int) + sizeof(int) + elements*elementSize;
+   if (matrix) {
+      delete []matrix;
+   }
+   matrix = new char[size];
+   memcpy(matrix, retMatrix, size);
+   delete []retMatrix;
 }
 
 void CRunBytecode::incspOpcode()
@@ -1201,7 +1215,16 @@
 
 void CRunBytecode::pushmvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("pushmv opcode");
+
+   char *matrix    = (char*) _dataStack.getInt(_code.fetchInt());
+   int elementSize = *((int*)(matrix+0));
+   int elements    = *((int*)(matrix+sizeof(int)));
+
+   int size = sizeof(int) + sizeof(int) + elements*elementSize;
+   char *newMatrix = new char[size]; // TODO: memory leak
+   memcpy(newMatrix, matrix, size);
+   _dataStack.pushInt((int)newMatrix);
 }
 
 void CRunBytecode::pushstOpcode()
@@ -1340,7 +1363,21 @@
 
 void CRunBytecode::m1allocOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m1alloc opcode");
+
+   // Header dos dados de uma matriz de uma linha:
+   // int (tamanho de cada elemento armazenado)
+   // int (numero de elementos)
+   // bytes (area sequencial para armazenar os dados)
+
+   int matrixAddress = _code.fetchInt();
+   int elementSize   = _dataStack.getInt(_code.fetchInt());
+   int elements      = _dataStack.getInt(_code.fetchInt());
+
+   char *matrix = new char[sizeof(int)+sizeof(int)+elementSize*elements];
+   *((int*)(matrix+0))           = elementSize;
+   *((int*)(matrix+sizeof(int))) = elements;
+   _dataStack.setInt(matrixAddress, (int)matrix);
 }
 
 void CRunBytecode::m2allocOpcode()
@@ -1350,17 +1387,44 @@
 
 void CRunBytecode::mfreeOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("mfree opcode");
+
+   int matrixAddress = _code.fetchInt();
+
+   char *matrix = (char*) _dataStack.getInt(matrixAddress);
+
+   delete []matrix;
+   _dataStack.setInt(matrixAddress, 0);
 }
 
 void CRunBytecode::m1setOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m1set opcode");
+
+   char *matrix     = (char*) _dataStack.getInt(_code.fetchInt());
+   int offset       = _dataStack.getInt(_code.fetchInt());
+   int valueAddress = _code.fetchInt();
+
+   int elementSize = *((int*)(matrix+0));
+//   int elements    = *((int*)(matrix+sizeof(int)));
+   char *data      = matrix + sizeof(int) + sizeof(int);
+   data += offset * elementSize;
+   memcpy(data, _dataStack.getPointer(valueAddress), elementSize);
 }
 
 void CRunBytecode::m1getOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m1get opcode");
+
+   int resultAddress = _code.fetchInt();
+   char *matrix      = (char*) _dataStack.getInt(_code.fetchInt());
+   int offset        = _dataStack.getInt(_code.fetchInt());
+
+   int elementSize = *((int*)(matrix+0));
+//   int elements    = *((int*)(matrix+sizeof(int)));
+   char *data      = matrix + sizeof(int) + sizeof(int);
+   data += offset * elementSize;
+   memcpy(_dataStack.getPointer(resultAddress), data, elementSize);
 }
 
 void CRunBytecode::m2setOpcode()

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Tue Dec  4 17:01:24 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 4 Dec 2007 17:01:24 +0100
Subject: [gpt-commit] r411 - in trunk/gpt2: gptasm/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712041601.lB4G1O9T009993@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-04 17:01:23 +0100 (Tue, 04 Dec 2007)
New Revision: 411

Added:
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
Modified:
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* Secao Data deveria ser inicializada com 0, mas estava sendo inicializada
  com ' '
* Implementacao correta de pushmv e popmv
  - pushmv esta gerando um memory leak que sera resolvido posteriormente


Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-12-04 14:10:49 UTC (rev 410)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-12-04 16:01:23 UTC (rev 411)
@@ -38,7 +38,7 @@
    //_data += symbol->getBinary();
    for (int i=0; i < symbol->getTypeSize(); i++) {
       // TODO: horrivel :-)
-      writeByte (' ');
+      writeByte ('\0');
    }
 
    return symbol;

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-04 14:10:49 UTC (rev 410)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-04 16:01:23 UTC (rev 411)
@@ -297,7 +297,7 @@
       std::map<std::string,int>::const_iterator solvedLabel;
       solvedLabel = _solvedLabels.find(unsolvedLabel->first);
       if (solvedLabel == _solvedLabels.end()) {
-         std::cout << "Label nao encontrado: " << unsolvedLabel->second << std::endl;
+         std::cout << "Label nao encontrado: " << unsolvedLabel->first << std::endl;
          abort();
       }
       _code.setInt(unsolvedLabel->second, solvedLabel->second);

Added: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-04 14:10:49 UTC (rev 410)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-04 16:01:23 UTC (rev 411)
@@ -0,0 +1,81 @@
+program exemplo
+
+var m matrix
+var i int
+var t1 int
+
+proc main
+    push_0 // funciona pq sizeof(int) e de matrix sao iguais... mas e para real ???
+    pcall insere_dados
+    popmv m
+
+    pushmv m
+    pcall mostra_dados
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+proc insere_dados
+    param d1 matrix
+//    var t1 int
+
+    // aloca espa?o para a matriz d1
+    // d1 armazena dados de 4 bytes e tem 10 elementos iniciais
+    m1alloc d1, 4, 10
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste:
+    ile t1, i, 9
+    ifnot t1, proximo
+
+    // d1[i] := i * 10;
+    imul t1, i, 10
+    m1set d1, i, t1
+
+    // fim-para
+    iinc i, 1
+    jmp teste
+    proximo:
+
+//    decsp_4
+    ret
+endproc
+
+proc mostra_dados
+    param d2 matrix
+//    var t1 int
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    // para i de 0 at? 9 fa?a
+    iset i, 0
+    teste2:
+    ile t1, i, 9
+    ifnot t1, proximo2
+
+    // imprima( d2[i] );
+    m1get t1, d2, i
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // fim-para
+    iinc i, 1
+    jmp teste2
+    proximo2:
+
+    decsp_4
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 14:10:49 UTC (rev 410)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 16:01:23 UTC (rev 411)
@@ -1058,19 +1058,22 @@
 {
    trace ("popmv opcode");
 
-   char *matrix    = (char*) _dataStack.getInt(_code.fetchInt());
+   int matrixAddress = _code.fetchInt();
 
    char *retMatrix = (char*) _dataStack.popInt();
    int elementSize = *((int*)(retMatrix+0));
    int elements    = *((int*)(retMatrix+sizeof(int)));
 
    int size = sizeof(int) + sizeof(int) + elements*elementSize;
+   char *matrix = (char*) _dataStack.getInt(matrixAddress);
+
    if (matrix) {
       delete []matrix;
    }
    matrix = new char[size];
    memcpy(matrix, retMatrix, size);
    delete []retMatrix;
+   _dataStack.setInt(matrixAddress, (int)matrix);
 }
 
 void CRunBytecode::incspOpcode()

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Tue Dec  4 20:03:26 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 4 Dec 2007 20:03:26 +0100
Subject: [gpt-commit] r412 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712041903.lB4J3QW4011666@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-04 20:03:24 +0100 (Tue, 04 Dec 2007)
New Revision: 412

Added:
   trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
Modified:
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
Log:
DEVNULL:
* Novos opcodes para empilhar retorno da funcao conforme o tipo de dado
  - pushir (push int result), pushrr (push real result), ...


Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -147,7 +147,12 @@
    OP_PUSH_5      = 119,
    OP_EXIT_0      = 120,
    OP_EXIT_1      = 121,
-   OPCODE_NUMBER  = 121
+   OP_PUSHIR      = 122,
+   OP_PUSHSR      = 123,
+   OP_PUSHRR      = 124,
+   OP_PUSHDR      = 125,
+   OP_PUSHMR      = 126,
+   OPCODE_NUMBER  = 126
 };
 
 #endif

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -290,6 +290,7 @@
 
 int sumAddress(int address, int value)
 {
+// TODO: ao somar dados em address os limites deveriam ser testados
    bool localAddress = false;
    bool negAddress = false;
 

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -101,6 +101,11 @@
    _opcodes[ "pushrv"      ] = OP_PUSHRV;
    _opcodes[ "pushdv"      ] = OP_PUSHDV;
    _opcodes[ "pushmv"      ] = OP_PUSHMV;
+   _opcodes[ "pushir"      ] = OP_PUSHIR;
+   _opcodes[ "pushsr"      ] = OP_PUSHSR;
+   _opcodes[ "pushrr"      ] = OP_PUSHRR;
+   _opcodes[ "pushdr"      ] = OP_PUSHDR;
+   _opcodes[ "pushmr"      ] = OP_PUSHMR;
    _opcodes[ "pushit"      ] = OP_PUSHIT;
    _opcodes[ "pushst"      ] = OP_PUSHST;
    _opcodes[ "pushrt"      ] = OP_PUSHRT;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-04 19:03:24 UTC (rev 412)
@@ -136,6 +136,11 @@
    T_KW_PUSHBT="pushbt";
    T_KW_PUSHDT="pushdt";
    T_KW_PUSHMT="pushmt";
+   T_KW_PUSHIR="pushir";
+   T_KW_PUSHRR="pushrr";
+   T_KW_PUSHSR="pushsr";
+   T_KW_PUSHDR="pushdr";
+   T_KW_PUSHMR="pushmr";
    T_KW_INCSP_4="incsp_4";
    T_KW_INCSP_8="incsp_8";
    T_KW_DECSP_4="decsp_4";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-04 19:03:24 UTC (rev 412)
@@ -251,6 +251,8 @@
       T_INT_VALUE
       { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
       // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
+   |  ("pushir"|"pushsr"|"pushrr"|"pushdr"|"pushmr")
+      {bytecode.addOpcode(getLastTokenText());}
    |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushdt"|"pushmt")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("popiv"|"popsv"|"poprv"|"popmv")

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-04 19:03:24 UTC (rev 412)
@@ -3,7 +3,7 @@
 proc main
     var t1 int
     // imprima( "A soma ?: ", soma( 2, 7 ) );
-    push_0 // resultado da fun??o
+    pushir // resultado da fun??o
     pushiv 7 // empilha 7
     pushiv 2 // empilha 2
     pcall soma

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-04 19:03:24 UTC (rev 412)
@@ -15,7 +15,7 @@
     popiv x
 
     // imprima( "Fatorial de ", x, " ? ", fatorial( x ) );
-    push_0 // retorno da fun??o
+    pushir // retorno da fun??o
     pushiv x
     pcall fatorial
     pushit
@@ -50,7 +50,7 @@
     senao:
         // retorne z * fatorial( z - 1 );
         isub t1, z, 1
-        push_0 // retorno da fun??o
+        pushir // retorno da fun??o
         pushiv t1
         pcall fatorial
         popiv t1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-04 19:03:24 UTC (rev 412)
@@ -5,7 +5,7 @@
 var t1 int
 
 proc main
-    push_0 // funciona pq sizeof(int) e de matrix sao iguais... mas e para real ???
+    pushmr
     pcall insere_dados
     popmv m
 

Added: trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-04 19:03:24 UTC (rev 412)
@@ -0,0 +1,32 @@
+program exemplo
+
+var v string
+
+proc main
+//    var v string
+
+//    salloc v
+    pushsr
+    pcall ajusta
+    popsv v
+
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    sfree v
+
+    exit 0
+endproc
+
+proc ajusta
+    param __result string
+
+    salloc __result
+    sset __result, "Hello !!!"
+    ret
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-04 19:03:24 UTC (rev 412)
@@ -0,0 +1,30 @@
+program exemplo
+
+proc main
+    var v string
+
+//    salloc v
+    pushsr
+    pcall ajusta
+    popsv v
+
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    sfree v
+
+    exit 0
+endproc
+
+proc ajusta
+    param __result string
+
+    salloc __result
+    sset __result, "Hello !!!"
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -282,3 +282,16 @@
    }
 }
 
+
+void CDataStack::pushBytes(const void* data, const int &size)
+{
+   const char* bytes = (const char*) data;
+   for(int i=0; i<size; i++) {
+      CBinString::pushByte(*bytes);
+      bytes++;
+   }
+
+   _SP+=size;
+}
+
+

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -36,6 +36,7 @@
    void pushByte(const char &value);
    char popByte();
    void *getPointer(const int &address);
+   void pushBytes(const void* data, const int &size);
 private:
    int _BS;
    int _SP; // TODO: SP eh equivalente a size() ???

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -5,10 +5,50 @@
 
 #include "Tools.hpp"
 
-
-// TODO: ao somar dados em address os limites deveriam ser testados
 // TODO: Armazenar todas as strings em memoria com o tamanho na frente ???
 
+struct SStringType {
+   char _type;
+   union UStringTypeValue {
+      std::string *_strValue;
+      int         _addressValue;
+   };
+   UStringTypeValue _value;
+   SStringType()
+   : _type(0)
+   {
+      _value._addressValue = 0;
+   }
+};
+
+struct SMatrixType {
+   int _elementSize;
+   int _elements;
+   char* _data;
+   SMatrixType()
+   : _elementSize(0)
+   , _elements(0)
+   , _data(NULL)
+   { }
+};
+
+struct SIntType {
+   int _value;
+
+   SIntType()
+   : _value(0)
+   { }
+};
+
+struct SRealType {
+   double _value;
+
+   SRealType()
+   : _value(0)
+   { }
+};
+
+
 CRunBytecode::CRunBytecode()
    : _returnCode(0)
 {
@@ -144,6 +184,12 @@
    _opcodePointer[OP_PUSHDV     ] = &CRunBytecode::pushdvOpcode;
    _opcodePointer[OP_PUSHMV     ] = &CRunBytecode::pushmvOpcode;
 
+   _opcodePointer[OP_PUSHSR     ] = &CRunBytecode::pushsrOpcode;
+   _opcodePointer[OP_PUSHIR     ] = &CRunBytecode::pushirOpcode;
+   _opcodePointer[OP_PUSHRR     ] = &CRunBytecode::pushrrOpcode;
+   _opcodePointer[OP_PUSHDR     ] = &CRunBytecode::pushdrOpcode;
+   _opcodePointer[OP_PUSHMR     ] = &CRunBytecode::pushmrOpcode;
+
    _opcodePointer[OP_PUSHST     ] = &CRunBytecode::pushstOpcode;
    _opcodePointer[OP_PUSHIT     ] = &CRunBytecode::pushitOpcode;
    _opcodePointer[OP_PUSHRT     ] = &CRunBytecode::pushrtOpcode;
@@ -152,10 +198,10 @@
    _opcodePointer[OP_PUSHDT     ] = &CRunBytecode::pushdtOpcode;
    _opcodePointer[OP_PUSHMT     ] = &CRunBytecode::pushmtOpcode;
 
-   _opcodePointer[OP_INCSP_4     ] = &CRunBytecode::incsp_4Opcode;
-   _opcodePointer[OP_INCSP_8     ] = &CRunBytecode::incsp_8Opcode;
-   _opcodePointer[OP_DECSP_4     ] = &CRunBytecode::decsp_4Opcode;
-   _opcodePointer[OP_DECSP_8     ] = &CRunBytecode::decsp_8Opcode;
+   _opcodePointer[OP_INCSP_4    ] = &CRunBytecode::incsp_4Opcode;
+   _opcodePointer[OP_INCSP_8    ] = &CRunBytecode::incsp_8Opcode;
+   _opcodePointer[OP_DECSP_4    ] = &CRunBytecode::decsp_4Opcode;
+   _opcodePointer[OP_DECSP_8    ] = &CRunBytecode::decsp_8Opcode;
 
    _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
    _opcodePointer[OP_SALLOC     ] = &CRunBytecode::sallocOpcode;
@@ -346,7 +392,7 @@
       error( "Endereco para lcall deve conter uma string constante !!!" );
    }
 
-   address=sumAddress(address,1);
+   address=sumAddress(address, 1);
 
    if (_dataStack.getCString(address) == "imprima") {
       procImprima();
@@ -392,18 +438,18 @@
 {
    trace ("hlt opcode");
 
-   exit(0);
+   exit(1);
 }
 
 void CRunBytecode::isumOpcode()
 {
    trace ("isum opcode");
 
-   int varAddress  = _code.fetchInt();
-   int val1Address = _code.fetchInt();
-   int val2Address = _code.fetchInt();
+   int varAddress = _code.fetchInt();
+   int val1       = _dataStack.getInt(_code.fetchInt());
+   int val2       = _dataStack.getInt(_code.fetchInt());
 
-   _dataStack.setInt(varAddress, _dataStack.getInt(val1Address) + _dataStack.getInt(val2Address));
+   _dataStack.setInt(varAddress, val1 + val2);
 }
 
 void CRunBytecode::ssumOpcode()
@@ -1023,7 +1069,30 @@
 
 void CRunBytecode::popsvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("popsv opcode");
+
+   int address = _code.fetchInt();
+
+//   if (_dataStack.getByte(address) != CSymbol::VAR) {
+//      error( "popsvOpcode apenas com variaveis !!!" );
+//   }
+
+   std::string* result = (std::string*) _dataStack.getInt(sumAddress(address,1));
+   if (result == NULL) {
+      _dataStack.setByte(address, CSymbol::VAR);
+      result = new std::string;
+      _dataStack.setInt(sumAddress(address,1), (int) result);
+   }
+
+   int value = _dataStack.popInt();
+   char type = _dataStack.popByte();
+
+   if (type == CSymbol::VAR) {
+      std::string* retValue = (std::string*) value;
+      *result = *retValue;
+   } else {
+      *result = _dataStack.getCString(value);
+   }
 }
 
 void CRunBytecode::popivOpcode()
@@ -1081,7 +1150,7 @@
    trace ("incsp opcode");
 
    int valAddress = _code.fetchInt();
-   int size = _dataStack.getInt(valAddress);
+   int size       = _dataStack.getInt(valAddress);
 
    _dataStack.pushBytes(size);
 }
@@ -1144,19 +1213,25 @@
 }
 
 
-
 void CRunBytecode::pushsvOpcode()
 {
    trace ("pushsv opcode");
 
    int address = _code.fetchInt();
 
+   std::string *value = new std::string(); // TODO: quando eh desalocado ??? No popsv ?
+   *value = _dataStack.getString(address);
+
+   SStringType type;
+   type._type                = CSymbol::VAR;
+   type._value._addressValue = (int)value;
+
+//   std::cout << "sizeof(type)=" << sizeof(type) << std::endl;
+//   _dataStack.pushBytes(&type, sizeof(type));
+//   TODO: problemas de alinhamento nas estruturas... nao consegui desativar com pragmas...
+
    _dataStack.pushByte(CSymbol::VAR);
-
-   std::string *value = new std::string(); // TODO: quando eh desalocado ??? 
    _dataStack.pushInt((int)value);
-
-   *value = _dataStack.getString(address);
 }
 
 
@@ -1191,10 +1266,10 @@
 {
    trace ("pushiv opcode");
 
-   int address = _code.fetchInt();
+   int value = _dataStack.getInt(_code.fetchInt());
 
    // Empilha o conteudo para que o formato dos dados globais e locais sejam o mesmo
-   _dataStack.pushInt(_dataStack.getInt(address));
+   _dataStack.pushInt(value);
 }
 
 void CRunBytecode::pushrvOpcode()
@@ -1230,6 +1305,50 @@
    _dataStack.pushInt((int)newMatrix);
 }
 
+
+void CRunBytecode::pushsrOpcode()
+{
+   trace ("pushsr opcode");
+
+   SStringType type;
+
+   _dataStack.pushBytes((char*)&type, sizeof(type));
+}
+
+
+void CRunBytecode::pushirOpcode()
+{
+   trace ("pushir opcode");
+
+   _dataStack.pushInt(0);
+}
+
+void CRunBytecode::pushrrOpcode()
+{
+   trace ("pushrr opcode");
+
+   _dataStack.pushReal(0);
+}
+
+void CRunBytecode::pushdrOpcode()
+{
+   trace ("pushdr opcode");
+
+   int size = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.pushBytes(size);
+}
+
+void CRunBytecode::pushmrOpcode()
+{
+   trace ("pushmr opcode");
+
+   SMatrixType type;
+
+   _dataStack.pushBytes((char*)&type, sizeof(type));
+}
+
+
 void CRunBytecode::pushstOpcode()
 {
    trace ("pushst opcode");

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-04 16:01:23 UTC (rev 411)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-04 19:03:24 UTC (rev 412)
@@ -138,6 +138,12 @@
    void pushdvOpcode();
    void pushmvOpcode();
 
+   void pushsrOpcode();
+   void pushirOpcode();
+   void pushrrOpcode();
+   void pushdrOpcode();
+   void pushmrOpcode();
+
    void pushstOpcode();
    void pushitOpcode();
    void pushrtOpcode();

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:31:05 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:31:05 +0100
Subject: [gpt-commit] r413 - trunk/gpt2/gptc/src
Message-ID: <200712051131.lB5BV5cq032340@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:31:03 +0100 (Wed, 05 Dec 2007)
New Revision: 413

Modified:
   trunk/gpt2/gptc/src/Makefile.am
Log:
-Criando TokenLabels.hpp

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-04 19:03:24 UTC (rev 412)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-05 11:31:03 UTC (rev 413)
@@ -12,7 +12,8 @@
                 PortugolParser.cpp \
                 SemanticWalker.hpp \
                 SemanticWalker.cpp \
-                TokenNames.hpp
+                TokenNames.hpp \
+                TokenLabels.hpp
 
 
 gptc_SOURCES = BaseSemanticWalker.hpp \
@@ -49,7 +50,8 @@
              SemanticWalker.cpp \
              SemanticWalkerTokenTypes.hpp \
              SemanticWalkerTokenTypes.txt \
-             TokenNames.hpp
+             TokenNames.hpp \
+             TokenLabels.hpp
 
 PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
 	$(ANTLR_BIN) $(srcdir)/lexer.g
@@ -72,3 +74,14 @@
 	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
 	sed -i -e '$$s/,/};/' $@
 	@echo "#endif" >> $@
+
+TokenLabels.hpp: Makefile
+	@echo "#ifndef TOKENLABELS_H" > $@
+	@echo "#define TOKENLABELS_H"  >> $@
+	@echo "static char* g_tokenLabels[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep '"' PortugolTokenTypes.txt >> $@
+	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo "#endif" >> $@
+



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:32:01 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:32:01 +0100
Subject: [gpt-commit] r414 - trunk/gpt2/gptc/src
Message-ID: <200712051132.lB5BW1td001459@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:31:59 +0100 (Wed, 05 Dec 2007)
New Revision: 414

Modified:
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
Log:
-Flags const/ref movidos para classe Type
-Adicionado atributo identifier, para identificar unicamente subprogramas
-Diversos incrementos

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-12-05 11:31:03 UTC (rev 413)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-12-05 11:31:59 UTC (rev 414)
@@ -1,16 +1,48 @@
 #include "Symbol.hpp"
+#include "Types.hpp"
 
+#include <sstream>
+
 Symbol::Symbol()
   : _type(0) {
 }
 
-Symbol::Symbol(const std::string& lexeme, Type* type, int line,
-         const std::string& unit, const std::string& scope,
-         bool isConst, bool isRef)
-    : _lexeme(lexeme), _type(type), _isConst(isConst), _isRef(isRef),
-      _unit(unit), _scope(scope), _line(line) {
+Symbol::Symbol(const std::string& lexeme,
+               Type* type,
+               const std::string& scope,
+               const std::string& unit,
+               int line)
+  :   _lexeme(lexeme),
+      _type(type),
+      _scope(scope),
+      _unit(unit),
+      _line(line) {
+
+  _identifier = buildIdentifier(lexeme, _type);
+
 }
 
+Symbol::Symbol(const std::string& lexeme,
+               Type* type,
+               const std::string& unit,
+               int line)
+  :   _lexeme(lexeme),
+      _type(type),
+      _unit(unit),
+      _line(line) {
+
+  _identifier = buildIdentifier(lexeme, _type);
+}
+
+
+
+Symbol::Symbol(const std::string& lexeme, Type* type) 
+  : _lexeme(lexeme), _type(type), _scope("?"), _unit("?"), _line(-1) {
+
+  _identifier = buildIdentifier(lexeme, _type);
+}
+
+
 const std::string& Symbol::lexeme() const {
   return _lexeme;
 }
@@ -19,52 +51,89 @@
   return _type;
 }
 
-bool Symbol::isConst() const {
-  return _isConst;
+void Symbol::setScope(const std::string& scope) {
+  _scope = scope;
 }
 
-bool Symbol::isRef() const {
-  return _isRef;
+const std::string& Symbol::scope() const {
+  return _scope;
 }
 
+const std::string& Symbol::unit() const {
+  return _unit;
+}
+
+int Symbol::line() const {
+  return _line;
+}
+
 std::string Symbol::toString() const {
-  std::string ret = _unit + "(" + _scope + ") - " + lexeme() + " : ";
-  if (_type) {
-    ret += _type->name();
+  std::stringstream ret;
+  ret << _unit << ":" << _line
+      << " (" << _scope << ") -> " << lexeme();
+
+  ret << " : " << _type->name();
+
+  ret << " -- attributes: {";
+  if (_type->isConst()) {
+    ret << "c";
   }
-  ret += " - ";
-  if (_isConst) {
-    ret += "c";
+
+  if (_type->isRef()) {
+    ret << "r";
   }
-  if (_isRef) {
-    ret += "r";
+  ret << "}";
+
+  return ret.str();
+}
+
+std::string 
+Symbol::buildIdentifier(const std::string& name, Type* type) {
+  if (!type->isSubprogram()) {
+    return name;
+  } else {
+    return buildIdentifier(name, type->paramTypes());
   }
-  return ret;
 }
 
+std::string 
+Symbol::buildIdentifier(const std::string& name, const TypeList& list) {
+  return name + "_" + list.toIdentifier();
+}
 
+std::string Symbol::identifier() const {
+  return _identifier;
+}
+
+
+bool Symbol::equivalent(const Symbol& other) const {
+  return _lexeme == other._lexeme &&
+         _type->equals(other._type);
+}
+
 //-------------------------------------------------------
 
 
 SymbolList::const_iterator SymbolList::duplicated() const {
   for (const_iterator it = begin(); it != end(); ++it) {
-    if (count((*it).lexeme()) > 1) {
+    if (count((*it).identifier()) > 1) {
       return it;
     }
   }
   return end();
 }
 
-Type::StructFieldList SymbolList::toStructFieldList() const {
-  Type::StructFieldList fields;
-
+int SymbolList::count(const std::string& identifier) const {
+  int c = 0;
   for (const_iterator it = begin(); it != end(); ++it) {
-    fields.push_back(Type::StructField((*it).lexeme(), (*it).type()));
+    if ((*it).lexeme() == identifier) {
+      c++;
+    }
   }
-  return fields;
+  return c;
 }
 
-TypeList SymbolList::toTypeList() const {
+TypeList SymbolList::typeList() const {
   TypeList list;
 
   for (const_iterator it = begin(); it != end(); ++it) {
@@ -73,18 +142,21 @@
   return list;
 }
 
-int SymbolList::count(const std::string& lexeme) const {
-  int ret = 0;
-  for (const_iterator it = begin(); it != end(); ++it) {
+SymbolList
+SymbolList::findAllByLexeme(const std::string& lexeme) const {
+  SymbolList ret;
+  SymbolList::const_iterator it;
+  for (it = begin(); it != end(); ++it) {
     if ((*it).lexeme() == lexeme) {
-      ret++;
+      ret.push_back(*it);
     }
   }
   return ret;
 }
 
-SymbolList::iterator SymbolList::find(const std::string& lexeme) {
-  for (iterator it = begin(); it != end(); ++it) {
+SymbolList::const_iterator 
+SymbolList::findFirstByLexeme(const std::string& lexeme) const {
+  for (const_iterator it = begin(); it != end(); ++it) {
     if ((*it).lexeme() == lexeme) {
       return it;
     }
@@ -92,6 +164,22 @@
   return end();
 }
 
+SymbolList::const_iterator 
+SymbolList::findByIdentifier(const std::string& identifier) const {
+  for (const_iterator it = begin(); it != end(); ++it) {
+    if ((*it).identifier() == identifier) {
+      return it;
+    }
+  }
+  return end();
+}
+
+void SymbolList::setScope(const std::string& scope) {
+  for (iterator it = begin(); it != end(); ++it) {
+    (*it).setScope(scope);
+  }
+}
+
 std::string SymbolList::toString() const {
   std::string ret = "";
   for (const_iterator it = begin(); it != end(); ++it) {
@@ -99,3 +187,16 @@
   }
   return ret;
 }
+
+bool SymbolList::equivalent(const SymbolList& other) const {
+  const_iterator it, jt;
+  for (it = begin(), jt = other.begin(); 
+       it != end() && jt != other.end(); 
+       ++it, ++jt) {
+    if (!(*it).equivalent(*jt)) {
+      return false;
+    }
+  }
+
+  return true;
+}

Modified: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-12-05 11:31:03 UTC (rev 413)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-12-05 11:31:59 UTC (rev 414)
@@ -1,53 +1,78 @@
 #ifndef SYMBOL_HPP
 #define SYMBOL_HPP
 
-#include "Types.hpp"
-
 #include <string>
+#include <list>
 
+class Type;
+class TypeList;
+
 class Symbol {
 public:
+  static std::string buildIdentifier(const std::string&, Type*);
+  static std::string buildIdentifier(const std::string&, const TypeList&);
+
   Symbol();
 
-  Symbol(const std::string& lexeme, Type* type, int line,
-         const std::string& unit, const std::string& scope,
-         bool isConst = false, bool isRef = false);
+  Symbol(const std::string& lexeme,
+         Type* type,
+         const std::string& scope,
+         const std::string& unit,
+         int line);
 
+  Symbol(const std::string& lexeme,
+         Type* type,
+         const std::string& unit,
+         int line);
+
+  Symbol(const std::string& lexeme,
+         Type* type);
+
   const std::string& lexeme() const;
 
   Type* type() const;
 
-  bool isConst() const;
+  void setScope(const std::string&);
+  const std::string& scope() const;
 
-  bool isRef() const;
+  const std::string& unit() const;
 
+  int line() const;
+
   std::string toString() const;
 
+  std::string identifier() const;
+
+  bool equivalent(const Symbol&) const;
 private:
   std::string      _lexeme;
+  std::string      _identifier;
   Type*            _type;
-  bool             _isConst;
-  bool             _isRef;
-
-  std::string _unit;
-  std::string _scope;
-  int         _line;
+  std::string      _scope;
+  std::string      _unit;
+  int              _line;
 };
 
 
 class SymbolList : public std::list<Symbol> {
 public:
+
   const_iterator duplicated() const;
 
-  Type::StructFieldList toStructFieldList() const;
+  TypeList typeList() const;
 
-  TypeList toTypeList() const;
+  SymbolList     findAllByLexeme(const std::string&) const;
+  const_iterator findFirstByLexeme(const std::string&) const;
+  const_iterator findByIdentifier(const std::string&) const;
+  
 
-  int count(const std::string& lexeme) const;
+  int count(const std::string&) const;
 
-  iterator find(const std::string& lexeme);
+  void setScope(const std::string&);
 
   std::string toString() const;
+
+  bool equivalent(const SymbolList&) const;
 };
 
 #endif



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:33:46 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:33:46 +0100
Subject: [gpt-commit] r415 - trunk/gpt2/gptc/src
Message-ID: <200712051133.lB5BXkoO004204@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:33:45 +0100 (Wed, 05 Dec 2007)
New Revision: 415

Modified:
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
Log:
-Utilizando TypeBuilder
-Limpeza geral da interface


Modified: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-05 11:31:59 UTC (rev 414)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-05 11:33:45 UTC (rev 415)
@@ -7,126 +7,192 @@
 
 #include <iostream>
 
-void SymbolTable::setScope(const std::string& scope) {
-  _scope = scope;
+SymbolTable::SymbolTable(const std::string& unit)
+  : _unit(unit), _typeBuilder(new TypeBuilder) {
+
+  setGlobalScope();
 }
 
 void SymbolTable::setGlobalScope() {
-  _scope = "@global";
+  _scope = globalScope();
 }
 
-Type* SymbolTable::getType(const std::string& name) {
-  TypeList::iterator ret = _types.find(name);
+bool SymbolTable::isInGlobalScope() {
+  return globalScope() == _scope;
+}
 
-  if (ret == _types.end()) {
-    throw UndeclaredTypeException(name);
-  }
+void SymbolTable::setIgnoreScope() {
+  static char r = 1;
+  _scope = "internal" + (r++);
+}
 
-  return *ret;
+const std::string SymbolTable::globalScope() {
+  return "@global";
 }
 
-Type* SymbolTable::getType(int id) {
-  TypeList::iterator ret = _types.find(id);
+void SymbolTable::setScope(const Symbol& scopeSymbol) {  
+  _scope = scopeSymbol.identifier();
+}
 
-  if (ret == _types.end()) {
-    throw UndeclaredTypeException(id);
-  }
+const std::string& SymbolTable::currentScope() {
+  return _scope;
+}
 
-  return *ret;
+const std::string& SymbolTable::unit() {
+  return _unit;
 }
 
-Type* SymbolTable::getType(Type *ofType, int dimensions) {
-  TypeList::iterator it = _types.find(ofType, dimensions);
-  Type* type;
-  if (it == _types.end()) {
-    type = new Type(ofType, dimensions);
-    _types.push_back(type);
-  } else {
-    type = *it;
+void SymbolTable::insertType(const std::string& name,
+                             const SymbolList& fields,
+                             int line) {
+  
+  //checando por campos duplicados na estrutura
+  SymbolList::const_iterator dup = fields.duplicated();
+  if (dup != fields.end()) {
+    throw RedeclarationException(*dup);
   }
-  return type;
+
+  //checando por redefinicao da estrutura
+  if (_typeBuilder->typeList().find(name) != _typeBuilder->typeList().end()) {
+    throw RedefinedTypeException(name);
+  }
+
+  _typeBuilder->typeList().push_back(
+    new Type(_typeBuilder, name, fields, _unit, line));
 }
 
-// Type* SymbolTable::getType(const TypeList& paramTypes, Type* returnType) {
-  //TODO
-  //Levar em consideracao o registro de funcoes polimorficas
-  //Type *type = new Type(paramTypes, returnType);
-//   throw;
+
+// void SymbolTable::insertType(const std::string& name,
+//                              const SymbolList& symbolList,
+//                              int line) {
+// 
+//   //checando por campos duplicados na estrutura
+//   SymbolList::const_iterator dup = symbolList.duplicated();
+//   if (dup != symbolList.end()) {
+//     throw RedeclarationException(*dup);
+//   }
+// 
+//   //checando por redefinicao da estrutura
+//   if (_typeBuilder->typeList().find(name) != _typeBuilder->typeList().end()) {
+//     throw RedefinedTypeException(name);
+//   }
+// 
+//   _typeBuilder->typeList().push_back(
+//     new Type(_typeBuilder, name,
+//              symbolList.toStructFieldList(), _unit, line));
 // }
 
+Type* SymbolTable::getType(const std::string& name) {
+  TypeList::iterator ret = _typeBuilder->typeList().find(name);
 
-Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
-                const std::string& scope, int line,
-                bool isConst, bool isRef) {
-  return Symbol(name, type, line, _unit, scope, isConst, isRef);
-}
+  if (ret == _typeBuilder->typeList().end()) {
+    throw UndeclaredTypeException(name);
+  }
 
-Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
-                int line, bool isConst, bool isRef) {
-  return Symbol(name, type, line, _unit, _scope, isConst, isRef);
+  return *ret;
 }
 
-void SymbolTable::defineStruct(const std::string& name,
-                               const SymbolList& symbolList,
-                               int line) {
-  SymbolList::const_iterator dup = symbolList.duplicated();
-  if (dup != symbolList.end()) {
-    throw RedeclarationException(*dup);
-  }
 
-  if (_types.find(name) != _types.end()) {
-    throw RedefinedTypeException(name);
+void SymbolTable::insertSymbol(const Symbol& symbol) {
+  if (symbolExists(symbol)) {
+    throw RedeclarationException(symbol);
   }
-  _types.push_back(new Type(name,
-      symbolList.toStructFieldList(), _unit, line));
+  _table[symbol.scope()].push_back(symbol);
 }
 
-Type* SymbolTable::createAnonymousStruct(const SymbolList& symbolList) {
-  Type* ret = new Type(symbolList.toStructFieldList());
-  _types.push_back(ret);
-  return ret;
+void SymbolTable::insertSymbols(const SymbolList& symbols) {
+  for (SymbolList::const_iterator it = symbols.begin();
+       it != symbols.end();
+       ++it) {
+    insertSymbol(*it);
+  }
 }
 
-bool SymbolTable::declared(const Symbol& s) {
-  return _table[_scope].count(s.lexeme()) >= 1;
+const Symbol& SymbolTable::getSymbol(const std::string& lexeme,
+                                     const std::string& scope) {
+  SymbolList::const_iterator it = _table[scope].findFirstByLexeme(lexeme);
+  if (it == _table[scope].end()) {
+    throw UndeclaredSymbolException(lexeme);
+  }
+  return (*it);
 }
 
-void SymbolTable::declare(const Symbol& symbol) {
-  if (declared(symbol)) {
-    throw RedeclarationException(symbol);
+const Symbol& 
+SymbolTable::getSymbol(const std::string& lexeme, const TypeList& params) {
+  //deve considerar promocao de tipos
+  //    fun??o f(a:real) ...
+  //    f(1);                //resolve para a fun??o "f_real"
+
+
+  SymbolList list = _table[globalScope()].findAllByLexeme(lexeme);
+
+  if (list.size() == 0) {
+    throw UndeclaredSymbolException(lexeme);
   }
-  _table[_scope].push_back(symbol);
-}
 
-void SymbolTable::declare(const SymbolList& params,
-                          const std::string& proc) {
-  try {
-    setScope(proc);
-    for (SymbolList::const_iterator it = params.begin(); it != params.end(); ++it) {
-      declare(*it);
+  //try exact version
+  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
+    if ((*it).type()->isSubprogram() &&
+        (*it).type()->paramTypes().equals(params)) {
+      return (*it);
     }
-  } catch( ... ) {
-    setGlobalScope();
-    throw;
   }
+
+  //tentando promocoes...
+  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
+    if ((*it).type()->isSubprogram() &&
+        (*it).type()->paramTypes().isLValueFor(params)) {
+      return (*it);
+    }
+  }
+
+  throw UnmatchedException(lexeme);
+
+//   std::string id = Symbol::buildIdentifier(lexeme, params);
+//   SymbolList::const_iterator it = _table[globalScope()].findByIdentifier(id);
+//   if (it == _table[globalScope()].end()) {
+//     throw UndeclaredSymbolException(id);
+//   }
+//   return (*it);
 }
 
+const Symbol& SymbolTable::getSymbol(const std::string& lexeme) {
+  //buscar primeiro no escopo atual, depois no global
 
-const Symbol& SymbolTable::getSymbol(const std::string& lexeme) {
-  SymbolList::const_iterator it = _table[_scope].find(lexeme);
-  if (it == _table[_scope].end()) {
-    throw UndeclaredSymbolException(lexeme);
+  if (isInGlobalScope()) {
+    return getSymbol(lexeme, _scope);
+  } else {
+    try {
+      return getSymbol(lexeme, _scope);
+    } catch( ... ) {
+      return getSymbol(lexeme, globalScope());
+    }
   }
-  return (*it);
 }
 
+bool SymbolTable::symbolExists(const Symbol& s) {
+  SymbolList::const_iterator it = 
+    _table[s.scope()].findByIdentifier(s.identifier());
 
-SymbolTable* SymbolTable::create(const std::string& unit) {
-  SymbolTable* s = new SymbolTable(unit);
-  s->initialize();
-  return s;
+  if (it == _table[s.scope()].end()) {
+    return false;
+  } else {
+    return true;
+  }
 }
 
+
+// bool SymbolTable::symbolExists(const std::string& id) {
+//   return symbolExists(id, _scope);
+// }
+// 
+// bool SymbolTable::symbolExists(const std::string& id,
+//                                const std::string& scope) {
+// 
+//   return _table[scope].findByIdentifier(id) != _table[scope].end();
+// }
+
+
 void SymbolTable::dump() {
 
   std::cerr << "=== SymbolTable ===\n";
@@ -136,27 +202,10 @@
     std::cerr << it->second.toString() << std::endl;
   }
   std::cerr << "Types ... " << std::endl;
-  std::cerr << _types.toString() << std::endl;
+  std::cerr << _typeBuilder->typeList().toString() << std::endl;
   std::cerr << "=== End SymbolTable ===\n\n";
 }
 
-
-SymbolTable::SymbolTable(const std::string& unit)
-  : _unit(unit) {
-  setGlobalScope();
+TypeBuilder* SymbolTable::typeBuilder() {
+  return _typeBuilder;
 }
-
-SymbolTable::~SymbolTable() {
-  //TODO: delete tables, types, etc...
-}
-
-void SymbolTable::initialize() {
-  _types.push_back(new Type(PortugolTokenTypes::T_INTEIRO,"inteiro"));
-  _types.push_back(new Type(PortugolTokenTypes::T_REAL,"real"));
-  _types.push_back(new Type(PortugolTokenTypes::T_CARACTERE,"caractere"));
-  _types.push_back(new Type(PortugolTokenTypes::T_LITERAL,"literal"));
-  _types.push_back(new Type(PortugolTokenTypes::T_LOGICO,"l?gico"));
-  _types.push_back(new Type(PortugolTokenTypes::T_NULO,"nulo"));
-  _types.push_back(new Type(PortugolTokenTypes::T_CORINGA,"coringa"));
-  _types.push_back(new Type(PortugolTokenTypes::T_RETICENCIAS,"retic?ncias"));
-}

Modified: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-05 11:31:59 UTC (rev 414)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-05 11:33:45 UTC (rev 415)
@@ -9,58 +9,54 @@
 
 class Symbol;
 class SymbolList;
+class TypeBuilder;
 
 class SymbolTable {
 public:
-  //void setCurrentUnit(string file)
-  //void loadSymbolTable(other) //load stable from other units
+  SymbolTable(const std::string& unit);
 
-  void setScope(const std::string& scope);
   void setGlobalScope();
+  bool isInGlobalScope();
+  void setIgnoreScope();
+  void setScope(const Symbol&);
+  const std::string& currentScope();
+  const std::string globalScope();
 
-  //
-  Type* getType(const std::string& name);
-  Type* getType(int id);
-  Type* getType(Type *ofType, int dimensions);
-//   Type* getType(const TypeList& paramTypes, Type* returnType);
+  const std::string& unit();
 
-  Symbol newSymbol(const std::string& name, Type* type,
-                   const std::string& scope, int line = -1,
-                   bool isConst = false, bool isRef = false);
+  void insertType(const std::string& name,
+                  const SymbolList&,
+                  int line);
 
-  Symbol newSymbol(const std::string& name, Type* type,
-                   int line = -1, bool isConst = false, bool isRef = false);
+  /* recuperar tipo por nome (ex. esruturas) */
+  Type* getType(const std::string& name);
 
-  void defineStruct(const std::string& name,
-                   const SymbolList& symbolList,
-                   int line);
+  void insertSymbol(const Symbol& symbol);
+  void insertSymbols(const SymbolList& symbols);
 
-  Type* createAnonymousStruct(const SymbolList& symbolList);
+  //(lexeme, scope)
+  const Symbol& getSymbol(const std::string&, const std::string&);
 
-  bool declared(const Symbol& s);
+  //(lexeme, params)
+  const Symbol& getSymbol(const std::string&, const TypeList&);
 
-  void declare(const Symbol& symbol);
 
-  void declare(const SymbolList& params, const std::string& proc);
+  //(lexeme) -> todos os escopos, iniciando pelo atual
+  const Symbol& getSymbol(const std::string&);
 
-  const Symbol& getSymbol(const std::string& lexeme);
-
-
-  static SymbolTable* create(const std::string& unit);
-
   void dump();
 
+  TypeBuilder* typeBuilder();
 private:
-  SymbolTable(const std::string& unit);
-  ~SymbolTable();
+/*  bool symbolExists(const std::string&);
+  bool symbolExists(const std::string&, const std::string&);*/
+  bool symbolExists(const Symbol& s);
 
-  void initialize();
-
-  std::string                        _scope;
   std::string                        _unit;
+  std::string                        _scope;
 
+  TypeBuilder                        *_typeBuilder;
   std::map<std::string, SymbolList>  _table;
-  TypeList                           _types;
 };
 
 #endif



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:34:23 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:34:23 +0100
Subject: [gpt-commit] r416 - trunk/gpt2/gptc/src
Message-ID: <200712051134.lB5BYNMc005900@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:34:22 +0100 (Wed, 05 Dec 2007)
New Revision: 416

Modified:
   trunk/gpt2/gptc/src/parser.g
Log:
-Adicionando localiza?\195?\167?\195?\163o (linha) para alguns nodes da ast
-T_FACA incorporado a ast do teste_caso como root node para facilitar analise semantica

Modified: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-12-05 11:33:45 UTC (rev 415)
+++ trunk/gpt2/gptc/src/parser.g	2007-12-05 11:34:22 UTC (rev 416)
@@ -201,17 +201,24 @@
   ;
 
 inicializacao_composta!
-  : T_ABRE_CHAVE!
+  : ch:T_ABRE_CHAVE!
       idx:inicializacao_indices
     T_FECHA_CHAVE!
 
-                 {#inicializacao_composta = #([T_VAL_MATRIZ, "&vmatriz"],idx);}
+                 {
+                   #inicializacao_composta = #([T_VAL_MATRIZ, "&vmatriz"],idx);
+                   #inicializacao_composta->setLine(ch->getLine());
+                 }
 
-  | T_ABRE_COLCHETE!
+  | co:T_ABRE_COLCHETE!
       mem:inicializacao_membros
     T_FECHA_COLCHETE!
 
-                 {#inicializacao_composta = #([T_VAL_ESTRUTURA, "&vestr"],mem);}
+                 {
+                   #inicializacao_composta =
+                       #([T_VAL_ESTRUTURA, "&vestr"],mem);
+                   #inicializacao_composta->setLine(co->getLine());
+                 }
   ;
 
 inicializacao_indices
@@ -425,10 +432,8 @@
       (caso_senao)? T_FIM_CASO!
   ;
 
-teste_caso!
-  : l:literal T_FACA! en:lista_enunciados T_FIM_FACA!
-
-                                {#teste_caso = #(l, en);}
+teste_caso
+  : literal T_FACA^ lista_enunciados T_FIM_FACA!
   ;
 
 caso_senao
@@ -554,5 +559,4 @@
   | T_CARACTERE_LITERAL
   | T_VERDADEIRO
   | T_FALSO
-  | T_NULO
   ;



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:35:02 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:35:02 +0100
Subject: [gpt-commit] r417 - trunk/gpt2/gptc/src
Message-ID: <200712051135.lB5BZ2a8007400@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:35:00 +0100 (Wed, 05 Dec 2007)
New Revision: 417

Modified:
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
Log:
-Usando Symbol/SymbolList em detrimento de StructField e StructFieldList 
-Incorporado flags para const/ref
-Adicionado TypeBuilder
-Adicionado ErrorType
-Maior elaboracao da interface, compatibilidade de tipos, etc.

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-12-05 11:34:22 UTC (rev 416)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-12-05 11:35:00 UTC (rev 417)
@@ -1,26 +1,33 @@
 #include "Types.hpp"
+#include "TokenLabels.hpp"
 
+#include <iostream>
 
-Type::StructField::StructField(const std::string& n, Type* t)
-      : name(n), type(t) {}
+// Type::StructField::StructField(const std::string& n, Type* t)
+//       : _name(n), _type(t) {
+// }
 
-bool
-Type::StructField::isLValueFor(const Type::StructField& other) const {
-  return name == other.name && type->isLValueFor(other.type);
-}
-
 // bool
-// Type::StructField::compatible(const Type::StructField& other) const {
-//   return name == other.name && type->compatible(other.type);
+// Type::StructField::isLValueFor(const Type::StructField& other) const {
+//   return _name == other._name && _type->isLValueFor(other._type);
 // }
 
-bool
-Type::StructField::operator==(const Type::StructField& other) const {
-  return name == other.name && type->equals(other.type);
-}
-
 // bool
-// Type::StructFieldList::compatible(const Type::StructFieldList& other) const {
+// Type::StructField::operator==(const Type::StructField& other) const {
+//   return _name == other._name && _type->equals(other._type);
+// }
+// 
+// Type* Type::StructField::type() const {
+//   return _type;
+// }
+// 
+// const std::string& Type::StructField::name() const {
+//   return _name;
+// }
+// 
+// 
+// bool
+// Type::StructFieldList::isLValueFor(const Type::StructFieldList& other) const {
 //   if (size() != other.size()) {
 //     return false;
 //   }
@@ -29,7 +36,7 @@
 //   for (it = begin(); it != end(); ++it) {
 //     found = false;
 //     for (jt = other.begin(); jt != other.end(); ++jt) {
-//       if ((*it).compatible(*jt)) {
+//       if ((*it).isLValueFor(*jt)) {
 //         found = true;
 //       }
 //     }
@@ -39,53 +46,90 @@
 //   }
 //   return true;
 // }
+// 
+// bool
+// Type::StructFieldList::operator==(const Type::StructFieldList& other) const {
+//   if (size() != other.size()) {
+//     return false;
+//   }
+//   const_iterator it, jt;
+//   bool found;
+//   for (it = begin(); it != end(); ++it) {
+//     found = false;
+//     for (jt = other.begin(); jt != other.end(); ++jt) {
+//       if ((*it) == (*jt)) {
+//         found = true;
+//       }
+//     }
+//     if (!found) {
+//       return false;
+//     }
+//   }
+//   return true;
+// }
+// 
+// 
+// Type::StructFieldList::const_iterator
+// Type::StructFieldList::find(const std::string& name) const {
+//   const_iterator it;
+//   for (it = begin(); it != end(); ++it) {
+//     if ((*it).name() == name) {
+//       return it;
+//     }
+//   }
+//   return end();
+// }
+// 
+// std::string Type::StructFieldList::toString() const {
+//   std::string ret = "{";
+//   std::string v = "";
+//   const_iterator it;
+//   for (it = begin(); it != end(); ++it) {
+//     ret += v + (*it).name() + ":" + (*it).type()->name();
+//     v = ", ";
+//   }
+//   ret += "}";
+//   return ret;
+// }
 
-bool
-Type::StructFieldList::isLValueFor(const Type::StructFieldList& other) const {
-  if (size() != other.size()) {
-    return false;
-  }
-  const_iterator it, jt;
-  bool found;
-  for (it = begin(); it != end(); ++it) {
-    found = false;
-    for (jt = other.begin(); jt != other.end(); ++jt) {
-      if ((*it).isLValueFor(*jt)) {
-        found = true;
-      }
-    }
-    if (!found) {
-      return false;
-    }
-  }
-  return true;
+//************* GENERAL *********************************/
+
+void Type::setConst(bool c) {
+  _isConst = c;
 }
 
-bool
-Type::StructFieldList::operator==(const Type::StructFieldList& other) const {
-  if (size() != other.size()) {
-    return false;
-  }
-  const_iterator it, jt;
-  bool found;
-  for (it = begin(); it != end(); ++it) {
-    found = false;
-    for (jt = other.begin(); jt != other.end(); ++jt) {
-      if ((*it) == (*jt)) {
-        found = true;
-      }
-    }
-    if (!found) {
-      return false;
-    }
-  }
-  return true;
+void Type::setRef(bool c) {
+  _isRef = c;
 }
 
+bool Type::isConst() const {
+  return _isConst;
+}
 
+bool Type::isRef()   const {
+  return _isRef;
+}
 
-//************* GENERAL *********************************/
+bool Type::isError() const {
+  if (_typeId == ERROR) {
+    return true;
+  }
 
+  if (isMatrix() && _ofType->isError()) {
+    return true;
+  }
+  
+  if (isStruct() && _fields.typeList().hasErrorType()) {
+    return true;
+  }
+
+  if (isSubprogram() && 
+     (_returnType->isError() || _paramTypes.hasErrorType())) {
+    return true;
+  }
+  return false;
+}
+
 bool Type::isPrimitive() const {
   return _typeId == PRIMITIVE;
 }
@@ -102,76 +146,50 @@
   return _typeId == SUBPROGRAM;
 }
 
-const std::string Type::name() const {
+const std::string& Type::name() const {
   return _name;
 }
 
+const std::string& Type::identifier() const {
+  return _identifier;
+}
+
 bool Type::equals(int id) const {
   return isPrimitive() && (_id == id);
 }
 
 bool Type::equals(Type* ofType, int dimensions) const {
-  return isMatrix() && (dimensions == _dimensions) &&
+  return isMatrix() && (dimensions == (int) _dimensions.size()) &&
           _ofType->equals(ofType);
 }
 
 /************* VIRTUAL *********************************/
 
-// bool Type::compatible(Type* other) {
-//   switch (_typeId) {
-//     case PRIMITIVE:
-//       return primitive_compatible(other);
-//     case MATRIX:
-//       return matrix_compatible(other);
-//     case STRUCT:
-//       return struct_compatible(other);
-//     case SUBPROGRAM:
-//       return subprogram_compatible(other);
-//     default:
-//       throw;
-//   }
-// }
-
-bool Type::equals(const Type* other) const {
+Type* Type::promotion(Type* other) {
   switch (_typeId) {
     case PRIMITIVE:
-      return primitive_equals(other);
+      return primitive_promotion(other);
     case MATRIX:
-      return matrix_equals(other);
+      return matrix_promotion(other);
     case STRUCT:
-      return struct_equals(other);
+      return struct_promotion(other);
     case SUBPROGRAM:
-      return subprogram_equals(other);
-    default:
-      throw;
-  }
-}
-
-Type* Type::numPromotionWith(Type* other) {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_numPromotionWith(other);
-    case MATRIX:
       return NULL;
-    case STRUCT:
-      return NULL;
-    case SUBPROGRAM:
-      return NULL;
     default:
       throw;
   }
 }
 
-Type* Type::litPromotionWith(Type* other) {
+bool Type::equals(const Type* other) const {
   switch (_typeId) {
     case PRIMITIVE:
-      return primitive_litPromotionWith(other);
+      return primitive_equals(other);
     case MATRIX:
-      return NULL;
+      return matrix_equals(other);
     case STRUCT:
-      return NULL;
+      return struct_equals(other);
     case SUBPROGRAM:
-      return NULL;
+      return subprogram_equals(other);
     default:
       throw;
   }
@@ -193,36 +211,39 @@
   }
 }
 
+
+
+//************* ERROR *********************************/
+
+
+Type::Type(TypeBuilder* builder)
+  : _typeId(ERROR), _builder(builder), _isConst(false), _isRef(false),
+    _name("erro"), _identifier(_name) {
+}
+
 //************* PRIMITIVE *********************************/
 
 
 
-Type::Type(int id, const std::string& name)
-  : _typeId(PRIMITIVE), _name(name), _id(id) {
+Type::Type(TypeBuilder* builder, int id, const std::string& name)
+  : _typeId(PRIMITIVE), _builder(builder), _isConst(false), _isRef(false),
+    _name(name), _identifier(name), _id(id) {
 }
 
 int Type::primitiveType() const {
   return _id;
 }
 
-// bool Type::primitive_compatible(Type* other) {
-//   if (other->isPrimitive()) {
-//     return equals(other) || numPromotionWith(other);
-//   } else {
-//     return false;
-//   }
-// }
+Type* Type::intOrReal(Type* other) {
+  if (!isPrimitive() || !other->isPrimitive()) {
+    return NULL;
+  }
 
-bool Type::primitive_equals(const Type* other) const {
-  return other->isPrimitive() && (other->_id == _id);
-}
-
-Type* Type::primitive_numPromotionWith(Type* other) {
   if ((_id == T_INTEIRO)
        &&
       (other->equals(T_INTEIRO) ||
        other->equals(T_REAL))) {
-    return other;
+    return _builder->primitiveType(other->primitiveType());
   } else if ((_id == T_REAL)
               &&
              (other->equals(T_INTEIRO) ||
@@ -233,7 +254,11 @@
   return NULL;
 }
 
-Type* Type::primitive_litPromotionWith(Type* other) {
+Type* Type::caracOrLit(Type* other) {
+  if (!isPrimitive() || !other->isPrimitive()) {
+    return NULL;
+  }
+
   if ((_id == T_LITERAL)
        &&
       (other->equals(T_LITERAL) ||
@@ -243,12 +268,36 @@
               &&
              ((_id == T_CARACTERE) ||
               (_id == T_LITERAL))) {
-    return other;
+    return _builder->primitiveType(other->primitiveType());
   }
 
   return NULL;
 }
 
+Type* Type::primitive_promotion(Type* other) {
+  if (!other->isPrimitive()) {
+    return NULL;
+  }
+
+  if (primitive_equals(other)) {
+    return other;
+  }
+
+  if (equals(T_CORINGA)) {
+    return other;
+  }
+
+  if (other->equals(T_CORINGA)) {
+    return this;
+  }
+
+  return intOrReal(other);
+}
+
+bool Type::primitive_equals(const Type* other) const {
+  return other->isPrimitive() && (other->_id == _id);
+}
+
 bool Type::primitive_isLValueFor(Type* rvalue) {
   if (equals(rvalue)) {
     return true;
@@ -258,53 +307,92 @@
       rvalue->equals(T_INTEIRO)) {
     return true;
   }
+
+  if (equals(T_CORINGA) || rvalue->equals(T_CORINGA)) {
+    return true;
+  }
+
   return false;
 }
 
 /************* MATRIX *********************************/
 
-Type::Type(Type* type, int dimensions)
-  : _typeId(MATRIX), _ofType(type), _dimensions(dimensions) {
 
-  _name = "matriz";
-  for (int i = 0; i < _dimensions; i++) {
-    _name += "[]";
+Type::Type(TypeBuilder* builder, Type* type, const std::list<int>& dimensions)
+  : _typeId(MATRIX), _builder(builder), _isConst(false), _isRef(false),
+    _ofType(type), _dimensions(dimensions) {
+
+/*
+  if (!_ofType->isPrimitive() && _ofType->isStruct()) {
+    throw; //ofType soh pode ser do tipo primitivo ou estrutura
   }
-  _name += " do tipo " + _ofType->name();
+
+  if (_dimensions <= 0) {
+    throw;
+  }
+*/
+
+  _name       = "matriz";
+  _identifier = "matriz";
+
+  for (int i = 0; i < (int)_dimensions.size(); i++) {
+    _name       += "[]";
+    _identifier += "_d";
+  }
+  _name       += " do tipo " + _ofType->name();
+  _identifier += "_tipo_"    + _ofType->identifier();
 }
 
-const Type* Type::ofType() const {
+Type* Type::ofType() const {
   return _ofType;
 }
 
-int Type::dimensions() const {
+const std::list<int>& Type::dimensions() const {
   return _dimensions;
 }
 
-// bool Type::matrix_compatible(Type* other) {
-//   if (other->isMatrix()) {
-//     return _dimensions == other->_dimensions &&
-//           _ofType->compatible(other->_ofType);
-//   } else {
-//     return false;
-//   }
-// }
+Type* Type::evalTypeFromSubscript(int dimensions) {
+  if (!isMatrix()) {
+    return NULL;
+  }
 
+  if (dimensions == 0) {
+    return this;
+  } else if (dimensions == (int)_dimensions.size()) {
+    return _ofType;
+  } else {
+    return _builder->matrixType(_ofType, _dimensions.size() - dimensions);
+  }
+}
+
+Type* Type::matrix_promotion(Type* other) {
+  if (!other->isMatrix()) {
+    return NULL;
+  }
+
+  Type *ofProm = _ofType->promotion(other->_ofType);
+  if (!ofProm) {
+    return NULL;
+  } else {
+    return _builder->matrixType(ofProm, _dimensions);
+  }
+}
+
 bool Type::matrix_equals(const Type* other) const {
-  return other->isMatrix() && equals(other->_ofType, other->_dimensions);
+  return other->isMatrix() && 
+         equals(other->_ofType, other->_dimensions.size());
 }
 
 bool Type::matrix_isLValueFor(Type* rvalue) {
   if (rvalue->isMatrix() &&
-      (rvalue->_dimensions == _dimensions) &&
-      rvalue->_ofType->isLValueFor(_ofType)) {
+      (rvalue->_dimensions.size() == _dimensions.size()) &&
+      _ofType->isLValueFor(rvalue->_ofType)) {
     return true;
   }
 
-  if (rvalue->isPrimitive() && rvalue->equals(T_NULO)) {
+  if (rvalue->isPrimitive() && rvalue->equals(T_CORINGA)) {
     return true;
   }
-
   return false;
 }
 
@@ -313,27 +401,70 @@
 /******************** STRUCT *********************************/
 
 
-Type::Type(const std::string& name, const StructFieldList& fields,
+Type::Type(TypeBuilder* builder,
+           const std::string& name,
+           const SymbolList& fields,
            const std::string& unit, int line)
-  : _typeId(STRUCT), _name(name), _anonymous(false), _fields(fields),
+  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
+    _name(name), _identifier(name), _anonymous(false), _fields(fields),
     _unit(unit), _line(line) {
+
+  _name = _identifier + ":{";
+  std::string v = "";
+  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
+    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
+    v = ",";
+  }
+  _name += "}";
 }
 
 
-Type::Type(const StructFieldList& fields)
-  : _typeId(STRUCT), _name("<estrutura an?nima>"), _anonymous(true),
-    _fields(fields), _unit("<interno>"), _line(-1) {
+Type::Type(TypeBuilder* builder, const SymbolList& fields)
+  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
+    _name("<an?nimo>"), _anonymous(true), _fields(fields), 
+    _unit("<interno>"), _line(-1) {
+
+  _name += ":{";
+  std::string v = "";
+  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
+    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
+    v = ",";
+  }
+  _name += "}";
 }
 
-const Type::StructFieldList& Type::fields() const {
+const SymbolList& Type::fields() const {
   return _fields;
 }
 
+Type* Type::struct_promotion(Type* other) {
+  if (!other->isStruct()) {
+    return NULL;
+  }
 
-// bool Type::struct_compatible(Type* other) {
-//   return other->isStruct() && _fields.compatible(other->_fields);
-// }
+  SymbolList                 retFieldList;
+  Type                       *promoType;
+  SymbolList::const_iterator otherFieldIt;
+  SymbolList::iterator       it;
 
+
+  for (it = _fields.begin(); it != _fields.end(); ++it) {
+    otherFieldIt = other->fields().findByIdentifier((*it).identifier());
+    if (otherFieldIt == other->fields().end()) { //structs diferentes
+      return NULL;
+    } else {
+      promoType = (*it).type()->promotion((*otherFieldIt).type());
+      if (!promoType) {
+        return NULL;
+      } else {
+        retFieldList.push_back(Symbol((*it).lexeme(), promoType));
+      }
+    }
+  }
+
+  return _builder->structType(retFieldList);
+}
+
 bool Type::struct_equals(const Type* other) const {
   if (!other->isStruct()) {
     return false;
@@ -342,7 +473,7 @@
   if ((_anonymous  && other->_anonymous) ||
       (!_anonymous && !other->_anonymous)) {
     //comparacao estrutural
-    return _fields == other->_fields;
+    return _fields.equivalent(other->_fields);
   } else {
     //comparacao nominal
     return _name == other->_name;
@@ -351,46 +482,76 @@
 
 
 bool Type::struct_isLValueFor(Type* rtype) {
-  if (rtype->isPrimitive()) {
-    return rtype->equals(T_NULO);
+  if (rtype->isPrimitive() && rtype->equals(T_CORINGA)) {
+    return true;
   }
 
   if (!rtype->isStruct()) {
     return false;
   }
 
-  if (_anonymous || rtype->_anonymous) {
-    return _fields.isLValueFor(rtype->_fields);
+  if (!_anonymous && !rtype->_anonymous) {
+    return equals(rtype);
   } else {
-    //comparacao nominal
-    return equals(rtype);
+    return fieldsIsLValueFor(rtype->_fields);
   }
 }
 
+bool Type::fieldsIsLValueFor(const SymbolList& others) {
+  if (_fields.size() != others.size()) {
+    return false;
+  }
 
+  SymbolList::const_iterator it, jt;
+  for (it = _fields.begin(); it != _fields.end(); ++it) {
+    jt = others.findByIdentifier((*it).identifier());
+    if (jt == others.end()) {
+      return false;
+    } else if (!(*it).type()->isLValueFor((*jt).type())) {
+      return false;
+    }
+  }
 
+  return true;
+}
+
 /******************** SUBPROGRAM *********************************/
 
-Type::Type(const TypeList& paramTypes,
+Type::Type(TypeBuilder* builder,
+           const TypeList& paramTypes,
            Type* returnType)
-  : _typeId(SUBPROGRAM), _paramTypes(paramTypes), _returnType(returnType) {
+  : _typeId(SUBPROGRAM), _builder(builder), _isConst(false), _isRef(false),
+    _paramTypes(paramTypes), _returnType(returnType) {
 
-  if (_returnType->equals(T_NULO)) {
+  if (!_returnType) {
     _name = "proc(";
   } else {
     _name = "func(";
   }
+
   _name += _paramTypes.toString();
   _name += ")";
-  _name += " : " + _returnType->name();
+
+  _identifier = _paramTypes.toIdentifier();
+
+  if (_returnType) {
+    _name       += " : " + _returnType->name();
+  }
 }
 
 
-// bool Type::subprogram_compatible(Type* other) {
-//   return equals(other);
+const TypeList& Type::paramTypes() const {
+  return _paramTypes;
+}
+
+Type* Type::returnType() const {
+  return _returnType;
+}
+
+// bool Type::paramMatches(const TypeList& types) const {
+//   return _paramTypes.matches(types);
 // }
 
-
 bool Type::subprogram_equals(const Type* other) const {
   return other->isSubprogram() &&
          (_paramTypes == other->_paramTypes) &&
@@ -410,7 +571,7 @@
   iterator it;
 
   for (it = begin(); it != end(); ++it) {
-    if ((*it)->name() == lexeme) {
+    if ((*it)->identifier() == lexeme) {
       return it;
     }
   }
@@ -439,12 +600,149 @@
   return end();
 }
 
+bool TypeList::equals(const TypeList& other) const {
+  const_iterator it;
+  const_iterator jt;
+
+  if (size() != other.size()) {
+    return false;
+  }
+
+  for (it = begin(), jt = other.begin();
+      (it != end()) && (jt != other.end()); ++it, ++jt) {
+    if (!(*it)->equals(*jt)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+bool TypeList::isLValueFor(const TypeList& other) const {
+  const_iterator it;
+  const_iterator jt;
+
+  if (size() != other.size()) {
+    return false;
+  }
+
+  for (it = begin(), jt = other.begin();
+      (it != end()) && (jt != other.end()); ++it, ++jt) {
+    if (!(*it)->isLValueFor(*jt)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+bool TypeList::hasErrorType() const {
+  const_iterator it;
+
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->isError()) {
+      return true;
+    }
+  }
+  return false;
+}
+
+
 std::string TypeList::toString() const {
   std::string ret = "";
+  std::string v = "";
   const_iterator it;
   for (it = begin(); it != end(); ++it) {
-    ret += (*it)->name() + ",";
+    ret += v + (*it)->name();
+    v = ",";
   }
   return ret;
 }
 
+std::string TypeList::toIdentifier() const {
+  std::string ret = "";
+  const_iterator it;
+  for (it = begin(); it != end(); ++it) {
+    ret += "_" + (*it)->identifier();
+  }
+  return ret;
+}
+
+/********************************************************************/
+
+Type* TypeBuilder::primitiveType(int id) {
+  Type* ret = new Type(this, id, g_tokenLabels[id]);
+  _types.push_back(ret);
+  return ret;
+}
+
+Type* TypeBuilder::matrixType(Type* ofType, 
+                              const std::list<int>& dimensions) {
+  Type* ret = new Type(this, ofType, dimensions);
+  _types.push_back(ret);
+  return ret;
+}
+
+Type* TypeBuilder::matrixType(Type* ofType, int dimensions) {
+  std::list<int> dims(dimensions);
+  Type* ret = new Type(this, ofType, dims);
+  _types.push_back(ret);
+  return ret;
+}
+
+
+Type* TypeBuilder::structType(const std::string& name,
+                    const SymbolList& fields,
+                    const std::string& unit,
+                    int line) {
+
+  Type* ret = new Type(this, name, fields, unit, line);
+  _types.push_back(ret);
+  return ret;
+}
+
+Type* TypeBuilder::structType(const SymbolList& fields) {
+  Type* ret = new Type(this, fields);
+  _types.push_back(ret);
+  return ret;
+}
+
+/*
+  estrutura Par?metro
+    tipo  : literal;
+    valor : coringa;
+  fim-estrutura
+
+  procedimento p( ... args) 
+
+  -> args : matriz[] do tipo Par?metro
+*/
+Type* TypeBuilder::reticencesType() {
+  SymbolList fields;
+
+  fields.push_back(Symbol("tipo", 
+    primitiveType(PortugolTokenTypes::T_LITERAL)));
+
+  fields.push_back(Symbol("valor", 
+    primitiveType(PortugolTokenTypes::T_CORINGA)));
+
+  return matrixType(
+    structType("Par?metro", fields, "<interno>",-1), std::list<int>(1));
+}
+
+Type* 
+TypeBuilder::subprogramType(const TypeList& paramTypes, Type* returnType) {
+  Type* ret = new Type(this, paramTypes, returnType);
+  _types.push_back(ret);
+  return ret;
+}
+
+Type* TypeBuilder::errorType() {
+  return new Type(this);
+}
+
+
+TypeList& TypeBuilder::typeList() {
+  return _types;
+}
+

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-12-05 11:34:22 UTC (rev 416)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-12-05 11:35:00 UTC (rev 417)
@@ -5,7 +5,9 @@
 #include <list>
 
 #include "PortugolTokenTypes.hpp"
+#include "Symbol.hpp"
 
+class TypeBuilder;
 class Type;
 
 class TypeList : public std::list<Type*> {
@@ -17,66 +19,100 @@
 
   iterator find(int id);
 
-//   void push_back(const TypeList&);
 
+  bool isLValueFor(const TypeList&) const;
+  bool equals(const TypeList&) const;
+  
+  bool hasErrorType() const;
+
   std::string toString() const;
+  std::string toIdentifier() const;
 };
 
 
+
+
 class Type : private PortugolTokenTypes {
 public:
-  enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM };
+  enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM, ERROR };
 
-  class StructField {
-  public:
-    StructField(const std::string& n, Type* t);
-    bool isLValueFor(const StructField& other) const;
+//   class StructField {
+//   public:
+//     StructField(const std::string& n, Type* t);
+// 
+//     bool isLValueFor(const StructField& other) const;
+// 
+//     bool operator==(const StructField& other) const;
+// 
+//     Type *type() const;
+//     const std::string& name() const;
+//   private:
+//     std::string _name;
+//     Type* _type;
+//   };
+// 
+//   class StructFieldList : public std::list<StructField> {
+//   public:
+// //     bool compatible(const StructFieldList& other) const;
+//     bool isLValueFor(const StructFieldList& other) const;
+//     bool operator==(const StructFieldList& other) const;
+// 
+//     const_iterator find(const std::string&) const;
+//     std::string toString() const;
+//   };
 
-//     bool compatible(const StructField& other) const;
 
-    bool operator==(const StructField& other) const;
+  //Error type
+  Type(TypeBuilder*);
 
-  private:
-    std::string name;
-    Type* type;
-  };
+  //Primitive
+  Type(TypeBuilder*, int id, const std::string& name);
+  int primitiveType() const;
 
-  class StructFieldList : public std::list<StructField> {
-  public:
-//     bool compatible(const StructFieldList& other) const;
-    bool isLValueFor(const StructFieldList& other) const;
-    bool operator==(const StructFieldList& other) const;
-  };
+  Type* intOrReal(Type* other);
+  Type* caracOrLit(Type* other);
 
+  //Matrix
+  Type(TypeBuilder*, Type* ofType, const std::list<int>& dimensions);
 
-  /* Constructors */
+  Type*                    ofType() const;
+  const std::list<int>&    dimensions() const;
 
-  //Primitive
-  Type(int id, const std::string& name);
-  int primitiveType() const;
+  Type*                    evalTypeFromSubscript(int);
 
-  //Matrix
-  Type(Type* ofType, int dimensions);
-  const Type*         ofType() const;
-  int                 dimensions() const;
-
   //Struct
-  Type(const std::string& name, const StructFieldList& fields,
-             const std::string& unit, int line);
-  Type(const StructFieldList& fields);
-  const StructFieldList& fields() const;
+  Type(TypeBuilder*,
+       const std::string& name, 
+       const SymbolList& fields,
+       const std::string& unit, int line);
 
+  Type(TypeBuilder*, const SymbolList& fields);
+
+  const SymbolList& fields() const;
+  bool fieldsIsLValueFor(const SymbolList&);
+
   //Subprogram
-  Type(const TypeList& paramTypes, Type* returnType);
+  Type(TypeBuilder*, const TypeList& paramTypes, Type* returnType);
 
+  const TypeList& paramTypes() const;
+  Type* returnType() const;
+//   bool  paramMatches(const TypeList&) const;
+  
+
   /* General Methods */
+  void setConst(bool);
+  void setRef(bool);
+  bool isConst() const;
+  bool isRef()   const;
 
+  bool isError() const;
   bool isPrimitive() const;
   bool isMatrix() const;
   bool isStruct() const;
   bool isSubprogram() const;
 
-  const std::string name() const;
+  const std::string& name() const;
+  const std::string& identifier() const;
 
   bool equals(int id) const;
   bool equals(Type* ofType, int dimensions) const;
@@ -84,49 +120,49 @@
 
 
   //virtual
-//   bool  compatible(Type* other);
+  Type* promotion(Type*);
   bool  equals(const Type* other) const;
-  Type* numPromotionWith(Type* other);
-  Type* litPromotionWith(Type* other);
   bool  isLValueFor(Type* rtype);
 
 
   //impl primitive
-//   bool  primitive_compatible(Type* other);
+  Type* primitive_promotion(Type* other);
   bool  primitive_equals(const Type* other) const;
-  Type* primitive_numPromotionWith(Type* other);
-  Type* primitive_litPromotionWith(Type* other);
   bool  primitive_isLValueFor(Type* rvalue);
 
   //impl matrix
-//   bool matrix_compatible(Type* other);
+  Type* matrix_promotion(Type* other);
   bool matrix_equals(const Type* other) const;
   bool matrix_isLValueFor(Type* rvalue);
 
   //impl struct
-//   bool struct_compatible(Type* other);
+  Type* struct_promotion(Type* other);
   bool struct_equals(const Type* other) const;
   bool struct_isLValueFor(Type* rtype);
 
   //impl subprogram
-//   bool subprogram_compatible(Type* other);
   bool subprogram_equals(const Type* other) const;
 
 private:
-  int         _typeId;
+  int          _typeId;
+  TypeBuilder* _builder;
 
-  std::string _name;
+  bool         _isConst;
+  bool         _isRef;
 
+  std::string  _name;
+  std::string  _identifier;
+
   //Primitive
   int         _id;
 
   //matrix
-  Type          *_ofType;
-  int           _dimensions;
+  Type             *_ofType;
+  std::list<int>   _dimensions;
 
   //struct
   bool             _anonymous;
-  StructFieldList  _fields;
+  SymbolList       _fields;
   std::string      _unit;
   int              _line;
 
@@ -135,4 +171,29 @@
   Type*            _returnType;
 };
 
+class TypeBuilder {
+public:
+  Type* primitiveType(int id);
+
+  Type* matrixType(Type* ofType, const std::list<int>& dimensions);
+  Type* matrixType(Type* ofType, int);
+
+  Type* structType(const std::string& name,
+                   const SymbolList& fields,
+                   const std::string& unit,
+                   int line);
+
+  Type* structType(const SymbolList& fields);
+
+  Type* reticencesType();
+
+  Type* subprogramType(const TypeList& paramTypes, Type* returnType);  
+
+  Type* errorType();
+
+  TypeList& typeList();
+private:
+  TypeList  _types;
+};
+
 #endif



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:35:57 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:35:57 +0100
Subject: [gpt-commit] r418 - trunk/gpt2/gptc/src
Message-ID: <200712051135.lB5BZvVj009949@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:35:56 +0100 (Wed, 05 Dec 2007)
New Revision: 418

Modified:
   trunk/gpt2/gptc/src/lexer.g
Log:
nomsg

Modified: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-12-05 11:35:00 UTC (rev 417)
+++ trunk/gpt2/gptc/src/lexer.g	2007-12-05 11:35:56 UTC (rev 418)
@@ -91,14 +91,16 @@
   T_NAO="n?o";
   T_VERDADEIRO="verdadeiro";
   T_FALSO="falso";
-  T_NULO="nulo";
   T_ASM="asm";
-  T_FIMASM="fim-asm";
+  T_FIMASM="fim-asm";  
 
   T_REAL_LITERAL="n?mero real"; //a regra T_INTEIRO_LITERAL lida com reais
+  
+  //imagin?rios para a AST
 
+  T_NULO="nulo";
 
-  //imagin?rios para a AST
+  
 
   T_PARAM;
   T_TIPO_RETORNO;



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:36:38 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:36:38 +0100
Subject: [gpt-commit] r419 - trunk/gpt2/gptc/src
Message-ID: <200712051136.lB5Bac0D012297@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:36:30 +0100 (Wed, 05 Dec 2007)
New Revision: 419

Modified:
   trunk/gpt2/gptc/src/teste.cpp
Log:
nomsg

Modified: trunk/gpt2/gptc/src/teste.cpp
===================================================================
--- trunk/gpt2/gptc/src/teste.cpp	2007-12-05 11:35:56 UTC (rev 418)
+++ trunk/gpt2/gptc/src/teste.cpp	2007-12-05 11:36:30 UTC (rev 419)
@@ -33,6 +33,11 @@
 RefPortugolAST dump_tree(char* fname, bool should_dump) {
 
   std::ifstream fi(fname);
+  if (!fi) {
+    std::cerr << "nao foi possivel abrir o arquivo " << fname << std::endl;
+    exit(1);
+  }
+
   PortugolLexer lexer(fi, true);
   PortugolParser parser(lexer);
 
@@ -63,7 +68,7 @@
 
   ast = dump_tree(fname, true);
 
-  SymbolTable* symtable = SymbolTable::create(fname);
+  SymbolTable* symtable = new SymbolTable(fname);
 
   SemanticWalker semantic(symtable);
   semantic.programa(ast);



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 12:37:05 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 12:37:05 +0100
Subject: [gpt-commit] r420 - trunk/gpt2/gptc/src
Message-ID: <200712051137.lB5Bb5lS013738@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 12:37:03 +0100 (Wed, 05 Dec 2007)
New Revision: 420

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Incorporacao da analise semantica concluida

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-05 11:36:30 UTC (rev 419)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-05 11:37:03 UTC (rev 420)
@@ -7,450 +7,715 @@
 #include "SymbolTableExceptions.hpp"
 
 #include <iostream>
+#include <sstream>
+using std::cerr;
+using std::endl;
 
-BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable)
- : antlr::TreeParser(), _symtable(symtable) {}
 
-void BaseSemanticWalker::useLib(const  std::string& lib) {
-  //TODO: sanitize lib: "bla\ bla" -> "bla bla"
-  std::cerr << "Using lib:" << lib << std::endl;
+
+bool InitMatrixList::hasUniformDimensions() const {
+  const_iterator it;
+  int d = -1;
+  for (it = begin(); it != end(); ++it) {
+    if (d == -1) {
+      d = (*it).first;
+    } else if (d != (*it).first) {
+      return false;
+    }
+  }
+  return true;
 }
 
-void BaseSemanticWalker::declare(const IDList& idlist,
-                                 Type* type,
-                                 bool isConst) {
+Type* InitMatrixList::elementsDivergeFrom(Type* from) const {
+  if (from->isError()) {
+    return NULL;
+  }
 
-  try {
-    IDList::const_iterator it;
-    for (it = idlist.begin(); it != idlist.end(); ++it) {
-      _symtable->declare(_symtable->newSymbol(
-            (*it)->getText(), type, (*it)->getLine(), isConst));
+  const_iterator it;
+  for (it = begin(); it != end(); ++it) {
+    if (!(*it).second->isError() && !from->promotion((*it).second)) {
+      return (*it).second;
     }
-  } catch (RedeclarationException e) {
-    cerr << "catched! Redeclaration: " << e.symbol().toString() <<"\n";
   }
+  return NULL;
 }
 
-void BaseSemanticWalker::defineStruct(const std::string& name,
-                                      const SymbolList& fieldList,
-                                      int line) {
+Type* InitMatrixList::evaluatedElementType(Type* from) const {
+  const_iterator it;
+  Type *ret = from;
+  for (it = begin(); it != end(); ++it) {
+    if (!(*it).second->isError()) {
+      ret = ret->promotion((*it).second);
+    }
+  }
+  return ret;
+}
 
-  try {
-    _symtable->defineStruct(name, fieldList, line);
-  } catch (RedefinedTypeException e) {
-    cerr << "catched! Redefined type: " << e.typeName() << "\n";
-  } catch (RedeclarationException e) {
-    cerr << "catched! Redeclaration: " << e.symbol().toString() << "\n";
+int InitMatrixList::divergentDimensionFrom(int d) const {
+  const_iterator it;
+  for (it = begin(); it != end(); it++) {
+    if (d == (*it).first) {
+      return d;
+    }
   }
+  return -1;
 }
 
-void BaseSemanticWalker::declareProc(const std::string& name,
-                                     const SymbolList& params,
-                                     int line,
-                                     Type* ret) {
+int InitMatrixList::dimensions() const {
+  return back().first;
+}
 
-  //TODO: Levar em consideracao o registro de funcoes polimorficas
-//   Type* type = _symtable->getType(params.toTypeList(),
-//           (ret == 0) ? _symtable->getType(PortugolTokenTypes::T_NULO) : ret);
+/////////////////////////////////////////////////////////////////////
 
-//   try {
-//     _symtable->declare(_symtable->newSymbol(name, type,line));
-//     _symtable->declare(params, name);
-//   } catch (RedeclarationException e) {
-//     cerr << "catched! Redeclaration: " << e.symbol().toString() << std::endl;
-//     delete type;
-//   }
+
+
+BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable)
+ : antlr::TreeParser(),
+  _symtable(symtable),
+  _typeBuilder(symtable->typeBuilder()) {
 }
 
-Type* BaseSemanticWalker::getType(const std::string& name) {
-  try {
-    return _symtable->getType(name);
-  } catch (UndeclaredTypeException e) {
-    std::cerr << "catched! Undeclared type: " << e.typeName() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
-  }
+void BaseSemanticWalker::useLib(const std::string& lib) {
+  cerr << "Using " << lib << endl;
 }
 
-Type* BaseSemanticWalker::getType(int id) {
+Type* BaseSemanticWalker::getStructType(RefPortugolAST node) {
   try {
-    return _symtable->getType(id);
+    return _symtable->getType(node->getText());
   } catch (UndeclaredTypeException e) {
-    std::cerr << "catched! Undeclared type: " << id << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(node->getLine(),
+           std::string("Undefined type: ") + node->getText());
+    return _typeBuilder->errorType();
   }
 }
 
-Type* BaseSemanticWalker::getSymbolType(const std::string& name) {
+Type* BaseSemanticWalker::getSymbolType(RefPortugolAST node) {
   try {
-    return _symtable->getSymbol(name).type();
+    return
+      _symtable->getSymbol(node->getText()).type();
   } catch (UndeclaredSymbolException e) {
-    std::cerr << "catched! Undeclared symbol: " << e.lexeme() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(node->getLine(),
+           std::string("Undeclared symbol: ") + node->getText());
+    return _typeBuilder->errorType();
   }
 }
 
-Type* BaseSemanticWalker::evalFCall(const std::string& fname,
-                                   const TypeList& paramTypes) {
-  //TODO
-  //-proibicao de consts passados para parametros "ref" sem constness
+Type* BaseSemanticWalker::getSymbolType(RefPortugolAST parent,
+                                        Type* sttype, RefPortugolAST id) {
+  if (sttype->isError()) {
+    return sttype;
+  }
 
-// - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
-//   -Avaliacao de qtd e tipos de parametros
+  if (!sttype->isStruct()) {
+    report(id->getLine(), parent->getText() + " n?o ? uma estrutura");
+    return _typeBuilder->errorType();
+  }
+
+  SymbolList::const_iterator it =
+      sttype->fields().findFirstByLexeme(id->getText());
+
+  if (it == sttype->fields().end()) {
+    report(id->getLine(),
+        sttype->name() + " n?o possui membro " + id->getText());
+    return _typeBuilder->errorType();
+  }
+
+  return (*it).type();
 }
 
-void BaseSemanticWalker::evalMatrixSubscript(Type* type) {
-  //TODO
+
+void BaseSemanticWalker::setCurrentScope(RefPortugolAST id, 
+                                         const SymbolList& params) {
+  _currentScopeSymbol = 
+      _symtable->getSymbol(id->getText(), params.typeList());
+
+  _symtable->setScope(_currentScopeSymbol);
 }
 
-  //TODO
-  //-proibicao de consts como lvalues em expressoes
 
-Type* BaseSemanticWalker::evalAttribution(Type* ltype, Type* rtype) {
-  if (!ltype->isLValueFor(rtype)) {
-    std::cerr << "ilegal: "
-              << ltype->name() << " := " << rtype->name() << endl;
+Type* BaseSemanticWalker::evalMatrixSubscript(RefPortugolAST id, Type* type,
+                                              int dimensions) {
+
+  if (type->isError()) {
+    return type;
   }
-  return rtype;
+
+  if (type->isMatrix() && (type->dimensions().size() >= (unsigned int) dimensions)) {
+    return type->evalTypeFromSubscript(dimensions);
+  } else if (type->isMatrix()) {
+    std::stringstream s;
+    s << id->getText() << " tem " << type->dimensions().size() << " dimens?es";
+    report(id->getLine(), s.str());
+  } else {
+    report(id->getLine(), id->getText() + " n?o ? uma matriz");
+  }
+  return _typeBuilder->errorType();
 }
 
-Type* BaseSemanticWalker::evalAttribution(Type* ltype, const InitMatrixList& mtx) {
-  Type* rtype = evalHomogeneity(mtx);
-  if (!ltype->isLValueFor(rtype)) {
-    std::cerr << "ilegal: "
-              << ltype->name() << " := " << rtype->name() << endl;
+void BaseSemanticWalker::declare(const IDList& ids, Type* type) {
+  try {
+    IDList::const_iterator it;
+    for (it = ids.begin(); it != ids.end(); ++it) {
+      _symtable->insertSymbol(
+        Symbol((*it)->getText(),
+              type,
+              _symtable->currentScope(),
+              _symtable->unit(),
+              (*it)->getLine()));
+    }
+  } catch (RedeclarationException e) {
+    report(ids.back()->getLine(),
+           std::string("Redeclaration: ") + e.symbol().toString());
   }
-  return ltype;
 }
 
-Type* BaseSemanticWalker::evalAttribution(Type* ltype, const InitStructList& stc) {
-  Type* rtype = createAnonymousStructFor(stc);
+void BaseSemanticWalker::declareProc(RefPortugolAST id,
+                                     SymbolList& params) {
 
-  if (!ltype->isLValueFor(rtype)) {
-    std::cerr << "ilegal: "
-              << ltype->name() << " := " << rtype->name() << endl;
+  Type *type = 
+    _typeBuilder->subprogramType(
+        params.typeList(), 
+        _typeBuilder->primitiveType(PortugolTokenTypes::T_NULO));
+
+  Symbol s(id->getText(),
+            type,
+            _symtable->globalScope(),
+            _symtable->unit(),
+            id->getLine());
+
+  declareProc(s, params);
+}
+
+void BaseSemanticWalker::declareProc(RefPortugolAST id,
+                                     SymbolList& params,
+                                     Type *rettype) {
+
+  Type *type = _typeBuilder->subprogramType(params.typeList(), rettype);
+
+  Symbol s(id->getText(),
+            type,
+            _symtable->globalScope(),
+            _symtable->unit(),
+            id->getLine());
+
+  declareProc(s, params);
+
+}
+
+void BaseSemanticWalker::declareProc(const Symbol& s, 
+                                     SymbolList& params) {
+  try {
+    _symtable->insertSymbol(s);
+  } catch (RedeclarationException e) {
+    report(e.symbol().line(),
+           std::string("Redeclaration: ") + e.symbol().toString());
+    _symtable->setIgnoreScope();
+    return;
+  }  
+
+  _symtable->setScope(s);
+  params.setScope(s.identifier());
+
+  try {
+    _symtable->insertSymbols(params);
+  } catch (RedeclarationException e) {
+    report(e.symbol().line(),
+           std::string("Redeclaration: ") + e.symbol().toString());
+  }  
+}
+
+void BaseSemanticWalker::declareStruct(RefPortugolAST id,
+                                       const SymbolList& fieldList) {
+
+  try {
+    _symtable->insertType(id->getText(), fieldList, id->getLine());
+  } catch (RedefinedTypeException e) {
+    report(id->getLine(), std::string("Redefinition: ") + e.typeName());
+  } catch (RedeclarationException e) {
+    report(id->getLine(), std::string("Redeclaration: ") + e.symbol().toString());
   }
-  return ltype;
 }
 
-Type* BaseSemanticWalker::createAnonymousStructFor(const InitStructList& stc) {
-  SymbolList slist;
+// void BaseSemanticWalker::defineStruct(RefPortugolAST id,
+//                                       const SymbolList& fieldList) {
+// 
+//   try {
+//     _symtable->insertType(id->getText(), fieldList, id->getLine());
+//   } catch (RedefinedTypeException e) {
+//     report(id->getLine(), std::string("Redefinition: ") + e.typeName());
+//   } catch (RedeclarationException e) {
+//     report(id->getLine(), std::string("Redeclaration: ") + e.symbol().toString());
+//   }
+// }
+
+Type* BaseSemanticWalker::evalInitStruct(const InitStructList& stc) {
+  SymbolList flist;
   InitStructList::const_iterator it;
   for (it = stc.begin(); it != stc.end(); ++it) {
-    slist.push_back(_symtable->newSymbol(it->first, it->second));
+    flist.push_back(Symbol(it->first->getText(), 
+                    it->second, 
+                    _symtable->globalScope(), 
+                    _symtable->unit(),
+                    it->first->getLine()));
   }
+  return _typeBuilder->structType(flist);
+}
 
-  return _symtable->createAnonymousStruct(slist);
+Type* BaseSemanticWalker::evalInitMatrix(int line,const InitMatrixList& mtx) {
+  if (!mtx.hasUniformDimensions()) {
+    std::stringstream s;
+    s << "Matriz tem valores em dimens?es diferentes";
+
+    report(line, s.str());
+    return _typeBuilder->errorType();
+  }
+
+
+  Type *ptype = mtx.front().second;
+  Type *dtype;
+  if (dtype = mtx.elementsDivergeFrom(ptype)) {
+    report(line, std::string("Matriz heterogenea: ")
+                 + ptype->name()
+                 + " e "
+                 + dtype->name());
+    return _typeBuilder->errorType();
+  }
+
+  Type *ret = _typeBuilder->matrixType(
+        mtx.evaluatedElementType(ptype), mtx.dimensions());
+
+  return ret;
 }
 
-Type* BaseSemanticWalker::evalHomogeneity(const InitMatrixList& mtx) {
-  InitMatrixList::const_iterator it;
 
-  Type *rtype = 0;
-  Type *tmptype = 0;
-  int dim = 0;
 
-  for (it = mtx.begin(); it != mtx.end(); ++it) {
-    if (dim == 0) {
-      dim = it->first;
-    } else if (dim != it->first) {
-      std::cerr << "ilegal: Numero variavel de dimensoes na matriz!\n";
-    }
+void BaseSemanticWalker::evalAttribution(int line,
+                                         Type* ltype, Type* rtype) {
+  if (ltype->isError() || rtype->isError()) {
+    return;
+  }
 
-    if (rtype == 0) {
-      rtype = it->second;
-    } else if (!rtype->equals(it->second)) {
-      std::cerr << "ilegal: Matriz heterogenea\n";
-    }
+  if (!ltype->isLValueFor(rtype)) {
+    report(line, string("ilegal: ") + ltype->name() + " := " + rtype->name());
   }
+}
 
-  return _symtable->getType(rtype, dim);
+
+Type* BaseSemanticWalker::evalCall(RefPortugolAST id,
+                                   const TypeList& paramTypes) {
+  //TODO
+  //-proibicao de consts passados para parametros "ref" sem constness
+
+// - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
+//   -Avaliacao de qtd e tipos de parametros
+
+  if (paramTypes.hasErrorType()) {
+    return _typeBuilder->errorType();
+  }
+
+  try {
+    return 
+      _symtable->getSymbol(id->getText(), paramTypes).type()->returnType();
+  } catch (UndeclaredSymbolException e) {
+    report(id->getLine(), std::string("Undeclared '") + id->getText());
+    return _typeBuilder->errorType();
+  } catch (UnmatchedException e) {
+    report(id->getLine(),
+           std::string("No matching call for '") + id->getText() 
+           + "(" + paramTypes.toString() + ")'");
+    return _typeBuilder->errorType();
+  }
 }
 
+void BaseSemanticWalker::evalRetorne(int line,Type* type) {
+  if (_symtable->isInGlobalScope()) {
+    report(line, "N?o h? retorno em escopo global");
+  } else if(!_currentScopeSymbol.type()->returnType()->isLValueFor(type)) {
+    report(line, "Tipo de retorno (" 
+           + type->name() + ") incompat?vel com tipo da fun??o (" 
+           + _currentScopeSymbol.type()->returnType()->name() +")");
+  }
+}
+
+
+void BaseSemanticWalker::evalCondicional(int line, Type* type) {
+  if (!type->equals(PortugolTokenTypes::T_LOGICO)) {
+    report(line, 
+      std::string("Enunciado exige express?o l?gica. Tipo ") 
+      + type->name() + " encontrado.");
+  }
+}
+
+/************************ EXPR ********************************************/
+
 Type*
-BaseSemanticWalker::evalExpr_OU(Type* left, Type* right) {
-  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
+BaseSemanticWalker::evalExpr_OU(int,Type* left, Type* right) {
+  //TODO: refatorar os copy/pastes dos metodos evalExpr
+
+  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 Type*
-BaseSemanticWalker::evalExpr_E(Type* left, Type* right) {
-  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
+BaseSemanticWalker::evalExpr_E(int,Type* left, Type* right) {
+  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_OU(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_OU(int line,Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " | " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " | " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_OUX(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_OUX(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " ^ " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " ^ " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_E(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_E(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " & " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " & " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_IGUAL(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_IGUAL(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(right)) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " = " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " = " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_DIFERENTE(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_DIFERENTE(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(right)) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " <> " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " <> " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIOR(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIOR(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->numPromotionWith(right))) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+      (left->equals(right) || left->intOrReal(right))) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " > " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " > " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOR(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOR(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->numPromotionWith(right))) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+      (left->equals(right) || left->intOrReal(right))) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " < " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " < " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIOR_EQ(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIOR_EQ(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->numPromotionWith(right))) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+      (left->equals(right) || left->intOrReal(right))) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " >= " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " >= " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOR_EQ(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOR_EQ(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->numPromotionWith(right))) {
-    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+      (left->equals(right) || left->intOrReal(right))) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " <= " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " <= " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " << " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " << " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " >> " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " >> " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIS(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIS(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    std::cerr << "ilegal: "
-              << left->name() << " + " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " + " + right->name());
+    return _typeBuilder->errorType();
   }
 
   Type* ret;
-  if (ret = left->numPromotionWith(right)) {
+  if (ret = left->intOrReal(right)) {
     return ret;
-  } else if (ret = left->litPromotionWith(right)) {
+  } else if (ret = left->caracOrLit(right)) {
     return ret;
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " + " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " + " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOS(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOS(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    std::cerr << "ilegal: "
-              << left->name() << " + " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " - " + right->name());
+    return _typeBuilder->errorType();
   }
 
   Type* ret;
-  if (ret = left->numPromotionWith(right)) {
+  if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " - " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " - " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_DIV(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_DIV(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    std::cerr << "ilegal: "
-              << left->name() << " + " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " / " + right->name());
+    return _typeBuilder->errorType();
   }
 
   Type* ret;
-  if (ret = left->numPromotionWith(right)) {
+  if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " / " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " / " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MULTIP(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MULTIP(int line, Type* left, Type* right) {
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    std::cerr << "ilegal: "
-              << left->name() << " + " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " * " + right->name());
+    return _typeBuilder->errorType();
   }
 
   Type* ret;
-  if (ret = left->numPromotionWith(right)) {
+  if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " * " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " * " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_MOD(Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MOD(int line, Type* left, Type* right) {
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << left->name() << " % " << right->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + left->name() + " % " + right->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_NEGATIVO(Type* left) {
+BaseSemanticWalker::evalExpr_UN_NEGATIVO(int line, Type* left) {
+  if (left->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
       left->equals(PortugolTokenTypes::T_REAL)) {
-    return left;
+    return _typeBuilder->primitiveType(left->primitiveType());
   } else {
-    std::cerr << "ilegal: "
-              << " - " << left->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + " - " + left->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_POSITIVO(Type* left) {
+BaseSemanticWalker::evalExpr_UN_POSITIVO(int line, Type* left) {
+  if (left->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
       left->equals(PortugolTokenTypes::T_REAL)) {
-    return left;
+    return _typeBuilder->primitiveType(left->primitiveType());
   } else {
-    std::cerr << "ilegal: "
-              << " + " << left->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + " + " + left->name());
+    return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_NAO(Type* left) {
-  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
+BaseSemanticWalker::evalExpr_NAO(int, Type* left) {
+  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_NAO(Type* left) {
+BaseSemanticWalker::evalExpr_BIT_NAO(int line, Type* left) {
+  if (left->isError()) {
+    return _typeBuilder->errorType();
+  }
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    std::cerr << "ilegal: "
-              << " ~ " << left->name() << std::endl;
-    return _symtable->getType(PortugolTokenTypes::T_NULO);
+    report(line, 
+      std::string("ilegal: ") + " ~ " + left->name());
+    return _typeBuilder->errorType();
   }
 }
 
+
+/********************************************************************/
+
+
+
+
+void BaseSemanticWalker::report(int line, const std::string& s) {
+  cerr << "linha " << line << " - " << s << endl;
+}

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-05 11:36:30 UTC (rev 419)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-05 11:37:03 UTC (rev 420)
@@ -26,17 +26,28 @@
 #include <string>
 
 #include "PortugolAST.hpp"
+#include "Symbol.hpp"
 
 class SymbolTable;
-class SymbolList;
 class Type;
 class TypeList;
+class TypeBuilder;
 
-typedef std::list<RefPortugolAST> IDList;
+typedef std::list<RefPortugolAST>                IDList;
 
-typedef std::list<std::pair<std::string,Type*> > InitStructList;
-typedef std::list<std::pair<int,Type*> >         InitMatrixList;
+//list<pair<field, type>>
+typedef std::list<std::pair<RefPortugolAST,Type*> > InitStructList;
 
+//list<pair<dimsize,type>>
+class InitMatrixList : public std::list<std::pair<int,Type*> > {
+public:
+  bool              hasUniformDimensions() const;
+  Type*             elementsDivergeFrom(Type*) const;
+  Type*             evaluatedElementType(Type* from) const;
+  int               divergentDimensionFrom(int) const;
+  int               dimensions() const;
+};
+
 class BaseSemanticWalker : public antlr::TreeParser {
 
 public:
@@ -45,55 +56,65 @@
 protected:
   void useLib(const std::string&);
 
-  void declare(const IDList&, Type*, bool);
+  Type* getStructType(RefPortugolAST);
 
-  void defineStruct(const std::string&, const SymbolList&, int);
+  Type* getSymbolType(RefPortugolAST);
 
-  void declareProc(const std::string&, const SymbolList&, int, Type* = 0);
+  Type* getSymbolType(RefPortugolAST,Type*, RefPortugolAST);
 
-  Type* getType(const std::string&);
-  Type* getType(int);
+  void setCurrentScope(RefPortugolAST id, const SymbolList& params);
 
-  Type* createAnonymousStructFor();
+  void declare(const IDList&, Type*);
 
-  Type* getSymbolType(const std::string&);
+  void declareProc(RefPortugolAST, SymbolList&);
+  void declareProc(RefPortugolAST, SymbolList&, Type*);
+  void declareProc(const Symbol&,  SymbolList&);
 
-  Type* evalFCall(const std::string&, const TypeList&);
+//   void defineStruct(RefPortugolAST, const SymbolList&);
+  void declareStruct(RefPortugolAST, const SymbolList& );
 
-  void evalMatrixSubscript(Type*);
 
-  Type* evalAttribution(Type*, Type*);
-  Type* evalAttribution(Type*, const InitMatrixList&);
-  Type* evalAttribution(Type*, const InitStructList&);
+  Type* evalInitStruct(const InitStructList& stc);
+  Type* evalInitMatrix(int, const InitMatrixList& mtx);
 
-  Type* createAnonymousStructFor(const InitStructList&);
+  Type* evalMatrixSubscript(RefPortugolAST, Type*, int);
 
-  Type* evalHomogeneity(const InitMatrixList& mtx);
+  void evalAttribution(int,Type*, Type*);
 
-  Type* evalExpr_OU(Type* left, Type* right);
-  Type* evalExpr_E(Type* left, Type* right);
-  Type* evalExpr_BIT_OU(Type* left, Type* right);
-  Type* evalExpr_BIT_OUX(Type* left, Type* right);
-  Type* evalExpr_BIT_E(Type* left, Type* right);
-  Type* evalExpr_IGUAL(Type* left, Type* right);
-  Type* evalExpr_DIFERENTE(Type* left, Type* right);
-  Type* evalExpr_MAIOR(Type* left, Type* right);
-  Type* evalExpr_MENOR(Type* left, Type* right);
-  Type* evalExpr_MAIOR_EQ(Type* left, Type* right);
-  Type* evalExpr_MENOR_EQ(Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_LEFT(Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_RIGHT(Type* left, Type* right);
-  Type* evalExpr_MAIS(Type* left, Type* right);
-  Type* evalExpr_MENOS(Type* left, Type* right);
-  Type* evalExpr_DIV(Type* left, Type* right);
-  Type* evalExpr_MULTIP(Type* left, Type* right);
-  Type* evalExpr_MOD(Type* left, Type* right);
-  Type* evalExpr_UN_NEGATIVO(Type*);
-  Type* evalExpr_UN_POSITIVO(Type*);
-  Type* evalExpr_NAO(Type*);
-  Type* evalExpr_BIT_NAO(Type*);
+  Type* evalCall(RefPortugolAST id, const TypeList& paramTypes);
 
+  void evalRetorne(int,Type*);
+
+  void evalCondicional(int, Type*);
+
+  Type* evalExpr_OU(int,Type* left, Type* right);
+  Type* evalExpr_E(int,Type* left, Type* right);
+  Type* evalExpr_BIT_OU(int,Type* left, Type* right);
+  Type* evalExpr_BIT_OUX(int,Type* left, Type* right);
+  Type* evalExpr_BIT_E(int,Type* left, Type* right);
+  Type* evalExpr_IGUAL(int,Type* left, Type* right);
+  Type* evalExpr_DIFERENTE(int,Type* left, Type* right);
+  Type* evalExpr_MAIOR(int,Type* left, Type* right);
+  Type* evalExpr_MENOR(int,Type* left, Type* right);
+  Type* evalExpr_MAIOR_EQ(int,Type* left, Type* right);
+  Type* evalExpr_MENOR_EQ(int,Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_LEFT(int,Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_RIGHT(int,Type* left, Type* right);
+  Type* evalExpr_MAIS(int,Type* left, Type* right);
+  Type* evalExpr_MENOS(int,Type* left, Type* right);
+  Type* evalExpr_DIV(int,Type* left, Type* right);
+  Type* evalExpr_MULTIP(int,Type* left, Type* right);
+  Type* evalExpr_MOD(int,Type* left, Type* right);
+  Type* evalExpr_UN_NEGATIVO(int,Type*);
+  Type* evalExpr_UN_POSITIVO(int,Type*);
+  Type* evalExpr_NAO(int,Type*);
+  Type* evalExpr_BIT_NAO(int,Type*);
+
+  void report(int, const std::string&);
+
   SymbolTable* _symtable;
+  TypeBuilder* _typeBuilder;
+  Symbol       _currentScopeSymbol;
 };
 
 #endif

Modified: trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-05 11:36:30 UTC (rev 419)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-05 11:37:03 UTC (rev 420)
@@ -49,3 +49,15 @@
 const Symbol& RedeclarationException::symbol() const {
   return _symbol;
 }
+
+//--------------------------------------------------------
+
+
+UnmatchedException::UnmatchedException(const std::string& l)
+  : _lexeme(l) {
+
+}
+
+const std::string& UnmatchedException::lexeme() {
+  return _lexeme;
+}

Modified: trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-05 11:36:30 UTC (rev 419)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-05 11:37:03 UTC (rev 420)
@@ -2,6 +2,7 @@
 #define SYMBOLTABLEEXCEPTIONS_HPP
 
 #include "Symbol.hpp"
+#include "Types.hpp"
 
 #include <string>
 
@@ -39,11 +40,20 @@
 
 class RedeclarationException {
 public:
-  RedeclarationException(const Symbol& s);
+  RedeclarationException(const Symbol&);
 
   const Symbol& symbol() const;
 private:
   Symbol _symbol;
 };
 
+class UnmatchedException {
+public:
+  UnmatchedException(const std::string&);
+
+  const std::string& lexeme();
+private:
+  std::string _lexeme;
+};
+
 #endif

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-05 11:36:30 UTC (rev 419)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-05 11:37:03 UTC (rev 420)
@@ -25,7 +25,6 @@
   #include "SymbolTable.hpp"
 }
 
-
 options {
   language="Cpp";
 }
@@ -36,7 +35,6 @@
   noConstructors = true;
   genHashLines   = false;
   ASTLabelType   = "RefPortugolAST";
-//   defaultErrorHandler=false;
 }
 
 {
@@ -55,14 +53,15 @@
 
         (importacao)*
 
-        declaracoes_globais
+        (declaracoes)?
+
                                       //recuperando declaracoes globais e
                                       //de subprogramas para a symtable
                                       {inicio = _t; /*backup da posicao*/}
-        definicoes_subprogramas
+        (declaracoes_subprogramas)?
 
         EOF
-                                      //analise semantica do codigo
+                                      //analise semantica dos blocos
                                       {_t = inicio; /*rollback*/}
         corpo
         EOF
@@ -70,109 +69,188 @@
   ;
 
 importacao
-  : #(T_USE lib:T_TEXTO_LITERAL)                  {useLib(lib->getText());}
+  : #(T_USE lib:T_TEXTO_LITERAL)      {useLib(lib->getText());}
   ;
 
-declaracoes_globais
-  : declaracao_variavel  (declaracoes_globais)?
-  | declaracao_constante (declaracoes_globais)?
-  | definicao_estrutura  (declaracoes_globais)?
-  ;
 
-definicoes_subprogramas
-  : definicao_subprograma (definicoes_subprogramas)?
-  | T_INICIO (definicoes_subprogramas)?
+/*********************** DECLARACOES *******************************/
+
+declaracoes
+  : declaracao_variavel    (declaracoes)?
+  | declaracao_constante   (declaracoes)?
+  | declaracao_estrutura   (declaracoes)?
   ;
 
 declaracao_variavel
                                 {
                                   IDList ids;
                                   Type *type;
+                                  Type *rtype;
                                 }
 
-  : #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao[type])?)
+  : #(T_VARIAVEL
+        type=tipo
+        ids=identificadores     {declare(ids, type);}
 
-                                {declare(ids, type, false);}
-  ;
+        (
+          rtype=valor_inicialiacao
 
-identificadores returns [IDList list]
-  : (
-      id:T_IDENTIFICADOR      {list.push_back(id);}
-    )*
+                                {evalAttribution(
+                                    ids.back()->getLine(), type, rtype);}
+        )?
+    )
   ;
 
 declaracao_constante
                                 {
                                   IDList ids;
                                   Type *type;
+                                  Type *rtype;                                  
                                 }
 
-  : #(T_CONSTANTE type=tipo ids=identificadores valor_inicialiacao[type])
+  : #(T_CONSTANTE
+        type=tipo
+        ids=identificadores
+        rtype=valor_inicialiacao)
 
-                                {declare(ids, type, true);}
+                                {
+                                  type->setConst(true);
+                                  declare(ids, type);
+                                  evalAttribution(
+                                      ids.back()->getLine(), type, rtype);
+                                }
   ;
 
-definicao_estrutura
-                                {SymbolList symbols;}
+identificadores returns [IDList list]
+  : (
+      id:T_IDENTIFICADOR        {list.push_back(id);}
+    )*
+  ;
 
-  : #(T_ESTRUTURA id:T_IDENTIFICADOR symbols=campos_estrutura)
+tipo returns [Type *type]
+  : id:T_IDENTIFICADOR          {type = getStructType(id);}
+  | type=tipo_primitivo
+  | type=tipo_matriz
+  ;
 
-                                {defineStruct(id->getText(),
-                                    symbols, id->getLine());}
+tipo_primitivo returns [Type *type]
+
+                      {RefPortugolAST prim = _t;}
+  : (
+        T_INTEIRO
+      | T_REAL
+      | T_CARACTERE
+      | T_LITERAL
+      | T_LOGICO
+      | T_CORINGA
+    )
+                      {type = _typeBuilder->primitiveType(prim->getType());}
   ;
 
-campos_estrutura returns [SymbolList symbols]
+tipo_matriz returns [Type *type]
 
+                        {
+                          std::list<int> dims;
+                          Type* ofType;
+                        }
+
+  : #(T_MATRIZ ofType=tipo dims=dimensoes)
+
+                  {type =_typeBuilder->matrixType(ofType,dims);}
+
+  ;
+
+dimensoes returns [std::list<int> dims]
+
+                        {int dsize;}
+  : (
+      dsize=dimensao
+                        {dims.push_back(dsize);}
+    )*
+  ;
+
+dimensao returns [int size]
+  : i:T_INTEIRO_LITERAL     {size = atoi(i->getText().c_str());}
+  | n:T_NULO                {size = 0;}
+  ;
+
+
+
+
+declaracao_estrutura
+                                {SymbolList fields;}
+
+  : #(T_ESTRUTURA id:T_IDENTIFICADOR fields=campos_estrutura)
+
+                                {declareStruct(id, fields);}
+  ;
+
+campos_estrutura returns [SymbolList fields]
+
                                 {
                                   IDList ids;
                                   Type *type;
+                                  Type *rtype;                                  
                                 }
 
   : (
-      #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao[type])?)
+      #(T_VARIAVEL type=tipo ids=identificadores
+            (
+              rtype=valor_inicialiacao
 
+                                {evalAttribution(
+                                  ids.back()->getLine(), type, rtype);}
+
+            )?
+    )
+
                                 {
                                   for (IDList::iterator it = ids.begin();
                                          it != ids.end(); ++it) {
-                                    symbols.push_back(
-                                      _symtable->newSymbol(
-                                          (*it)->getText(), type,
-                                               (*it)->getLine()));
+                                    fields.push_back(
+                                      Symbol((*it)->getText(),
+                                                    type,
+                                                    _symtable->currentScope(),
+                                                    _symtable->unit(),
+                                                    (*it)->getLine()));
                                   }
                                 }
     )+
   ;
 
-valor_inicialiacao[Type* ltype]
 
+/********************** INICIALIZACAO *************************/
+
+
+valor_inicialiacao returns [Type *rtype]
+
                           {
-                            Type* rtype;
                             _analisingInitializationList = true;
                           }
 
-  : #(v:T_VALOR rtype=valor[ltype])
+  : #(v:T_VALOR rtype=valor)
 
                           {
-                            v->setEvalType(rtype);
                             _analisingInitializationList = false;
                           }
   ;
 
-valor[Type *ltype] returns [Type* rtype]
+valor returns [Type *rtype]
                           {
                             InitMatrixList         mtx;
                             InitStructList         stc;
                           }
+  : rtype=expressao
 
-  : rtype=expressao       {rtype = evalAttribution(ltype, rtype);}
+  | #(m:T_VAL_MATRIZ
+        (valor_matriz[1,mtx])+)
 
-  | #(T_VAL_MATRIZ  (valor_matriz[1,mtx])+)
+                          {rtype = evalInitMatrix(m->getLine(), mtx);}
 
-                          {rtype = evalAttribution(ltype, mtx);}
+  | #(T_VAL_ESTRUTURA
+      (id:T_IDENTIFICADOR valor_estrutura[id,stc])+)
 
-  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)
-
-                          {rtype = evalAttribution(ltype, stc);}
+                          {rtype = evalInitStruct(stc);}
   ;
 
 valor_matriz [int dimension, InitMatrixList& mtx]
@@ -184,71 +262,61 @@
 
   : type=expressao     {mtx.push_back(std::pair<int,Type*>(dimension, type));}
 
-  | #(T_VAL_MATRIZ (valor_matriz[dimension+1, mtx])+)
+  | #(T_VAL_MATRIZ
+      (valor_matriz[dimension+1, mtx])+)
 
-  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(), stc])+)
+  | #(T_VAL_ESTRUTURA
+      (id:T_IDENTIFICADOR valor_estrutura[id, stc])+)
 
                        {mtx.push_back(std::pair<int,Type*>(dimension,
-                            createAnonymousStructFor(stc)));}
+                            evalInitStruct(stc)));}
   ;
 
-valor_estrutura [const std::string& field, InitStructList& stc]
+valor_estrutura [RefPortugolAST field, InitStructList& stc]
                               {
                                 Type *type;
                                 InitMatrixList mtx;
+                                InitStructList stc_;
                               }
   : type=expressao
                               {
                                 stc.push_back(
-                                  std::pair<std::string,Type*>(
+                                  std::pair<RefPortugolAST,Type*>(
                                     field, type));
                               }
 
-  | #(T_VAL_MATRIZ (valor_matriz[1, mtx])+)
+  | #(m:T_VAL_MATRIZ
+      (valor_matriz[1, mtx])+)
+
                               {
-                                type = evalHomogeneity(mtx);
+                                type = evalInitMatrix(m->getLine(), mtx);
                                 stc.push_back(
-                                  std::pair<std::string,Type*>(
-                                    field,type));
+                                  std::pair<RefPortugolAST,Type*>(
+                                    field, type));
                               }
 
-  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)
-  ;
+  | #(T_VAL_ESTRUTURA
+      (id:T_IDENTIFICADOR valor_estrutura[id,stc_])+)
 
-
-tipo returns [Type *type]
-  : id:T_IDENTIFICADOR       {type = getType(id->getText());}
-  | type=tipo_primitivo
-  | type=tipo_matriz
+                              {
+                                type = evalInitStruct(stc_);
+                                stc.push_back(
+                                  std::pair<RefPortugolAST,Type*>(
+                                    field, type));
+                              }
   ;
 
-tipo_primitivo returns [Type *type]
-  : i:T_INTEIRO             {type = getType(i->getText());}
-  | r:T_REAL                {type = getType(r->getText());}
-  | ca:T_CARACTERE          {type = getType(ca->getText());}
-  | li:T_LITERAL            {type = getType(li->getText());}
-  | lo:T_LOGICO             {type = getType(lo->getText());}
-  | co:T_CORINGA            {type = getType(co->getText());}
-  ;
 
-tipo_matriz returns [Type *type]
 
-                            {
-                              int d = 0;
-                              Type * ofType;
-                            }
 
-  : #(T_MATRIZ ofType=tipo (dimensao {d++;})*)
+/********************* DECLARACAO SUBPROGRAMAS ****************************/
 
-                            {type = _symtable->getType(ofType,d);}
+declaracoes_subprogramas
+  : declaracao_subprograma (declaracoes_subprogramas)?
+  | T_INICIO               (declaracoes_subprogramas)?//pula o bloco principal
   ;
 
-dimensao
-  : T_INTEIRO_LITERAL
-  | T_NULO
-  ;
-
-definicao_subprograma
+declaracao_subprograma
   : declaracao_funcao
   | declaracao_procedimento
   ;
@@ -258,13 +326,10 @@
 
   : #(T_PROCEDIMENTO
         id:T_IDENTIFICADOR
-        params=lista_parametros[id->getText()]
+        params=lista_parametros
 
                                       {
-                                        declareProc(id->getText(),
-                                                   params, id->getLine());
-
-                                        _symtable->setScope(id->getText());
+                                        declareProc(id, params);
                                       }
 
       (declaracao_variavel | declaracao_constante)*)
@@ -275,17 +340,14 @@
 declaracao_funcao
                                       {
                                         SymbolList params;
-                                        Type * rettype;
+                                        Type *type;
                                       }
   : #(T_FUNCAO
         id:T_IDENTIFICADOR
-        params=lista_parametros[id->getText()]
-        rettype=tipo_retorno
+        params=lista_parametros
+        type=tipo_retorno
                                       {
-                                        declareProc(id->getText(),
-                                            params, id->getLine(), rettype);
-
-                                        _symtable->setScope(id->getText());
+                                        declareProc(id, params, type);
                                       }
 
       (declaracao_variavel | declaracao_constante)*)
@@ -293,76 +355,54 @@
                                       {_symtable->setGlobalScope();}
   ;
 
-tipo_retorno returns [Type * ret]
-  : #(T_TIPO_RETORNO ret=tipo)
+tipo_retorno returns [Type* type]
+  : #(T_TIPO_RETORNO type=tipo)
   ;
 
-lista_parametros[std::string scope] returns [SymbolList list]
+lista_parametros returns [SymbolList list]
 
-                                  {Type *type;}
-  : (
-      #(T_PARAM type=tipo id:T_IDENTIFICADOR (r:T_REF)? (c:T_CONSTANTE)?)
+                                 {Symbol symbol;}
 
-                                  {
-                                    list.push_back(
-                                        _symtable->newSymbol(
-                                          id->getText(), type,
-                                          scope,
-                                          id->getLine(),
-                                          c != antlr::nullAST,
-                                          r != antlr::nullAST));
-
-                                      c = antlr::nullAST;
-                                      r = antlr::nullAST;
-                                  }
-    )*
+  : (#(T_PARAM symbol=parametro) {list.push_back(symbol);})*
   ;
 
+parametro returns [Symbol symbol]
 
-corpo
-  :  corpo_subprograma      (corpo)?
-  |  bloco_codigo           (corpo_subprograma)*
-  ;
+                                  {Type* type;}
 
+  : type=tipo id:T_IDENTIFICADOR (r:T_REF)? (c:T_CONSTANTE)?
 
-corpo_subprograma
-  : #(T_FUNCAO   f:T_IDENTIFICADOR     {_symtable->setScope(f->getText());}
-                 (~(T_INICIO))*
-                 bloco_codigo          {_symtable->setGlobalScope();}
-    )
-  | #(T_PROCEDIMENTO p:T_IDENTIFICADOR {_symtable->setScope(p->getText());}
-                 (~(T_INICIO))*
-                 bloco_codigo)         {_symtable->setGlobalScope();}
-  ;
+                                  {
+                                    if (c != antlr::nullAST) {
+                                      type->setConst(true);
+                                    }
 
+                                    if (r != antlr::nullAST) {
+                                      type->setRef(true);
+                                    }
 
+                                    symbol = 
+                                        Symbol(id->getText(),
+                                          type,
+                                          _symtable->unit(),
+                                          id->getLine());
+                                  }
 
-bloco_codigo
-  : #(T_INICIO (enunciado)*)
-  ;
+  | T_RETICENCIAS idret:T_IDENTIFICADOR
 
-enunciado
-  : en_atribuicao
-//   | en_retorne
-//   | en_se
-//   | en_enquanto
-//   | en_repita
-//   | en_para
-//   | en_caso
-//   | en_asm
-//
-//   | T_SAIR
-//   | chamada_subrotina T_PONTO_VIRGULA!
+                                  {
+                                    symbol = Symbol(idret->getText(),
+                                              _typeBuilder->reticencesType(),
+                                              _symtable->unit(),
+                                              idret->getLine());
+                                  }
   ;
 
-en_atribuicao
-                        {Type *ltype, *rtype;}
 
-  : #(T_ATRIBUICAO ltype=lvalue rtype=expressao)
+/* ************************* EXPRESSOES *************************/
 
-                        {evalAttribution(ltype, rtype);}
-  ;
 
+
 expressao returns [Type *type]
                                       {
                                         Type *l, *r;
@@ -371,109 +411,151 @@
   : (
 
       #(T_OU              l=expressao r=expressao)
-                                      {type = evalExpr_OU(l,r);}
+                                      {type = evalExpr_OU(op->getLine(), l,r);}
 
     | #(T_E               l=expressao r=expressao)
-                                      {type = evalExpr_E(l,r);}
+                                      {type = evalExpr_E(op->getLine(), l,r);}
 
     | #(T_BIT_OU          l=expressao r=expressao)
-                                      {type = evalExpr_BIT_OU(l,r);}
+                                      {type = evalExpr_BIT_OU(op->getLine(), l,r);}
 
     | #(T_BIT_OUX         l=expressao r=expressao)
-                                      {type = evalExpr_BIT_OUX(l,r);}
+                                      {type = evalExpr_BIT_OUX(op->getLine(), l,r);}
 
     | #(T_BIT_E           l=expressao r=expressao)
-                                      {type = evalExpr_BIT_E(l,r);}
+                                      {type = evalExpr_BIT_E(op->getLine(), l,r);}
 
     | #(T_IGUAL           l=expressao r=expressao)
-                                      {type = evalExpr_IGUAL(l,r);}
+                                      {type = evalExpr_IGUAL(op->getLine(), l,r);}
 
     | #(T_DIFERENTE       l=expressao r=expressao)
-                                      {type = evalExpr_DIFERENTE(l,r);}
+                                      {type = evalExpr_DIFERENTE(op->getLine(), l,r);}
 
     | #(T_MAIOR           l=expressao r=expressao)
-                                      {type = evalExpr_MAIOR(l,r);}
+                                      {type = evalExpr_MAIOR(op->getLine(), l,r);}
 
     | #(T_MENOR           l=expressao r=expressao)
-                                      {type = evalExpr_MENOR(l,r);}
+                                      {type = evalExpr_MENOR(op->getLine(), l,r);}
 
     | #(T_MAIOR_EQ        l=expressao r=expressao)
-                                      {type = evalExpr_MAIOR_EQ(l,r);}
+                                      {type = evalExpr_MAIOR_EQ(op->getLine(), l,r);}
 
     | #(T_MENOR_EQ        l=expressao r=expressao)
-                                      {type = evalExpr_MENOR_EQ(l,r);}
+                                      {type = evalExpr_MENOR_EQ(op->getLine(), l,r);}
 
     | #(T_BIT_SHIFT_LEFT  l=expressao r=expressao)
-                                      {type = evalExpr_BIT_SHIFT_LEFT(l,r);}
+                                      {type = evalExpr_BIT_SHIFT_LEFT(op->getLine(), l,r);}
 
     | #(T_BIT_SHIFT_RIGHT l=expressao r=expressao)
-                                      {type = evalExpr_BIT_SHIFT_RIGHT(l,r);}
+                                      {type = evalExpr_BIT_SHIFT_RIGHT(op->getLine(), l,r);}
 
     | #(T_MAIS            l=expressao r=expressao)
-                                      {type = evalExpr_MAIS(l,r);}
+                                      {type = evalExpr_MAIS(op->getLine(), l,r);}
 
     | #(T_MENOS           l=expressao r=expressao)
-                                      {type = evalExpr_MENOS(l,r);}
+                                      {type = evalExpr_MENOS(op->getLine(), l,r);}
 
     | #(T_DIV             l=expressao r=expressao)
-                                      {type = evalExpr_DIV(l,r);}
+                                      {type = evalExpr_DIV(op->getLine(), l,r);}
 
     | #(T_MULTIP          l=expressao r=expressao)
-                                      {type = evalExpr_MULTIP(l,r);}
+                                      {type = evalExpr_MULTIP(op->getLine(), l,r);}
 
     | #(T_MOD             l=expressao r=expressao)
-                                      {type = evalExpr_MOD(l,r);}
+                                      {type = evalExpr_MOD(op->getLine(), l,r);}
 
     | #(T_UN_NEGATIVO     l=elemento)
-                                      {type = evalExpr_UN_NEGATIVO(l);}
+                                      {type = evalExpr_UN_NEGATIVO(op->getLine(),l);}
 
     | #(T_UN_POSITIVO     l=elemento)
-                                      {type = evalExpr_UN_POSITIVO(l);}
+                                      {type = evalExpr_UN_POSITIVO(op->getLine(),l);}
 
     | #(T_NAO             l=elemento)
-                                      {type = evalExpr_NAO(l);}
+                                      {type = evalExpr_NAO(op->getLine(),l);}
 
     | #(T_BIT_NAO         l=elemento)
-                                      {type = evalExpr_BIT_NAO(l);}
+                                      {type = evalExpr_BIT_NAO(op->getLine(),l);}
 
-    | type=elemento
-  )
+    )
+                       {op->setEvalType(type);}
 
-    {op->setEvalType(type);}
+  | type=elemento
   ;
 
 
 elemento returns [Type *type]
   : type=literal
+  | type=lvalue
   | type=chamada_subrotina
-  | type=lvalue
   | #(T_ABRE_PAREN type=expressao)
   ;
 
+literal returns [Type *type]
+  : T_TEXTO_LITERAL         {type = _typeBuilder->primitiveType(T_LITERAL);}
+  | T_INTEIRO_LITERAL       {type = _typeBuilder->primitiveType(T_INTEIRO);}
+  | T_REAL_LITERAL          {type = _typeBuilder->primitiveType(T_REAL);}
+  | T_CARACTERE_LITERAL     {type = _typeBuilder->primitiveType(T_CARACTERE);}
+  | T_VERDADEIRO            {type = _typeBuilder->primitiveType(T_LOGICO);}
+  | T_FALSO                 {type = _typeBuilder->primitiveType(T_LOGICO);}
+  ;
+
+
 lvalue returns [Type *type]
 
-  : #(id:T_IDENTIFICADOR
+                            {int dimensions;}
 
-      (   lvalue_indices         {type = getSymbolType(id->getText());}
-        | type=lvalue_membro
-        | /*vazio*/              {type = getSymbolType(id->getText());}
-      )
+  : #(id:T_IDENTIFICADOR    {type = getSymbolType(id);}
+
+      (
+        dimensions=lvalue_indices
+
+                           {type = evalMatrixSubscript(id,
+                                                       type, dimensions);}
+      )?
+
+      (type=lvalue_membro[id,type])?
     )
   ;
 
-lvalue_membro returns [Type *type]
-  : #(T_MEMBRO type=lvalue)
+
+lvalue_membro [RefPortugolAST parent, Type *sttype] returns [Type *type]
+
+  : #(T_MEMBRO type=lvalue_struct[parent,sttype])
   ;
 
-lvalue_indices
-                                {Type *type;}
+lvalue_struct[RefPortugolAST parent, Type *sttype] returns [Type *type]
+
+                             {int dimensions;}
+
+  : #(id:T_IDENTIFICADOR     {type = getSymbolType(parent,sttype,id);}
+
+      (
+        dimensions=lvalue_indices
+
+                             {type = evalMatrixSubscript(id,
+                                                         type, dimensions);}
+      )?
+
+      (type=lvalue_membro[id,type])?
+    )
+  ;
+
+lvalue_indices returns [int dimensions]
+
+                                {
+                                  Type *type;
+                                  dimensions = 0;
+                                }
   : #(T_SUBSCRITO
       (
-        type=expressao          {evalMatrixSubscript(type);}
+        type=expressao          {dimensions++;}
       )+
     )
   ;
 
+
+
+
 chamada_subrotina returns [Type *type]
 
                                   {
@@ -484,15 +566,15 @@
 
                                   {
                                     if (!_analisingInitializationList) {
-                                      type = evalFCall(id->getText(), params);
+                                      type = evalCall(id, params);
                                     } else {
-                                      type = getType(T_NULO);
-                                      std:: cerr << "illegal fcall in initlist\n";
+                                      type = _typeBuilder->errorType();
+                                      report(id->getLine(),
+                                        "ilegal: fcall em lista de inicializa??o");
                                     }
                                   }
   ;
 
-
 lista_argumentos returns [TypeList list]
 
                                    {Type *type;}
@@ -501,12 +583,124 @@
     )*
   ;
 
-literal returns [Type *type]
-  : T_TEXTO_LITERAL      {type = getType(T_LITERAL);}
-  | T_INTEIRO_LITERAL    {type = getType(T_INTEIRO);}
-  | T_REAL_LITERAL       {type = getType(T_REAL);}
-  | T_CARACTERE_LITERAL  {type = getType(T_CARACTERE);}
-  | T_VERDADEIRO         {type = getType(T_LOGICO);}
-  | T_FALSO              {type = getType(T_CARACTERE);}
-  | T_NULO               {type = getType(T_NULO);}
+
+
+
+/************************** CORPO *************************/
+
+corpo
+  :  corpo_subprograma      (corpo)?
+  |  bloco_codigo           (corpo_subprograma)*
   ;
+
+
+corpo_subprograma
+                      {SymbolList params;}
+
+  : #(T_FUNCAO   f:T_IDENTIFICADOR
+                 params=lista_parametros {setCurrentScope(f, params);}
+                 T_TIPO_RETORNO
+                 bloco_codigo            {_symtable->setGlobalScope();}
+    )
+
+  | #(T_PROCEDIMENTO p:T_IDENTIFICADOR
+                 params=lista_parametros {setCurrentScope(p, params);}
+                 bloco_codigo)           {_symtable->setGlobalScope();}
+  ;
+
+
+
+bloco_codigo
+  : #(T_INICIO lista_enunciados)
+  ;
+
+lista_enunciados
+  : (enunciado)*
+  ;
+
+enunciado
+                    {Type *devnull;}
+  : en_atribuicao
+  | en_retorne
+  | en_se
+  | en_enquanto
+  | en_repita
+  | en_para
+  | en_caso
+  | T_SAIR                                
+  | devnull=chamada_subrotina
+  ;
+
+en_atribuicao
+                        {Type *ltype, *rtype;}
+
+  : #(at:T_ATRIBUICAO ltype=lvalue rtype=expressao)
+
+                        {evalAttribution(at->getLine(), ltype, rtype);}
+  ;
+
+en_retorne
+                        {Type *type;}
+
+  : #(ret:T_RETORNE type=expressao) 
+
+                        {evalRetorne(ret->getLine(), type);}
+  ;
+
+en_se
+                        {Type *type;}
+
+  : #(se:T_SE 
+
+      type=expressao    {evalCondicional(se->getLine(),type);}
+      lista_enunciados 
+      (T_SENAO lista_enunciados)?
+    )
+  ;
+
+en_enquanto
+                        {Type *type;}
+  : #(enq:T_ENQUANTO 
+      type=expressao    {evalCondicional(enq->getLine(), type);}
+      lista_enunciados
+    )
+  ;
+
+en_repita
+                              {Type *type;}
+  : #(T_REPITA      
+      lista_enunciados
+      a:T_ATE type=expressao    {evalCondicional(a->getLine(), type);}
+    )
+  ;
+
+en_para
+                              {Type *ltype, *from, *to;}
+
+  : #(p:T_PARA ltype=lvalue 
+        from=expressao        {evalAttribution(p->getLine(), ltype, from);}
+        to=expressao          {evalAttribution(p->getLine(), ltype, to);}
+        T_PASSO
+        lista_enunciados)
+  ;
+
+  //TODO: checar por op??es repetidas nos testes
+
+en_caso
+                              {Type *type;}
+
+  : #(c:T_CASO type=expressao (teste_caso[c->getLine(), type])+ (caso_senao)?)
+  ;
+
+teste_caso[int line, Type* ltype]
+                             {Type *rtype;}
+
+  : #(T_FACA 
+      rtype=literal            {evalExpr_IGUAL(line, ltype, rtype);}
+      lista_enunciados
+    )
+  ;
+
+caso_senao
+  : #(T_SENAO lista_enunciados)
+  ;



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 19:31:43 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 19:31:43 +0100
Subject: [gpt-commit] r421 - trunk/gpt2/gptc/src
Message-ID: <200712051831.lB5IVh6r009692@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 19:31:42 +0100 (Wed, 05 Dec 2007)
New Revision: 421

Added:
   trunk/gpt2/gptc/src/main.cpp
Removed:
   trunk/gpt2/gptc/src/teste.cpp
Modified:
   trunk/gpt2/gptc/src/Makefile.am
Log:
nomsg

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-05 11:37:03 UTC (rev 420)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-05 18:31:42 UTC (rev 421)
@@ -30,7 +30,7 @@
                SymbolTable.cpp \
                SymbolTableExceptions.hpp \
                SymbolTableExceptions.cpp \
-               teste.cpp \
+               main.cpp \
                Types.hpp \
                Types.cpp \
                UnicodeCharBuffer.hpp \

Copied: trunk/gpt2/gptc/src/main.cpp (from rev 420, trunk/gpt2/gptc/src/teste.cpp)
===================================================================
--- trunk/gpt2/gptc/src/teste.cpp	2007-12-05 11:37:03 UTC (rev 420)
+++ trunk/gpt2/gptc/src/main.cpp	2007-12-05 18:31:42 UTC (rev 421)
@@ -0,0 +1,100 @@
+#include <stdio.h>
+#include <fstream>
+
+#include <antlr/TokenBuffer.hpp>
+#include <antlr/CommonAST.hpp>
+
+#include "PortugolLexer.hpp"
+#include "PortugolParser.hpp"
+#include "SemanticWalker.hpp"
+#include "PortugolTokenTypes.hpp"
+#include "SymbolTable.hpp"
+
+#include "TokenNames.hpp"
+
+void dump_tokens(char* fname) {
+
+  std::ifstream fi(fname);
+  PortugolLexer lexer(fi, true);
+  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
+
+  while (true) {
+    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
+              << g_tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
+    buffer->consume();
+    getchar();
+
+    if (buffer->LA(1) == PortugolTokenTypes::EOF_) {
+      break;
+    }
+  }
+}
+
+RefPortugolAST dump_tree(char* fname, bool should_dump) {
+
+  std::ifstream fi(fname);
+  if (!fi) {
+    std::cerr << "nao foi possivel abrir o arquivo " << fname << std::endl;
+    exit(1);
+  }
+
+  PortugolLexer lexer(fi, true);
+  PortugolParser parser(lexer);
+
+  antlr::ASTFactory ast_factory(PortugolAST::TYPE_NAME,
+                                &PortugolAST::factory);
+
+  parser.initializeASTFactory(ast_factory);
+  parser.setASTFactory(&ast_factory);
+
+  parser.programa();
+
+  antlr::RefAST ast = parser.getAST();
+  RefPortugolAST cast = RefPortugolAST(ast);
+
+  if (!cast) {
+    std::cerr << "no parse tree!" << std::endl;
+  }
+
+  if (should_dump) {
+    std::cerr << "parser.g AST:\n";
+    std::cerr << cast->toStringList() << std::endl << std::endl;
+  }
+  return cast;
+}
+
+void semantic(char* fname) {
+  RefPortugolAST ast;
+
+  ast = dump_tree(fname, true);
+
+  SymbolTable* symtable = new SymbolTable(fname);
+
+  SemanticWalker semantic(symtable, fname);
+  semantic.programa(ast);
+
+  symtable->dump();
+
+  std::cerr << "semantic.g AST:\n";
+  std::cerr << ast->toStringList() << std::endl << std::endl;
+}
+
+int main(int argc, char** argv) {
+
+  if (argc < 3) {
+    std::cerr << "./test [lps] <file.gpt>" << std::endl;
+    return 0;
+  }
+
+  switch(*argv[1]) {
+    case 'l':
+      dump_tokens(argv[2]);
+      break;
+    case 'p':
+      dump_tree(argv[2], true);
+      break;
+    case 's':
+    default:
+      semantic(argv[2]);
+  }
+}

Deleted: trunk/gpt2/gptc/src/teste.cpp
===================================================================
--- trunk/gpt2/gptc/src/teste.cpp	2007-12-05 11:37:03 UTC (rev 420)
+++ trunk/gpt2/gptc/src/teste.cpp	2007-12-05 18:31:42 UTC (rev 421)
@@ -1,100 +0,0 @@
-#include <stdio.h>
-#include <fstream>
-
-#include <antlr/TokenBuffer.hpp>
-#include <antlr/CommonAST.hpp>
-
-#include "PortugolLexer.hpp"
-#include "PortugolParser.hpp"
-#include "SemanticWalker.hpp"
-#include "PortugolTokenTypes.hpp"
-#include "SymbolTable.hpp"
-
-#include "TokenNames.hpp"
-
-void dump_tokens(char* fname) {
-
-  std::ifstream fi(fname);
-  PortugolLexer lexer(fi, true);
-  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
-
-  while (true) {
-    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
-              << g_tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
-    buffer->consume();
-    getchar();
-
-    if (buffer->LA(1) == PortugolTokenTypes::EOF_) {
-      break;
-    }
-  }
-}
-
-RefPortugolAST dump_tree(char* fname, bool should_dump) {
-
-  std::ifstream fi(fname);
-  if (!fi) {
-    std::cerr << "nao foi possivel abrir o arquivo " << fname << std::endl;
-    exit(1);
-  }
-
-  PortugolLexer lexer(fi, true);
-  PortugolParser parser(lexer);
-
-  antlr::ASTFactory ast_factory(PortugolAST::TYPE_NAME,
-                                &PortugolAST::factory);
-
-  parser.initializeASTFactory(ast_factory);
-  parser.setASTFactory(&ast_factory);
-
-  parser.programa();
-
-  antlr::RefAST ast = parser.getAST();
-  RefPortugolAST cast = RefPortugolAST(ast);
-
-  if (!cast) {
-    std::cerr << "no parse tree!" << std::endl;
-  }
-
-  if (should_dump) {
-    std::cerr << "parser.g AST:\n";
-    std::cerr << cast->toStringList() << std::endl << std::endl;
-  }
-  return cast;
-}
-
-void semantic(char* fname) {
-  RefPortugolAST ast;
-
-  ast = dump_tree(fname, true);
-
-  SymbolTable* symtable = new SymbolTable(fname);
-
-  SemanticWalker semantic(symtable);
-  semantic.programa(ast);
-
-  symtable->dump();
-
-  std::cerr << "semantic.g AST:\n";
-  std::cerr << ast->toStringList() << std::endl << std::endl;
-}
-
-int main(int argc, char** argv) {
-
-  if (argc < 3) {
-    std::cerr << "./test [lps] <file.gpt>" << std::endl;
-    return 0;
-  }
-
-  switch(*argv[1]) {
-    case 'l':
-      dump_tokens(argv[2]);
-      break;
-    case 'p':
-      dump_tree(argv[2], true);
-      break;
-    case 's':
-    default:
-      semantic(argv[2]);
-  }
-}



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 19:32:10 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 19:32:10 +0100
Subject: [gpt-commit] r422 - trunk/gpt2/gptc/src
Message-ID: <200712051832.lB5IWAeV009798@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 19:32:10 +0100 (Wed, 05 Dec 2007)
New Revision: 422

Modified:
   trunk/gpt2/gptc/src/lexer.g
   trunk/gpt2/gptc/src/parser.g
Log:
-Utilizando T_EXPRESSAO como raiz das expressoes

Modified: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-12-05 18:31:42 UTC (rev 421)
+++ trunk/gpt2/gptc/src/lexer.g	2007-12-05 18:32:10 UTC (rev 422)
@@ -109,6 +109,8 @@
   T_VAL_MATRIZ;    //valor da matriz    (literal [])
   T_VAL_ESTRUTURA; //valor da estrutura (literal {})
 
+  T_EXPRESSAO;
+
 //   T_DIMENSOES;
   T_SUBSCRITO;
   T_MEMBRO;

Modified: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-12-05 18:31:42 UTC (rev 421)
+++ trunk/gpt2/gptc/src/parser.g	2007-12-05 18:32:10 UTC (rev 422)
@@ -451,8 +451,11 @@
 //##            Express?es          ##
 //####################################
 
+expressao!
+  : ou:expr_ou {#expressao = #([T_EXPRESSAO,"&expr"], ou);}
+  ;
 
-expressao
+expr_ou
   : expr_e (T_OU^ expr_e)*
   ;
 
@@ -538,7 +541,7 @@
   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
   |  lvalue
   |  literal
-  | T_ABRE_PAREN^ expressao T_FECHA_PAREN!
+  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
   ;
 
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 19:32:52 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 19:32:52 +0100
Subject: [gpt-commit] r423 - trunk/gpt2/gptc/src
Message-ID: <200712051832.lB5IWqmt009864@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 19:32:52 +0100 (Wed, 05 Dec 2007)
New Revision: 423

Modified:
   trunk/gpt2/gptc/src/PortugolAST.cpp
   trunk/gpt2/gptc/src/PortugolAST.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
Log:
-Adicionado atributo 'coluna' do lexema

Modified: trunk/gpt2/gptc/src/PortugolAST.cpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-05 18:32:10 UTC (rev 422)
+++ trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-05 18:32:52 UTC (rev 423)
@@ -15,7 +15,7 @@
  *   You should have received a copy of the GNU General Public License     *
  *   along with this program; if not, write to the                         *
  *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ *   59 Temple Place - Suite 330, Boston, MA  021110307, USA.             *
  ***************************************************************************/
 
 
@@ -26,19 +26,19 @@
 const char* const PortugolAST::TYPE_NAME = "PortugolAST";
 
 PortugolAST::PortugolAST()
-    : CommonAST(), line(-1), type(0) {
+    : CommonAST(), line(0), column(0), type(0) {
 }
 
 PortugolAST::PortugolAST(RefToken t)
-    : CommonAST(t), line(t->getLine()), type(0) {
+    : CommonAST(t), line(t->getLine()), column(t->getColumn()), type(0) {
 }
 
 PortugolAST::PortugolAST( const CommonAST& other )
-    : CommonAST(other), line(-1), type(0) {
+    : CommonAST(other), line(0), column(0), type(0) {
 }
 
 PortugolAST::PortugolAST( const PortugolAST& other )
-    : CommonAST(other), line(other.line), type(0) {
+    : CommonAST(other), line(other.line), column(other.column), type(0) {
 }
 
 PortugolAST::~PortugolAST() {
@@ -59,6 +59,7 @@
 {
   CommonAST::initialize(t);
   setLine(t->getLine());
+  setColumn(t->getColumn());
 }
 
 void PortugolAST::setLine(int line_) {
@@ -66,9 +67,33 @@
 }
 
 int PortugolAST::getLine() const {
-  return line;
+    // most of the time the line number is not set if the node is a
+    // imaginary one. Usually this means it has a child. Refer to the
+    // child line number. Of course this could be extended a bit.
+    // based on an example by Peter Morling.
+    if ( line != 0 )
+        return line;
+    if( getFirstChild() )
+        return ( RefPortugolAST(getFirstChild())->getLine() );
+    return 0;
 }
 
+void PortugolAST::setColumn(int c) {
+  column = c;
+}
+
+int PortugolAST::getColumn() const {
+    // most of the time the line number is not set if the node is a
+    // imaginary one. Usually this means it has a child. Refer to the
+    // child line number. Of course this could be extended a bit.
+    // based on an example by Peter Morling.
+    if ( column != 0 )
+        return column;
+    if( getFirstChild() )
+        return ( RefPortugolAST(getFirstChild())->getColumn() );
+    return 0;
+}
+
 void PortugolAST::setEvalType(Type* t) {
   type = t;
 }
@@ -81,6 +106,7 @@
 std::string PortugolAST::toString() const {
   std::stringstream s;
   s << getText();
+//   s << "(" << getLine() << ":" << getColumn() << ")" << getText();
   if (type) {
     s << ":" << type->name();
   }

Modified: trunk/gpt2/gptc/src/PortugolAST.hpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-05 18:32:10 UTC (rev 422)
+++ trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-05 18:32:52 UTC (rev 423)
@@ -41,6 +41,9 @@
   void setLine(int line);
   int getLine() const;
 
+  void setColumn(int);
+  int getColumn() const;
+
   void setEvalType(Type*);
   Type* getEvalType();
 
@@ -56,6 +59,7 @@
   static const char* const TYPE_NAME;
 protected:
   int   line;
+  int   column;
   Type* type;
   int endLine;
   int eval_type; //evaluated type of expression

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-12-05 18:32:10 UTC (rev 422)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-12-05 18:32:52 UTC (rev 423)
@@ -11,12 +11,14 @@
                Type* type,
                const std::string& scope,
                const std::string& unit,
-               int line)
+               int line,
+               int column)
   :   _lexeme(lexeme),
       _type(type),
       _scope(scope),
       _unit(unit),
-      _line(line) {
+      _line(line),
+      _column(column) {
 
   _identifier = buildIdentifier(lexeme, _type);
 
@@ -25,11 +27,13 @@
 Symbol::Symbol(const std::string& lexeme,
                Type* type,
                const std::string& unit,
-               int line)
+               int line,
+               int column)
   :   _lexeme(lexeme),
       _type(type),
       _unit(unit),
-      _line(line) {
+      _line(line),
+      _column(column) {
 
   _identifier = buildIdentifier(lexeme, _type);
 }
@@ -37,7 +41,8 @@
 
 
 Symbol::Symbol(const std::string& lexeme, Type* type) 
-  : _lexeme(lexeme), _type(type), _scope("?"), _unit("?"), _line(-1) {
+  : _lexeme(lexeme), _type(type), _scope("?"), _unit("?"), 
+    _line(0), _column(0) {
 
   _identifier = buildIdentifier(lexeme, _type);
 }
@@ -67,6 +72,10 @@
   return _line;
 }
 
+int Symbol::column() const {
+  return _column;
+}
+
 std::string Symbol::toString() const {
   std::stringstream ret;
   ret << _unit << ":" << _line

Modified: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-12-05 18:32:10 UTC (rev 422)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-12-05 18:32:52 UTC (rev 423)
@@ -18,12 +18,14 @@
          Type* type,
          const std::string& scope,
          const std::string& unit,
-         int line);
+         int line,
+         int column);
 
   Symbol(const std::string& lexeme,
          Type* type,
          const std::string& unit,
-         int line);
+         int line,
+         int column);
 
   Symbol(const std::string& lexeme,
          Type* type);
@@ -38,6 +40,7 @@
   const std::string& unit() const;
 
   int line() const;
+  int column() const;
 
   std::string toString() const;
 
@@ -51,6 +54,7 @@
   std::string      _scope;
   std::string      _unit;
   int              _line;
+  int              _column;
 };
 
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec  5 19:34:06 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 5 Dec 2007 19:34:06 +0100
Subject: [gpt-commit] r424 - trunk/gpt2/gptc/src
Message-ID: <200712051834.lB5IY6FN009963@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-05 19:34:04 +0100 (Wed, 05 Dec 2007)
New Revision: 424

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Elaboracao da reportagem de erro, seguindo as mensagens do javac da Sun

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-05 18:32:52 UTC (rev 423)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-05 18:34:04 UTC (rev 424)
@@ -8,11 +8,8 @@
 
 #include <iostream>
 #include <sstream>
-using std::cerr;
-using std::endl;
+#include <fstream>
 
-
-
 bool InitMatrixList::hasUniformDimensions() const {
   const_iterator it;
   int d = -1;
@@ -69,22 +66,35 @@
 
 
 
-BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable)
+BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable,
+                                       const std::string& filepath)
  : antlr::TreeParser(),
   _symtable(symtable),
-  _typeBuilder(symtable->typeBuilder()) {
+  _typeBuilder(symtable->typeBuilder()),
+  _filepath(filepath) {
+
+  buildSourceLines();
 }
 
+void BaseSemanticWalker::buildSourceLines() {
+  std::ifstream fi(_filepath.c_str());
+  std::string line;
+  while (!fi.eof()) {
+    getline(fi, line);
+    _sourcelines.push_back(line);
+  }
+}
+
 void BaseSemanticWalker::useLib(const std::string& lib) {
-  cerr << "Using " << lib << endl;
+  std::cerr << "Using " << lib << std::endl;
 }
 
 Type* BaseSemanticWalker::getStructType(RefPortugolAST node) {
   try {
     return _symtable->getType(node->getText());
   } catch (UndeclaredTypeException e) {
-    report(node->getLine(),
-           std::string("Undefined type: ") + node->getText());
+    report(node->getLine(), node->getColumn(),
+           std::string("tipo indefinido: ") + node->getText());
     return _typeBuilder->errorType();
   }
 }
@@ -94,8 +104,8 @@
     return
       _symtable->getSymbol(node->getText()).type();
   } catch (UndeclaredSymbolException e) {
-    report(node->getLine(),
-           std::string("Undeclared symbol: ") + node->getText());
+    report(node->getLine(), node->getColumn(),
+           std::string("s?mbolo n?o declarado: ") + node->getText());
     return _typeBuilder->errorType();
   }
 }
@@ -107,7 +117,8 @@
   }
 
   if (!sttype->isStruct()) {
-    report(id->getLine(), parent->getText() + " n?o ? uma estrutura");
+    report(id->getLine(), id->getColumn(), 
+      std::string("'") + parent->getText() + "' n?o ? uma estrutura");
     return _typeBuilder->errorType();
   }
 
@@ -115,8 +126,9 @@
       sttype->fields().findFirstByLexeme(id->getText());
 
   if (it == sttype->fields().end()) {
-    report(id->getLine(),
-        sttype->name() + " n?o possui membro " + id->getText());
+    report(id->getLine(), id->getColumn(),
+        std::string("estrutura '")  + 
+        sttype->name() + "' n?o possui membro '" + id->getText() + "'");
     return _typeBuilder->errorType();
   }
 
@@ -144,28 +156,42 @@
     return type->evalTypeFromSubscript(dimensions);
   } else if (type->isMatrix()) {
     std::stringstream s;
-    s << id->getText() << " tem " << type->dimensions().size() << " dimens?es";
-    report(id->getLine(), s.str());
+    s << id->getText() 
+    << " tem " << type->dimensions().size() 
+    << " dimens?es"; //dimens?o / dimens?es
+    report(id->getLine(), id->getColumn(), s.str());
   } else {
-    report(id->getLine(), id->getText() + " n?o ? uma matriz");
+    report(id->getLine(), id->getColumn(), "'" + id->getText() + "' n?o ? uma matriz");
   }
   return _typeBuilder->errorType();
 }
 
+void  BaseSemanticWalker::evalMatrixSubscriptType(RefPortugolAST exp,Type* type) {
+  if (type->isError()) {
+    return;
+  }
+
+  if (!type->equals(PortugolTokenTypes::T_INTEIRO)) {
+    report(exp->getLine(), exp->getColumn(), 
+      "subscrito da matriz deve ser do tipo inteiro. Encontrado tipo " + type->name());
+  }
+}
+
 void BaseSemanticWalker::declare(const IDList& ids, Type* type) {
-  try {
-    IDList::const_iterator it;
-    for (it = ids.begin(); it != ids.end(); ++it) {
+  IDList::const_iterator it;
+  for (it = ids.begin(); it != ids.end(); ++it) {
+    try {
       _symtable->insertSymbol(
         Symbol((*it)->getText(),
               type,
               _symtable->currentScope(),
               _symtable->unit(),
-              (*it)->getLine()));
+              (*it)->getLine(),
+              (*it)->getColumn()));
+    } catch (RedeclarationException e) {
+      report((*it)->getLine(), (*it)->getColumn(),
+            std::string("redeclara??o: ") + e.symbol().lexeme());
     }
-  } catch (RedeclarationException e) {
-    report(ids.back()->getLine(),
-           std::string("Redeclaration: ") + e.symbol().toString());
   }
 }
 
@@ -181,7 +207,8 @@
             type,
             _symtable->globalScope(),
             _symtable->unit(),
-            id->getLine());
+            id->getLine(),
+            id->getColumn());
 
   declareProc(s, params);
 }
@@ -196,7 +223,8 @@
             type,
             _symtable->globalScope(),
             _symtable->unit(),
-            id->getLine());
+            id->getLine(),
+            id->getColumn());
 
   declareProc(s, params);
 
@@ -207,8 +235,8 @@
   try {
     _symtable->insertSymbol(s);
   } catch (RedeclarationException e) {
-    report(e.symbol().line(),
-           std::string("Redeclaration: ") + e.symbol().toString());
+    report(e.symbol().line(), e.symbol().column(),
+           std::string("redeclara??o: ") + e.symbol().lexeme());
     _symtable->setIgnoreScope();
     return;
   }  
@@ -219,8 +247,8 @@
   try {
     _symtable->insertSymbols(params);
   } catch (RedeclarationException e) {
-    report(e.symbol().line(),
-           std::string("Redeclaration: ") + e.symbol().toString());
+    report(e.symbol().line(), e.symbol().column(),
+           std::string("redeclara??o: ") + e.symbol().lexeme());
   }  
 }
 
@@ -230,24 +258,14 @@
   try {
     _symtable->insertType(id->getText(), fieldList, id->getLine());
   } catch (RedefinedTypeException e) {
-    report(id->getLine(), std::string("Redefinition: ") + e.typeName());
+    report(id->getLine(), id->getColumn(), 
+        std::string("redefini??o do tipo '") + e.typeName() + "'");
   } catch (RedeclarationException e) {
-    report(id->getLine(), std::string("Redeclaration: ") + e.symbol().toString());
+    report(e.symbol().line(), e.symbol().column(),
+        std::string("redeclara??o: ") + e.symbol().lexeme());
   }
 }
 
-// void BaseSemanticWalker::defineStruct(RefPortugolAST id,
-//                                       const SymbolList& fieldList) {
-// 
-//   try {
-//     _symtable->insertType(id->getText(), fieldList, id->getLine());
-//   } catch (RedefinedTypeException e) {
-//     report(id->getLine(), std::string("Redefinition: ") + e.typeName());
-//   } catch (RedeclarationException e) {
-//     report(id->getLine(), std::string("Redeclaration: ") + e.symbol().toString());
-//   }
-// }
-
 Type* BaseSemanticWalker::evalInitStruct(const InitStructList& stc) {
   SymbolList flist;
   InitStructList::const_iterator it;
@@ -256,17 +274,18 @@
                     it->second, 
                     _symtable->globalScope(), 
                     _symtable->unit(),
-                    it->first->getLine()));
+                    it->first->getLine(),
+                    it->first->getColumn()));
   }
   return _typeBuilder->structType(flist);
 }
 
-Type* BaseSemanticWalker::evalInitMatrix(int line,const InitMatrixList& mtx) {
+Type* BaseSemanticWalker::evalInitMatrix(RefPortugolAST node, const InitMatrixList& mtx) {
   if (!mtx.hasUniformDimensions()) {
     std::stringstream s;
-    s << "Matriz tem valores em dimens?es diferentes";
+    s << "valores da matriz n?o podem ter dimens?es diferentes";
 
-    report(line, s.str());
+    report(node->getLine(), node->getColumn(), s.str());
     return _typeBuilder->errorType();
   }
 
@@ -274,7 +293,8 @@
   Type *ptype = mtx.front().second;
   Type *dtype;
   if (dtype = mtx.elementsDivergeFrom(ptype)) {
-    report(line, std::string("Matriz heterogenea: ")
+    report(node->getLine(), node->getColumn(), 
+                 std::string("matriz heterogenea: ")
                  + ptype->name()
                  + " e "
                  + dtype->name());
@@ -289,18 +309,32 @@
 
 
 
-void BaseSemanticWalker::evalAttribution(int line,
+void BaseSemanticWalker::evalAttribution(RefPortugolAST lastId,
                                          Type* ltype, Type* rtype) {
   if (ltype->isError() || rtype->isError()) {
     return;
   }
 
   if (!ltype->isLValueFor(rtype)) {
-    report(line, string("ilegal: ") + ltype->name() + " := " + rtype->name());
+    report(lastId->getLine(), lastId->getColumn(), 
+            string("vari?vel do tipo '") + ltype->name() 
+            + "' n?o pode receber valor do tipo '" + rtype->name() + "'");
   }
 }
 
+void BaseSemanticWalker::evalAttribution(const ExpressionReturn& l, 
+                                         const ExpressionReturn& r) {
+  if (l.second->isError() || r.second->isError()) {
+    return;
+  }
 
+  if (!l.second->isLValueFor(r.second)) {
+    report(r.first->getLine(), r.first->getColumn(), 
+            "vari?vel do tipo '" + l.second->name() 
+            + "' n?o pode receber valor do tipo '" + r.second->name() + "'");
+  }
+}
+
 Type* BaseSemanticWalker::evalCall(RefPortugolAST id,
                                    const TypeList& paramTypes) {
   //TODO
@@ -317,52 +351,62 @@
     return 
       _symtable->getSymbol(id->getText(), paramTypes).type()->returnType();
   } catch (UndeclaredSymbolException e) {
-    report(id->getLine(), std::string("Undeclared '") + id->getText());
+    report(id->getLine(), id->getColumn(), 
+        "fun??o n?o encontrada: '" + id->getText() + "'");
     return _typeBuilder->errorType();
   } catch (UnmatchedException e) {
-    report(id->getLine(),
-           std::string("No matching call for '") + id->getText() 
-           + "(" + paramTypes.toString() + ")'");
+    report(id->getLine(), id->getColumn(),
+           "Fun??o compat?vel com '" + id->getText() 
+           + "(" + paramTypes.toString() + ")' n?o encontrada");
     return _typeBuilder->errorType();
   }
 }
 
-void BaseSemanticWalker::evalRetorne(int line,Type* type) {
+void BaseSemanticWalker::evalRetorne(RefPortugolAST ret,Type* type) {
+  if (type->isError()) {
+    return;
+  }
+
   if (_symtable->isInGlobalScope()) {
-    report(line, "N?o h? retorno em escopo global");
+    report(ret->getLine(), ret->getColumn(), 
+        "n?o h? retorno em escopo global");
   } else if(!_currentScopeSymbol.type()->returnType()->isLValueFor(type)) {
-    report(line, "Tipo de retorno (" 
+    report(ret->getLine(), ret->getColumn(), "tipo de retorno (" 
            + type->name() + ") incompat?vel com tipo da fun??o (" 
            + _currentScopeSymbol.type()->returnType()->name() +")");
   }
 }
 
 
-void BaseSemanticWalker::evalCondicional(int line, Type* type) {
-  if (!type->equals(PortugolTokenTypes::T_LOGICO)) {
-    report(line, 
-      std::string("Enunciado exige express?o l?gica. Tipo ") 
-      + type->name() + " encontrado.");
+void BaseSemanticWalker::evalCondicional(const ExpressionReturn& ex) {
+  if (ex.second->isError()) {
+    return;
   }
+
+  if (!ex.second->equals(PortugolTokenTypes::T_LOGICO)) {
+    report(ex.first->getLine(), ex.first->getColumn(),
+      "enunciado exige express?o l?gica. Tipo '" 
+      + ex.second->name() + "' encontrado.");
+  }
 }
 
 /************************ EXPR ********************************************/
 
 Type*
-BaseSemanticWalker::evalExpr_OU(int,Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_OU(RefPortugolAST,Type* left, Type* right) {
   //TODO: refatorar os copy/pastes dos metodos evalExpr
 
   return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 Type*
-BaseSemanticWalker::evalExpr_E(int,Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_E(RefPortugolAST,Type* left, Type* right) {
   return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_OU(int line,Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_OU(RefPortugolAST op,Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -371,7 +415,7 @@
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(), 
       std::string("ilegal: ") + left->name() + " | " + right->name());
     return _typeBuilder->errorType();
   }
@@ -379,7 +423,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_OUX(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_OUX(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -388,7 +432,7 @@
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " ^ " + right->name());
     return _typeBuilder->errorType();
   }
@@ -396,7 +440,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_E(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_E(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -405,7 +449,7 @@
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " & " + right->name());
     return _typeBuilder->errorType();
   }
@@ -413,7 +457,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_IGUAL(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_IGUAL(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -421,7 +465,7 @@
   if (left->equals(right)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " = " + right->name());
     return _typeBuilder->errorType();
   }
@@ -429,7 +473,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_DIFERENTE(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_DIFERENTE(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -437,7 +481,7 @@
   if (left->equals(right)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " <> " + right->name());
     return _typeBuilder->errorType();
   }
@@ -445,7 +489,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIOR(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIOR(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -454,7 +498,7 @@
       (left->equals(right) || left->intOrReal(right))) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " > " + right->name());
     return _typeBuilder->errorType();
   }
@@ -462,7 +506,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOR(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOR(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -471,7 +515,7 @@
       (left->equals(right) || left->intOrReal(right))) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " < " + right->name());
     return _typeBuilder->errorType();
   }
@@ -479,7 +523,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIOR_EQ(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIOR_EQ(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -488,7 +532,7 @@
       (left->equals(right) || left->intOrReal(right))) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " >= " + right->name());
     return _typeBuilder->errorType();
   }
@@ -497,7 +541,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOR_EQ(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOR_EQ(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -506,7 +550,7 @@
       (left->equals(right) || left->intOrReal(right))) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " <= " + right->name());
     return _typeBuilder->errorType();
   }
@@ -514,7 +558,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -523,7 +567,7 @@
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " << " + right->name());
     return _typeBuilder->errorType();
   }
@@ -531,7 +575,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -540,7 +584,7 @@
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " >> " + right->name());
     return _typeBuilder->errorType();
   }
@@ -548,13 +592,13 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MAIS(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MAIS(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " + " + right->name());
     return _typeBuilder->errorType();
   }
@@ -565,7 +609,7 @@
   } else if (ret = left->caracOrLit(right)) {
     return ret;
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " + " + right->name());
     return _typeBuilder->errorType();
   }
@@ -573,13 +617,13 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MENOS(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MENOS(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " - " + right->name());
     return _typeBuilder->errorType();
   }
@@ -588,7 +632,7 @@
   if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " - " + right->name());
     return _typeBuilder->errorType();
   }
@@ -596,13 +640,13 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_DIV(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_DIV(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " / " + right->name());
     return _typeBuilder->errorType();
   }
@@ -611,7 +655,7 @@
   if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " / " + right->name());
     return _typeBuilder->errorType();
   }
@@ -619,13 +663,13 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MULTIP(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MULTIP(RefPortugolAST op, Type* left, Type* right) {
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " * " + right->name());
     return _typeBuilder->errorType();
   }
@@ -634,7 +678,7 @@
   if (ret = left->intOrReal(right)) {
     return ret;
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " * " + right->name());
     return _typeBuilder->errorType();
   }
@@ -642,12 +686,12 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_MOD(int line, Type* left, Type* right) {
+BaseSemanticWalker::evalExpr_MOD(RefPortugolAST op, Type* left, Type* right) {
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " % " + right->name());
     return _typeBuilder->errorType();
   }
@@ -656,7 +700,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_NEGATIVO(int line, Type* left) {
+BaseSemanticWalker::evalExpr_UN_NEGATIVO(RefPortugolAST op, Type* left) {
   if (left->isError()) {
     return _typeBuilder->errorType();
   }
@@ -665,7 +709,7 @@
       left->equals(PortugolTokenTypes::T_REAL)) {
     return _typeBuilder->primitiveType(left->primitiveType());
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + " - " + left->name());
     return _typeBuilder->errorType();
   }
@@ -673,7 +717,7 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_POSITIVO(int line, Type* left) {
+BaseSemanticWalker::evalExpr_UN_POSITIVO(RefPortugolAST op, Type* left) {
   if (left->isError()) {
     return _typeBuilder->errorType();
   }
@@ -682,7 +726,7 @@
       left->equals(PortugolTokenTypes::T_REAL)) {
     return _typeBuilder->primitiveType(left->primitiveType());
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + " + " + left->name());
     return _typeBuilder->errorType();
   }
@@ -690,13 +734,13 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_NAO(int, Type* left) {
+BaseSemanticWalker::evalExpr_NAO(RefPortugolAST, Type* left) {
   return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_NAO(int line, Type* left) {
+BaseSemanticWalker::evalExpr_BIT_NAO(RefPortugolAST op, Type* left) {
   if (left->isError()) {
     return _typeBuilder->errorType();
   }
@@ -704,7 +748,7 @@
   if (left->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
-    report(line, 
+    report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + " ~ " + left->name());
     return _typeBuilder->errorType();
   }
@@ -714,8 +758,25 @@
 /********************************************************************/
 
 
+using std::cerr;
+using std::endl;
 
 
+void BaseSemanticWalker::report(int line, int col, const std::string& msg) {
+  //<file>:<line>: <message>
+  //.............<source code>
+  //...................^
+
+  std::string space = "                ";
+  std::cerr << _filepath << ":" << line << ": " << msg << std::endl;
+  std::cerr << space << _sourcelines.at(line-1) << std::endl;
+
+  for (unsigned int i = 1; i < col + space.length(); i++) {
+    std::cerr << " ";
+  }
+  std::cerr << "^" << std::endl;
+}
+
 void BaseSemanticWalker::report(int line, const std::string& s) {
   cerr << "linha " << line << " - " << s << endl;
 }

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-05 18:32:52 UTC (rev 423)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-05 18:34:04 UTC (rev 424)
@@ -23,6 +23,7 @@
 
 #include <antlr/TreeParser.hpp>
 #include <list>
+#include <vector>
 #include <string>
 
 #include "PortugolAST.hpp"
@@ -38,6 +39,8 @@
 //list<pair<field, type>>
 typedef std::list<std::pair<RefPortugolAST,Type*> > InitStructList;
 
+typedef std::pair<RefPortugolAST,Type*>  ExpressionReturn;
+
 //list<pair<dimsize,type>>
 class InitMatrixList : public std::list<std::pair<int,Type*> > {
 public:
@@ -51,7 +54,7 @@
 class BaseSemanticWalker : public antlr::TreeParser {
 
 public:
-  BaseSemanticWalker(SymbolTable*);
+  BaseSemanticWalker(SymbolTable*, const std::string&);
 
 protected:
   void useLib(const std::string&);
@@ -75,46 +78,54 @@
 
 
   Type* evalInitStruct(const InitStructList& stc);
-  Type* evalInitMatrix(int, const InitMatrixList& mtx);
+  Type* evalInitMatrix(RefPortugolAST, const InitMatrixList& mtx);
 
   Type* evalMatrixSubscript(RefPortugolAST, Type*, int);
+  void  evalMatrixSubscriptType(RefPortugolAST,Type*);
 
-  void evalAttribution(int,Type*, Type*);
+  void evalAttribution(RefPortugolAST,Type*, Type*);
+  void evalAttribution(const ExpressionReturn&, const ExpressionReturn&);
 
   Type* evalCall(RefPortugolAST id, const TypeList& paramTypes);
 
-  void evalRetorne(int,Type*);
+  void evalRetorne(RefPortugolAST,Type*);
 
-  void evalCondicional(int, Type*);
+  void evalCondicional(const ExpressionReturn&);
 
-  Type* evalExpr_OU(int,Type* left, Type* right);
-  Type* evalExpr_E(int,Type* left, Type* right);
-  Type* evalExpr_BIT_OU(int,Type* left, Type* right);
-  Type* evalExpr_BIT_OUX(int,Type* left, Type* right);
-  Type* evalExpr_BIT_E(int,Type* left, Type* right);
-  Type* evalExpr_IGUAL(int,Type* left, Type* right);
-  Type* evalExpr_DIFERENTE(int,Type* left, Type* right);
-  Type* evalExpr_MAIOR(int,Type* left, Type* right);
-  Type* evalExpr_MENOR(int,Type* left, Type* right);
-  Type* evalExpr_MAIOR_EQ(int,Type* left, Type* right);
-  Type* evalExpr_MENOR_EQ(int,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_LEFT(int,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_RIGHT(int,Type* left, Type* right);
-  Type* evalExpr_MAIS(int,Type* left, Type* right);
-  Type* evalExpr_MENOS(int,Type* left, Type* right);
-  Type* evalExpr_DIV(int,Type* left, Type* right);
-  Type* evalExpr_MULTIP(int,Type* left, Type* right);
-  Type* evalExpr_MOD(int,Type* left, Type* right);
-  Type* evalExpr_UN_NEGATIVO(int,Type*);
-  Type* evalExpr_UN_POSITIVO(int,Type*);
-  Type* evalExpr_NAO(int,Type*);
-  Type* evalExpr_BIT_NAO(int,Type*);
+  Type* evalExpr_OU(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_E(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_BIT_OU(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_BIT_OUX(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_BIT_E(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_IGUAL(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_DIFERENTE(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MAIOR(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MENOR(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MAIOR_EQ(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MENOR_EQ(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_LEFT(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MAIS(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MENOS(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_DIV(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MULTIP(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_MOD(RefPortugolAST,Type* left, Type* right);
+  Type* evalExpr_UN_NEGATIVO(RefPortugolAST,Type*);
+  Type* evalExpr_UN_POSITIVO(RefPortugolAST,Type*);
+  Type* evalExpr_NAO(RefPortugolAST,Type*);
+  Type* evalExpr_BIT_NAO(RefPortugolAST,Type*);
 
+  void buildSourceLines();
+
+  void report(int, int, const std::string&);
   void report(int, const std::string&);
+  
 
-  SymbolTable* _symtable;
-  TypeBuilder* _typeBuilder;
-  Symbol       _currentScopeSymbol;
+  SymbolTable*                 _symtable;
+  TypeBuilder*                 _typeBuilder;
+  std::string                  _filepath;
+  std::vector<std::string>     _sourcelines;
+  Symbol                       _currentScopeSymbol;
 };
 
 #endif

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-05 18:32:52 UTC (rev 423)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-05 18:34:04 UTC (rev 424)
@@ -39,8 +39,10 @@
 
 {
 public:
-  SemanticWalker::SemanticWalker(SymbolTable* stable)
-	 : BaseSemanticWalker(stable), _analisingInitializationList(false) { }
+  SemanticWalker::SemanticWalker(SymbolTable* symtable, 
+                                 const std::string& filepath)
+	 : BaseSemanticWalker(symtable, filepath), 
+    _analisingInitializationList(false) { }
 
 private:
   bool _analisingInitializationList;
@@ -63,7 +65,7 @@
         EOF
                                       //analise semantica dos blocos
                                       {_t = inicio; /*rollback*/}
-        corpo
+        (corpo)?
         EOF
      )
   ;
@@ -93,10 +95,9 @@
         ids=identificadores     {declare(ids, type);}
 
         (
-          rtype=valor_inicialiacao
+          rtype=v:valor_inicialiacao
 
-                                {evalAttribution(
-                                    ids.back()->getLine(), type, rtype);}
+                                {evalAttribution(ids.back(), type, rtype);}
         )?
     )
   ;
@@ -116,8 +117,7 @@
                                 {
                                   type->setConst(true);
                                   declare(ids, type);
-                                  evalAttribution(
-                                      ids.back()->getLine(), type, rtype);
+                                  evalAttribution(ids.back(),type, rtype);
                                 }
   ;
 
@@ -198,8 +198,7 @@
             (
               rtype=valor_inicialiacao
 
-                                {evalAttribution(
-                                  ids.back()->getLine(), type, rtype);}
+                                {evalAttribution(ids.back(), type, rtype);}
 
             )?
     )
@@ -212,7 +211,8 @@
                                                     type,
                                                     _symtable->currentScope(),
                                                     _symtable->unit(),
-                                                    (*it)->getLine()));
+                                                    (*it)->getLine(),
+                                                    (*it)->getColumn()));
                                   }
                                 }
     )+
@@ -240,12 +240,12 @@
                             InitMatrixList         mtx;
                             InitStructList         stc;
                           }
-  : rtype=expressao
+  : rtype=expressao_
 
   | #(m:T_VAL_MATRIZ
         (valor_matriz[1,mtx])+)
 
-                          {rtype = evalInitMatrix(m->getLine(), mtx);}
+                          {rtype = evalInitMatrix(m, mtx);}
 
   | #(T_VAL_ESTRUTURA
       (id:T_IDENTIFICADOR valor_estrutura[id,stc])+)
@@ -260,7 +260,7 @@
                                 InitStructList stc;
                               }
 
-  : type=expressao     {mtx.push_back(std::pair<int,Type*>(dimension, type));}
+  : type=expressao_      {mtx.push_back(std::pair<int,Type*>(dimension, type));}
 
   | #(T_VAL_MATRIZ
       (valor_matriz[dimension+1, mtx])+)
@@ -278,7 +278,7 @@
                                 InitMatrixList mtx;
                                 InitStructList stc_;
                               }
-  : type=expressao
+  : type=expressao_
                               {
                                 stc.push_back(
                                   std::pair<RefPortugolAST,Type*>(
@@ -289,7 +289,7 @@
       (valor_matriz[1, mtx])+)
 
                               {
-                                type = evalInitMatrix(m->getLine(), mtx);
+                                type = evalInitMatrix(m, mtx);
                                 stc.push_back(
                                   std::pair<RefPortugolAST,Type*>(
                                     field, type));
@@ -385,7 +385,8 @@
                                         Symbol(id->getText(),
                                           type,
                                           _symtable->unit(),
-                                          id->getLine());
+                                          id->getLine(),
+                                          id->getColumn());
                                   }
 
   | T_RETICENCIAS idret:T_IDENTIFICADOR
@@ -394,7 +395,8 @@
                                     symbol = Symbol(idret->getText(),
                                               _typeBuilder->reticencesType(),
                                               _symtable->unit(),
-                                              idret->getLine());
+                                              idret->getLine(),
+                                              idret->getColumn());
                                   }
   ;
 
@@ -402,79 +404,92 @@
 /* ************************* EXPRESSOES *************************/
 
 
+expressao returns [ExpressionReturn ret]
 
-expressao returns [Type *type]
+                                {
+                                  Type *type;
+                                }
+
+  : #(e:T_EXPRESSAO type=expr)  {ret.first = e; ret.second = type;}
+  ;
+
+expressao_ returns [Type *type]
+  : #(T_EXPRESSAO type=expr)
+  ;
+
+
+expr returns [Type *type]
                                       {
                                         Type *l, *r;
                                         RefPortugolAST op = _t;
                                       }
   : (
 
-      #(T_OU              l=expressao r=expressao)
-                                      {type = evalExpr_OU(op->getLine(), l,r);}
+      #(T_OU              l=expr r=expr)
+                                      {type = evalExpr_OU(op, l,r);}
 
-    | #(T_E               l=expressao r=expressao)
-                                      {type = evalExpr_E(op->getLine(), l,r);}
+    | #(T_E               l=expr r=expr)
+                                      {type = evalExpr_E(op, l,r);}
 
-    | #(T_BIT_OU          l=expressao r=expressao)
-                                      {type = evalExpr_BIT_OU(op->getLine(), l,r);}
+    | #(T_BIT_OU          l=expr r=expr)
+                                      {type = evalExpr_BIT_OU(op, l,r);}
 
-    | #(T_BIT_OUX         l=expressao r=expressao)
-                                      {type = evalExpr_BIT_OUX(op->getLine(), l,r);}
+    | #(T_BIT_OUX         l=expr r=expr)
+                                      {type = evalExpr_BIT_OUX(op, l,r);}
 
-    | #(T_BIT_E           l=expressao r=expressao)
-                                      {type = evalExpr_BIT_E(op->getLine(), l,r);}
+    | #(T_BIT_E           l=expr r=expr)
+                                      {type = evalExpr_BIT_E(op, l,r);}
 
-    | #(T_IGUAL           l=expressao r=expressao)
-                                      {type = evalExpr_IGUAL(op->getLine(), l,r);}
+    | #(T_IGUAL           l=expr r=expr)
+                                      {type = evalExpr_IGUAL(op, l,r);}
 
-    | #(T_DIFERENTE       l=expressao r=expressao)
-                                      {type = evalExpr_DIFERENTE(op->getLine(), l,r);}
+    | #(T_DIFERENTE       l=expr r=expr)
+                                      {type = evalExpr_DIFERENTE(op, l,r);}
 
-    | #(T_MAIOR           l=expressao r=expressao)
-                                      {type = evalExpr_MAIOR(op->getLine(), l,r);}
+    | #(T_MAIOR           l=expr r=expr)
+                                      {type = evalExpr_MAIOR(op, l,r);}
 
-    | #(T_MENOR           l=expressao r=expressao)
-                                      {type = evalExpr_MENOR(op->getLine(), l,r);}
+    | #(T_MENOR           l=expr r=expr)
+                                      {type = evalExpr_MENOR(op, l,r);}
 
-    | #(T_MAIOR_EQ        l=expressao r=expressao)
-                                      {type = evalExpr_MAIOR_EQ(op->getLine(), l,r);}
+    | #(T_MAIOR_EQ        l=expr r=expr)
+                                      {type = evalExpr_MAIOR_EQ(op, l,r);}
 
-    | #(T_MENOR_EQ        l=expressao r=expressao)
-                                      {type = evalExpr_MENOR_EQ(op->getLine(), l,r);}
+    | #(T_MENOR_EQ        l=expr r=expr)
+                                      {type = evalExpr_MENOR_EQ(op, l,r);}
 
-    | #(T_BIT_SHIFT_LEFT  l=expressao r=expressao)
-                                      {type = evalExpr_BIT_SHIFT_LEFT(op->getLine(), l,r);}
+    | #(T_BIT_SHIFT_LEFT  l=expr r=expr)
+                                      {type = evalExpr_BIT_SHIFT_LEFT(op, l,r);}
 
-    | #(T_BIT_SHIFT_RIGHT l=expressao r=expressao)
-                                      {type = evalExpr_BIT_SHIFT_RIGHT(op->getLine(), l,r);}
+    | #(T_BIT_SHIFT_RIGHT l=expr r=expr)
+                                      {type = evalExpr_BIT_SHIFT_RIGHT(op, l,r);}
 
-    | #(T_MAIS            l=expressao r=expressao)
-                                      {type = evalExpr_MAIS(op->getLine(), l,r);}
+    | #(T_MAIS            l=expr r=expr)
+                                      {type = evalExpr_MAIS(op, l,r);}
 
-    | #(T_MENOS           l=expressao r=expressao)
-                                      {type = evalExpr_MENOS(op->getLine(), l,r);}
+    | #(T_MENOS           l=expr r=expr)
+                                      {type = evalExpr_MENOS(op, l,r);}
 
-    | #(T_DIV             l=expressao r=expressao)
-                                      {type = evalExpr_DIV(op->getLine(), l,r);}
+    | #(T_DIV             l=expr r=expr)
+                                      {type = evalExpr_DIV(op, l,r);}
 
-    | #(T_MULTIP          l=expressao r=expressao)
-                                      {type = evalExpr_MULTIP(op->getLine(), l,r);}
+    | #(T_MULTIP          l=expr r=expr)
+                                      {type = evalExpr_MULTIP(op, l,r);}
 
-    | #(T_MOD             l=expressao r=expressao)
-                                      {type = evalExpr_MOD(op->getLine(), l,r);}
+    | #(T_MOD             l=expr r=expr)
+                                      {type = evalExpr_MOD(op, l,r);}
 
     | #(T_UN_NEGATIVO     l=elemento)
-                                      {type = evalExpr_UN_NEGATIVO(op->getLine(),l);}
+                                      {type = evalExpr_UN_NEGATIVO(op,l);}
 
     | #(T_UN_POSITIVO     l=elemento)
-                                      {type = evalExpr_UN_POSITIVO(op->getLine(),l);}
+                                      {type = evalExpr_UN_POSITIVO(op,l);}
 
     | #(T_NAO             l=elemento)
-                                      {type = evalExpr_NAO(op->getLine(),l);}
+                                      {type = evalExpr_NAO(op,l);}
 
     | #(T_BIT_NAO         l=elemento)
-                                      {type = evalExpr_BIT_NAO(op->getLine(),l);}
+                                      {type = evalExpr_BIT_NAO(op,l);}
 
     )
                        {op->setEvalType(type);}
@@ -484,10 +499,11 @@
 
 
 elemento returns [Type *type]
+                               {ExpressionReturn lv;}
   : type=literal
-  | type=lvalue
+  | lv=lvalue                  {type = lv.second;}
   | type=chamada_subrotina
-  | #(T_ABRE_PAREN type=expressao)
+  | type=expressao_
   ;
 
 literal returns [Type *type]
@@ -500,21 +516,25 @@
   ;
 
 
-lvalue returns [Type *type]
+lvalue returns [ExpressionReturn ret]
 
-                            {int dimensions;}
+                            {
+                              Type *type;
+                              int dimensions;
+                            }
 
   : #(id:T_IDENTIFICADOR    {type = getSymbolType(id);}
 
       (
         dimensions=lvalue_indices
 
-                           {type = evalMatrixSubscript(id,
-                                                       type, dimensions);}
+                           {type = evalMatrixSubscript(id, type, dimensions);}
       )?
 
       (type=lvalue_membro[id,type])?
     )
+
+      {ret.first = id; ret.second = type;}
   ;
 
 
@@ -525,7 +545,9 @@
 
 lvalue_struct[RefPortugolAST parent, Type *sttype] returns [Type *type]
 
-                             {int dimensions;}
+                              {
+                                int dimensions;
+                              }
 
   : #(id:T_IDENTIFICADOR     {type = getSymbolType(parent,sttype,id);}
 
@@ -543,12 +565,16 @@
 lvalue_indices returns [int dimensions]
 
                                 {
-                                  Type *type;
+                                  ExpressionReturn ex;
                                   dimensions = 0;
                                 }
-  : #(T_SUBSCRITO
+  : #(s:T_SUBSCRITO
       (
-        type=expressao          {dimensions++;}
+        ex=expressao
+                                {
+                                  dimensions++;
+                                  evalMatrixSubscriptType(ex.first, ex.second);
+                                }
       )+
     )
   ;
@@ -579,7 +605,7 @@
 
                                    {Type *type;}
   : (
-      type=expressao               {list.push_back(type);}
+      type=expressao_                   {list.push_back(type);}
     )*
   ;
 
@@ -600,11 +626,13 @@
   : #(T_FUNCAO   f:T_IDENTIFICADOR
                  params=lista_parametros {setCurrentScope(f, params);}
                  T_TIPO_RETORNO
+                 (T_VARIAVEL|T_CONSTANTE)*
                  bloco_codigo            {_symtable->setGlobalScope();}
     )
 
   | #(T_PROCEDIMENTO p:T_IDENTIFICADOR
                  params=lista_parametros {setCurrentScope(p, params);}
+                 (T_VARIAVEL|T_CONSTANTE)*
                  bloco_codigo)           {_symtable->setGlobalScope();}
   ;
 
@@ -632,55 +660,55 @@
   ;
 
 en_atribuicao
-                        {Type *ltype, *rtype;}
+                        {ExpressionReturn lret, rret;}
 
-  : #(at:T_ATRIBUICAO ltype=lvalue rtype=expressao)
+  : #(at:T_ATRIBUICAO lret=lvalue rret=expressao)
 
-                        {evalAttribution(at->getLine(), ltype, rtype);}
+                        {evalAttribution(at, lret.second, rret.second);}
   ;
 
 en_retorne
                         {Type *type;}
 
-  : #(ret:T_RETORNE type=expressao) 
+  : #(ret:T_RETORNE type=expressao_) 
 
-                        {evalRetorne(ret->getLine(), type);}
+                        {evalRetorne(ret, type);}
   ;
 
 en_se
-                        {Type *type;}
+                        {ExpressionReturn ex;}
 
   : #(se:T_SE 
 
-      type=expressao    {evalCondicional(se->getLine(),type);}
+      ex=expressao    {evalCondicional(ex);}
       lista_enunciados 
       (T_SENAO lista_enunciados)?
     )
   ;
 
 en_enquanto
-                        {Type *type;}
+                        {ExpressionReturn ex;}
   : #(enq:T_ENQUANTO 
-      type=expressao    {evalCondicional(enq->getLine(), type);}
+      ex=expressao      {evalCondicional(ex);}
       lista_enunciados
     )
   ;
 
 en_repita
-                              {Type *type;}
+                              {ExpressionReturn ex;}
   : #(T_REPITA      
       lista_enunciados
-      a:T_ATE type=expressao    {evalCondicional(a->getLine(), type);}
+      T_ATE ex=expressao      {evalCondicional(ex);}
     )
   ;
 
 en_para
-                              {Type *ltype, *from, *to;}
+                              {ExpressionReturn lv, from, to;}
 
-  : #(p:T_PARA ltype=lvalue 
-        from=expressao        {evalAttribution(p->getLine(), ltype, from);}
-        to=expressao          {evalAttribution(p->getLine(), ltype, to);}
-        T_PASSO
+  : #(p:T_PARA lv=lvalue 
+        from=expressao        {evalAttribution(lv, from);}
+        to=expressao          {evalAttribution(lv, to);}
+        (T_PASSO)?
         lista_enunciados)
   ;
 
@@ -689,14 +717,15 @@
 en_caso
                               {Type *type;}
 
-  : #(c:T_CASO type=expressao (teste_caso[c->getLine(), type])+ (caso_senao)?)
+  : #(c:T_CASO type=expressao_ (teste_caso[type])+ (caso_senao)?)
   ;
 
-teste_caso[int line, Type* ltype]
-                             {Type *rtype;}
+teste_caso[Type *ltype]
 
+                               {Type *rtype;}
+
   : #(T_FACA 
-      rtype=literal            {evalExpr_IGUAL(line, ltype, rtype);}
+      rtype=lit:literal            {evalExpr_IGUAL(lit, ltype, rtype);}
       lista_enunciados
     )
   ;



From gpt-commit-noreply at mail.berlios.de  Thu Dec  6 20:29:32 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 6 Dec 2007 20:29:32 +0100
Subject: [gpt-commit] r425 - in trunk/gpt2: common/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712061929.lB6JTWnE016332@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-06 20:29:31 +0100 (Thu, 06 Dec 2007)
New Revision: 425

Modified:
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
Log:
DEVNULL:
* Melhorias no codigo para tratamento de matrizes


Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-12-05 18:34:04 UTC (rev 424)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-06 19:29:31 UTC (rev 425)
@@ -152,7 +152,7 @@
    OP_PUSHRR      = 124,
    OP_PUSHDR      = 125,
    OP_PUSHMR      = 126,
-   OPCODE_NUMBER  = 126
+   OPCODE_NUMBER  = 127
 };
 
 #endif

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-05 18:34:04 UTC (rev 424)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-06 19:29:31 UTC (rev 425)
@@ -16,8 +16,8 @@
     ile t1, i, 9
     ifnot t1, proximo
 
-    // m[i] := i * 10;
-    imul t1, i, 10
+    // m[i] := i * 100;
+    imul t1, i, 100
     m1set m, i, t1
 
     // fim-para

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-05 18:34:04 UTC (rev 424)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-06 19:29:31 UTC (rev 425)
@@ -32,8 +32,8 @@
     ile t1, i, 9
     ifnot t1, proximo
 
-    // d1[i] := i * 10;
-    imul t1, i, 10
+    // d1[i] := i * 1000;
+    imul t1, i, 1000
     m1set d1, i, t1
 
     // fim-para

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-05 18:34:04 UTC (rev 424)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-06 19:29:31 UTC (rev 425)
@@ -21,17 +21,37 @@
    }
 };
 
-struct SMatrixType {
+struct SMatrix1TypeHeader {
+   int _dimNumber;
    int _elementSize;
-   int _elements;
-   char* _data;
-   SMatrixType()
-   : _elementSize(0)
-   , _elements(0)
-   , _data(NULL)
+   int _elements[1];
+   SMatrix1TypeHeader()
+   : _dimNumber(1)
+   , _elementSize(0)
+   {
+      memset(_elements, 0, sizeof(_elements));
+   }
+};
+
+struct SMatrix1TypeData {
+   char *_data;
+   SMatrix1TypeData()
+   : _data(NULL)
    { }
 };
 
+struct SMatrix2Type {
+   int _dimNumber;
+   int _elementSize;
+   int _elements[2];
+   SMatrix2Type()
+   : _dimNumber(2)
+   , _elementSize(0)
+   {
+      memset(_elements, 0, sizeof(_elements));
+   }
+};
+
 struct SIntType {
    int _value;
 
@@ -1129,11 +1149,9 @@
 
    int matrixAddress = _code.fetchInt();
 
-   char *retMatrix = (char*) _dataStack.popInt();
-   int elementSize = *((int*)(retMatrix+0));
-   int elements    = *((int*)(retMatrix+sizeof(int)));
+   SMatrix1TypeHeader *retMatrix = (SMatrix1TypeHeader*) _dataStack.popInt();
 
-   int size = sizeof(int) + sizeof(int) + elements*elementSize;
+   int size = sizeof(SMatrix1TypeHeader) + retMatrix->_elements[0]*retMatrix->_elementSize;
    char *matrix = (char*) _dataStack.getInt(matrixAddress);
 
    if (matrix) {
@@ -1295,11 +1313,9 @@
 {
    trace ("pushmv opcode");
 
-   char *matrix    = (char*) _dataStack.getInt(_code.fetchInt());
-   int elementSize = *((int*)(matrix+0));
-   int elements    = *((int*)(matrix+sizeof(int)));
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
 
-   int size = sizeof(int) + sizeof(int) + elements*elementSize;
+   int size = sizeof(SMatrix1TypeHeader) + matrix->_elements[0]*matrix->_elementSize;
    char *newMatrix = new char[size]; // TODO: memory leak
    memcpy(newMatrix, matrix, size);
    _dataStack.pushInt((int)newMatrix);
@@ -1343,12 +1359,21 @@
 {
    trace ("pushmr opcode");
 
-   SMatrixType type;
-
-   _dataStack.pushBytes((char*)&type, sizeof(type));
+   _dataStack.pushBytes(getTypeSize(CSymbol::MATRIX));
 }
 
+//void CRunBytecode::pushmrOpcode()
+//{
+//   trace ("pushmr opcode");
+//
+//   SMatrix1TypeHeader header;
+//   SMatrix1TypeData   data;
+//
+//   _dataStack.pushBytes((char*)&header, sizeof(header));
+//   _dataStack.pushBytes((char*)&data,   sizeof(data));
+//}
 
+
 void CRunBytecode::pushstOpcode()
 {
    trace ("pushst opcode");
@@ -1488,18 +1513,21 @@
    trace ("m1alloc opcode");
 
    // Header dos dados de uma matriz de uma linha:
+   // int (numero de dimensoes)
    // int (tamanho de cada elemento armazenado)
-   // int (numero de elementos)
+   // int (numero de elementos da dimensao 1)
    // bytes (area sequencial para armazenar os dados)
 
    int matrixAddress = _code.fetchInt();
    int elementSize   = _dataStack.getInt(_code.fetchInt());
    int elements      = _dataStack.getInt(_code.fetchInt());
 
-   char *matrix = new char[sizeof(int)+sizeof(int)+elementSize*elements];
-   *((int*)(matrix+0))           = elementSize;
-   *((int*)(matrix+sizeof(int))) = elements;
-   _dataStack.setInt(matrixAddress, (int)matrix);
+   char *matrixPointer = new char[sizeof(SMatrix1TypeHeader)+elementSize*elements];
+   SMatrix1TypeHeader *matrixHeader = (SMatrix1TypeHeader*) matrixPointer;
+   matrixHeader->_dimNumber   = 1;
+   matrixHeader->_elementSize = elementSize;
+   matrixHeader->_elements[0] = elements;
+   _dataStack.setInt(matrixAddress, (int)matrixPointer);
 }
 
 void CRunBytecode::m2allocOpcode()
@@ -1523,29 +1551,42 @@
 {
    trace ("m1set opcode");
 
-   char *matrix     = (char*) _dataStack.getInt(_code.fetchInt());
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
    int offset       = _dataStack.getInt(_code.fetchInt());
    int valueAddress = _code.fetchInt();
 
-   int elementSize = *((int*)(matrix+0));
-//   int elements    = *((int*)(matrix+sizeof(int)));
-   char *data      = matrix + sizeof(int) + sizeof(int);
+   int elementSize = matrix->_elementSize;
+   char *data      = ((char*)matrix) + sizeof(SMatrix1TypeHeader);
    data += offset * elementSize;
    memcpy(data, _dataStack.getPointer(valueAddress), elementSize);
 }
 
+//void CRunBytecode::m1setOpcode()
+//{
+//   trace ("m1set opcode");
+//
+//   char *matrix     = (char*) _dataStack.getInt(_code.fetchInt());
+//   int offset       = _dataStack.getInt(_code.fetchInt());
+//   int valueAddress = _code.fetchInt();
+//
+//   int elementSize = *((int*)(matrix+0));
+////   int elements    = *((int*)(matrix+sizeof(int)));
+//   char *data      = matrix + sizeof(int) + sizeof(int);
+//   data += offset * elementSize;
+//   memcpy(data, _dataStack.getPointer(valueAddress), elementSize);
+//}
+
 void CRunBytecode::m1getOpcode()
 {
    trace ("m1get opcode");
 
    int resultAddress = _code.fetchInt();
-   char *matrix      = (char*) _dataStack.getInt(_code.fetchInt());
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
    int offset        = _dataStack.getInt(_code.fetchInt());
 
-   int elementSize = *((int*)(matrix+0));
-//   int elements    = *((int*)(matrix+sizeof(int)));
-   char *data      = matrix + sizeof(int) + sizeof(int);
-   data += offset * elementSize;
+   int elementSize = matrix->_elementSize;
+   char *data      = ((char*)matrix) + sizeof(SMatrix1TypeHeader);
+   data           += offset * elementSize;
    memcpy(_dataStack.getPointer(resultAddress), data, elementSize);
 }
 

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Dec  7 18:05:26 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 7 Dec 2007 18:05:26 +0100
Subject: [gpt-commit] r426 - in trunk/gpt2: gptasm/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712071705.lB7H5QmV007589@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-07 18:05:25 +0100 (Fri, 07 Dec 2007)
New Revision: 426

Added:
   trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm
Modified:
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
Log:
DEVNULL:
* Retirado algumas redundancias no parser
* Criado alguns tipos de dados (structs) para facilitar a manipulacao de
  matrizes
* Suporte a matrizes de 1 e 2 dimensoes


Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-07 17:05:25 UTC (rev 426)
@@ -248,8 +248,7 @@
       {bytecode.addOpcode(getLastTokenText());}
       element
       T_COMMA
-      T_INT_VALUE
-      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
       // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
    |  ("pushir"|"pushsr"|"pushrr"|"pushdr"|"pushmr")
       {bytecode.addOpcode(getLastTokenText());}
@@ -262,12 +261,10 @@
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA
-      T_INT_VALUE
-      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
    |  ("incsp"|"decsp")
       {bytecode.addOpcode(getLastTokenText());}
-      T_INT_VALUE
-      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
    |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
@@ -305,18 +302,18 @@
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA
-      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
       T_COMMA 
-      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
    |  "m2alloc"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA
-      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
       T_COMMA
-      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
       T_COMMA
-      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
    |  "mfree"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
@@ -350,7 +347,7 @@
       {bytecode.addOpcode(getLastTokenText());}
    |   "exit"
       {bytecode.addOpcode(getLastTokenText());}
-       T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      intvalue
   ;
 
 identifier
@@ -389,3 +386,6 @@
   | literal
   ;
 
+intvalue
+  : T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+  ;

Added: trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm	2007-12-07 17:05:25 UTC (rev 426)
@@ -0,0 +1,40 @@
+program exemplo
+
+var m matrix
+
+proc main
+    var t1 int
+
+    // aloca espa?o para a matriz m
+    // m armazena dados de 4 bytes e tem 4 linhas e 5 colunas
+    m2alloc m, 4, 5, 10
+
+    m2set m, 0, 0, 1
+    m2set m, 0, 1, 2
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    m2get t1, m, 0, 0
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    m2get t1, m, 0, 1
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-07 17:05:25 UTC (rev 426)
@@ -0,0 +1,85 @@
+program exemplo
+
+var m matrix
+var i int
+var j int
+var c int
+
+proc main
+    var t1 int
+
+    // aloca espa?o para a matriz m
+    // m armazena dados de 4 bytes e tem 4 linhas e 5 colunas
+    m2alloc m, 4, 4, 5
+
+    // para i de 0 at? 3 fa?a
+    iset i, 0
+    teste:
+    ile t1, i, 3
+    ifnot t1, proximo
+
+    // para j de 0 at? 4 fa?a
+    iset j, 0
+    teste2:
+    ile t1, j, 4
+    ifnot t1, proximo2
+
+    // c := c + 1
+    iinc c, 1
+
+    // m[i][j] := c;
+    m2set m, i, j, c
+
+    // fim-para
+    iinc j, 1
+    jmp teste2
+    proximo2:
+
+    // fim-para
+    iinc i, 1
+    jmp teste
+    proximo:
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    // para i de 0 at? 3 fa?a
+    iset i, 0
+    teste3:
+    ile t1, i, 3
+    ifnot t1, proximo3
+
+    // para j de 0 at? 4 fa?a
+    iset j, 0
+    teste4:
+    ile t1, j, 4
+    ifnot t1, proximo4
+
+    // imprima( m[i][j] );
+    m2get t1, m, i, j
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // fim-para
+    iinc j, 1
+    jmp teste4
+    proximo4:
+
+    // fim-para
+    iinc i, 1
+    jmp teste3
+    proximo3:
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm	2007-12-07 17:05:25 UTC (rev 426)
@@ -0,0 +1,59 @@
+program exemplo
+
+var m matrix
+var i int
+
+proc main
+    var t1 int
+
+    // aloca espa?o para a matriz m
+    // m armazena dados de 4 bytes e tem 5x6 elementos iniciais
+    m2alloc m, 4, 5, 6
+
+    // para i de 0 at? 4 fa?a
+    iset i, 0
+    teste:
+    ile t1, i, 4
+    ifnot t1, proximo
+
+    // m[i][i] := i * 10;
+    imul t1, i, 10
+    m2set m, i, i, t1
+
+    // fim-para
+    iinc i, 1
+    jmp teste
+    proximo:
+
+    // imprima( "Valores armazenados:" );
+    pushsv "Valores armazenados:"
+    pushst
+    push_1
+    lcall imprima
+
+    // para i de 0 at? 4 fa?a
+    iset i, 0
+    teste2:
+    ile t1, i, 4
+    ifnot t1, proximo2
+
+    // imprima( m[i][i] );
+    m2get t1, m, i, i
+    pushiv t1
+    pushit
+    push_1
+    lcall imprima
+
+    // fim-para
+    iinc i, 1
+    jmp teste2
+    proximo2:
+
+    // desaloca espa?o da matriz m
+    mfree m
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm	2007-12-07 17:05:25 UTC (rev 426)
@@ -0,0 +1,63 @@
+program exemplo
+
+var m1 matrix
+var m2 matrix
+var m3 matrix
+var m4 matrix
+
+proc main
+    var t1 int
+
+    m1alloc m1, 4, 100
+    m1alloc m2, 10, 1000
+    m2alloc m3, 2, 10, 20
+    m2alloc m4, 1, 15, 25
+
+    mgetsize1 t1, m1
+    pushiv t1
+    pushit
+    pushsv "Tamanho de m1 deve ser 100: "
+    pushst
+    push_2
+    lcall imprima
+
+    mgetsize1 t1, m2
+    pushiv t1
+    pushit
+    pushsv "Tamanho de m2 deve ser 1000: "
+    pushst
+    push_2
+    lcall imprima
+
+    mgetsize2 t1, m3
+    pushiv t1
+    pushit
+    mgetsize1 t1, m3
+    pushiv t1
+    pushit
+    pushsv "Tamanho de m3 deve ser 10 e 20: "
+    pushst
+    push_3
+    lcall imprima
+
+    mgetsize2 t1, m4
+    pushiv t1
+    pushit
+    mgetsize1 t1, m4
+    pushiv t1
+    pushit
+    pushsv "Tamanho de m4 deve ser 15 e 25: "
+    pushst
+    push_3
+    lcall imprima
+
+    mfree m1
+    mfree m2
+    mfree m3
+    mfree m4
+
+    exit_0
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-06 19:29:31 UTC (rev 425)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-07 17:05:25 UTC (rev 426)
@@ -33,18 +33,18 @@
    }
 };
 
-struct SMatrix1TypeData {
-   char *_data;
-   SMatrix1TypeData()
-   : _data(NULL)
-   { }
-};
+//struct SMatrix1TypeData {
+//   char *_data;
+//   SMatrix1TypeData()
+//   : _data(NULL)
+//   { }
+//};
 
-struct SMatrix2Type {
+struct SMatrix2TypeHeader {
    int _dimNumber;
    int _elementSize;
    int _elements[2];
-   SMatrix2Type()
+   SMatrix2TypeHeader()
    : _dimNumber(2)
    , _elementSize(0)
    {
@@ -1532,7 +1532,20 @@
 
 void CRunBytecode::m2allocOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m2alloc opcode");
+
+   int matrixAddress = _code.fetchInt();
+   int elementSize   = _dataStack.getInt(_code.fetchInt());
+   int elements1     = _dataStack.getInt(_code.fetchInt());
+   int elements2     = _dataStack.getInt(_code.fetchInt());
+
+   char *matrixPointer = new char[sizeof(SMatrix2TypeHeader)+elementSize*elements1*elements2];
+   SMatrix2TypeHeader *matrixHeader = (SMatrix2TypeHeader*) matrixPointer;
+   matrixHeader->_dimNumber   = 2;
+   matrixHeader->_elementSize = elementSize;
+   matrixHeader->_elements[0] = elements1;
+   matrixHeader->_elements[1] = elements2;
+   _dataStack.setInt(matrixAddress, (int)matrixPointer);
 }
 
 void CRunBytecode::mfreeOpcode()
@@ -1555,6 +1568,10 @@
    int offset       = _dataStack.getInt(_code.fetchInt());
    int valueAddress = _code.fetchInt();
 
+   if (matrix->_dimNumber != 1) {
+      error( "m1set em matrix de dimensao <> 1" );
+   }
+
    int elementSize = matrix->_elementSize;
    char *data      = ((char*)matrix) + sizeof(SMatrix1TypeHeader);
    data += offset * elementSize;
@@ -1584,6 +1601,10 @@
    SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
    int offset        = _dataStack.getInt(_code.fetchInt());
 
+   if (matrix->_dimNumber != 1) {
+      error( "m1get em matrix de dimensao <> 1" );
+   }
+
    int elementSize = matrix->_elementSize;
    char *data      = ((char*)matrix) + sizeof(SMatrix1TypeHeader);
    data           += offset * elementSize;
@@ -1592,12 +1613,38 @@
 
 void CRunBytecode::m2setOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m2set opcode");
+
+   SMatrix2TypeHeader *matrix = (SMatrix2TypeHeader*) _dataStack.getInt(_code.fetchInt());
+   int offset1                = _dataStack.getInt(_code.fetchInt());
+   int offset2                = _dataStack.getInt(_code.fetchInt());
+   int valueAddress           = _code.fetchInt();
+
+   if (matrix->_dimNumber != 2) {
+      error( "m2set em matrix de dimensao <> 2" );
+   }
+
+   char *data      = ((char*)matrix) + sizeof(SMatrix2TypeHeader);
+   data           += (offset1 * matrix->_elements[1] + offset2) * matrix->_elementSize;
+   memcpy(data, _dataStack.getPointer(valueAddress), matrix->_elementSize);
 }
 
 void CRunBytecode::m2getOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("m2get opcode");
+
+   int resultAddress = _code.fetchInt();
+   SMatrix2TypeHeader *matrix = (SMatrix2TypeHeader*) _dataStack.getInt(_code.fetchInt());
+   int offset1        = _dataStack.getInt(_code.fetchInt());
+   int offset2        = _dataStack.getInt(_code.fetchInt());
+
+   if (matrix->_dimNumber != 2) {
+      error( "m2set em matrix de dimensao <> 2" );
+   }
+
+   char *data      = ((char*)matrix) + sizeof(SMatrix2TypeHeader);
+   data           += (offset1 * matrix->_elements[1] + offset2) * matrix->_elementSize;
+   memcpy(_dataStack.getPointer(resultAddress), data, matrix->_elementSize);
 }
 
 void CRunBytecode::mcopyOpcode()
@@ -1607,11 +1654,25 @@
 
 void CRunBytecode::mgetSize1Opcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("mgetSize1 opcode");
+
+   int resultAddress = _code.fetchInt();
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.setInt(resultAddress, matrix->_elements[0]);
 }
 
 void CRunBytecode::mgetSize2Opcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("mgetSize2 opcode");
+
+   int resultAddress = _code.fetchInt();
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
+
+   if (matrix->_dimNumber == 1) {
+      error( "mgetsize2 em matrix de dimensao 1" );
+   }
+
+   _dataStack.setInt(resultAddress, matrix->_elements[1]);
 }
 

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Sat Dec  8 10:30:55 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 8 Dec 2007 10:30:55 +0100
Subject: [gpt-commit] r427 - trunk/gpt2/gptc/src
Message-ID: <200712080930.lB89Utmb017784@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-08 10:30:55 +0100 (Sat, 08 Dec 2007)
New Revision: 427

Modified:
   trunk/gpt2/gptc/src/Makefile.am
Log:
-Adicionado global indicando tamanho dos arrays

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-07 17:05:25 UTC (rev 426)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-08 09:30:55 UTC (rev 427)
@@ -1,41 +1,48 @@
 INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
 
+noinst_LTLIBRARIES = libgptc.la
+
 bin_PROGRAMS = gptc
-gptc_LDADD = $(ANTLR_LIB)
 
-EXTRA_DIST = lexer.g parser.g semantic.g
+gptc_SOURCES = main.cpp
 
+gptc_LDADD = libgptc.la $(ANTLR_LIB)
 
+
+EXTRA_DIST = lexer.g parser.g semantic.g code.g
+
+
 BUILT_SOURCES = PortugolLexer.hpp \
                 PortugolLexer.cpp \
                 PortugolParser.hpp \
                 PortugolParser.cpp \
                 SemanticWalker.hpp \
                 SemanticWalker.cpp \
+								CodeWalker.hpp \
+								CodeWalker.cpp \
                 TokenNames.hpp \
                 TokenLabels.hpp
 
 
-gptc_SOURCES = BaseSemanticWalker.hpp \
-               BaseSemanticWalker.cpp \
-               CompilerError.hpp \
-               CompilerError.cpp \
-               MismatchedUnicodeCharException.hpp \
-               MismatchedUnicodeCharException.cpp \
-               PortugolAST.hpp \
-               PortugolAST.cpp \
-               Symbol.hpp \
-               Symbol.cpp \
-               SymbolTable.hpp \
-               SymbolTable.cpp \
-               SymbolTableExceptions.hpp \
-               SymbolTableExceptions.cpp \
-               main.cpp \
-               Types.hpp \
-               Types.cpp \
-               UnicodeCharBuffer.hpp \
-               UnicodeCharScanner.hpp \
-               $(BUILT_SOURCES)
+libgptc_la_SOURCES =  BaseSemanticWalker.hpp \
+											BaseSemanticWalker.cpp \
+											CompilerError.hpp \
+											CompilerError.cpp \
+											MismatchedUnicodeCharException.hpp \
+											MismatchedUnicodeCharException.cpp \
+											PortugolAST.hpp \
+											PortugolAST.cpp \
+											Symbol.hpp \
+											Symbol.cpp \
+											SymbolTable.hpp \
+											SymbolTable.cpp \
+											SymbolTableExceptions.hpp \
+											SymbolTableExceptions.cpp \
+											Types.hpp \
+											Types.cpp \
+											UnicodeCharBuffer.hpp \
+											UnicodeCharScanner.hpp \
+											$(BUILT_SOURCES)
 
 
 CLEANFILES = PortugolLexer.cpp \
@@ -50,20 +57,22 @@
              SemanticWalker.cpp \
              SemanticWalkerTokenTypes.hpp \
              SemanticWalkerTokenTypes.txt \
+             CodeWalkerTokenTypes.hpp \
+             CodeWalkerTokenTypes.txt \
              TokenNames.hpp \
              TokenLabels.hpp
 
 PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
 	$(ANTLR_BIN) $(srcdir)/lexer.g
 
-PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile \
-                                       PortugolLexer.cpp  PortugolLexer.hpp
+PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile
 	$(ANTLR_BIN) $(srcdir)/parser.g
 
-SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile \
-                                       PortugolLexer.cpp  PortugolLexer.hpp
+SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
 	$(ANTLR_BIN) $(srcdir)/semantic.g
 
+CodeWalker.hpp CodeWalker.cpp: $(srcdir)/code.g Makefile
+	$(ANTLR_BIN) $(srcdir)/code.g
 
 TokenNames.hpp: Makefile
 	@echo "#ifndef TOKENNAMES_H" > $@
@@ -73,6 +82,9 @@
 	grep = PortugolTokenTypes.txt >> $@
 	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
 	sed -i -e '$$s/,/};/' $@
+	@echo -n "static int g_tokenNamesSize = " >> $@
+	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
 	@echo "#endif" >> $@
 
 TokenLabels.hpp: Makefile
@@ -83,5 +95,9 @@
 	grep '"' PortugolTokenTypes.txt >> $@
 	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
 	sed -i -e '$$s/,/};/' $@
+	@echo "static int g_tokenLabelsSize = " >> $@
+	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
 	@echo "#endif" >> $@
 
+



From gpt-commit-noreply at mail.berlios.de  Sat Dec  8 10:31:34 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 8 Dec 2007 10:31:34 +0100
Subject: [gpt-commit] r428 - in trunk/gpt2/gptc: . test test/tests
Message-ID: <200712080931.lB89VYJg017854@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-08 10:31:34 +0100 (Sat, 08 Dec 2007)
New Revision: 428

Modified:
   trunk/gpt2/gptc/Makefile.am
   trunk/gpt2/gptc/test/TestAST.cpp
   trunk/gpt2/gptc/test/compiler_test.g
   trunk/gpt2/gptc/test/tests/ast.test
Log:
-Testes atualizados

Modified: trunk/gpt2/gptc/Makefile.am
===================================================================
--- trunk/gpt2/gptc/Makefile.am	2007-12-08 09:30:55 UTC (rev 427)
+++ trunk/gpt2/gptc/Makefile.am	2007-12-08 09:31:34 UTC (rev 428)
@@ -1 +1 @@
-SUBDIRS = src
\ No newline at end of file
+SUBDIRS = src test
\ No newline at end of file

Modified: trunk/gpt2/gptc/test/TestAST.cpp
===================================================================
--- trunk/gpt2/gptc/test/TestAST.cpp	2007-12-08 09:30:55 UTC (rev 427)
+++ trunk/gpt2/gptc/test/TestAST.cpp	2007-12-08 09:31:34 UTC (rev 428)
@@ -1,5 +1,6 @@
 #include "TestAST.hpp"
 #include <iostream>
+#include "TokenNames.hpp"
 
 #include <map>
 #include <string>
@@ -62,16 +63,15 @@
 		return false;
   }
 
-  #include "tokenNames.hpp"
 
   int token = -1;
-  std::map<int, std::string >::iterator it;
-  for (it = tokenNames.begin(); it != tokenNames.end(); it++) {
-    if (it->second == getText()) {
-      token = it->first;
+  for (int i = 0; i < g_tokenNamesSize; i++) {
+    if (g_tokenNames[i] == getText()) {
+      token = i;
+      break;
     }
   }
-
+  
   if (token == -1) {
     cerr << "\n\n[TestAST::equals] ops: token n?o encontrado: "
          << getText() << endl << endl;

Modified: trunk/gpt2/gptc/test/compiler_test.g
===================================================================
--- trunk/gpt2/gptc/test/compiler_test.g	2007-12-08 09:30:55 UTC (rev 427)
+++ trunk/gpt2/gptc/test/compiler_test.g	2007-12-08 09:31:34 UTC (rev 428)
@@ -109,7 +109,6 @@
   ;
 
 COMENTARIO_C
-{int line = getLine();}
   : "/*"
     (
       options { generateAmbigWarnings=false; } :

Modified: trunk/gpt2/gptc/test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/test/tests/ast.test	2007-12-08 09:30:55 UTC (rev 427)
+++ trunk/gpt2/gptc/test/tests/ast.test	2007-12-08 09:31:34 UTC (rev 428)
@@ -69,7 +69,7 @@
 
   ast: (T_ALGORITMO
          (T_VARIAVEL T_LITERAL T_IDENTIFICADOR
-           (T_VALOR T_INTEIRO_LITERAL)))
+           (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL))))
 fim
 
 teste
@@ -91,7 +91,9 @@
          (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO) T_IDENTIFICADOR
            (T_VALOR
              (T_VAL_MATRIZ
-                T_CARACTERE_LITERAL T_CARACTERE_LITERAL T_CARACTERE_LITERAL))))
+                (T_EXPRESSAO T_CARACTERE_LITERAL)
+                (T_EXPRESSAO T_CARACTERE_LITERAL)
+                (T_EXPRESSAO T_CARACTERE_LITERAL)))))
 fim
 
 teste
@@ -104,9 +106,9 @@
            (T_VALOR
              (T_VAL_MATRIZ
                 (T_VAL_MATRIZ
-                  T_CARACTERE_LITERAL T_CARACTERE_LITERAL)
+                  (T_EXPRESSAO T_CARACTERE_LITERAL) (T_EXPRESSAO T_CARACTERE_LITERAL))
                 (T_VAL_MATRIZ
-                  T_CARACTERE_LITERAL T_CARACTERE_LITERAL)))))
+                  (T_EXPRESSAO T_CARACTERE_LITERAL) (T_EXPRESSAO T_CARACTERE_LITERAL))))))
 fim
 
 teste
@@ -125,8 +127,8 @@
   ast: (T_ALGORITMO
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR (T_VAL_ESTRUTURA
-                        T_IDENTIFICADOR T_IDENTIFICADOR
-                        T_IDENTIFICADOR T_INTEIRO_LITERAL))))
+                        T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                        T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))))
 fim
 
 teste
@@ -138,9 +140,9 @@
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA T_IDENTIFICADOR
-                (T_VAL_MATRIZ T_INTEIRO_LITERAL
-                              T_INTEIRO_LITERAL
-                              T_INTEIRO_LITERAL)))))
+                (T_VAL_MATRIZ (T_EXPRESSAO T_INTEIRO_LITERAL)
+                              (T_EXPRESSAO T_INTEIRO_LITERAL)
+                              (T_EXPRESSAO T_INTEIRO_LITERAL))))))
 fim
 
 
@@ -158,9 +160,9 @@
             T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_TEXTO_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_VERDADEIRO)))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_VERDADEIRO))))))
 fim
 
 
@@ -178,9 +180,9 @@
             T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_TEXTO_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_VERDADEIRO)))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_VERDADEIRO))))))
 fim
 
 teste
@@ -194,13 +196,15 @@
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA T_IDENTIFICADOR
-                (T_VAL_MATRIZ T_INTEIRO_LITERAL
-                              T_INTEIRO_LITERAL
-                              T_INTEIRO_LITERAL))))
+                (T_VAL_MATRIZ (T_EXPRESSAO T_INTEIRO_LITERAL)
+                              (T_EXPRESSAO T_INTEIRO_LITERAL)
+                              (T_EXPRESSAO T_INTEIRO_LITERAL)))))
           (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO) T_IDENTIFICADOR
            (T_VALOR
              (T_VAL_MATRIZ
-                T_CARACTERE_LITERAL T_CARACTERE_LITERAL T_CARACTERE_LITERAL)))
+                (T_EXPRESSAO  T_CARACTERE_LITERAL) 
+                (T_EXPRESSAO  T_CARACTERE_LITERAL) 
+                (T_EXPRESSAO  T_CARACTERE_LITERAL))))
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR))
 fim
 
@@ -244,9 +248,9 @@
             T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))))))
 fim
 
 
@@ -273,11 +277,11 @@
                T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                (T_VALOR
                   (T_VAL_MATRIZ
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                      (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))))
 fim
 
 
@@ -309,11 +313,11 @@
                          T_INTEIRO_LITERAL)
                T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                (T_VALOR (T_VAL_MATRIZ
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))))
 fim
 
 
@@ -329,7 +333,7 @@
 
   ast: (T_ALGORITMO
           (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
-            (T_VALOR T_INTEIRO_LITERAL)))
+            (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL))))
 fim
 
 
@@ -343,7 +347,9 @@
             (T_MATRIZ T_INTEIRO T_INTEIRO_LITERAL) T_IDENTIFICADOR
               (T_VALOR
                 (T_VAL_MATRIZ
-                  T_INTEIRO_LITERAL T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))
+                  (T_EXPRESSAO T_INTEIRO_LITERAL)
+                  (T_EXPRESSAO T_INTEIRO_LITERAL)
+                  (T_EXPRESSAO T_INTEIRO_LITERAL)))))
 fim
 
 teste
@@ -355,8 +361,8 @@
           (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA
-                T_IDENTIFICADOR T_IDENTIFICADOR
-                T_IDENTIFICADOR T_REAL_LITERAL))))
+                T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
 fim
 
 teste
@@ -370,11 +376,11 @@
               (T_VALOR
                 (T_VAL_MATRIZ
                   (T_VAL_ESTRUTURA
-                    T_IDENTIFICADOR T_INTEIRO_LITERAL
-                    T_IDENTIFICADOR T_REAL_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))
                   (T_VAL_ESTRUTURA
-                    T_IDENTIFICADOR T_CARACTERE_LITERAL
-                    T_IDENTIFICADOR T_TEXTO_LITERAL)))))
+                    T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))))))
 fim
 
 
@@ -386,17 +392,17 @@
 
   ast: (T_ALGORITMO
          (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
-            (T_VALOR T_INTEIRO_LITERAL))
+            (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
           (T_CONSTANTE
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL) T_IDENTIFICADOR
               (T_VALOR
                 (T_VAL_MATRIZ
                   (T_VAL_ESTRUTURA
-                    T_IDENTIFICADOR T_INTEIRO_LITERAL
-                    T_IDENTIFICADOR T_REAL_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))
                   (T_VAL_ESTRUTURA
-                    T_IDENTIFICADOR T_CARACTERE_LITERAL
-                    T_IDENTIFICADOR T_TEXTO_LITERAL)))))
+                    T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL)
+                    T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))))))
 fim
 
 teste
@@ -412,15 +418,15 @@
 
   ast : (T_ALGORITMO
           (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
-                        (T_VALOR T_INTEIRO_LITERAL))
+                        (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
           (T_CONSTANTE
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
              T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))))))
 fim
 
 teste
@@ -437,20 +443,20 @@
 
   ast : (T_ALGORITMO
           (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
-                        (T_VALOR T_INTEIRO_LITERAL))
+                        (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
           (T_CONSTANTE
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
              T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
                     (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA
-                T_IDENTIFICADOR T_IDENTIFICADOR
-                T_IDENTIFICADOR T_REAL_LITERAL))))
+                T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
 fim
 
 
@@ -473,15 +479,15 @@
           (T_ESTRUTURA T_IDENTIFICADOR
             (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
             (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR
-               (T_VALOR T_INTEIRO_LITERAL))
+               (T_VALOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
             (T_VARIAVEL
               (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
               T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
               (T_VALOR
                 (T_VAL_MATRIZ
-                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))))
 fim
 
 
@@ -608,11 +614,11 @@
                             T_INTEIRO_LITERAL)
                   T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                   (T_VALOR (T_VAL_MATRIZ
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))))
             (T_INICIO)))
 fim
 
@@ -637,7 +643,7 @@
          (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
          (T_INICIO
             (T_ATRIBUICAO T_IDENTIFICADOR
-              (T_MAIS T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))
+              (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))))
 fim
 
 teste
@@ -650,8 +656,8 @@
   ast: (T_ALGORITMO
          (T_INICIO
             (T_ATRIBUICAO T_IDENTIFICADOR
-              (T_MAIS T_INTEIRO_LITERAL
-                (T_MULTIP T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))))
+              (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL
+                (T_MULTIP T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))))
 fim
 
 
@@ -667,7 +673,22 @@
           x := 1;
         fim-para
       fim-para
+    fim
+  }
 
+
+  ast:
+    (T_ALGORITMO
+      (T_INICIO
+        (T_PARA T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
+          (T_PARA T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
+                ( T_PASSO T_MENOS T_INTEIRO_LITERAL )
+            ( T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+fim
+
+teste
+  {
+    in?cio
       enquanto x > 10 / 3 fa?a
         repita
           se x % 2 <> 3 / 4 ent?o
@@ -675,7 +696,24 @@
           fim-se
         at? 10 > 3
       fim-enquanto
+    fim
+  }
+  ast:
+    (T_ALGORITMO
+      (T_INICIO
+        (T_ENQUANTO
+          (T_EXPRESSAO (T_MAIOR T_IDENTIFICADOR (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
+            (T_REPITA
+              (T_SE (T_EXPRESSAO (T_DIFERENTE
+                      (T_MOD T_IDENTIFICADOR T_INTEIRO_LITERAL)
+                      (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
+                (T_CALL T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))
+              T_ATE (T_EXPRESSAO ( T_MAIOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))))
+fim
 
+teste
+  {
+    in?cio
       sair;
 
       se verdadeiro ent?o
@@ -683,7 +721,28 @@
       sen?o
         f((1+2)*3);
       fim-se
+    fim
+  }
 
+  ast:
+    (T_ALGORITMO
+      (T_INICIO
+        (T_SAIR)
+        (T_SE (T_EXPRESSAO T_VERDADEIRO)
+          (T_RETORNE (T_EXPRESSAO (T_BIT_SHIFT_RIGHT
+                        (T_IDENTIFICADOR (T_MEMBRO T_IDENTIFICADOR))
+                        (T_IDENTIFICADOR (T_SUBSCRITO (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+          T_SENAO (T_CALL T_IDENTIFICADOR (T_EXPRESSAO (T_MULTIP
+                                            (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL
+                                                                T_INTEIRO_LITERAL))
+                                                        T_INTEIRO_LITERAL))))))
+
+fim
+
+
+teste
+  {
+    in?cio
       caso x seja
         "teste" fa?a
           f(1);
@@ -701,36 +760,16 @@
     fim
   }
 
-  ast:
-(T_ALGORITMO
-  (T_INICIO
-    (T_PARA T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL
-      (T_PARA T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL
-            ( T_PASSO T_MENOS T_INTEIRO_LITERAL )
-        ( T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL ) ) )
-    (T_ENQUANTO
-      (T_MAIOR T_IDENTIFICADOR (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL))
-        (T_REPITA
-          (T_SE (T_DIFERENTE
-                  (T_MOD T_IDENTIFICADOR T_INTEIRO_LITERAL)
-                  (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL))
-            (T_CALL T_IDENTIFICADOR T_IDENTIFICADOR))
-          T_ATE ( T_MAIOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
-    (T_SAIR)
-    (T_SE T_VERDADEIRO
-      (T_RETORNE (T_BIT_SHIFT_RIGHT
-                    (T_IDENTIFICADOR T_IDENTIFICADOR)
-                    (T_IDENTIFICADOR T_INTEIRO_LITERAL)))
-      T_SENAO (T_CALL T_IDENTIFICADOR (T_MULTIP
-                                      (T_MAIS T_INTEIRO_LITERAL
-                                              T_INTEIRO_LITERAL)
-                                       T_INTEIRO_LITERAL)))
-    (T_CASO T_IDENTIFICADOR
-      (T_TEXTO_LITERAL
-        (T_CALL T_IDENTIFICADOR T_INTEIRO_LITERAL)
-        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL))
-      (T_REAL_LITERAL
-        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL))
-      (T_SENAO
-        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL)))))
+  ast: 
+      (T_ALGORITMO
+        (T_INICIO
+          (T_CASO (T_EXPRESSAO T_IDENTIFICADOR)
+            (T_FACA T_TEXTO_LITERAL
+              (T_CALL T_IDENTIFICADOR (T_EXPRESSAO  T_INTEIRO_LITERAL))
+              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
+            (T_FACA T_REAL_LITERAL
+              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
+            (T_SENAO
+              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+          
 fim
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Thu Dec 13 21:58:32 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 13 Dec 2007 21:58:32 +0100
Subject: [gpt-commit] r429 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712132058.lBDKwW2C028158@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-13 21:58:27 +0100 (Thu, 13 Dec 2007)
New Revision: 429

Modified:
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
   trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* Novos opcodes: iret, sret, rret, dret e mret
* GptASM nao reconhece mais incsp e decsp, mas esses opcodes continuam
  existindo na VM
* Retirado os opcodes pushir, pushrr, pushsr, pushdr e pushmr
* Os opcodes de retorno de procedimento (ret) agora indicam o tamanho
  do RA


Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/common/src/Common.hpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -111,48 +111,53 @@
    OP_DECSP_4     = 83,
    OP_DECSP_8     = 84,
    OP_PCALL       = 85,
-   OP_RET         = 86,
-   OP_LCALL       = 87,
-   OP_SALLOC      = 88,
-   OP_SFREE       = 89,
-   OP_SSETC       = 90,
-   OP_SGETC       = 91,
-   OP_M1ALLOC     = 92,
-   OP_M2ALLOC     = 93,
-   OP_MFREE       = 94,
-   OP_M1SET       = 95,
-   OP_M1GET       = 96,
-   OP_M2SET       = 97,
-   OP_M2GET       = 98,
-   OP_MCOPY       = 99,
-   OP_MGETSIZE1   = 100,
-   OP_MGETSIZE2   = 101,
-   OP_PUSHIT      = 102,
-   OP_PUSHST      = 103,
-   OP_PUSHRT      = 104,
-   OP_PUSHCT      = 105,
-   OP_PUSHBT      = 106,
-   OP_PUSHDT      = 107,
-   OP_PUSHMT      = 108,
-   OP_POPIV       = 109,
-   OP_POPRV       = 110,
-   OP_POPSV       = 111,
-   OP_POPDV       = 112,
-   OP_POPMV       = 113,
-   OP_PUSH_0      = 114,
-   OP_PUSH_1      = 115,
-   OP_PUSH_2      = 116,
-   OP_PUSH_3      = 117,
-   OP_PUSH_4      = 118,
-   OP_PUSH_5      = 119,
-   OP_EXIT_0      = 120,
-   OP_EXIT_1      = 121,
-   OP_PUSHIR      = 122,
-   OP_PUSHSR      = 123,
-   OP_PUSHRR      = 124,
-   OP_PUSHDR      = 125,
-   OP_PUSHMR      = 126,
-   OPCODE_NUMBER  = 127
+   OP_IRET        = 86,
+   OP_RRET        = 87,
+   OP_SRET        = 88,
+   OP_DRET        = 89,
+   OP_MRET        = 90,
+   OP_LCALL       = 91,
+   OP_SALLOC      = 92,
+   OP_SFREE       = 93,
+   OP_SSETC       = 94,
+   OP_SGETC       = 95,
+   OP_M1ALLOC     = 96,
+   OP_M2ALLOC     = 97,
+   OP_MFREE       = 98,
+   OP_M1SET       = 99,
+   OP_M1GET       = 100,
+   OP_M2SET       = 101,
+   OP_M2GET       = 102,
+   OP_MCOPY       = 103,
+   OP_MGETSIZE1   = 104,
+   OP_MGETSIZE2   = 105,
+   OP_PUSHIT      = 106,
+   OP_PUSHST      = 107,
+   OP_PUSHRT      = 108,
+   OP_PUSHCT      = 109,
+   OP_PUSHBT      = 110,
+   OP_PUSHDT      = 111,
+   OP_PUSHMT      = 112,
+   OP_POPIV       = 113,
+   OP_POPRV       = 114,
+   OP_POPSV       = 115,
+   OP_POPDV       = 116,
+   OP_POPMV       = 117,
+   OP_PUSH_0      = 118,
+   OP_PUSH_1      = 119,
+   OP_PUSH_2      = 120,
+   OP_PUSH_3      = 121,
+   OP_PUSH_4      = 122,
+   OP_PUSH_5      = 123,
+   OP_EXIT_0      = 124,
+   OP_EXIT_1      = 125,
+//   OP_PUSHIR      = 126,
+//   OP_PUSHSR      = 127,
+//   OP_PUSHRR      = 128,
+//   OP_PUSHDR      = 129,
+//   OP_PUSHMR      = 130,
+   OP_RET         = 131,
+   OPCODE_NUMBER  = 132
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -88,8 +88,8 @@
    _opcodes[ "popsv"       ] = OP_POPSV;
    _opcodes[ "popdv"       ] = OP_POPDV;
    _opcodes[ "popmv"       ] = OP_POPMV;
-   _opcodes[ "incsp"       ] = OP_INCSP;
-   _opcodes[ "decsp"       ] = OP_DECSP;
+//   _opcodes[ "incsp"       ] = OP_INCSP;
+//   _opcodes[ "decsp"       ] = OP_DECSP;
    _opcodes[ "push_0"      ] = OP_PUSH_0;
    _opcodes[ "push_1"      ] = OP_PUSH_1;
    _opcodes[ "push_2"      ] = OP_PUSH_2;
@@ -101,11 +101,11 @@
    _opcodes[ "pushrv"      ] = OP_PUSHRV;
    _opcodes[ "pushdv"      ] = OP_PUSHDV;
    _opcodes[ "pushmv"      ] = OP_PUSHMV;
-   _opcodes[ "pushir"      ] = OP_PUSHIR;
-   _opcodes[ "pushsr"      ] = OP_PUSHSR;
-   _opcodes[ "pushrr"      ] = OP_PUSHRR;
-   _opcodes[ "pushdr"      ] = OP_PUSHDR;
-   _opcodes[ "pushmr"      ] = OP_PUSHMR;
+//   _opcodes[ "pushir"      ] = OP_PUSHIR;
+//   _opcodes[ "pushsr"      ] = OP_PUSHSR;
+//   _opcodes[ "pushrr"      ] = OP_PUSHRR;
+//   _opcodes[ "pushdr"      ] = OP_PUSHDR;
+//   _opcodes[ "pushmr"      ] = OP_PUSHMR;
    _opcodes[ "pushit"      ] = OP_PUSHIT;
    _opcodes[ "pushst"      ] = OP_PUSHST;
    _opcodes[ "pushrt"      ] = OP_PUSHRT;
@@ -113,12 +113,17 @@
    _opcodes[ "pushbt"      ] = OP_PUSHBT;
    _opcodes[ "pushdt"      ] = OP_PUSHDT;
    _opcodes[ "pushmt"      ] = OP_PUSHMT;
-   _opcodes[ "incsp_4"     ] = OP_INCSP_4;
-   _opcodes[ "incsp_8"     ] = OP_INCSP_8;
-   _opcodes[ "decsp_4"     ] = OP_DECSP_4;
-   _opcodes[ "decsp_8"     ] = OP_DECSP_8;
+//   _opcodes[ "incsp_4"     ] = OP_INCSP_4;
+//   _opcodes[ "incsp_8"     ] = OP_INCSP_8;
+//   _opcodes[ "decsp_4"     ] = OP_DECSP_4;
+//   _opcodes[ "decsp_8"     ] = OP_DECSP_8;
    _opcodes[ "pcall"       ] = OP_PCALL;
    _opcodes[ "ret"         ] = OP_RET;
+   _opcodes[ "iret"        ] = OP_IRET;
+   _opcodes[ "rret"        ] = OP_RRET;
+   _opcodes[ "sret"        ] = OP_SRET;
+   _opcodes[ "dret"        ] = OP_DRET;
+   _opcodes[ "mret"        ] = OP_MRET;
    _opcodes[ "lcall"       ] = OP_LCALL;
    _opcodes[ "salloc"      ] = OP_SALLOC;
    _opcodes[ "sfree"       ] = OP_SFREE;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-13 20:58:27 UTC (rev 429)
@@ -116,8 +116,8 @@
    T_KW_POPRV="poprv";
    T_KW_POPDV="popdv";
    T_KW_POPMV="popmv";
-   T_KW_INCSP="incsp";
-   T_KW_DECSP="decsp";
+//   T_KW_INCSP="incsp";
+//   T_KW_DECSP="decsp";
    T_KW_PUSH_0="push_0";
    T_KW_PUSH_1="push_1";
    T_KW_PUSH_2="push_2";
@@ -136,18 +136,23 @@
    T_KW_PUSHBT="pushbt";
    T_KW_PUSHDT="pushdt";
    T_KW_PUSHMT="pushmt";
-   T_KW_PUSHIR="pushir";
-   T_KW_PUSHRR="pushrr";
-   T_KW_PUSHSR="pushsr";
-   T_KW_PUSHDR="pushdr";
-   T_KW_PUSHMR="pushmr";
-   T_KW_INCSP_4="incsp_4";
-   T_KW_INCSP_8="incsp_8";
-   T_KW_DECSP_4="decsp_4";
-   T_KW_DECSP_8="decsp_8";
+//   T_KW_PUSHIR="pushir";
+//   T_KW_PUSHRR="pushrr";
+//   T_KW_PUSHSR="pushsr";
+//   T_KW_PUSHDR="pushdr";
+//   T_KW_PUSHMR="pushmr";
+//   T_KW_INCSP_4="incsp_4";
+//   T_KW_INCSP_8="incsp_8";
+//   T_KW_DECSP_4="decsp_4";
+//   T_KW_DECSP_8="decsp_8";
    T_KW_PCALL="pcall";
    T_KW_LCALL="lcall";
    T_KW_RET="ret";
+   T_KW_IRET="iret";
+   T_KW_RRET="rret";
+   T_KW_SRET="sret";
+   T_KW_DRET="dret";
+   T_KW_MRET="mret";
    T_KW_SALLOC="salloc";
    T_KW_SFREE="sfree";
    T_KW_SSETC="ssetc";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-13 20:58:27 UTC (rev 429)
@@ -262,13 +262,13 @@
       identifier
       T_COMMA
       intvalue
-   |  ("incsp"|"decsp")
-      {bytecode.addOpcode(getLastTokenText());}
-      intvalue
+//   |  ("incsp"|"decsp")
+//      {bytecode.addOpcode(getLastTokenText());}
+//      intvalue
    |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
       {bytecode.addOpcode(getLastTokenText());}
-   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
-      {bytecode.addOpcode(getLastTokenText());}
+//   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
+//      {bytecode.addOpcode(getLastTokenText());}
    |  "pcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
@@ -279,6 +279,12 @@
       { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
    |  "ret"
       {bytecode.addOpcode(getLastTokenText());}
+      intvalue
+   |  ("iret"|"rret"|"sret"|"dret"|"mret")
+      {bytecode.addOpcode(getLastTokenText());}
+      intvalue
+      T_COMMA
+      identifier
    ;
 
 //----------------------

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -38,8 +38,9 @@
     push_2
     lcall imprima
 
-    decsp 12
-    ret
+//    descp 12
+
+    ret 12
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -39,8 +39,9 @@
     push_2
     lcall imprima
 
-    decsp 20
-    ret
+//    descp 20
+
+    ret 20
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -3,7 +3,6 @@
 proc main
     var t1 int
     // imprima( "A soma ?: ", soma( 2, 7 ) );
-    pushir // resultado da fun??o
     pushiv 7 // empilha 7
     pushiv 2 // empilha 2
     pcall soma
@@ -19,14 +18,14 @@
 endproc
 
 proc soma
-    param __result int
     param x int
     param y int
+    var __result int
 
     isum __result, x, y
 
-    decsp_8 // tamanho dos parametros + variaveis locais - retorno da funcao
-    ret
+//    decsp 12 // tamanho dos parametros + variaveis locais - retorno da funcao
+    iret 12, __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -15,7 +15,6 @@
     popiv x
 
     // imprima( "Fatorial de ", x, " ? ", fatorial( x ) );
-    pushir // retorno da fun??o
     pushiv x
     pcall fatorial
     pushit
@@ -32,8 +31,8 @@
 endproc
 
 proc fatorial
-    param __result int
     param z int
+    var __result int
 	
     var t1 int
     var t2 int
@@ -43,26 +42,25 @@
     ifnot t1, senao
         // retorne 1;
         iset __result, 1
-        decsp 12
-        ret
+//        decsp 16
+        iret 16, __result
         jmp proximo
     // sen?o
     senao:
         // retorne z * fatorial( z - 1 );
         isub t1, z, 1
-        pushir // retorno da fun??o
         pushiv t1
         pcall fatorial
         popiv t1
         imul t2, z, t1
         iset __result, t2
-        decsp 12
-        ret
+//        decsp 16
+        iret 16, __result
     // fim-se
     proximo:
 
-    decsp 12
-    ret
+//    decsp 16
+    iret 16, __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -62,7 +62,8 @@
     jmp teste2
     proximo2:
 
-    ret
+//    decsp_8
+    ret 8
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -5,7 +5,6 @@
 var t1 int
 
 proc main
-    pushmr
     pcall insere_dados
     popmv m
 
@@ -19,8 +18,8 @@
 endproc
 
 proc insere_dados
-    param d1 matrix
 //    var t1 int
+    var d1 matrix
 
     // aloca espa?o para a matriz d1
     // d1 armazena dados de 4 bytes e tem 10 elementos iniciais
@@ -42,7 +41,7 @@
     proximo:
 
 //    decsp_4
-    ret
+    mret 4, d1
 endproc
 
 proc mostra_dados
@@ -73,8 +72,8 @@
     jmp teste2
     proximo2:
 
-    decsp_4
-    ret
+//    decsp_4
+    ret 4
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -78,6 +78,8 @@
     // desaloca espa?o da matriz m
     mfree m
 
+//    decsp_4
+
     exit_0
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -27,8 +27,9 @@
     push_2
     lcall imprima
 
-    decsp 12
-    ret	
+//    decsp 12
+
+    ret	 12
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -28,8 +28,8 @@
     isum t1, v1, v2
     isetv r:0, t1
 
-    decsp 16
-    ret	
+//    decsp 16
+    ret	16
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -21,8 +21,8 @@
    pushiv 1
    lcall imprima
 
-   decsp 4
-   ret
+//   decsp 4
+   ret 4
 endproc
    
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -6,7 +6,6 @@
 //    var v string
 
 //    salloc v
-    pushsr
     pcall ajusta
     popsv v
 
@@ -21,11 +20,12 @@
 endproc
 
 proc ajusta
-    param __result string
+    var __result string
 
     salloc __result
     sset __result, "Hello !!!"
-    ret
+//    decsp 5
+    sret 5, __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
@@ -4,7 +4,6 @@
     var v string
 
 //    salloc v
-    pushsr
     pcall ajusta
     popsv v
 
@@ -19,11 +18,12 @@
 endproc
 
 proc ajusta
-    param __result string
+    var __result string
 
     salloc __result
     sset __result, "Hello !!!"
-    ret
+//    decsp 4
+    sret 5,__result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -231,10 +231,18 @@
 
 void CDataStack::setSP(const int &value)
 {
+   CBinString::resize(value);
    _SP = value;
 }
 
 
+void CDataStack::decSP(const int &value)
+{
+   CBinString::popBytes(value);
+   _SP -= value;
+}
+
+
 int CDataStack::getBS() const
 {
    return _BS;

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -26,6 +26,7 @@
    void discardBytes(const int &number);
    void setBS(const int &value);
    void setSP(const int &value);
+   void decSP(const int &value);
    int getBS() const;
    int getSP() const;
    void readString(std::string &value);

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -7,6 +7,8 @@
 
 // TODO: Armazenar todas as strings em memoria com o tamanho na frente ???
 
+#pragma pack(1)
+
 struct SStringType {
    char _type;
    union UStringTypeValue {
@@ -68,6 +70,7 @@
    { }
 };
 
+#pragma pack()
 
 CRunBytecode::CRunBytecode()
    : _returnCode(0)
@@ -204,11 +207,11 @@
    _opcodePointer[OP_PUSHDV     ] = &CRunBytecode::pushdvOpcode;
    _opcodePointer[OP_PUSHMV     ] = &CRunBytecode::pushmvOpcode;
 
-   _opcodePointer[OP_PUSHSR     ] = &CRunBytecode::pushsrOpcode;
-   _opcodePointer[OP_PUSHIR     ] = &CRunBytecode::pushirOpcode;
-   _opcodePointer[OP_PUSHRR     ] = &CRunBytecode::pushrrOpcode;
-   _opcodePointer[OP_PUSHDR     ] = &CRunBytecode::pushdrOpcode;
-   _opcodePointer[OP_PUSHMR     ] = &CRunBytecode::pushmrOpcode;
+//   _opcodePointer[OP_PUSHSR     ] = &CRunBytecode::pushsrOpcode;
+//   _opcodePointer[OP_PUSHIR     ] = &CRunBytecode::pushirOpcode;
+//   _opcodePointer[OP_PUSHRR     ] = &CRunBytecode::pushrrOpcode;
+//   _opcodePointer[OP_PUSHDR     ] = &CRunBytecode::pushdrOpcode;
+//   _opcodePointer[OP_PUSHMR     ] = &CRunBytecode::pushmrOpcode;
 
    _opcodePointer[OP_PUSHST     ] = &CRunBytecode::pushstOpcode;
    _opcodePointer[OP_PUSHIT     ] = &CRunBytecode::pushitOpcode;
@@ -224,6 +227,11 @@
    _opcodePointer[OP_DECSP_8    ] = &CRunBytecode::decsp_8Opcode;
 
    _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
+   _opcodePointer[OP_IRET       ] = &CRunBytecode::iretOpcode;
+   _opcodePointer[OP_RRET       ] = &CRunBytecode::rretOpcode;
+   _opcodePointer[OP_SRET       ] = &CRunBytecode::sretOpcode;
+   _opcodePointer[OP_DRET       ] = &CRunBytecode::dretOpcode;
+   _opcodePointer[OP_MRET       ] = &CRunBytecode::mretOpcode;
    _opcodePointer[OP_SALLOC     ] = &CRunBytecode::sallocOpcode;
    _opcodePointer[OP_SFREE      ] = &CRunBytecode::sfreeOpcode;
    _opcodePointer[OP_SSETC      ] = &CRunBytecode::ssetcOpcode;
@@ -260,7 +268,7 @@
 
 void CRunBytecode::step()
 {
-    char opcode;
+    unsigned char opcode;
     opcode = _code.fetchByte();
 
    if (opcode >= OPCODE_NUMBER) {
@@ -365,7 +373,19 @@
    std::cout << std::endl;
 }
 
+void CRunBytecode::popRA()
+{
+   _code.setIP(_executionStack.top());
+   _executionStack.pop();
 
+//   _dataStack.setSP(_executionStack.top());
+//   _executionStack.pop();
+
+   _dataStack.setBS(_executionStack.top());
+   _executionStack.pop();
+}
+
+
 /////////////
 // opcodes //
 /////////////
@@ -1244,10 +1264,6 @@
    type._type                = CSymbol::VAR;
    type._value._addressValue = (int)value;
 
-//   std::cout << "sizeof(type)=" << sizeof(type) << std::endl;
-//   _dataStack.pushBytes(&type, sizeof(type));
-//   TODO: problemas de alinhamento nas estruturas... nao consegui desativar com pragmas...
-
    _dataStack.pushByte(CSymbol::VAR);
    _dataStack.pushInt((int)value);
 }
@@ -1322,46 +1338,46 @@
 }
 
 
-void CRunBytecode::pushsrOpcode()
-{
-   trace ("pushsr opcode");
+//void CRunBytecode::pushsrOpcode()
+//{
+//   trace ("pushsr opcode");
+//
+//   SStringType type;
+//
+//   _dataStack.pushBytes((char*)&type, sizeof(type));
+//}
 
-   SStringType type;
 
-   _dataStack.pushBytes((char*)&type, sizeof(type));
-}
+//void CRunBytecode::pushirOpcode()
+//{
+//   trace ("pushir opcode");
+//
+//   _dataStack.pushInt(0);
+//}
 
+//void CRunBytecode::pushrrOpcode()
+//{
+//   trace ("pushrr opcode");
+//
+//   _dataStack.pushReal(0);
+//}
 
-void CRunBytecode::pushirOpcode()
-{
-   trace ("pushir opcode");
+//void CRunBytecode::pushdrOpcode()
+//{
+//   trace ("pushdr opcode");
+//
+//   int size = _dataStack.getInt(_code.fetchInt());
+//
+//   _dataStack.pushBytes(size);
+//}
 
-   _dataStack.pushInt(0);
-}
+//void CRunBytecode::pushmrOpcode()
+//{
+//   trace ("pushmr opcode");
+//
+//   _dataStack.pushBytes(getTypeSize(CSymbol::MATRIX));
+//}
 
-void CRunBytecode::pushrrOpcode()
-{
-   trace ("pushrr opcode");
-
-   _dataStack.pushReal(0);
-}
-
-void CRunBytecode::pushdrOpcode()
-{
-   trace ("pushdr opcode");
-
-   int size = _dataStack.getInt(_code.fetchInt());
-
-   _dataStack.pushBytes(size);
-}
-
-void CRunBytecode::pushmrOpcode()
-{
-   trace ("pushmr opcode");
-
-   _dataStack.pushBytes(getTypeSize(CSymbol::MATRIX));
-}
-
 //void CRunBytecode::pushmrOpcode()
 //{
 //   trace ("pushmr opcode");
@@ -1452,17 +1468,86 @@
    _dataStack.popInt();
 }
 
+
 void CRunBytecode::retOpcode()
 {
    trace ("ret opcode");
 
-   _code.setIP(_executionStack.top());
-   _executionStack.pop();
+   int raSize  = _dataStack.getInt(_code.fetchInt());
 
-   _dataStack.setBS(_executionStack.top());
-   _executionStack.pop();
+   _dataStack.decSP(raSize);
+
+   popRA();
 }
 
+void CRunBytecode::iretOpcode()
+{
+   trace ("iret opcode");
+
+   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int result = _dataStack.getInt(_code.fetchInt());
+
+   _dataStack.decSP(raSize);
+
+   popRA();
+
+   // Empilha o resultado
+   _dataStack.pushInt(result);
+}
+
+void CRunBytecode::rretOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sretOpcode()
+{
+   trace ("sret opcode");
+
+   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int address = _code.fetchInt();
+
+   std::string *value = new std::string(); // TODO: quando eh desalocado ?
+   *value = _dataStack.getString(address);
+
+   SStringType type;
+   type._type                = CSymbol::VAR;
+   type._value._addressValue = (int)value;
+
+   _dataStack.decSP(raSize);
+
+   popRA();
+
+   _dataStack.pushBytes((char*)&type, sizeof(type));
+
+//   _dataStack.pushByte(CSymbol::VAR);
+//   _dataStack.pushInt((int)value);
+}
+
+void CRunBytecode::dretOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::mretOpcode()
+{
+   trace ("mret opcode");
+
+   int raSize  = _dataStack.getInt(_code.fetchInt());
+   SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
+
+   int size = sizeof(SMatrix1TypeHeader) + matrix->_elements[0]*matrix->_elementSize;
+   char *newMatrix = new char[size]; // TODO: memory leak
+   memcpy(newMatrix, matrix, size);
+
+
+   _dataStack.decSP(raSize);
+
+   popRA();
+
+   _dataStack.pushInt((int)newMatrix);
+}
+
 void CRunBytecode::sallocOpcode()
 {
    trace ("salloc opcode");

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-08 09:31:34 UTC (rev 428)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-13 20:58:27 UTC (rev 429)
@@ -38,6 +38,7 @@
    double getRealData(const int &address);
    void setStringData(const int &address, const std::string &value);
    std::string getStringData(const int &address);
+   void popRA();
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
@@ -138,11 +139,11 @@
    void pushdvOpcode();
    void pushmvOpcode();
 
-   void pushsrOpcode();
-   void pushirOpcode();
-   void pushrrOpcode();
-   void pushdrOpcode();
-   void pushmrOpcode();
+//   void pushsrOpcode();
+//   void pushirOpcode();
+//   void pushrrOpcode();
+//   void pushdrOpcode();
+//   void pushmrOpcode();
 
    void pushstOpcode();
    void pushitOpcode();
@@ -158,6 +159,11 @@
    void decsp_8Opcode();
 
    void retOpcode();
+   void iretOpcode();
+   void rretOpcode();
+   void sretOpcode();
+   void dretOpcode();
+   void mretOpcode();
    void sallocOpcode();
    void sfreeOpcode();
    void ssetcOpcode();

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Dec 14 14:38:45 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 14 Dec 2007 14:38:45 +0100
Subject: [gpt-commit] r430 - in trunk/gpt2: gptasm/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712141338.lBEDcjHd011705@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-14 14:38:43 +0100 (Fri, 14 Dec 2007)
New Revision: 430

Modified:
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
   trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
Log:
DEVNULL:
* Simplificacoes no assembly gerado:
  - pushdv e popdv nao precisam mais indicar o tamanho do dado
  - decsp nao precisa mais ser gerado no final do procedimento
  - os opcodes ret e <type>ret precisam do tamanho do RA
  - o GptASM gera o tamanho do RA nos opcodes ret e <type>ret
    para gerar o bytecode
* GptASM nao reconhece mais os mnemonicos incsp e decsp, mas os opcodes
  continuam existindo na VM


Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-12-14 13:38:43 UTC (rev 430)
@@ -162,6 +162,7 @@
     registryLabel(procedureName);
    _parameters.clear();
 //   _parametersSize = 0;
+   _raSize = 0;
 }
 
 
@@ -195,6 +196,7 @@
       _code.writeByte(OP_INCSP);
       addAddress(itoa(symbol->getTypeSize()), CSymbol::CONST, CSymbol::INT, size);
    }
+   _raSize += size;
 }
 
 
@@ -208,6 +210,7 @@
 //   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
 //   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
 //   _currentSP += symbol->getTypeSize();
+   _raSize += size;
 }
 
 
@@ -255,11 +258,30 @@
 
 void CGenBytecode::addOpcode(const std::string &mn)
 {
+   unsigned char opcode = _opcodes[mn];
 //   std::cout << "Mn=" << mn << " opcode: " << (int)_opcodes[mn] << std::endl;
-   _code.writeByte(_opcodes[mn]);
+   _code.writeByte(opcode);
+   switch (opcode) {
+      case OP_RET:
+      case OP_IRET:
+      case OP_RRET:
+      case OP_SRET:
+      case OP_DRET:
+      case OP_MRET:
+         // Para os mnemonicos ret, iret, rret, sret, dret e mret o montador acrescenta o tamanho do registro de ativacao
+         _code.writeInt(_raSize);
+         break;
+   }
 }
 
 
+void CGenBytecode::addSymbolSize(const std::string &symbol)
+{
+   int size = _symbolTable.getSymbol(symbol)->getTypeSize();
+   _code.writeInt(size);
+}
+
+
 void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type, int size)
 {
    if (size == 0) {

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-12-14 13:38:43 UTC (rev 430)
@@ -38,6 +38,7 @@
    CBinString getBinary();
    void unsolvedLabel(const std::string &label);
    void translateLabelsToAddress();
+   void addSymbolSize(const std::string &symbol);
 private:
 
    CHeader                    _header;
@@ -48,6 +49,7 @@
    std::string                _currentProcedure;
    int                        _currentSP;
 //   int                        _parametersSize;
+   int                        _raSize;
    std::list<std::pair<std::string, int> > _unsolvedLabels;
    std::map<std::string, int> _solvedLabels;
 //   std::list<std::pair<std::string,int> > _parameters;

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-14 13:38:43 UTC (rev 430)
@@ -247,11 +247,10 @@
    |  "pushdv"
       {bytecode.addOpcode(getLastTokenText());}
       element
-      T_COMMA
-      intvalue
+      {bytecode.addSymbolSize(getLastTokenText());}
       // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
-   |  ("pushir"|"pushsr"|"pushrr"|"pushdr"|"pushmr")
-      {bytecode.addOpcode(getLastTokenText());}
+//   |  ("pushir"|"pushsr"|"pushrr"|"pushdr"|"pushmr")
+//      {bytecode.addOpcode(getLastTokenText());}
    |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushdt"|"pushmt")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("popiv"|"popsv"|"poprv"|"popmv")
@@ -260,8 +259,7 @@
    |  "popdv"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
-      T_COMMA
-      intvalue
+      {bytecode.addSymbolSize(getLastTokenText());}
 //   |  ("incsp"|"decsp")
 //      {bytecode.addOpcode(getLastTokenText());}
 //      intvalue
@@ -279,11 +277,11 @@
       { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
    |  "ret"
       {bytecode.addOpcode(getLastTokenText());}
-      intvalue
+//      intvalue
    |  ("iret"|"rret"|"sret"|"dret"|"mret")
       {bytecode.addOpcode(getLastTokenText());}
-      intvalue
-      T_COMMA
+//      intvalue
+//      T_COMMA
       identifier
    ;
 

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -9,7 +9,7 @@
     // c.y := 20;
     isetv c:4, 20 // *(c + 4 ) := 20
 
-    pushdv c, 8
+    pushdv c
     pcall exibe
 
     exit_0
@@ -38,9 +38,7 @@
     push_2
     lcall imprima
 
-//    descp 12
-
-    ret 12
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -9,7 +9,7 @@
     // c.y := 20;
     isetv c:8, 20 // *(c + 4 ) := 20
 
-    pushdv c, 12
+    pushdv c
     pcall exibe
 
     exit_0
@@ -39,9 +39,7 @@
     push_2
     lcall imprima
 
-//    descp 20
-
-    ret 20
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -24,8 +24,7 @@
 
     isum __result, x, y
 
-//    decsp 12 // tamanho dos parametros + variaveis locais - retorno da funcao
-    iret 12, __result
+    iret __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -42,8 +42,7 @@
     ifnot t1, senao
         // retorne 1;
         iset __result, 1
-//        decsp 16
-        iret 16, __result
+        iret __result
         jmp proximo
     // sen?o
     senao:
@@ -54,13 +53,11 @@
         popiv t1
         imul t2, z, t1
         iset __result, t2
-//        decsp 16
-        iret 16, __result
+        iret __result
     // fim-se
     proximo:
 
-//    decsp 16
-    iret 16, __result
+    iret __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -62,8 +62,7 @@
     jmp teste2
     proximo2:
 
-//    decsp_8
-    ret 8
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -40,8 +40,7 @@
     jmp teste
     proximo:
 
-//    decsp_4
-    mret 4, d1
+    mret d1
 endproc
 
 proc mostra_dados
@@ -72,8 +71,7 @@
     jmp teste2
     proximo2:
 
-//    decsp_4
-    ret 4
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -78,8 +78,6 @@
     // desaloca espa?o da matriz m
     mfree m
 
-//    decsp_4
-
     exit_0
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -27,9 +27,7 @@
     push_2
     lcall imprima
 
-//    decsp 12
-
-    ret	 12
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -28,8 +28,7 @@
     isum t1, v1, v2
     isetv r:0, t1
 
-//    decsp 16
-    ret	16
+    ret
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -21,8 +21,7 @@
    pushiv 1
    lcall imprima
 
-//   decsp 4
-   ret 4
+   ret
 endproc
    
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -5,7 +5,6 @@
 proc main
 //    var v string
 
-//    salloc v
     pcall ajusta
     popsv v
 
@@ -24,8 +23,7 @@
 
     salloc __result
     sset __result, "Hello !!!"
-//    decsp 5
-    sret 5, __result
+    sret __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-14 13:38:43 UTC (rev 430)
@@ -3,7 +3,6 @@
 proc main
     var v string
 
-//    salloc v
     pcall ajusta
     popsv v
 
@@ -22,8 +21,7 @@
 
     salloc __result
     sset __result, "Hello !!!"
-//    decsp 4
-    sret 5,__result
+    sret __result
 endproc
 
 endprogram

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-13 20:58:27 UTC (rev 429)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-14 13:38:43 UTC (rev 430)
@@ -1158,9 +1158,9 @@
    trace ("popdv opcode");
 
    int varAddress  = _code.fetchInt();
-   int sizeAddress = _code.fetchInt();
+   int size        = _code.fetchInt();
 
-   _dataStack.setBytes(varAddress, _dataStack.popBytes(_dataStack.getInt(sizeAddress)));
+   _dataStack.setBytes(varAddress, _dataStack.popBytes(size));
 }
 
 void CRunBytecode::popmvOpcode()
@@ -1320,9 +1320,9 @@
    trace ("pushdv opcode");
 
    int varAddress  = _code.fetchInt();
-   int sizeAddress = _code.fetchInt();
+   int size        = _code.fetchInt();
 
-   _dataStack.pushBytes(_dataStack.getBytes(varAddress, _dataStack.getInt(sizeAddress)));
+   _dataStack.pushBytes(_dataStack.getBytes(varAddress, size));
 }
 
 void CRunBytecode::pushmvOpcode()
@@ -1473,7 +1473,8 @@
 {
    trace ("ret opcode");
 
-   int raSize  = _dataStack.getInt(_code.fetchInt());
+//   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int raSize  = _code.fetchInt();
 
    _dataStack.decSP(raSize);
 
@@ -1484,7 +1485,8 @@
 {
    trace ("iret opcode");
 
-   int raSize  = _dataStack.getInt(_code.fetchInt());
+//   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int raSize  = _code.fetchInt();
    int result = _dataStack.getInt(_code.fetchInt());
 
    _dataStack.decSP(raSize);
@@ -1504,7 +1506,8 @@
 {
    trace ("sret opcode");
 
-   int raSize  = _dataStack.getInt(_code.fetchInt());
+//   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int raSize  = _code.fetchInt();
    int address = _code.fetchInt();
 
    std::string *value = new std::string(); // TODO: quando eh desalocado ?
@@ -1533,7 +1536,8 @@
 {
    trace ("mret opcode");
 
-   int raSize  = _dataStack.getInt(_code.fetchInt());
+//   int raSize  = _dataStack.getInt(_code.fetchInt());
+   int raSize  = _code.fetchInt();
    SMatrix1TypeHeader *matrix = (SMatrix1TypeHeader*) _dataStack.getInt(_code.fetchInt());
 
    int size = sizeof(SMatrix1TypeHeader) + matrix->_elements[0]*matrix->_elementSize;

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Dec 14 17:32:31 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 14 Dec 2007 17:32:31 +0100
Subject: [gpt-commit] r431 - trunk/gpt2/gptc/src
Message-ID: <200712141632.lBEGWV58023469@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-14 17:32:31 +0100 (Fri, 14 Dec 2007)
New Revision: 431

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
Log:
-"Type::promotion" renomeado para "Type::attrPromotion"
-Adicionado "Type::asmName"

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-14 13:38:43 UTC (rev 430)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-14 16:32:31 UTC (rev 431)
@@ -30,7 +30,7 @@
 
   const_iterator it;
   for (it = begin(); it != end(); ++it) {
-    if (!(*it).second->isError() && !from->promotion((*it).second)) {
+    if (!(*it).second->isError() && !from->attrPromotion((*it).second)) {
       return (*it).second;
     }
   }
@@ -42,7 +42,7 @@
   Type *ret = from;
   for (it = begin(); it != end(); ++it) {
     if (!(*it).second->isError()) {
-      ret = ret->promotion((*it).second);
+      ret = ret->attrPromotion((*it).second);
     }
   }
   return ret;

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-12-14 13:38:43 UTC (rev 430)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-12-14 16:32:31 UTC (rev 431)
@@ -16,16 +16,16 @@
 // Type::StructField::operator==(const Type::StructField& other) const {
 //   return _name == other._name && _type->equals(other._type);
 // }
-// 
+//
 // Type* Type::StructField::type() const {
 //   return _type;
 // }
-// 
+//
 // const std::string& Type::StructField::name() const {
 //   return _name;
 // }
-// 
-// 
+//
+//
 // bool
 // Type::StructFieldList::isLValueFor(const Type::StructFieldList& other) const {
 //   if (size() != other.size()) {
@@ -46,7 +46,7 @@
 //   }
 //   return true;
 // }
-// 
+//
 // bool
 // Type::StructFieldList::operator==(const Type::StructFieldList& other) const {
 //   if (size() != other.size()) {
@@ -67,8 +67,8 @@
 //   }
 //   return true;
 // }
-// 
-// 
+//
+//
 // Type::StructFieldList::const_iterator
 // Type::StructFieldList::find(const std::string& name) const {
 //   const_iterator it;
@@ -79,7 +79,7 @@
 //   }
 //   return end();
 // }
-// 
+//
 // std::string Type::StructFieldList::toString() const {
 //   std::string ret = "{";
 //   std::string v = "";
@@ -118,12 +118,12 @@
   if (isMatrix() && _ofType->isError()) {
     return true;
   }
-  
+
   if (isStruct() && _fields.typeList().hasErrorType()) {
     return true;
   }
 
-  if (isSubprogram() && 
+  if (isSubprogram() &&
      (_returnType->isError() || _paramTypes.hasErrorType())) {
     return true;
   }
@@ -150,6 +150,33 @@
   return _name;
 }
 
+std::string Type::asmName() const {
+  switch (_typeId) {
+    case PRIMITIVE:
+      switch (_id) {
+        case T_INTEIRO:
+          return "int";
+        case T_REAL:
+          return "real";
+        case T_LITERAL:
+          return "string";
+        case T_CARACTERE:
+          return "char";
+        case T_LOGICO:
+          return "bool";
+        case T_CORINGA:
+          return "pointer";
+      }
+      throw;
+    case MATRIX:
+      return "matrix";
+    case STRUCT:
+      return "data";
+    default:
+      throw;
+  }
+}
+
 const std::string& Type::identifier() const {
   return _identifier;
 }
@@ -165,14 +192,14 @@
 
 /************* VIRTUAL *********************************/
 
-Type* Type::promotion(Type* other) {
+Type* Type::attrPromotion(Type* other) {
   switch (_typeId) {
     case PRIMITIVE:
-      return primitive_promotion(other);
+      return primitive_attrPromotion(other);
     case MATRIX:
-      return matrix_promotion(other);
+      return matrix_attrPromotion(other);
     case STRUCT:
-      return struct_promotion(other);
+      return struct_attrPromotion(other);
     case SUBPROGRAM:
       return NULL;
     default:
@@ -274,7 +301,7 @@
   return NULL;
 }
 
-Type* Type::primitive_promotion(Type* other) {
+Type* Type::primitive_attrPromotion(Type* other) {
   if (!other->isPrimitive()) {
     return NULL;
   }
@@ -365,12 +392,12 @@
   }
 }
 
-Type* Type::matrix_promotion(Type* other) {
+Type* Type::matrix_attrPromotion(Type* other) {
   if (!other->isMatrix()) {
     return NULL;
   }
 
-  Type *ofProm = _ofType->promotion(other->_ofType);
+  Type *ofProm = _ofType->attrPromotion(other->_ofType);
   if (!ofProm) {
     return NULL;
   } else {
@@ -379,7 +406,7 @@
 }
 
 bool Type::matrix_equals(const Type* other) const {
-  return other->isMatrix() && 
+  return other->isMatrix() &&
          equals(other->_ofType, other->_dimensions.size());
 }
 
@@ -421,7 +448,7 @@
 
 Type::Type(TypeBuilder* builder, const SymbolList& fields)
   : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name("<an?nimo>"), _anonymous(true), _fields(fields), 
+    _name("<an?nimo>"), _anonymous(true), _fields(fields),
     _unit("<interno>"), _line(-1) {
 
   _name += ":{";
@@ -437,7 +464,7 @@
   return _fields;
 }
 
-Type* Type::struct_promotion(Type* other) {
+Type* Type::struct_attrPromotion(Type* other) {
   if (!other->isStruct()) {
     return NULL;
   }
@@ -453,7 +480,7 @@
     if (otherFieldIt == other->fields().end()) { //structs diferentes
       return NULL;
     } else {
-      promoType = (*it).type()->promotion((*otherFieldIt).type());
+      promoType = (*it).type()->attrPromotion((*otherFieldIt).type());
       if (!promoType) {
         return NULL;
       } else {
@@ -676,7 +703,7 @@
   return ret;
 }
 
-Type* TypeBuilder::matrixType(Type* ofType, 
+Type* TypeBuilder::matrixType(Type* ofType,
                               const std::list<int>& dimensions) {
   Type* ret = new Type(this, ofType, dimensions);
   _types.push_back(ret);
@@ -713,24 +740,24 @@
     valor : coringa;
   fim-estrutura
 
-  procedimento p( ... args) 
+  procedimento p( ... args)
 
   -> args : matriz[] do tipo Par?metro
 */
 Type* TypeBuilder::reticencesType() {
   SymbolList fields;
 
-  fields.push_back(Symbol("tipo", 
+  fields.push_back(Symbol("tipo",
     primitiveType(PortugolTokenTypes::T_LITERAL)));
 
-  fields.push_back(Symbol("valor", 
+  fields.push_back(Symbol("valor",
     primitiveType(PortugolTokenTypes::T_CORINGA)));
 
   return matrixType(
     structType("Par?metro", fields, "<interno>",-1), std::list<int>(1));
 }
 
-Type* 
+Type*
 TypeBuilder::subprogramType(const TypeList& paramTypes, Type* returnType) {
   Type* ret = new Type(this, paramTypes, returnType);
   _types.push_back(ret);

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-12-14 13:38:43 UTC (rev 430)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-12-14 16:32:31 UTC (rev 431)
@@ -22,7 +22,7 @@
 
   bool isLValueFor(const TypeList&) const;
   bool equals(const TypeList&) const;
-  
+
   bool hasErrorType() const;
 
   std::string toString() const;
@@ -36,32 +36,6 @@
 public:
   enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM, ERROR };
 
-//   class StructField {
-//   public:
-//     StructField(const std::string& n, Type* t);
-// 
-//     bool isLValueFor(const StructField& other) const;
-// 
-//     bool operator==(const StructField& other) const;
-// 
-//     Type *type() const;
-//     const std::string& name() const;
-//   private:
-//     std::string _name;
-//     Type* _type;
-//   };
-// 
-//   class StructFieldList : public std::list<StructField> {
-//   public:
-// //     bool compatible(const StructFieldList& other) const;
-//     bool isLValueFor(const StructFieldList& other) const;
-//     bool operator==(const StructFieldList& other) const;
-// 
-//     const_iterator find(const std::string&) const;
-//     std::string toString() const;
-//   };
-
-
   //Error type
   Type(TypeBuilder*);
 
@@ -82,7 +56,7 @@
 
   //Struct
   Type(TypeBuilder*,
-       const std::string& name, 
+       const std::string& name,
        const SymbolList& fields,
        const std::string& unit, int line);
 
@@ -97,8 +71,8 @@
   const TypeList& paramTypes() const;
   Type* returnType() const;
 //   bool  paramMatches(const TypeList&) const;
-  
 
+
   /* General Methods */
   void setConst(bool);
   void setRef(bool);
@@ -112,6 +86,7 @@
   bool isSubprogram() const;
 
   const std::string& name() const;
+  std::string asmName() const;
   const std::string& identifier() const;
 
   bool equals(int id) const;
@@ -120,23 +95,23 @@
 
 
   //virtual
-  Type* promotion(Type*);
+  Type* attrPromotion(Type*);
   bool  equals(const Type* other) const;
   bool  isLValueFor(Type* rtype);
 
 
   //impl primitive
-  Type* primitive_promotion(Type* other);
+  Type* primitive_attrPromotion(Type* other);
   bool  primitive_equals(const Type* other) const;
   bool  primitive_isLValueFor(Type* rvalue);
 
   //impl matrix
-  Type* matrix_promotion(Type* other);
+  Type* matrix_attrPromotion(Type* other);
   bool matrix_equals(const Type* other) const;
   bool matrix_isLValueFor(Type* rvalue);
 
   //impl struct
-  Type* struct_promotion(Type* other);
+  Type* struct_attrPromotion(Type* other);
   bool struct_equals(const Type* other) const;
   bool struct_isLValueFor(Type* rtype);
 
@@ -187,7 +162,7 @@
 
   Type* reticencesType();
 
-  Type* subprogramType(const TypeList& paramTypes, Type* returnType);  
+  Type* subprogramType(const TypeList& paramTypes, Type* returnType);
 
   Type* errorType();
 



From gpt-commit-noreply at mail.berlios.de  Fri Dec 14 17:34:00 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 14 Dec 2007 17:34:00 +0100
Subject: [gpt-commit] r432 - trunk/gpt2/gptc/src
Message-ID: <200712141634.lBEGY0cI023582@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-14 17:33:58 +0100 (Fri, 14 Dec 2007)
New Revision: 432

Added:
   trunk/gpt2/gptc/src/Arguments.cpp
   trunk/gpt2/gptc/src/Arguments.hpp
   trunk/gpt2/gptc/src/AsmProgram.cpp
   trunk/gpt2/gptc/src/AsmProgram.hpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/Context.cpp
   trunk/gpt2/gptc/src/Context.hpp
   trunk/gpt2/gptc/src/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/Makefile.in
   trunk/gpt2/gptc/src/Options.hpp
   trunk/gpt2/gptc/src/Subroutine.cpp
   trunk/gpt2/gptc/src/Subroutine.hpp
   trunk/gpt2/gptc/src/TextFile.cpp
   trunk/gpt2/gptc/src/TextFile.hpp
   trunk/gpt2/gptc/src/Tools.cpp
   trunk/gpt2/gptc/src/Tools.hpp
   trunk/gpt2/gptc/src/gptasm.g
Modified:
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptc/src/main.cpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Adicionando classes para a geracao de gptasembly

Added: trunk/gpt2/gptc/src/Arguments.cpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Arguments.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,32 @@
+#include "Arguments.hpp"
+
+#include "Tools.hpp"
+
+
+Arguments::Arguments( )
+{
+}
+
+void Arguments::init( Subroutine* subroutine, const string &subroutineName )
+{
+	clear();
+	_subroutine     = subroutine;
+	_subroutineName = subroutineName;
+}
+
+void Arguments::emitMnsInSubroutineCall( )
+{
+	iterator argument;
+
+	bool varArgs = _subroutineName == "imprima";
+
+	// se for "imprima" empilha o nro de argumentos e o tipo de cada um
+	// por enquanto imprima eh um caso especial, mas nas proximas versoes isso seria corrigido...
+	for( argument = end() - 1; argument >= begin(); argument-- ) {
+		_subroutine->emitPUSHMn( *argument, varArgs );
+
+	}
+	if (varArgs) {
+		_subroutine->emitMn( "push", itoa( size( ) ) );
+	}
+}

Added: trunk/gpt2/gptc/src/Arguments.hpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Arguments.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,24 @@
+#ifndef ARGUMENTS_H
+#define ARGUMENTS_H
+
+#include <vector>
+using namespace std;
+
+#include "Subroutine.hpp"
+
+class Arguments : public vector<string> // usar list :-)
+{
+public:
+	Arguments( );
+	void init( Subroutine* subroutine, const string &subroutineName );
+	void emitMnsInSubroutineCall( );
+	void setSubroutineName( const string &_name ) {
+		_subroutineName = _name;
+	}
+private:
+	string _subroutineName;
+	Subroutine *_subroutine;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/AsmProgram.cpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,84 @@
+#include "AsmProgram.hpp"
+
+#include "Tools.hpp"
+
+
+AsmProgram::AsmProgram(Options *options)
+	: _options(options), _context(NULL)
+{
+}
+
+void AsmProgram::init()
+{
+	_asmPrg.writeln("// Programa " + _options->filename + ".gasm gerado a partir de " + _options->filename + ".gpt");
+	_asmPrg.writeln("program " + _options->filename);
+	_asmPrg.writeln();
+}
+
+void AsmProgram::finish()
+{
+	_asmPrg.writeln("end-program");
+}
+
+AsmProgram::~AsmProgram()
+{
+}
+
+Subroutine *AsmProgram::initSubroutine(string name)
+{
+	Subroutine *action = new Subroutine(_options, /*_file,*/ name);
+	action->init();
+
+	return action;
+}
+
+
+void AsmProgram::finishSubroutine(Subroutine *action)
+{
+	action->finish();
+	_asmPrg.write(action->getCode());
+	delete action;
+}
+
+
+/*CContext *AsmProgram::addContext()
+{
+	CContext* context = new CContext();
+	_contexts.push(context);
+	_context = context;
+
+	return context;
+}
+
+
+CContext *AsmProgram::remContext()
+{
+	delete _contexts.top();
+	_contexts.pop();
+	if (_contexts.size() > 0) {
+		_context = _contexts.top();
+		return _contexts.top();
+	} else {
+		_context = NULL;
+		return NULL;
+	}
+}
+
+
+CContext *AsmProgram::getContext()
+{
+	return _context;
+}
+*/
+
+void AsmProgram::emitVarDefinition(const string &name, const string &type)
+{
+	_asmPrg.writeln("var " + name + " " + type);
+}
+
+
+string AsmProgram::getAsm() const
+{
+	return _asmPrg.getText();
+}
+

Added: trunk/gpt2/gptc/src/AsmProgram.hpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,33 @@
+#ifndef ASM_PROGRAM_H
+#define ASM_PROGRAM_H
+
+#include "Context.hpp"
+#include "Options.hpp"
+
+#include <string>
+#include <stack>
+using namespace std;
+
+class AsmProgram
+{
+public:
+	AsmProgram(Options *options);
+	~AsmProgram();
+	void init();
+	void finish();
+	Subroutine *initSubroutine(string name);
+	void finishSubroutine(Subroutine *subroutine);
+	Context *addContext();
+	Context *remContext();
+	Context *getContext();
+	void emitVarDefinition(const string &name, const string& type);
+	string getAsm() const;
+private:
+	Options *_options;
+	Context *_context;
+	stack<Context*> _contexts;
+	TextFile _asmPrg;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,75 @@
+#include "BaseGptAsmWalker.hpp"
+
+#include "SymbolTable.hpp"
+#include "Symbol.hpp"
+#include "AsmProgram.hpp"
+#include "Types.hpp"
+
+BaseGptAsmWalker::BaseGptAsmWalker(SymbolTable* symtable,
+                                   const std::string& filepath)
+  : antlr::TreeParser(), _symtable(symtable), _filepath(filepath) {
+
+  _symtable->setGlobalScope();
+
+  _options.filename = _filepath;
+  //options.sourcefile = filename + ".gpt";
+  //options.destfile   = filename + ".gasm";
+  _asmPrg = new AsmProgram(&_options);
+}
+
+
+void BaseGptAsmWalker::finishParser() {
+  delete _asmPrg;
+  _asmPrg = NULL;
+}
+
+void BaseGptAsmWalker::declareProgramVars(const std::list<string>& ids) {
+  for (std::list<string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
+    _asmPrg->emitVarDefinition(
+      *it, _symtable->getSymbol(*it).type()->asmName());
+  }
+}
+
+void BaseGptAsmWalker::declareSubroutineVars(const std::list<string>& ids) {
+  for (std::list<string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
+    _subroutine->emitVarDefinition(
+      *it, _symtable->getSymbol(*it).type()->asmName());
+  }  
+}
+
+void BaseGptAsmWalker::declareParameter(const string& lexeme) {
+  _subroutine->emitParDefinition(
+    lexeme, _symtable->getSymbol(lexeme).type()->asmName());
+}
+
+int BaseGptAsmWalker::getSymbolType(const string& lexeme) {
+  return _symtable->getSymbol(lexeme).type()->primitiveType();
+}
+
+std::string BaseGptAsmWalker::expandOffset(const std::string&, const std::list<std::string>&) {
+}
+
+void BaseGptAsmWalker::expr_MAIS(GptAsmExpression&, const GptAsmExpression&, const GptAsmExpression&) {
+}
+
+
+
+
+
+
+//      string getAsmProgram( ) const
+//      {
+//         return asmPrg->getAsm( );
+//      }
+
+// void BaseGptAsmWalker::declareGlobals(const IDList& ids) {
+//   for (IDList::const_iterator it = ids.begin(); it != ids.end(); ++it) {
+//     _globalarea << "var " << (*it) << " " << getAsmType(*it) << std::endl;
+//   }
+// }
+// 
+// std::string BaseGptAsmWalker::getAsmType(const std::string& id) {
+//   return _symtable->getSymbol(
+//       id, _symtable->currentScope()).type()->asmName();
+// }
+

Added: trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,43 @@
+#ifndef BASEGPTASMWALKER_HPP
+#define BASEGPTASMWALKER_HPP
+
+#include <antlr/TreeParser.hpp>
+#include <string>
+#include <list>
+
+#include "Options.hpp"
+#include "AsmProgram.hpp"
+
+class SymbolTable;
+class AsmProgram;
+class Subroutine;
+class GptAsmExpression;
+
+class BaseGptAsmWalker : public antlr::TreeParser {
+public:
+  BaseGptAsmWalker(SymbolTable*, const std::string&);
+protected:
+  void finishParser();
+  void declareProgramVars(const std::list<std::string>&);
+  void declareSubroutineVars(const std::list<std::string>&);
+  void declareParameter(const string&);
+  int getSymbolType(const string&);
+
+  std::string expandOffset(const std::string&, const std::list<std::string>&);
+  void expr_MAIS(GptAsmExpression&, const GptAsmExpression&, const GptAsmExpression&);
+
+//   void declareGlobals(const IDList&);
+//   void addPrologue(code);
+//   void initStructMembers(const string&, const IDList&, code);
+
+//   std::string getAsmType(const std::string&);
+
+  SymbolTable                 *_symtable;
+  std::string                  _filepath;
+
+  Options         _options;
+  AsmProgram      *_asmPrg;
+  Subroutine      *_subroutine;
+};
+
+#endif

Added: trunk/gpt2/gptc/src/Context.cpp
===================================================================
--- trunk/gpt2/gptc/src/Context.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Context.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,35 @@
+#include "Context.hpp"
+
+Context::Context( ) : _arity(0), lastStoredVar(NULL)//, lastInvocationType(IT_QU)
+{
+}
+
+
+Context::~Context( )
+{
+}
+
+
+void Context::addArg( const char *name, const int &type, const string &indexVar )
+{
+	//arguments.push_back( new CArgument( name, type, indexVar ) );
+}
+
+
+void Context::initArity( const int &value )
+{
+	_arity = value;
+}
+
+
+void Context::addArity( )
+{
+	_arity++;
+}
+
+
+int Context::getArity( )
+{
+	return _arity;
+}
+

Added: trunk/gpt2/gptc/src/Context.hpp
===================================================================
--- trunk/gpt2/gptc/src/Context.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Context.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,32 @@
+#ifndef CONTEXT_H
+#define CONTEXT_H
+
+#include <string>
+using namespace std;
+
+#include "Arguments.hpp"
+
+class Context
+{
+private:
+	int _arity;
+public:
+	Context( );
+	~Context( );
+	void addArg( const char *name, const int &type = 0, const string &indexVar = "" );
+	void initArity( const int &value = 0 );
+	void addArity( );
+	int getArity( );
+
+	char *lastStoredVar;
+	string label1;
+	string label2;
+	string tempVar1;
+	string tempVar2;
+//	CArguments arguments;
+//	int lastInvocationType;
+//	int blackboardType;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/GptAsmExpression.hpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,110 @@
+#ifndef GPTASMEXPRESSION_HPP
+#define GPTASMEXPRESSION_HPP
+
+#include "PortugolTokenTypes.hpp"
+#include "Types.hpp"
+
+#include <sstream>
+#include <string>
+
+class GptAsmExpression {
+public:
+
+  void set(Type* type,
+           int mm,
+           GptAsmExpression* op1,
+           GptAsmExpression* op2) {
+
+    _mm   = mm;
+    _op1  = op1;
+    _op2  = op2;
+    _type = type;
+  }
+
+  void set(const std::string& value, Type* type) {
+    _value = value;
+    _type = type;
+  }
+
+
+  void expand(const std::string lvalue, /*const GptAsmSubprogram& ctx*/ int ctx) {
+    //TODO: check for type promotion
+
+    if (isAtom()) {
+      return;
+    }
+
+    std::stringstream code;
+
+    if (_op1->isAtom() && _op2->isAtom()) {
+      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->type(), ctx);
+      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->type(), ctx);
+//       ctx.emit(_mm, lvalue, cp1, cp2);
+
+    } else if (_op1->isAtom()) {
+      std::string t2/* = ctx.declareTmp(_op2->type())*/;
+
+      _op2->expand(t2, ctx);
+
+      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->type(), ctx);
+      std::string cp2 = expandCast(lvalue, t2, _op2->type(), ctx);
+
+//       ctx.emit(_mm, lvalue, cp1, cp2);
+
+    } else if (_op2->isAtom()) {
+      std::string t1/* = ctx.declareTmp(_op1->type())*/;
+
+      _op1->expand(t1, ctx);
+
+      std::string cp1 = expandCast(lvalue, t1, _op1->type(), ctx);
+      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->type(), ctx);
+
+//       ctx.emit(_mm, lvalue, cp1, cp2);
+
+    } else {
+
+      std::string t1/* = ctx.declareTmp(_op1->type())*/;
+      std::string t2/* = ctx.declareTmp(_op2->type())*/;
+
+      _op1->expand(t1, ctx);
+      _op2->expand(t2, ctx);
+
+      std::string cp1 = expandCast(lvalue, t1, _op1->type(), ctx);
+      std::string cp2 = expandCast(lvalue, t2, _op2->type(), ctx);
+
+//       ctx.emit(_mm, lvalue, cp1, cp2);
+    }
+  }
+
+  bool isAtom() {
+    return _value.length() > 0;
+  }
+
+  const std::string& value() { return _value; }
+  Type*              type()  { return _type; }
+private:
+
+  std::string expandCast(const std::string &lvalue,
+                         const std::string& opval,
+                         Type *optype,
+                         /*const GptAsmSubprogram& */ int ctx) {
+    if (optype->equals(PortugolTokenTypes::T_CORINGA)) {
+      return opval;
+    }
+
+    if (_type->equals(optype)) {
+      return opval;
+    } else {
+//       ctx.emit(opcodeCast(optype, _type), lvalue, opval);
+      return lvalue;
+    }
+  }
+
+  Type              *_type;
+  int               _mm;
+  std::string       _value;
+  GptAsmExpression  *_op1;
+  GptAsmExpression  *_op2;
+};
+
+#endif

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-14 16:33:58 UTC (rev 432)
@@ -9,7 +9,7 @@
 gptc_LDADD = libgptc.la $(ANTLR_LIB)
 
 
-EXTRA_DIST = lexer.g parser.g semantic.g code.g
+EXTRA_DIST = lexer.g parser.g semantic.g gptasm.g
 
 
 BUILT_SOURCES = PortugolLexer.hpp \
@@ -18,14 +18,16 @@
                 PortugolParser.cpp \
                 SemanticWalker.hpp \
                 SemanticWalker.cpp \
-								CodeWalker.hpp \
-								CodeWalker.cpp \
+								GptAsmWalker.hpp \
+								GptAsmWalker.cpp \
                 TokenNames.hpp \
                 TokenLabels.hpp
 
 
 libgptc_la_SOURCES =  BaseSemanticWalker.hpp \
 											BaseSemanticWalker.cpp \
+											BaseGptAsmWalker.hpp \
+											BaseGptAsmWalker.cpp \
 											CompilerError.hpp \
 											CompilerError.cpp \
 											MismatchedUnicodeCharException.hpp \
@@ -42,6 +44,15 @@
 											Types.cpp \
 											UnicodeCharBuffer.hpp \
 											UnicodeCharScanner.hpp \
+											GptAsmExpression.hpp \
+											Arguments.hpp \
+											Arguments.cpp \
+											AsmProgram.hpp AsmProgram.cpp \
+										  Context.hpp Context.cpp \
+										  Options.hpp \
+											Subroutine.hpp Subroutine.cpp \
+											TextFile.hpp TextFile.cpp \
+										  Tools.hpp Tools.cpp \
 											$(BUILT_SOURCES)
 
 
@@ -57,8 +68,10 @@
              SemanticWalker.cpp \
              SemanticWalkerTokenTypes.hpp \
              SemanticWalkerTokenTypes.txt \
-             CodeWalkerTokenTypes.hpp \
-             CodeWalkerTokenTypes.txt \
+             GptAsmWalkerTokenTypes.hpp \
+             GptAsmWalker.cpp \
+						 GptAsmWalker.hpp  \
+             GptAsmWalkerTokenTypes.txt \
              TokenNames.hpp \
              TokenLabels.hpp
 
@@ -71,8 +84,8 @@
 SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
 	$(ANTLR_BIN) $(srcdir)/semantic.g
 
-CodeWalker.hpp CodeWalker.cpp: $(srcdir)/code.g Makefile
-	$(ANTLR_BIN) $(srcdir)/code.g
+GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
+	$(ANTLR_BIN) $(srcdir)/gptasm.g
 
 TokenNames.hpp: Makefile
 	@echo "#ifndef TOKENNAMES_H" > $@

Added: trunk/gpt2/gptc/src/Makefile.in
===================================================================
--- trunk/gpt2/gptc/src/Makefile.in	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Makefile.in	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,611 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+bin_PROGRAMS = gptc$(EXEEXT)
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libgptc_la_LIBADD =
+am__objects_1 = PortugolLexer.lo PortugolParser.lo SemanticWalker.lo \
+	GptAsmWalker.lo
+am_libgptc_la_OBJECTS = BaseSemanticWalker.lo BaseGptAsmWalker.lo \
+	CompilerError.lo MismatchedUnicodeCharException.lo \
+	PortugolAST.lo Symbol.lo SymbolTable.lo \
+	SymbolTableExceptions.lo Types.lo Arguments.lo AsmProgram.lo \
+	Context.lo Subroutine.lo TextFile.lo Tools.lo $(am__objects_1)
+libgptc_la_OBJECTS = $(am_libgptc_la_OBJECTS)
+am__installdirs = "$(DESTDIR)$(bindir)"
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(bin_PROGRAMS)
+am_gptc_OBJECTS = main.$(OBJEXT)
+gptc_OBJECTS = $(am_gptc_OBJECTS)
+am__DEPENDENCIES_1 =
+gptc_DEPENDENCIES = libgptc.la $(am__DEPENDENCIES_1)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --tag=CXX --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libgptc_la_SOURCES) $(gptc_SOURCES)
+DIST_SOURCES = $(libgptc_la_SOURCES) $(gptc_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+ANTLR_BIN = @ANTLR_BIN@
+ANTLR_CFG = @ANTLR_CFG@
+ANTLR_INC = @ANTLR_INC@
+ANTLR_LIB = @ANTLR_LIB@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
+noinst_LTLIBRARIES = libgptc.la
+gptc_SOURCES = main.cpp
+gptc_LDADD = libgptc.la $(ANTLR_LIB)
+EXTRA_DIST = lexer.g parser.g semantic.g gptasm.g
+BUILT_SOURCES = PortugolLexer.hpp \
+                PortugolLexer.cpp \
+                PortugolParser.hpp \
+                PortugolParser.cpp \
+                SemanticWalker.hpp \
+                SemanticWalker.cpp \
+								GptAsmWalker.hpp \
+								GptAsmWalker.cpp \
+                TokenNames.hpp \
+                TokenLabels.hpp
+
+libgptc_la_SOURCES = BaseSemanticWalker.hpp \
+											BaseSemanticWalker.cpp \
+											BaseGptAsmWalker.hpp \
+											BaseGptAsmWalker.cpp \
+											CompilerError.hpp \
+											CompilerError.cpp \
+											MismatchedUnicodeCharException.hpp \
+											MismatchedUnicodeCharException.cpp \
+											PortugolAST.hpp \
+											PortugolAST.cpp \
+											Symbol.hpp \
+											Symbol.cpp \
+											SymbolTable.hpp \
+											SymbolTable.cpp \
+											SymbolTableExceptions.hpp \
+											SymbolTableExceptions.cpp \
+											Types.hpp \
+											Types.cpp \
+											UnicodeCharBuffer.hpp \
+											UnicodeCharScanner.hpp \
+											GptAsmExpression.hpp \
+											Arguments.hpp \
+											Arguments.cpp \
+											AsmProgram.hpp AsmProgram.cpp \
+										  Context.hpp Context.cpp \
+										  Options.hpp \
+											Subroutine.hpp Subroutine.cpp \
+											TextFile.hpp TextFile.cpp \
+										  Tools.hpp Tools.cpp \
+											$(BUILT_SOURCES)
+
+CLEANFILES = PortugolLexer.cpp \
+             PortugolLexer.hpp \
+             PortugolTokenTypes.hpp \
+             PortugolTokenTypes.txt \
+             PortugolParser.cpp \
+						 PortugolParser.hpp  \
+             PortugolParserTokenTypes.hpp \
+             PortugolParserTokenTypes.txt \
+             SemanticWalker.hpp \
+             SemanticWalker.cpp \
+             SemanticWalkerTokenTypes.hpp \
+             SemanticWalkerTokenTypes.txt \
+             GptAsmWalkerTokenTypes.hpp \
+             GptAsmWalker.cpp \
+						 GptAsmWalker.hpp  \
+             GptAsmWalkerTokenTypes.txt \
+             TokenNames.hpp \
+             TokenLabels.hpp
+
+all: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libgptc.la: $(libgptc_la_OBJECTS) $(libgptc_la_DEPENDENCIES) 
+	$(CXXLINK)  $(libgptc_la_LDFLAGS) $(libgptc_la_OBJECTS) $(libgptc_la_LIBADD) $(LIBS)
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
+	done
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+gptc$(EXEEXT): $(gptc_OBJECTS) $(gptc_DEPENDENCIES) 
+	@rm -f gptc$(EXEEXT)
+	$(CXXLINK) $(gptc_LDFLAGS) $(gptc_OBJECTS) $(gptc_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Arguments.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/AsmProgram.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/BaseGptAsmWalker.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/BaseSemanticWalker.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/CompilerError.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Context.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/GptAsmWalker.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MismatchedUnicodeCharException.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolAST.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolLexer.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolParser.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SemanticWalker.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Subroutine.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Symbol.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SymbolTable.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SymbolTableExceptions.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/TextFile.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Tools.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Types.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/main.Po at am__quote@
+
+.cpp.o:
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+ at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cpp.lo:
+ at am__fastdepCXX_TRUE@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+ at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-am
+all-am: Makefile $(LTLIBRARIES) $(PROGRAMS)
+installdirs:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic clean-libtool clean-noinstLTLIBRARIES ctags \
+	distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-binPROGRAMS \
+	uninstall-info-am
+
+
+PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
+	$(ANTLR_BIN) $(srcdir)/lexer.g
+
+PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile
+	$(ANTLR_BIN) $(srcdir)/parser.g
+
+SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
+	$(ANTLR_BIN) $(srcdir)/semantic.g
+
+GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
+	$(ANTLR_BIN) $(srcdir)/gptasm.g
+
+TokenNames.hpp: Makefile
+	@echo "#ifndef TOKENNAMES_H" > $@
+	@echo "#define TOKENNAMES_H"  >> $@
+	@echo "static char* g_tokenNames[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep = PortugolTokenTypes.txt >> $@
+	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo -n "static int g_tokenNamesSize = " >> $@
+	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
+	@echo "#endif" >> $@
+
+TokenLabels.hpp: Makefile
+	@echo "#ifndef TOKENLABELS_H" > $@
+	@echo "#define TOKENLABELS_H"  >> $@
+	@echo "static char* g_tokenLabels[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep '"' PortugolTokenTypes.txt >> $@
+	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo "static int g_tokenLabelsSize = " >> $@
+	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
+	@echo "#endif" >> $@
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/gpt2/gptc/src/Options.hpp
===================================================================
--- trunk/gpt2/gptc/src/Options.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Options.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,21 @@
+#ifndef OPTIONS
+#define OPTIONS
+
+#include <string>
+using namespace std;
+
+class Options {
+public:
+	Options( ) {
+		sentences = false;
+		sourceLine = NULL;
+	}
+	string filename;
+//	string sourcefile;
+//	string destfile;
+	bool sentences;
+	int *sourceLine;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/Subroutine.cpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,171 @@
+#include "Subroutine.hpp"
+
+#include <iostream>
+using namespace std;
+
+#include "Tools.hpp"
+
+#include "PortugolParserTokenTypes.hpp"
+
+
+Subroutine::Subroutine(Options *options, /*CGptAssemblyFile *file,*/ const string &name)
+	: _options(options), _name(name), _lastSourceLine(0)
+{
+	if (_options->sentences) {
+		//_sourceInfo = new SourceInfo();
+		//_sourceInfo->setFileName(_options->sourcefile);
+	}
+	_body.incTab();
+}
+
+
+Subroutine::~Subroutine()
+{
+	//if (_sourceInfo) {
+	//	delete _sourceInfo;
+	//}
+}
+
+
+void Subroutine::init()
+{
+	_header.writeln(string("// Procedure ") + _name);
+	_header.writeln("proc " + _name);
+	_header.incTab();
+//	_body.incTab();
+}
+
+
+void Subroutine::finish()
+{
+	if (_name == "main") {
+		_body.writeln("exit_0");
+	}
+//	_body->decTab();
+	_footer.writeln("end-proc");
+
+	_footer.writeln("// Fim da procedure");
+	_footer.writeln();
+}
+
+
+void Subroutine::emitPUSHMn(const string &symbol, const bool &pushType)
+{
+//    SymbolType symbolType = _symbolTable->getSymbol(getName(), symbol, true).getType();
+// 
+//    _body.writeln(string("push ")   + symbol);
+// 
+//    if (pushType) {
+//       _body.writeln(string("push_") + symbolType.toAsmType());
+//    }
+}
+
+
+void Subroutine::emitMn(const string &mn, const string &op1, const string &op2, const string &op3)
+{
+	_body.write(mn);
+	if (op1.empty()) {
+		_body.writeln();
+		return;
+	}
+
+	_body.write(" " + op1);
+	if (op2.empty()) {
+		_body.writeln();
+		return;
+	}
+
+	_body.write(", " + op2);
+	if (op3.empty()) {
+		_body.writeln();
+		return;
+	}
+
+	_body.writeln(", " + op3);
+}
+
+void Subroutine::emitMnWithPrefix(const string &mn, const string &var, const string &op1, const string &op2)
+{
+	emitMn(getMnWithPrefix(mn, var), var, op1, op2);
+}
+
+
+void Subroutine::emitLabel(const string &label)
+{
+	_body.writeln(label + string(":"));
+}
+
+
+void Subroutine::emitAsmCode(const string &code)
+{
+	_body.writeln();
+	_body.writeln("// asm-begin");
+	_body.writeln(code);
+	_body.writeln("// asm-end");
+	_body.writeln();
+}
+
+
+/*
+void Subroutine::write(string value)
+{
+//	if (_sourceInfo && *_options->sourceLine > _lastSourceLine) {
+//		string line = _sourceInfo->getLine(*_options->sourceLine);
+//		line = alltrim(wo_ctrl_chrs(line, ' '));
+//		_file->write(
+//				string("// LINE ") + string(itoa(*_options->sourceLine)) + string(" --> ") + line
+//				);
+//		_lastSourceLine = *_options->sourceLine;
+//	}
+
+	_body.write(value);
+}
+
+void Subroutine::writeln(string value)
+{
+//	if (_sourceInfo && *_options->sourceLine > _lastSourceLine) {
+//		string line = _sourceInfo->getLine(*_options->sourceLine);
+//		line = alltrim(wo_ctrl_chrs(line, ' '));
+//		_file->writeln(
+//				string("// LINE ") + string(itoa(*_options->sourceLine)) + string(" --> ") + line
+//				);
+//		_lastSourceLine = *_options->sourceLine;
+//	}
+
+	_body.writeln(value);
+}
+*/
+
+void Subroutine::emitVarDefinition(const string &name, const string &type)
+{
+	_header.writeln("var " + name + " " + type);
+}
+
+
+void Subroutine::emitParDefinition(const string &name, const string &type)
+{
+	_header.writeln("par " + name + " " + type);
+}
+
+
+string Subroutine::getCode() const
+{
+	return _header.getText() + _body.getText() + _footer.getText();
+}
+
+
+string Subroutine::getMnWithPrefix(const string &mn, const string &var) // TODO: serviria para simbolos tb ???
+{
+// 	int primitiveType = _symbolTable->getSymbol (getName(), var, true).getType().getPrimitiveType();
+
+// 	switch(primitiveType) {
+// 		case PortugolParserTokenTypes::T_KW_INTEIRO:    return "i" + mn;
+// 		case PortugolParserTokenTypes::T_KW_REAL:       return "r" + mn;
+// 		case PortugolParserTokenTypes::T_KW_CARACTERE:  return "i" + mn;
+// 		case PortugolParserTokenTypes::T_KW_LITERAL:    return "s" + mn;
+// 		case PortugolParserTokenTypes::T_KW_LOGICO:     return "i" + mn;
+// 		case PortugolParserTokenTypes::T_KW_MATRIZ:     return "m" + mn;
+// 		default:                                        return "undefined_" + mn;
+// 	}
+}
+

Added: trunk/gpt2/gptc/src/Subroutine.hpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,54 @@
+#ifndef SUBROUTINE_H
+#define SUBROUTINE_H
+
+#include <string>
+#include <vector>
+
+#include "Options.hpp"
+
+#include <antlr/LLkParser.hpp>
+#include "PortugolParserTokenTypes.hpp"
+
+#include "TextFile.hpp"
+
+using namespace std;
+
+
+class Subroutine
+{
+public:
+	Subroutine(Options *options, const string &name);
+	~Subroutine();
+	void init();
+	void finish();
+	void emitPUSHMn(const string &symbol, const bool &pushType = false);
+	void emitMn(const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
+	void emitMnWithPrefix(const string &mn, const string &var, const string &op1 = "", const string &op2 = "");
+
+	void emitLabel(const string &label);
+
+	void emitAsmCode(const string &code);
+
+//	void write(string value);
+//	void writeln(string value = "");
+
+	const string& getName() const
+	{
+		return _name;
+	}
+	void emitVarDefinition(const string &name, const string &type);
+	void emitParDefinition(const string &name, const string &type);
+	string getCode() const;
+private:
+	string getMnWithPrefix(const string &mn, const string &var);
+	Options *_options;
+	vector<string> _params;
+	int _lastSourceLine;
+	string _name;
+	TextFile _header;
+	TextFile _body;
+	TextFile _footer;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/TextFile.cpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/TextFile.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,71 @@
+#include "TextFile.hpp"
+
+
+TextFile::TextFile( const string &chrTab )
+	: _chrTab( chrTab ), _emitTab( true )
+{
+}
+
+
+TextFile::~TextFile( )
+{
+}
+
+
+void TextFile::writeln( const string &message )
+{
+	if ( _emitTab ) {
+		_txt << _tabs;
+	}
+	_txt << message << endl;
+	_emitTab = true;
+}
+
+
+void TextFile::writeln( )
+{
+	_txt << endl;
+	_emitTab = true;
+}
+
+
+void TextFile::write( const string &message )
+{
+	if ( _emitTab ) {
+		_txt << _tabs;
+	}
+	_txt << message;
+	_emitTab = false;
+}
+
+
+void TextFile::incTab( )
+{
+    _tabs += _chrTab;
+}
+
+
+void TextFile::decTab( )
+{
+    _tabs.erase( _tabs.length( ) - _chrTab.length( ), _chrTab.length( ) );
+}
+
+
+string TextFile::getText( ) const
+{
+	return _txt.str( );
+}
+
+
+bool TextFile::writeToFile( const string &filename )
+{
+	ofstream *_file;
+	_file = new ofstream( filename.c_str( ) );
+	if (_file) {
+		(*_file) << _txt;
+		delete _file;
+		return true;
+	}
+	return false;
+}
+

Added: trunk/gpt2/gptc/src/TextFile.hpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/TextFile.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,30 @@
+#ifndef GPT_TEXT_FILE_H
+#define GPT_TEXT_FILE_H
+
+#include <string>
+#include <fstream>
+#include <sstream>
+
+using namespace std;
+
+class TextFile
+{
+public:
+	TextFile( const string &chrTab = "\t" );
+	~TextFile( );
+	void writeln( const string &message );
+	void writeln( );
+	void write( const string &message );
+	void incTab( );
+	void decTab( );
+	string getText( ) const;
+	bool writeToFile( const string &filename );
+private:
+	string _chrTab;
+	string _tabs;
+	bool _emitTab;
+	stringstream _txt;
+};
+
+#endif
+

Added: trunk/gpt2/gptc/src/Tools.cpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Tools.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,299 @@
+/*
+ * $Id: Tools.cpp,v 1.1.1.1 2005/08/15 15:19:52 asgarzao Exp $
+ * MyLibrary version 0.1.0
+ * Copyright (C) 2002 Alex Sandro Garz? <alexgarzao at bol.com.br>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include "PortugolParserTokenTypes.hpp"
+
+#include "Tools.hpp"
+
+
+int hexToInt(const char* _value) {
+    int result = 0;
+    char *position;
+    char conversionTable[] = "0123456789ABCDEF";
+
+    while (*_value) {
+        position = strchr(conversionTable, *_value);
+        if (position == NULL)
+            return 0;
+
+        result <<= 4;
+        result = result | (position - conversionTable);
+        _value++;
+    }
+
+    return result;
+}
+
+string pad(string _text, unsigned int _size) {
+    if (_size > _text.length())
+        _text.append(_size - _text.length(), ' ');
+
+    return _text;
+}
+
+string lpad(string _text, unsigned int _size) {
+    if (_size > _text.length())
+        _text = string(_size - _text.length(), ' ') + _text;
+
+    return _text;
+}
+
+string intToHex(unsigned int _value, int _size) {
+    string codHex = "0123456789ABCDEF";
+    string result;
+    int nible;
+
+    while (_value > 0) {
+        nible = _value & 0xF;
+        _value >>= 4;
+        result = codHex[nible] + result;
+    }
+
+    if ( _size == -1 )
+        _size = 1;
+
+    return strZero(result, _size);
+    // if (_size == -1)
+    //     return( result );
+    // else
+    //     return( strZero( result, _size ) );
+    //
+}
+
+string strZero(string _value, unsigned int _size) {
+    while (_value.length() < _size) {
+        _value = '0' + _value;
+    }
+
+    return _value;
+}
+
+string strZero(int _value, unsigned int _size) {
+    string result = itoa(_value);
+
+    while (result.length() < _size) {
+        result = '0' + result;
+    }
+
+    return result;
+}
+
+string dataToHex(char _code[], unsigned int _length) {
+    string result;
+    unsigned int count;
+
+    for (count = 0; count < _length; count++)
+        result += intToHex(_code[count], 2);
+
+    return result;
+}
+
+string dataToHex(char _code[], unsigned int _start, unsigned int _length) {
+    string result;
+    unsigned int count;
+
+    for (count = _start; count - _start < _length; count++)
+        result += intToHex(_code[count], 2);
+
+    return result;
+}
+
+int binToInt(const char* _binValue) {
+    int intValue = 0;
+    int length = strlen(_binValue) - 1;
+    int countBit;
+
+    for (countBit = length; countBit >= 0; countBit--) {
+        if (_binValue[countBit] == '1')
+            intValue += int(pow(2.0, length - countBit));
+    }
+
+    return intValue;
+}
+
+string itoa(int _number) {
+    stringstream s;
+
+    s << _number;
+    return s.str();
+}
+
+string ftos(double _value) {
+    stringstream s;
+
+    s <<  setiosflags(ios::fixed) << _value;
+    
+    return s.str();
+}
+
+string itobool(int _number) {
+    if (_number == 0)
+        return "false";
+    else
+        return "true";
+}
+
+string strtoupper(string str) {
+    unsigned int count;
+
+    for (count = 0; count < str.size(); count++)
+        str[count] = toupper(str[count]);
+
+    return str;
+}
+
+string strToUpperWithEscapeControls(string str) {
+    unsigned int count;
+
+    for (count = 0; count < str.size(); count++) {
+        if (str[count] == '\\')
+            count += 2;
+        else
+            str[count] = toupper(str[count]);
+    }
+
+    return str;
+}
+
+string alltrim(string str) {
+    // crap version...  :-)
+    // precisamos usar `find', `rfind'! --felipek
+    while (str[0] == ' ')
+        str.erase(0, 1);
+
+    while (str[str.length() - 1] == ' ')
+        str.erase(str.length() - 1, 1);
+
+    return str;
+}
+
+string wo_ctrl_chrs(string str, char chr_to_put) {
+    unsigned int chr_number;
+
+    for (chr_number = 0; chr_number < str.size(); chr_number++) {
+        if (str[chr_number] < 32)
+            str[chr_number] = chr_to_put;
+    }
+
+    return str;
+}
+
+/* CRAP!  --felipek
+string& getStringWithTab(string _data, string _tab) {
+	cout << "begin getStringWithTab" << endl;
+	cout << "tab=\"" << _tab << "\"" << endl;
+	cout << "begin datae" << endl;
+	cout << _data << endl;
+	cout << "end datae" << endl;
+	int pos = -1;
+ 
+	// test too another new line sequences
+	while( ( pos = _data.find( "\n", pos + 1 ) ) != -1 ) {
+		_data.insert( pos + 1, _tab );
+	}
+ 
+	cout << "begin datas" << endl;
+	cout << _data << endl;
+	cout << "end datas" << endl;
+	return( _data );
+}
+*/
+
+bool streamtoken(istringstream& stream, string& key, string& val) {
+     /* FIXME: leak, --felipek */
+     char buffer[8192];
+     unsigned int delim;
+     string entry;
+//     bool ret;
+
+     /* FIXME: ret type, -- felipek */
+     stream.getline(buffer, 8192 - 1);
+     entry = string(buffer);
+     delim = entry.find(' ', 0);
+
+     if (delim != entry.npos) {
+         key = entry.substr(0, delim);
+         val = entry.substr(delim + 1);
+     }
+
+     return !stream.eof();
+}
+
+
+const string typeToText(const int &type)
+{
+//    if (type == PortugolParserTokenTypes::T_INT_LIT) {
+//       return "int";
+//    } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
+//       return "char";
+//    } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
+//       return "string";
+//    } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
+//       return "real";
+//    } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
+//       return "id";
+//    }
+// 
+//    return "ERRO !!!";
+}
+
+const string typeInAsm( const int &type )
+{
+//    if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
+//       return "int";
+//    } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
+//       return "string";
+//    } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
+//       return "char";
+//    } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
+//       return "bool";
+//    } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
+//       return "real";
+//    } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
+//       return "pointer ???";
+//    } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
+//       return "matrix";
+//    }
+
+   return "ERRO !!!";
+}
+
+
+const int typeToLiteral( const int &type )
+{
+//    switch (type) {
+//       case PortugolParserTokenTypes::T_KW_INTEIRO:
+//          return PortugolParserTokenTypes::T_INT_LIT;
+//       case PortugolParserTokenTypes::T_KW_LITERAL:
+//          return PortugolParserTokenTypes::T_STRING_LIT;
+//       case PortugolParserTokenTypes::T_KW_CARACTERE:
+//          return PortugolParserTokenTypes::T_CARAC_LIT;
+//       case PortugolParserTokenTypes::T_KW_LOGICO:
+//          return PortugolParserTokenTypes::T_INT_LIT;
+// //      case PortugolParserTokenTypes::T_KW_CORINGA:
+// //         return "pointer ???";
+// //      case PortugolParserTokenTypes::T_KW_MATRIZ:
+// //          return PortugolParserTokenTypes::T_MATRIZ;
+//       default:
+//           return 0;
+//           // trow exception ???
+//    }
+}
+


Property changes on: trunk/gpt2/gptc/src/Tools.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptc/src/Tools.hpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.hpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/Tools.hpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,39 @@
+#ifndef GPT_TOOLS_H
+#define GPT_TOOLS_H
+
+#include <iomanip>
+
+#include <iostream>
+#include <string>
+#include <cstdlib>
+#include <cstring>
+#include <cmath>
+#include <cstdio>
+#include <sstream>
+using namespace std;
+
+
+int hexToInt(const char *);
+string pad(string, unsigned int);
+string lpad(string, unsigned int);
+string intToHex(unsigned int, int = -1);
+string strZero(string, unsigned int);
+string strZero(int, unsigned int);
+string dataToHex(char *, unsigned int);
+string dataToHex( char *, unsigned int, unsigned int);
+int binToInt(const char *);
+int octToInt(const char *);
+string itoa(int);
+string itobool(int);
+string ftos(double);
+string strtoupper(string);
+string strToUpperWithEscapeControls(string);
+string alltrim(string);
+string wo_ctrl_chrs(string str, char = ' ');
+bool streamtoken(istringstream&, string&, string&);
+// string& getStringWithTab(string, string);
+const string typeToText(const int &type);
+const string typeInAsm( const int &type );
+const int typeToLiteral( const int &type );
+
+#endif


Property changes on: trunk/gpt2/gptc/src/Tools.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptc/src/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm.g	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/gptasm.g	2007-12-14 16:33:58 UTC (rev 432)
@@ -0,0 +1,270 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+header {
+  #include "BaseGptAsmWalker.hpp"
+  #include "PortugolAST.hpp"
+  #include "GptAsmExpression.hpp"
+}
+
+options {
+  language="Cpp";
+}
+
+class GptAsmWalker extends TreeParser("BaseGptAsmWalker");
+options {
+  importVocab    = Portugol;
+  noConstructors = true;
+  genHashLines   = false;
+  ASTLabelType   = "RefPortugolAST";
+}
+
+{
+public:
+  GptAsmWalker::GptAsmWalker(SymbolTable* symtable,
+                             const std::string& filepath)
+	 : BaseGptAsmWalker(symtable, filepath) {}
+}
+
+
+programa
+  : #(T_ALGORITMO                {_asmPrg->init();}
+
+        (importacao)*
+
+        (declaracoes)?
+
+//         (corpo)?
+
+        EOF
+     )
+  ;
+
+importacao
+  : #(T_USE T_TEXTO_LITERAL)
+  ;
+
+declaracoes
+  : declaracao_variavel[false]    (declaracoes)?
+  | declaracao_constante[false]   (declaracoes)?
+  | declaracao_estrutura          (declaracoes)?
+  ;
+
+declaracao_variavel[bool isLocal]
+
+                                          {std::list<std::string> ids;}
+
+  : #(T_VARIAVEL tipo ids=identificadores
+                                          {
+                                            if (isLocal) {
+                                              declareProgramVars(ids);
+                                            } else {
+                                              declareSubroutineVars(ids);
+                                            }
+                                          }
+//       (
+//         code=valor_inicialiacao            {addPrologue(code);}
+//       )?
+    )
+  ;
+
+declaracao_constante[bool isLocal]
+                                          {std::list<std::string> ids;}
+
+  : #(T_CONSTANTE tipo ids=identificadores /*code=valor_inicialiacao*/)
+
+                                          {
+                                            if (isLocal) {
+                                              declareProgramVars(ids);
+                                            } else {
+                                              declareSubroutineVars(ids);
+                                            }
+                                          }
+  ;
+
+identificadores returns [std::list<std::string> ids]
+  : (id:T_IDENTIFICADOR {ids.push_back(id->getText());})+
+  ;
+
+tipo
+  : T_IDENTIFICADOR
+  | T_MATRIZ
+  | T_INTEIRO
+  | T_REAL
+  | T_CARACTERE
+  | T_LITERAL
+  | T_LOGICO
+  | T_CORINGA
+  ;
+
+declaracao_estrutura
+  : #(T_ESTRUTURA T_IDENTIFICADOR (campo_estrutura)+)
+  ;
+
+campo_estrutura
+                      {std::list<std::string> ids;}
+
+  : #(T_VARIAVEL tipo ids=identificadores
+//       (
+//         valor_inicialiacao
+//       )?
+    )
+  ;
+
+
+
+
+/////////////////////////////////////////////////////////////
+
+
+
+
+/************************** EXPRESSOES *************************/
+
+
+expressao [const std::string& lvalue]
+
+                                      {GptAsmExpression ret;}
+  : #(T_EXPRESSAO ret=expr)
+                                      {ret.expand(lvalue,1/*_subroutine*/);}
+  ;
+
+expr returns [GptAsmExpression ret]
+
+                        {GptAsmExpression l, r;}
+
+//   : #(T_OU              l=expr r=expr) {expr_OU(ret, l, r);}
+//   | #(T_E               l=expr r=expr) {expr_E(ret, l, r);}
+//   | #(T_BIT_OU          l=expr r=expr) {expr_BIT_OU(ret, l, r);}
+//   | #(T_BIT_OUX         l=expr r=expr) {expr_BIT_XOU(ret, l, r);}
+//   | #(T_BIT_E           l=expr r=expr) {expr_BIT_E(ret, l, r);}
+//   | #(T_IGUAL           l=expr r=expr) {expr_IGUAL(ret, l, r);}
+//   | #(T_DIFERENTE       l=expr r=expr) {expr_DIFERENTE(ret, l, r);}
+//   | #(T_MAIOR           l=expr r=expr) {expr_MAIOR(ret, l, r);}
+//   | #(T_MENOR           l=expr r=expr) {expr_MENOR(ret, l, r);}
+//   | #(T_MAIOR_EQ        l=expr r=expr) {expr_MAIOR_EQ(ret, l, r);}
+//   | #(T_MENOR_EQ        l=expr r=expr) {expr_MENOR_EQ(ret, l, r);}
+//   | #(T_BIT_SHIFT_LEFT  l=expr r=expr) {expr_BIT_SHIFT_LEFT(ret, l, r);}
+//   | #(T_BIT_SHIFT_RIGHT l=expr r=expr) {expr_BIT_SHIFT_RIGHT(ret, l, r);}
+  : #(T_MAIS            l=expr r=expr) {expr_MAIS(ret, l, r);}
+//   | #(T_MENOS           l=expr r=expr) {expr_MENOS(ret, l, r);}
+//   | #(T_DIV             l=expr r=expr) {expr_DIV(ret, l, r);}
+//   | #(T_MULTIP          l=expr r=expr) {expr_MULTIP(ret, l, r);}
+//   | #(T_MOD             l=expr r=expr) {expr_MOD(ret, l, r);}
+//   | #(T_UN_NEGATIVO     l=elemento)  {expr_UN_NEGATIVO(ret,l);}
+//   | #(T_UN_POSITIVO     l=elemento)  {expr_UN_POSITIVO(ret,l);}
+//   | #(T_NAO             l=elemento)  {expr_UN_NAO(ret,l);}
+//   | #(T_BIT_NAO         l=elemento)  {expr_BIT_NAO(ret,l);}
+  | ret=elemento
+  ;
+
+
+elemento returns [GptAsmExpression ret]
+                      {std::string r;}
+  : ret=literal
+  | r=lvalue
+//   | ret=chamada_subrotina
+  | expressao[r]
+  ;
+
+literal returns [GptAsmExpression ret]
+
+  : l:T_TEXTO_LITERAL          {/*ret.set(l->getText());*/}
+  | i:T_INTEIRO_LITERAL        {/*ret.set(i->getText());*/}
+  | r:T_REAL_LITERAL           {/*ret.set(r->getText());*/}
+  | c:T_CARACTERE_LITERAL      {/*ret.set(c->getText());*/}
+  | v:T_VERDADEIRO             {/*ret.set(v->getText());*/}
+  | f:T_FALSO                  {/*ret.set(f->getText());*/}
+  ;
+
+
+lvalue returns [std::string lv]
+
+                                      {std::string offset;}
+
+  : #(id:T_IDENTIFICADOR              {lv = id->getText();}
+      (offset=lvalue_indices[lv]      {lv += ":" + offset;})?
+//       (lvalue_membro)?
+    )
+                
+  ;
+
+
+lvalue_indices[const std::string id] returns [std::string ret]
+                                {
+                                  std::list<std::string> dimensions;
+                                  std:string tmp;
+                                }
+  : #(T_SUBSCRITO
+        (
+                                {/*tmp = _subroutine->newTmp();*/}
+          expressao[tmp]
+                                {dimensions.push_back(tmp);}
+        )+
+    )
+                                {ret = expandOffset(id, dimensions);}
+  ;
+
+
+// lvalue_membro
+//   : #(T_MEMBRO lvalue)
+//   ;
+
+
+
+
+
+
+
+
+// corpo
+//   :  corpo_subprograma      (corpo)?
+//   |  bloco_codigo           (corpo_subprograma)*
+//   ;
+// 
+// 
+// bloco_codigo
+//   : #(T_INICIO lista_enunciados)
+//   ;
+// 
+// lista_enunciados
+//   : (enunciado)*
+//   ;
+// 
+// enunciado
+//   : en_atribuicao
+// /*  | en_retorne
+//   | en_se
+//   | en_enquanto
+//   | en_repita
+//   | en_para
+//   | en_caso
+//   | T_SAIR
+//   | chamada_subrotina*/
+//   ;
+// 
+// en_atribuicao
+//                       {std::string lv;}
+//   : #(T_ATRIBUICAO
+//         lv=lvalue      //x / x:offset
+//         expressao[lv]
+//       )
+//   ;
+

Modified: trunk/gpt2/gptc/src/main.cpp
===================================================================
--- trunk/gpt2/gptc/src/main.cpp	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/main.cpp	2007-12-14 16:33:58 UTC (rev 432)
@@ -4,10 +4,11 @@
 #include <antlr/TokenBuffer.hpp>
 #include <antlr/CommonAST.hpp>
 
+#include "PortugolTokenTypes.hpp"
 #include "PortugolLexer.hpp"
 #include "PortugolParser.hpp"
 #include "SemanticWalker.hpp"
-#include "PortugolTokenTypes.hpp"
+#include "GptAsmWalker.hpp"
 #include "SymbolTable.hpp"
 
 #include "TokenNames.hpp"
@@ -79,8 +80,26 @@
   std::cerr << ast->toStringList() << std::endl << std::endl;
 }
 
+void all(char* fname) {
+  RefPortugolAST ast;
+
+  ast = dump_tree(fname, true);
+
+  SymbolTable* symtable = new SymbolTable(fname);
+
+  SemanticWalker semantic(symtable, fname);
+  semantic.programa(ast);
+
+  GptAsmWalker code(symtable, fname);
+  code.programa(ast);
+}
+
 int main(int argc, char** argv) {
 
+  if (argc == 2) {
+    all(argv[1]);
+  }
+
   if (argc < 3) {
     std::cerr << "./test [lps] <file.gpt>" << std::endl;
     return 0;

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-14 16:32:31 UTC (rev 431)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-14 16:33:58 UTC (rev 432)
@@ -39,9 +39,9 @@
 
 {
 public:
-  SemanticWalker::SemanticWalker(SymbolTable* symtable, 
+  SemanticWalker::SemanticWalker(SymbolTable* symtable,
                                  const std::string& filepath)
-	 : BaseSemanticWalker(symtable, filepath), 
+	 : BaseSemanticWalker(symtable, filepath),
     _analisingInitializationList(false) { }
 
 private:
@@ -106,7 +106,7 @@
                                 {
                                   IDList ids;
                                   Type *type;
-                                  Type *rtype;                                  
+                                  Type *rtype;
                                 }
 
   : #(T_CONSTANTE
@@ -124,7 +124,7 @@
 identificadores returns [IDList list]
   : (
       id:T_IDENTIFICADOR        {list.push_back(id);}
-    )*
+    )+
   ;
 
 tipo returns [Type *type]
@@ -166,7 +166,7 @@
   : (
       dsize=dimensao
                         {dims.push_back(dsize);}
-    )*
+    )+
   ;
 
 dimensao returns [int size]
@@ -190,7 +190,7 @@
                                 {
                                   IDList ids;
                                   Type *type;
-                                  Type *rtype;                                  
+                                  Type *rtype;
                                 }
 
   : (
@@ -381,7 +381,7 @@
                                       type->setRef(true);
                                     }
 
-                                    symbol = 
+                                    symbol =
                                         Symbol(id->getText(),
                                           type,
                                           _symtable->unit(),
@@ -655,7 +655,7 @@
   | en_repita
   | en_para
   | en_caso
-  | T_SAIR                                
+  | T_SAIR //TODO: deve estar dentro de uma itera??o
   | devnull=chamada_subrotina
   ;
 
@@ -670,7 +670,7 @@
 en_retorne
                         {Type *type;}
 
-  : #(ret:T_RETORNE type=expressao_) 
+  : #(ret:T_RETORNE type=expressao_)
 
                         {evalRetorne(ret, type);}
   ;
@@ -678,17 +678,17 @@
 en_se
                         {ExpressionReturn ex;}
 
-  : #(se:T_SE 
+  : #(se:T_SE
 
       ex=expressao    {evalCondicional(ex);}
-      lista_enunciados 
+      lista_enunciados
       (T_SENAO lista_enunciados)?
     )
   ;
 
 en_enquanto
                         {ExpressionReturn ex;}
-  : #(enq:T_ENQUANTO 
+  : #(enq:T_ENQUANTO
       ex=expressao      {evalCondicional(ex);}
       lista_enunciados
     )
@@ -696,7 +696,7 @@
 
 en_repita
                               {ExpressionReturn ex;}
-  : #(T_REPITA      
+  : #(T_REPITA
       lista_enunciados
       T_ATE ex=expressao      {evalCondicional(ex);}
     )
@@ -705,7 +705,7 @@
 en_para
                               {ExpressionReturn lv, from, to;}
 
-  : #(p:T_PARA lv=lvalue 
+  : #(p:T_PARA lv=lvalue
         from=expressao        {evalAttribution(lv, from);}
         to=expressao          {evalAttribution(lv, to);}
         (T_PASSO)?
@@ -724,7 +724,7 @@
 
                                {Type *rtype;}
 
-  : #(T_FACA 
+  : #(T_FACA
       rtype=lit:literal            {evalExpr_IGUAL(lit, ltype, rtype);}
       lista_enunciados
     )



From gpt-commit-noreply at mail.berlios.de  Mon Dec 17 19:56:56 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 17 Dec 2007 19:56:56 +0100
Subject: [gpt-commit] r433 - in trunk/gpt2: gptasm/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200712171856.lBHIuuox027892@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-17 19:56:47 +0100 (Mon, 17 Dec 2007)
New Revision: 433

Added:
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm
Modified:
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
   trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* No mnemonico lcall agora eh necessario indicar a biblioteca
* Codigo inicial para carga de libs dinamicas
* Especializando melhor a gramatica do GptASM


Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/src/parser.g	2007-12-17 18:56:47 UTC (rev 433)
@@ -241,16 +241,24 @@
 //--------------------
   mn_chamada_subrotina
 //--------------------
-   :  ("pushiv"|"pushsv"|"pushrv"|"pushmv")
+// TODO: talvez o ideal seria agrupar os opcodes por tipo de dado que manipulam. Isso deixaria o parser e o tornaria mais consistente.
+   :  "pushiv"
       {bytecode.addOpcode(getLastTokenText());}
+      intelement
+   |  "pushsv"
+      {bytecode.addOpcode(getLastTokenText());}
+      stringelement
+   |  "pushmv"
+      {bytecode.addOpcode(getLastTokenText());}
       element
+   |  "pushrv"
+      {bytecode.addOpcode(getLastTokenText());}
+      realelement
    |  "pushdv"
       {bytecode.addOpcode(getLastTokenText());}
       element
       {bytecode.addSymbolSize(getLastTokenText());}
       // TODO: muitos opcodes poderiam ter o valor inteiro diretamente ao inves de um enderecamento...
-//   |  ("pushir"|"pushsr"|"pushrr"|"pushdr"|"pushmr")
-//      {bytecode.addOpcode(getLastTokenText());}
    |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushdt"|"pushmt")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("popiv"|"popsv"|"poprv"|"popmv")
@@ -260,13 +268,8 @@
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       {bytecode.addSymbolSize(getLastTokenText());}
-//   |  ("incsp"|"decsp")
-//      {bytecode.addOpcode(getLastTokenText());}
-//      intvalue
    |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
       {bytecode.addOpcode(getLastTokenText());}
-//   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
-//      {bytecode.addOpcode(getLastTokenText());}
    |  "pcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
@@ -275,13 +278,13 @@
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
       { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
+      T_COMMA
+      T_ID
+      { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
    |  "ret"
       {bytecode.addOpcode(getLastTokenText());}
-//      intvalue
    |  ("iret"|"rret"|"sret"|"dret"|"mret")
       {bytecode.addOpcode(getLastTokenText());}
-//      intvalue
-//      T_COMMA
       identifier
    ;
 
@@ -306,18 +309,18 @@
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA
-      intvalue
+      intliteral
       T_COMMA 
-      intvalue
+      intliteral
    |  "m2alloc"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
       T_COMMA
-      intvalue
+      intliteral
       T_COMMA
-      intvalue
+      intliteral
       T_COMMA
-      intvalue
+      intliteral
    |  "mfree"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
@@ -351,7 +354,7 @@
       {bytecode.addOpcode(getLastTokenText());}
    |   "exit"
       {bytecode.addOpcode(getLastTokenText());}
-      intvalue
+      intliteral
   ;
 
 identifier
@@ -390,6 +393,29 @@
   | literal
   ;
 
-intvalue
+intliteral
   : T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+  | T_CHAR_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::CHAR);   }
+  | "true"         { bytecode.addAddress("1",                CSymbol::CONST, CSymbol::BOOL);    }
+  | "false"        { bytecode.addAddress("0",                CSymbol::CONST, CSymbol::BOOL);    }
   ;
+
+intelement
+  : identifier
+  | intliteral
+  ;
+realelement
+  : identifier
+  | realliteral
+  ;
+
+realliteral
+  : T_REAL_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::REAL); }
+  | T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::REAL); }
+  ;
+
+stringelement
+  : identifier
+  | T_STRING_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::STRING); }
+  ;
+

Added: trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -0,0 +1,15 @@
+program exemplo
+// use io
+
+proc main
+    lcall io, imprime_hello
+
+    lcall io, imprime_hello
+
+    pushsv "Oi !!!!"
+    lcall io, imprime_mensagem
+
+    exit 0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -0,0 +1,20 @@
+program exemplo
+// use io
+
+var t1 int
+
+proc main
+    pushiv 2
+    pushiv 4
+    lcall io, soma
+    popiv t1
+
+    pushiv t1
+    pushit
+    push_1
+    lcall io, imprima
+
+    exit 0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -0,0 +1,20 @@
+program exemplo
+// use io
+
+var t1 real
+
+proc main
+    pushrv 3
+    pushrv 9
+    lcall io, pow
+    poprv t1
+
+    pushrv t1
+    pushrt
+    push_1
+    lcall io, imprima
+
+    exit 0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -0,0 +1,19 @@
+program exemplo
+// use io
+
+var t1 real
+
+proc main
+    pushrv 9
+    lcall io, sqrt
+    poprv t1
+
+    pushrv t1
+    pushrt
+    push_1
+    lcall io, imprima
+
+    exit 0
+endproc
+
+endprogram

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -18,7 +18,7 @@
     pushsv "c.x="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     // imprima( "c.y=", c.y );
     igetv t1, c:4 // t1 := *(c + 4)
@@ -27,7 +27,7 @@
     pushsv "c.y="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -27,7 +27,7 @@
     pushsv "est.x="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     // imprima( "est.y=", est.y );
     igetv t1, est:4 // t1 := *(est + 4)
@@ -36,7 +36,7 @@
     pushsv "est.y="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     ret
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -28,7 +28,7 @@
     pushsv "est.x="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     // imprima( "est.y=", est.y );
     igetv t2, est:8 // t2 := *(est + 8)
@@ -37,7 +37,7 @@
     pushsv "est.y="
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     ret
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -27,7 +27,7 @@
     pushiv x
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -15,7 +15,7 @@
     pushiv x
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc x, 1

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -12,7 +12,7 @@
     pushsv "2+5*3="
     pushst
     pushiv 2
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -12,7 +12,7 @@
     pushsv "A soma ?: "
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -7,11 +7,11 @@
     pushsv "Digite o n?mero para calcular o fatorial:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // x := leia( );
     pushit
-    lcall leia
+    lcall io, leia
     popiv x
 
     // imprima( "Fatorial de ", x, " ? ", fatorial( x ) );
@@ -25,7 +25,7 @@
     pushsv "Fatorial de "
     pushst
     push_4
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -4,7 +4,7 @@
     pushsv "Ol? mundo !!!"
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -7,10 +7,10 @@
     pushsv "Digite um n?mero: "
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
     // x := leia( );
     pushit
-    lcall leia
+    lcall io, leia
     popiv x
     // imprima( "O n?mero digitado foi ", x );
     pushiv x
@@ -18,7 +18,7 @@
     pushsv "O n?mero digitado foi "
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -29,7 +29,7 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // para i de 0 at? 9 fa?a
     iset i, 0
@@ -42,7 +42,7 @@
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc i, 1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -42,7 +42,7 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // para i de 0 at? 9 fa?a
     iset i, 0
@@ -55,7 +55,7 @@
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc i, 1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -51,7 +51,7 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // para i de 0 at? 9 fa?a
     iset i, 0
@@ -64,7 +64,7 @@
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc i, 1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -16,19 +16,19 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     m2get t1, m, 0, 0
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     m2get t1, m, 0, 1
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // desaloca espa?o da matriz m
     mfree m

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -44,7 +44,7 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // para i de 0 at? 3 fa?a
     iset i, 0
@@ -63,7 +63,7 @@
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc j, 1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -29,7 +29,7 @@
     pushsv "Valores armazenados:"
     pushst
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // para i de 0 at? 4 fa?a
     iset i, 0
@@ -42,7 +42,7 @@
     pushiv t1
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 
     // fim-para
     iinc i, 1

Modified: trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/matrizes_4_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -19,7 +19,7 @@
     pushsv "Tamanho de m1 deve ser 100: "
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     mgetsize1 t1, m2
     pushiv t1
@@ -27,7 +27,7 @@
     pushsv "Tamanho de m2 deve ser 1000: "
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     mgetsize2 t1, m3
     pushiv t1
@@ -38,7 +38,7 @@
     pushsv "Tamanho de m3 deve ser 10 e 20: "
     pushst
     push_3
-    lcall imprima
+    lcall io, imprima
 
     mgetsize2 t1, m4
     pushiv t1
@@ -49,7 +49,7 @@
     pushsv "Tamanho de m4 deve ser 15 e 25: "
     pushst
     push_3
-    lcall imprima
+    lcall io, imprima
 
     mfree m1
     mfree m2

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -25,7 +25,7 @@
     pushsv "A soma ?: "
     pushst
     push_2
-    lcall imprima
+    lcall io, imprima
 
     ret
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -13,7 +13,7 @@
     pushiv s
     pushit
     push_1
-    lcall imprima
+    lcall io, imprima
 	
     exit_0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -6,7 +6,7 @@
    pushsv "Finalizando..."
    pushst
    pushiv 1
-   lcall imprima
+   lcall io, imprima
 
    exit 0
 endproc
@@ -19,7 +19,7 @@
    pushiv temp
    pushit
    pushiv 1
-   lcall imprima
+   lcall io, imprima
 
    ret
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -21,7 +21,7 @@
     pushsv "x*y+4="
     pushst
     pushiv 2
-    lcall imprima
+    lcall io, imprima
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -13,12 +13,12 @@
     pushiv v
     pushit
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     pushiv 10
     pushit
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -13,12 +13,12 @@
     pushrv v
     pushrt
     push_1
-    lcall imprima
+    lcall io, imprima
 
     pushrv 10.8
     pushrt
     push_1
-    lcall imprima
+    lcall io, imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -9,42 +9,42 @@
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     sset v, v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, "12", "34"
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, v, v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, v, "10"
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, "10", v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     pushsv "10"
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     sfree v
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_1.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -9,42 +9,42 @@
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     sset v, v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, "12", "34"
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, v, v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, v, "10"
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     ssum v, "10", v
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     pushsv "10"
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 	
     sfree v
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_2.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -11,7 +11,7 @@
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     sfree v
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4_3.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -9,7 +9,7 @@
     pushsv v
     pushst
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     sfree v
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -13,12 +13,12 @@
     pushiv v
     pushct
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     pushiv 'a'
     pushct
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-12-17 18:56:47 UTC (rev 433)
@@ -10,17 +10,17 @@
     pushiv true
     pushbt
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     pushiv false
     pushbt
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     pushiv v
     pushbt
     pushiv 1
-    lcall imprima
+    lcall io, imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-17 18:56:47 UTC (rev 433)
@@ -209,6 +209,14 @@
 }
 
 
+std::string CDataStack::popString()
+{
+   int dataSize = sizeof(char)+sizeof(std::string*);
+   std::string result = getString(size()-dataSize);
+   CBinString::popBytes(dataSize);
+   return result;
+}
+
 void CDataStack::pushBytes(const int &number)
 {
    CBinString::pushBytes(number);

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-17 18:56:47 UTC (rev 433)
@@ -31,6 +31,7 @@
    int getSP() const;
    void readString(std::string &value);
    std::string getString(int address);
+   std::string popString();
    void setString(int address, const std::string &value);
    void setByte(const int &address, const char &value);
    char getByte(const int &address);

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-17 18:56:47 UTC (rev 433)
@@ -2,6 +2,7 @@
 
 #include <sstream>
 #include <iostream>
+#include <dlfcn.h>
 
 #include "Tools.hpp"
 
@@ -386,6 +387,37 @@
 }
 
 
+void CRunBytecode::callSyslib(const std::string &libname, const std::string &procname)
+{
+   std::map<std::string, void*>::iterator ithandler;
+   void *dlhandler = NULL;
+
+   ithandler = syslibHandlerList.find(libname);
+
+   if (ithandler == syslibHandlerList.end()) {
+      // TODO: path absoluto ??? nem pensar :-)
+      dlhandler = dlopen(("../../../syslib/src/lib" + libname + ".so").c_str(), RTLD_LAZY);
+      if (!dlhandler) {
+         fprintf (stderr, "%s\n", dlerror());
+         exit(1);
+      }
+      dlerror();    /* Clear any existing error */
+      syslibHandlerList[libname] = dlhandler;
+   } else {
+      dlhandler = ithandler->second;
+   }
+
+   void (*func)(CDataStack&);
+   func = (void (*)(CDataStack&)) dlsym(dlhandler, ("gsl_"+procname).c_str());
+   char *error;
+   if ((error = dlerror()) != NULL) {
+      fprintf (stderr, "%s\n", error);
+      exit(1);
+   }
+   (*func)(_dataStack);
+}
+
+
 /////////////
 // opcodes //
 /////////////
@@ -426,20 +458,26 @@
    _executionStack.push(_dataStack.getBS());
    _dataStack.setBS(_dataStack.getSP());
 
-   int address = _code.fetchInt();
+   std::string libname = _dataStack.getCString(_code.fetchInt()+1);
+   int procAddress = _code.fetchInt();
 
-   if (_dataStack[address] != CSymbol::CONST) {
+   if (_dataStack[procAddress] != CSymbol::CONST) {
       error( "Endereco para lcall deve conter uma string constante !!!" );
    }
 
-   address=sumAddress(address, 1);
+   procAddress=sumAddress(procAddress, 1);
 
-   if (_dataStack.getCString(address) == "imprima") {
-      procImprima();
-   } else if (_dataStack.getCString(address) == "leia") {
-      procLeia();
-   } else {
-      error("lcall invocando subrotina desconhecida !!!");
+   std::string procname = _dataStack.getCString(procAddress);
+
+   if (libname == "io") {
+      if (procname == "imprima") {
+         procImprima();
+      } else if (procname == "leia") {
+         procLeia();
+      } else {
+//         error("lcall invocando subrotina desconhecida !!!");
+         callSyslib(libname, procname);
+      }
    }
 
    _dataStack.setBS(_executionStack.top());

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-12-17 18:56:47 UTC (rev 433)
@@ -39,6 +39,7 @@
    void setStringData(const int &address, const std::string &value);
    std::string getStringData(const int &address);
    void popRA();
+   void callSyslib(const std::string &libname, const std::string &procname);
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
@@ -189,6 +190,7 @@
    int             _returnCode;
    CDataStack      _dataStack;
    std::stack<int> _executionStack;
+   std::map<std::string, void*> syslibHandlerList;
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-12-14 16:33:58 UTC (rev 432)
+++ trunk/gpt2/gptvm/src/Makefile	2007-12-17 18:56:47 UTC (rev 433)
@@ -12,7 +12,7 @@
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
           
 all: $(objects)
-	g++ -o gptvm $(objects)
+	g++ -o gptvm $(objects) -ldl
 
 %.o: %.cpp %.hpp
 	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Tue Dec 18 18:53:23 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 18 Dec 2007 18:53:23 +0100
Subject: [gpt-commit] r434 - in trunk/gpt2: . bindings bindings/gptbind
	bindings/gptbind/src bindings/gptbind/test
Message-ID: <200712181753.lBIHrNva025094@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-18 18:53:16 +0100 (Tue, 18 Dec 2007)
New Revision: 434

Added:
   trunk/gpt2/bindings/
   trunk/gpt2/bindings/gptbind/
   trunk/gpt2/bindings/gptbind/src/
   trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
   trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
   trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
   trunk/gpt2/bindings/gptbind/src/CGptBind.hpp
   trunk/gpt2/bindings/gptbind/src/Makefile
   trunk/gpt2/bindings/gptbind/src/lexer.g
   trunk/gpt2/bindings/gptbind/src/main.cpp
   trunk/gpt2/bindings/gptbind/src/parser.g
   trunk/gpt2/bindings/gptbind/test/
   trunk/gpt2/bindings/gptbind/test/test.sld
Log:
DEVNULL:
* Inicio do gerador de bindings


Added: trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,85 @@
+#include "CBindSources.hpp"
+
+
+#include <map>
+
+
+CBindSources::CBindSources(const std::string &filename, const std::string &prefix)
+      : _filename(filename)
+      , _prefix(prefix)
+{
+}
+
+
+void CBindSources::writeHeaders()
+{
+   hppSource.writeln( "#ifndef GPTBIND_" + _filename + "_HPP" );
+   hppSource.writeln( "#define GPTBIND_" + _filename + "_HPP" );
+   hppSource.writeln();
+   hppSource.writeln( "extern \"C\" {" );
+   hppSource.incTab();
+
+   cppSource.writeln( "#include \"" + _filename + ".hpp\"" );
+   cppSource.writeln();
+   cppSource.writeln( "#include \"CDataStack.hpp\"" );
+   cppSource.writeln( "#include \"CSymbol.hpp\"" );
+   cppSource.writeln();
+}
+
+
+void CBindSources::addProcedureBind(
+      const std::string &name, 
+      std::vector<std::pair<std::string, std::string> > parameters,
+      const std::string &functionBind,
+      std::vector<std::string> arguments )
+{
+   hppSource.writeln( "void " + _prefix + name + "( CDataStack &dataStack );" );
+
+   cppSource.writeln();
+   cppSource.writeln( "void " + _prefix + name + "( CDataStack &dataStack )" );
+   cppSource.writeln( "{" );
+   cppSource.incTab();
+   for(std::vector<std::pair<std::string, std::string> >::iterator param = parameters.begin(); param != parameters.end(); param++) {
+      cppSource.writeln (sourceToGetParameter (param->first, param->second));
+   }
+   cppSource.write(functionBind + "(");
+   for(std::vector<std::string>::iterator arg = arguments.begin(); arg != arguments.end(); arg++) {
+      if (arg != arguments.begin()) {
+         cppSource.write(", ");
+      }
+      if ((*arg)[0] != '"') {
+         cppSource.write("c" + *arg);
+      } else {
+         cppSource.write(*arg);
+      }
+   }
+   cppSource.writeln(");");
+   cppSource.decTab();
+   cppSource.writeln( "}" );
+}
+
+
+std::string CBindSources::sourceToGetParameter(const std::string &name, const std::string &type)
+{
+   std::string result;
+
+   std::map<std::string, std::string> mapType;
+   mapType["string"] = "const char *";
+
+   std::map<std::string, std::string> mapPop;
+   mapPop["string"] = "dataStack.popString().c_str()";
+
+   result = mapType[type] + " c" + name + "=" + mapPop[type] + ";";
+
+   return result;
+}
+
+
+void CBindSources::writeFooters()
+{
+   hppSource.decTab();
+   hppSource.writeln("}");
+   hppSource.writeln();
+   hppSource.writeln( "#endif" );
+}
+

Added: trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,43 @@
+#ifndef GPT_CBIND_SOURCES_HPP
+#define GPT_CBIND_SOURCES_HPP
+
+#include "CTextFile.hpp"
+
+#include <string>
+#include <vector>
+
+class CBindSources
+{
+public:
+   CBindSources(const std::string &filename, const std::string &prefix);
+   void writeHeaders();
+   void addProcedureBind(
+         const std::string &name, 
+         std::vector<std::pair<std::string, std::string> > parameters,
+         const std::string &functionBind,
+         std::vector<std::string> arguments
+   );
+   void writeFooters();
+   std::string getHppSource()
+   {
+      return hppSource.getText();
+   }
+   std::string getCppSource()
+   {
+      return cppSource.getText();
+   }
+   std::string getMakefileSource()
+   {
+      return makefileSource.getText();
+   }
+   std::string sourceToGetParameter(const std::string &name, const std::string &type);
+private:
+   std::string _filename;
+   std::string _prefix;
+   CTextFile hppSource;
+   CTextFile cppSource;
+   CTextFile makefileSource;
+};
+
+#endif
+

Added: trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,45 @@
+#include <fstream>
+
+
+#include "CGptBind.hpp"
+#include "GptBindLexer.hpp"
+#include "GptBindParser.hpp"
+
+
+CGptBind::CGptBind( COptions *options ) : _options( options )
+{
+}
+
+
+bool CGptBind::run( )
+{
+   ifstream in(_options->sourcefile.c_str());
+   GptBindLexer lexer(in);
+   GptBindParser parser(lexer);
+
+//   string asmProgram = parser.program(_options->sourcefile);
+   parser.sld_grammar();
+
+   string cppOutput = parser.getCpp();
+   string hppOutput = parser.getHpp();
+   string makefileOutput = parser.getMakefile();
+
+   ofstream cppFile((_options->destfile + ".cpp").c_str(), ios_base::out);
+   if (!cppFile) {
+      cout << "ERRO: n?o foi poss?vel abrir o arquivo: \"" << _options->destfile << "\"" << endl;
+      return false;
+   }
+
+   cppFile << cppOutput;
+
+   ofstream hppFile((_options->destfile + ".hpp").c_str(), ios_base::out);
+   if (!hppFile) {
+      cout << "ERRO: n?o foi poss?vel abrir o arquivo: \"" << _options->destfile << "\"" << endl;
+      return false;
+   }
+
+   hppFile << hppOutput;
+
+   return true;
+}
+

Added: trunk/gpt2/bindings/gptbind/src/CGptBind.hpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CGptBind.hpp	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/CGptBind.hpp	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,16 @@
+#ifndef GPT_CGPTBIND_H
+#define GPT_CGPTBIND_H
+
+#include "COptions.hpp"
+
+class CGptBind
+{
+public:
+   CGptBind( COptions *options );
+   bool run( );
+private:
+   COptions *_options;
+};
+
+#endif
+

Added: trunk/gpt2/bindings/gptbind/src/Makefile
===================================================================
--- trunk/gpt2/bindings/gptbind/src/Makefile	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/Makefile	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,30 @@
+COMMON_DIR=../../../common/src/
+
+INCLUDE_DIR=-I/usr/include/antlr/ -I$(COMMON_DIR)
+CC=g++
+CCFLAGS=-g -Wall
+
+objects = GptBindLexer.o GptBindParser.o main.o CGptBind.o CBindSources.o \
+          $(COMMON_DIR)/CTextFile.o
+
+all: $(objects)
+	g++ -o gptbind $(objects) /usr/local/lib/libantlr.a
+
+GptBindLexer.hpp GptBindLexer.cpp: lexer.g
+	antlr lexer.g
+
+GptBindParser.hpp GptBindParser.cpp: parser.g
+	antlr parser.g
+
+
+%.o: %.cpp %.hpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+%.o: %.cpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+
+clean:
+	rm -f *.o $(COMMON_DIR)*.o GptBindLexer.cpp GptBindLexer.hpp GptBindLexerTokenTypes.hpp \
+	GptBindLexerTokenTypes.txt GptBindParser.cpp GptBindParser.hpp gptbind \
+	GptBindParserTokenTypes.hpp GptBindParserTokenTypes.txt 

Added: trunk/gpt2/bindings/gptbind/src/lexer.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,269 @@
+header {
+   #include <string>
+   #include <sstream>
+}
+
+
+options {
+   language="Cpp";  
+}
+
+
+class GptBindLexer extends Lexer;
+
+
+options {
+   k=2;
+   charVocabulary='\0'..'\377';
+   exportVocab=GptBindLexer;
+  testLiterals = true;
+//  testLiterals = false;
+//  filter=T_INVALID;
+//  genHashLines=false;//no #line
+}
+
+
+tokens {
+   T_KW_OPTIONS="options";
+   T_KW_HEADERS="headers";
+   T_KW_PROCEDURE="procedure";
+   T_KW_FUNCTION="function";
+   T_KW_INT="int";
+   T_KW_REAL="real";
+   T_KW_CHAR="char";
+   T_KW_STRING="string";
+   T_KW_BOOL="bool";
+   T_KW_POINTER="pointer";
+   T_KW_MATRIX="matrix";
+   T_KW_DATA="data";
+   T_KW_LIBNAME="libname";
+   T_KW_FUNCTIONPREFIX="functionprefix";
+   T_KW_LINKERLIB="linkerlib";
+   T_REAL_VALUE="n?mero real"; //nondeterminism T_INT_LIT & T_REAL_LIT
+}
+
+
+{
+public:  
+
+private:
+}
+
+
+/******************* Constant literals ***********************/
+
+T_INT_VALUE
+options {
+   paraphrase = "int number";
+}
+   : ('0' ('c'|'C') )=> T_OCTAL_VALUE
+   | ('0' ('x'|'X') )=> T_HEX_VALUE
+   | ('0' ('b'|'B') )=> T_BIN_VALUE
+   | T_INTEGER_VALUE
+      (
+         '.' (T_DIGIT)+
+         {$setType(T_REAL_VALUE);}
+      )?
+   ;
+
+protected
+T_INTEGER_VALUE
+   : (T_DIGIT)+
+   ;
+
+protected
+T_OCTAL_VALUE
+   : '0' ('c'|'C')
+      {
+         //convert to base 10
+         std::string str = $getText;
+         int base10;
+         str = str.substr(2);//0c
+         base10 = strtoul(str.c_str(), NULL, 8);
+
+         std::stringstream s;
+         s << base10;        
+         std::string res = s.str();
+         $setText(res);
+      }
+   ;
+
+protected
+T_HEX_VALUE
+   : '0' ('x'|'X')
+      {
+         //convert to base 10
+         std::string str = $getText;
+         int base10;
+         base10 = strtoul(str.c_str(), NULL, 16);
+  
+         std::stringstream s;
+         s << base10;
+         std::string res = s.str();
+         $setText(res);      
+      }
+   ;
+
+protected
+T_BIN_VALUE
+   : '0' ('b'|'B')
+      {
+         //convert to base 10
+         int base10;
+         std::string str = $getText.substr(2);
+         base10 = strtoul(str.c_str(), NULL, 2);//0b
+
+         std::stringstream s;
+         s << base10;
+         std::string res = s.str();
+         $setText(res);
+      }
+   ;
+
+T_CHAR_VALUE
+options {
+   paraphrase = "char";
+}
+   : '\'' ( ~( '\'' | '\\' ) | ESC )? '\''
+   ;
+
+T_STRING_VALUE
+options {
+   paraphrase = "string";
+}
+   : '"' ( ~( '"' | '\\' | '\n' | '\r') | ESC)* '"'
+   ;
+
+protected
+ESC
+   : '\\' . //permite "\a" (possibilida ser avaliado posteriormente como "a")
+   ;
+
+
+T_COLON
+options {
+   paraphrase = "':'";
+}
+   : ':'
+   ;
+  
+T_COMMA
+options {
+   paraphrase = "','";
+}
+   : ','
+   ;
+
+T_MAPINTO
+options {
+   paraphrase = "::=";
+}
+   : "::="
+   ;
+
+T_ABREC
+options {
+  paraphrase = "'{'";
+}
+  : '{'
+  ;
+
+T_FECHAC
+options {
+  paraphrase = "'}'";
+}
+  : '}'
+  ;
+
+T_ABREP
+options {
+  paraphrase = "'('";
+}
+  : '('
+  ;
+
+T_FECHAP
+options {
+  paraphrase = "')'";
+}
+  : ')'
+  ;
+
+
+T_EQUAL
+options {
+  paraphrase = "'='";
+}
+  : '='
+  ;
+
+
+T_SEMICOLON
+options {
+  paraphrase = "';'";
+}
+  : ';'
+  ;
+
+
+T_WS_ : (' '
+   | '\t'
+   | '\n' { newline(); }
+   | '\r')
+      { $setType(antlr::Token::SKIP); }
+   ;
+
+SL_COMMENT
+   : "//" (~('\n'))* ('\n')?
+      { 
+         newline();
+         $setType(antlr::Token::SKIP);
+      }
+   ;
+
+ML_COMMENT
+{int line = getLine();}
+   : "/*" 
+      ( 
+         options { generateAmbigWarnings=false; } :  
+         '\n'                     {newline();}
+         | ('\r' '\n')=> '\r' '\n'  {newline();}
+         | '\r'                     {newline();}
+         |~('*'|'\n'|'\r')
+         | ('*' ~'/' )=> '*' 
+      )* 
+      "*/"
+      {$setType(antlr::Token::SKIP);}
+   ;
+
+exception
+catch[antlr::RecognitionException] {  
+   std::stringstream s;
+   s << "AVISO: coment?rio iniciado na linha " << line << " n?o termina com \"*/\".";
+
+   _ttype = antlr::Token::SKIP;
+}
+
+T_ID
+   : (T_LETTER | '_') (T_LETTER | T_DIGIT | '_')*
+   ;
+
+protected
+T_DIGIT
+   : '0'..'9'
+   ;
+
+protected
+T_LETTER
+   : 'a'..'z'|'A'..'Z' | '\u00C0'..'\u00FF' /* latim-1 */
+   ;
+
+
+protected
+T_INVALID
+   : . 
+      {
+         printf("INVALID %d == '%x' -> '%c'\n", $getText.c_str()[0], $getText.c_str()[0], $getText.c_str()[0]);
+      }
+   ;
+

Added: trunk/gpt2/bindings/gptbind/src/main.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/main.cpp	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/main.cpp	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,68 @@
+#include <iostream>
+#include <string>
+
+using namespace std;
+
+
+#include "COptions.hpp"
+#include "CGptBind.hpp"
+
+
+void showSyntax();
+
+
+int main (int argc, char *argv[])
+{
+   int i;
+   COptions options;
+
+   cout << "GptBind - Release 0.1.0 (GEPETO)" << endl;
+
+   while ((i = getopt(argc, argv, "h")) != -1) {
+      switch (i) {
+         case 'h':
+            showSyntax();
+            return EXIT_SUCCESS;
+            break;
+         default:
+            break;
+      }
+   }
+
+   argc -= optind;
+   argv += optind;
+
+   if (argc < 1) {
+      showSyntax();
+      return EXIT_FAILURE;
+   }
+
+   options.sourcefile = string(argv[0]) + ".sld";
+   options.destfile   = string(argv[0]) + ".gvm";
+
+   cout << "Binding " << options.sourcefile << "..." << endl;
+
+   CGptBind gptbind( &options );
+
+   if (gptbind.run()) {
+      cout << "Program " << options.sourcefile << " ok !!!" << endl << endl;
+   } else {
+      cout << "Program " << options.sourcefile << " has errors..." << endl << endl;
+      exit( EXIT_FAILURE );
+   }
+
+   return EXIT_SUCCESS;
+}
+
+
+void showSyntax() {
+   cout << endl 
+        << "Desenvolvido por XXX, YYY e ZZZ" << endl 
+        << "Dezembro, 2007" << endl 
+        << endl 
+        << "Syntax: gptbind [options] file" << endl 
+        << "Options:" << endl 
+        << "         -h help" << endl 
+        << endl;
+}
+

Added: trunk/gpt2/bindings/gptbind/src/parser.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,246 @@
+header {
+   #include <string>
+//   #include <antlr/config.hpp>
+//   #include <antlr/TokenStream.hpp>
+//   #include <antlr/TokenBuffer.hpp>
+//   #include <antlr/LLkParser.hpp>
+   #include "CSymbol.hpp"
+   #include "CBindSources.hpp"
+}
+
+options {
+  language="Cpp";  
+}
+
+{
+}
+
+class GptBindParser extends Parser;
+
+options {
+  importVocab=GptBindLexer;  // use vocab generated by lexer
+//  genHashLines=false;//no #line
+//  k=2;
+}
+
+{  
+   public:
+//      CGenBytecode bytecode;
+      void init()
+      {
+         sources = new CBindSources( "teste", "gptbind_" );
+      }
+      antlr::RefToken getLastToken()
+      {
+         return LT(0);
+      }
+      std::string getLastTokenText()
+      {
+         return LT(0)->getText();
+      }
+      std::string getCpp()
+      {
+         return sources->getCppSource();
+      }
+      std::string getHpp()
+      {
+         return sources->getHppSource();
+      }
+      std::string getMakefile()
+      {
+         return sources->getMakefileSource();
+      }
+   private:
+      CBindSources *sources;
+}
+
+
+//####################################################################
+//####################### In?cio da gram?tica ########################
+//####################################################################
+
+//###############
+//## GRAMATICA ##
+//###############
+
+//-----------
+  sld_grammar
+//-----------
+   : { init(); }
+     (optionsdef)?
+     (headersdef)?
+     {
+        sources->writeHeaders();
+     }
+     (bindingdef)*
+     {
+        sources->writeFooters();
+     }
+     EOF
+     ;
+
+//#############
+//## Options ##
+//#############
+
+//-------
+  optionsdef
+//-------
+   : "options" T_ABREC (optiondef)+ T_FECHAC
+   ;
+
+//------
+  optiondef
+//------
+   : optionname T_EQUAL T_STRING_VALUE T_SEMICOLON
+   ;
+
+///----------
+   optionname
+///----------
+   : "libname" | "functionprefix" | "linkerlib"
+   ;
+
+//#############
+//## Headers ##
+//#############
+
+//-------
+  headersdef
+//-------
+   : "headers" T_ABREC (headerdef)+ T_FECHAC
+   ;
+
+//------
+  headerdef
+//------
+   : T_STRING_VALUE T_SEMICOLON
+   ;
+
+//#############
+//## Binding ##
+//#############
+
+//-------
+  bindingdef
+//-------
+   : procedure_bind
+   | function_bind
+   ;
+
+//--------------
+  procedure_bind
+//--------------
+{
+   std::vector<std::pair<std::string, std::string> > parameters;
+   std::vector<std::string> arguments;
+//   std::vector<std::pair<std::string, int> > arguments;
+}
+   : "procedure" tk_procname:T_ID (parameters_declaration[parameters])
+     T_MAPINTO
+     tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
+     {
+        sources->addProcedureBind(tk_procname->getText(), parameters, tk_mapname->getText(), arguments);
+     }
+   ;
+
+//-------------
+  function_bind
+//-------------
+{
+   std::vector<std::pair<std::string, std::string> > parameters;
+   std::vector<std::string> arguments;
+//   std::vector<std::pair<std::string, int> > arguments;
+}
+   : "function" T_ID (parameters_declaration[parameters]) T_COLON type
+     T_MAPINTO
+     T_ID (arguments_declaration[arguments])? T_SEMICOLON
+   ;
+
+///----------------------
+   parameters_declaration[std::vector<std::pair<std::string, std::string> > &parameters]
+///----------------------
+{
+   std::string typeValue;
+}
+   : T_ABREP
+     (
+        type {typeValue = getLastTokenText();} tk_id:T_ID
+        {parameters.push_back(std::pair<std::string, std::string>(tk_id->getText(), typeValue));} 
+        (
+           T_COMMA type {typeValue = getLastTokenText();} tk_id2:T_ID
+           {parameters.push_back(std::pair<std::string, std::string>(tk_id2->getText(), typeValue));} 
+        )*
+     )?
+     T_FECHAP
+   ;
+
+///---------------------
+   arguments_declaration[std::vector<std::string> &arguments]
+///---------------------
+   : T_ABREP
+     (
+        (literal|T_ID) {arguments.push_back(getLastTokenText());}
+        (
+           T_COMMA (literal|T_ID) {arguments.push_back(getLastTokenText());}
+        )* 
+     )? 
+     T_FECHAP
+   ;
+
+/////---------------------
+//   arguments_declaration[std::vector<std::pair<std::string, int> > &arguments]
+/////---------------------
+//{
+//   std::string value;
+//}
+//   : T_ABREP
+//     (
+//        literal|T_ID {value=getLastTokenText();}
+//        (
+//           T_COMMA literal|T_ID {value=getLastTokenText();}
+//        )* 
+//     )? 
+//     T_FECHAP
+//   ;
+
+
+//-------
+  literal
+//-------
+  : ( 
+        T_STRING_VALUE
+      | T_INT_VALUE
+      | T_REAL_VALUE
+      | T_CHAR_VALUE
+      | "true"
+      | "false"
+    ) 
+  ;
+
+///----
+   type
+///----
+   : "int"
+   | "real"
+   | "char"
+   | "string"
+   | "bool"
+   | "pointer"
+   | "matrix"
+   | "data"
+   ;
+
+/////----
+//   type returns [int ret]
+/////----
+//   : "int"     { ret=CSymbol::INT; }
+//   | "real"    { ret=CSymbol::REAL; }
+//   | "char"    { ret=CSymbol::CHAR; }
+//   | "string"  { ret=CSymbol::STRING; }
+//   | "bool"    { ret=CSymbol::BOOL; }
+//   | "pointer" { ret=CSymbol::POINTER; }
+//   | "matrix"  { ret=CSymbol::MATRIX; }
+//   | "data"    { ret=CSymbol::DATA; }
+//   ;
+

Added: trunk/gpt2/bindings/gptbind/test/test.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-17 18:56:47 UTC (rev 433)
+++ trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-18 17:53:16 UTC (rev 434)
@@ -0,0 +1,22 @@
+options {
+   libname        = "math";
+   functionprefix = "math_"; // poderia ser libname + "_"
+   linkerlib      = "math";
+}
+
+headers {
+   "stdlib.h";
+   "math.h";
+   "iostream";
+}
+
+procedure mensagem_padrao() ::= puts("Hello !!!");
+
+procedure mensagem_personalizada(string msg) ::= puts(msg);
+
+// Acho que esse formato eh o foto da versao .1 do gerador
+procedure outra_mensagem_personalizada(string msg) ::= puts(msg);
+
+function sqrt(real value) : real ::= puts(msg);
+
+function exponencial(real valor) : real ::= exp(valor);



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:52:09 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:52:09 +0100
Subject: [gpt-commit] r435 - trunk/gpt2/gptc/src
Message-ID: <200712190052.lBJ0q9XE020122@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:52:09 +0100 (Wed, 19 Dec 2007)
New Revision: 435

Modified:
   trunk/gpt2/gptc/src/lexer.g
   trunk/gpt2/gptc/src/parser.g
Log:
-Correcao na montagem da ast para operacoes unarias.
-Adicao do token T_LVALUE

Modified: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-12-18 17:53:16 UTC (rev 434)
+++ trunk/gpt2/gptc/src/lexer.g	2007-12-19 00:52:09 UTC (rev 435)
@@ -99,7 +99,7 @@
   //imagin?rios para a AST
 
   T_NULO="nulo";
-
+  T_LVALUE;
   
 
   T_PARAM;

Modified: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-12-18 17:53:16 UTC (rev 434)
+++ trunk/gpt2/gptc/src/parser.g	2007-12-19 00:52:09 UTC (rev 435)
@@ -385,7 +385,7 @@
 
 lvalue!
   : id:T_IDENTIFICADOR (m:lvalue_indices)? (T_PONTO es:lvalue_membro)?
-    {#lvalue = #(id, m, es);}
+    {#lvalue = #([T_LVALUE,"&lvalue"], id, m, es);}
   ;
 
 lvalue_membro!
@@ -522,18 +522,18 @@
   : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
   ;
 
-expr_unario
+expr_unario!
 options {
   defaultErrorHandler=false;
 }
-  : op_unario expr_elemento
+  : o:op_unario e:expr_elemento {#expr_unario = #(o,e);}
   ;
 
 op_unario!
   : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
     | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
-    | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
-    | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
+    | n:T_NAO      {#op_unario = #n;}
+    | bn:T_BIT_NAO {#op_unario = #bn;}
     )?
   ;
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:52:45 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:52:45 +0100
Subject: [gpt-commit] r436 - trunk/gpt2/gptc/src
Message-ID: <200712190052.lBJ0qjcf020433@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:52:44 +0100 (Wed, 19 Dec 2007)
New Revision: 436

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Checando omissao de tamanho das dimensoes corretamente
-Reavaliacao das expressoes de acordo com a ultima atualizacao das regras no wiki
-carregando os tipos corretamente nos nodes da ast

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 00:52:09 UTC (rev 435)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 00:52:44 UTC (rev 436)
@@ -144,7 +144,26 @@
   _symtable->setScope(_currentScopeSymbol);
 }
 
+void
+BaseSemanticWalker::checkMatrixDimensions(RefPortugolAST m, 
+                                          const std::list<int>& dimensions) {
+  if (dimensions.size() > 2) {
+    report(m->getLine(), m->getColumn(), 
+      "matrizes com mais de 2 dimens?es n?o s?o suportadas");
+  }
 
+  bool found_null = false;
+  std::list<int>::const_iterator it = dimensions.begin();
+  for (; it != dimensions.end(); ++it) {
+    if (*it == 0) {
+      found_null = true;
+    } else if (found_null) {
+      report(m->getLine(), m->getColumn(), 
+        "somente as ?ltimas dimens?es podem ter o tamanho omitido");
+    }
+  }
+}
+
 Type* BaseSemanticWalker::evalMatrixSubscript(RefPortugolAST id, Type* type,
                                               int dimensions) {
 
@@ -316,21 +335,21 @@
   }
 
   if (!ltype->isLValueFor(rtype)) {
-    report(lastId->getLine(), lastId->getColumn(), 
-            string("vari?vel do tipo '") + ltype->name() 
+    report(lastId->getLine(), lastId->getColumn(),
+            string("vari?vel do tipo '") + ltype->name()
             + "' n?o pode receber valor do tipo '" + rtype->name() + "'");
   }
 }
 
-void BaseSemanticWalker::evalAttribution(const ExpressionReturn& l, 
+void BaseSemanticWalker::evalAttribution(const ExpressionReturn& l,
                                          const ExpressionReturn& r) {
   if (l.second->isError() || r.second->isError()) {
     return;
   }
 
   if (!l.second->isLValueFor(r.second)) {
-    report(r.first->getLine(), r.first->getColumn(), 
-            "vari?vel do tipo '" + l.second->name() 
+    report(r.first->getLine(), r.first->getColumn(),
+            "vari?vel do tipo '" + l.second->name()
             + "' n?o pode receber valor do tipo '" + r.second->name() + "'");
   }
 }
@@ -392,21 +411,52 @@
 
 /************************ EXPR ********************************************/
 
-Type*
-BaseSemanticWalker::evalExpr_OU(RefPortugolAST,Type* left, Type* right) {
   //TODO: refatorar os copy/pastes dos metodos evalExpr
 
-  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+Type*
+BaseSemanticWalker::evalExpr_OU(RefPortugolAST op,Type* left, Type* right) {
+
+//l?gico ou l?gico --> l?gico
+
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
+  if (left->equals(PortugolTokenTypes::T_LOGICO) &&
+      right->equals(PortugolTokenTypes::T_LOGICO)) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    report(op->getLine(), op->getColumn(), 
+      std::string("ilegal: ") + left->name() + " ou " + right->name());
+    return _typeBuilder->errorType();
+  }
 }
 
 Type*
-BaseSemanticWalker::evalExpr_E(RefPortugolAST,Type* left, Type* right) {
-  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+BaseSemanticWalker::evalExpr_E(RefPortugolAST op,Type* left, Type* right) {
+
+//l?gico e l?gico --> l?gico
+
+  if (left->isError() || right->isError()) {
+    return _typeBuilder->errorType();
+  }
+
+  if (left->equals(PortugolTokenTypes::T_LOGICO) &&
+      right->equals(PortugolTokenTypes::T_LOGICO)) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    report(op->getLine(), op->getColumn(), 
+      std::string("ilegal: ") + left->name() + " e " + right->name());
+    return _typeBuilder->errorType();
+  }
 }
 
 
 Type*
 BaseSemanticWalker::evalExpr_BIT_OU(RefPortugolAST op,Type* left, Type* right) {
+
+//inteiro | inteiro --> inteiro
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -424,6 +474,9 @@
 
 Type*
 BaseSemanticWalker::evalExpr_BIT_OUX(RefPortugolAST op, Type* left, Type* right) {
+
+//inteiro ^ inteiro --> inteiro
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -441,6 +494,9 @@
 
 Type*
 BaseSemanticWalker::evalExpr_BIT_E(RefPortugolAST op, Type* left, Type* right) {
+
+//inteiro & inteiro --> inteiro
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -458,11 +514,21 @@
 
 Type*
 BaseSemanticWalker::evalExpr_IGUAL(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro = inteiro --> l?gico
+    * real = real --> l?gico
+    * caractere = caractere --> l?gico
+    * literal = literal --> l?gico
+    * l?gico = l?gico --> l?gico 
+*/
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (left->equals(right)) {
+  if (left->isPrimitive() && 
+      !left->equals(PortugolTokenTypes::T_CORINGA) && 
+      left->equals(right)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -474,11 +540,21 @@
 
 Type*
 BaseSemanticWalker::evalExpr_DIFERENTE(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro <> inteiro --> l?gico
+    * real <> real --> l?gico
+    * caractere <> caractere --> l?gico
+    * literal <> literal --> l?gico
+    * l?gico <> l?gico --> l?gico 
+*/
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (left->equals(right)) {
+  if (left->isPrimitive() && 
+      !left->equals(PortugolTokenTypes::T_CORINGA) && 
+      left->equals(right)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -490,12 +566,38 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MAIOR(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro > inteiro --> l?gico
+    * real > real --> l?gico
+    * caractere > caractere --> l?gico 
+    * literal > literal --> l?gico 
+
+    * inteiro > real --> l?gico
+    * real > inteiro --> l?gico 
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->intOrReal(right))) {
+          (left->equals(right) || 
+           left->intOrReal(right) || 
+           left->caracOrLit(right))) {
+
+    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
+        right->equals(PortugolTokenTypes::T_LOGICO)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " > " + right->name());
+      return _typeBuilder->errorType();
+    }
+  
+    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
+        right->equals(PortugolTokenTypes::T_CORINGA)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " > " + right->name());
+      return _typeBuilder->errorType();
+    }
+
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -507,12 +609,36 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MENOR(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro < inteiro --> l?gico
+    * real < real --> l?gico
+    * caractere < caractere --> l?gico 
+    * literal < literal --> l?gico 
+
+    * inteiro < real --> l?gico
+    * real < inteiro --> l?gico 
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if ((left->isPrimitive() && right->isPrimitive()) &&
       (left->equals(right) || left->intOrReal(right))) {
+
+    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
+        right->equals(PortugolTokenTypes::T_LOGICO)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " < " + right->name());
+      return _typeBuilder->errorType();
+    }
+  
+    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
+        right->equals(PortugolTokenTypes::T_CORINGA)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " < " + right->name());
+      return _typeBuilder->errorType();
+    }
+
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -524,12 +650,36 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MAIOR_EQ(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro >= inteiro --> l?gico
+    * real >= real --> l?gico
+    * caractere >= caractere --> l?gico 
+    * literal >= literal --> l?gico 
+
+    * inteiro >= real --> l?gico
+    * real >= inteiro --> l?gico 
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if ((left->isPrimitive() && right->isPrimitive()) &&
       (left->equals(right) || left->intOrReal(right))) {
+
+    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
+        right->equals(PortugolTokenTypes::T_LOGICO)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " >= " + right->name());
+      return _typeBuilder->errorType();
+    }
+  
+    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
+        right->equals(PortugolTokenTypes::T_CORINGA)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " >= " + right->name());
+      return _typeBuilder->errorType();
+    }
+
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -542,12 +692,37 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MENOR_EQ(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro <= inteiro --> l?gico
+    * real <= real --> l?gico
+    * caractere <= caractere --> l?gico 
+    * literal <= literal --> l?gico 
+
+    * inteiro >= real --> l?gico
+    * real >= inteiro --> l?gico 
+*/
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
   if ((left->isPrimitive() && right->isPrimitive()) &&
       (left->equals(right) || left->intOrReal(right))) {
+
+    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
+        right->equals(PortugolTokenTypes::T_LOGICO)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " <= " + right->name());
+      return _typeBuilder->errorType();
+    }
+  
+    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
+        right->equals(PortugolTokenTypes::T_CORINGA)) {
+      report(op->getLine(), op->getColumn(),
+        std::string("ilegal: ") + left->name() + " <= " + right->name());
+      return _typeBuilder->errorType();
+    }
+
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
   } else {
     report(op->getLine(), op->getColumn(),
@@ -559,6 +734,9 @@
 
 Type*
 BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(RefPortugolAST op, Type* left, Type* right) {
+
+//inteiro << inteiro --> inteiro
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -576,6 +754,9 @@
 
 Type*
 BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST op, Type* left, Type* right) {
+
+//inteiro >> inteiro --> inteiro
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
@@ -593,21 +774,32 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MAIS(RefPortugolAST op, Type* left, Type* right) {
+
+/*
+    * inteiro + inteiro --> inteiro
+    * real + real --> real 
+
+    * inteiro + real --> real
+    * real + inteiro --> real
+
+
+    * literal + literal --> literal
+    * caractere + caractere --> literal
+    * literal + caractere --> literal
+    * caractere + literal --> literal 
+
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " + " + right->name());
-    return _typeBuilder->errorType();
-  }
-
   Type* ret;
   if (ret = left->intOrReal(right)) {
-    return ret;
-  } else if (ret = left->caracOrLit(right)) {
-    return ret;
+    //int ou real
+    return ret; 
+  } else if (left->caracOrLit(right)) {
+    //sempre literal
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LITERAL);
   } else {
     report(op->getLine(), op->getColumn(),
       std::string("ilegal: ") + left->name() + " + " + right->name());
@@ -618,16 +810,18 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MENOS(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro - inteiro --> inteiro
+    * real - real --> real 
+
+    * inteiro - real --> real
+    * real - inteiro --> real 
+*/
+
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " - " + right->name());
-    return _typeBuilder->errorType();
-  }
-
   Type* ret;
   if (ret = left->intOrReal(right)) {
     return ret;
@@ -641,16 +835,17 @@
 
 Type*
 BaseSemanticWalker::evalExpr_DIV(RefPortugolAST op, Type* left, Type* right) {
+/*
+    * inteiro / inteiro --> inteiro
+    * real / real --> real 
+
+    * inteiro / real --> real
+    * real / inteiro --> real 
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " / " + right->name());
-    return _typeBuilder->errorType();
-  }
-
   Type* ret;
   if (ret = left->intOrReal(right)) {
     return ret;
@@ -664,16 +859,18 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MULTIP(RefPortugolAST op, Type* left, Type* right) {
+
+/*
+    * inteiro * inteiro --> inteiro
+    * real * real --> real 
+
+    * inteiro * real --> real
+    * real * inteiro --> real 
+*/
   if (left->isError() || right->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (!left->isPrimitive() || !right->isPrimitive()) {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " * " + right->name());
-    return _typeBuilder->errorType();
-  }
-
   Type* ret;
   if (ret = left->intOrReal(right)) {
     return ret;
@@ -687,6 +884,9 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MOD(RefPortugolAST op, Type* left, Type* right) {
+
+//inteiro % inteiro --> inteiro
+
   if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
       right->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
@@ -700,56 +900,80 @@
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_NEGATIVO(RefPortugolAST op, Type* left) {
-  if (left->isError()) {
+BaseSemanticWalker::evalExpr_UN_NEGATIVO(RefPortugolAST op, Type* term) {
+/*
+    * - inteiro --> inteiro
+    * - real --> real 
+*/
+  if (term->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
-      left->equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder->primitiveType(left->primitiveType());
+  if (term->equals(PortugolTokenTypes::T_INTEIRO) ||
+      term->equals(PortugolTokenTypes::T_REAL)) {
+    return _typeBuilder->primitiveType(term->primitiveType());
   } else {
     report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " - " + left->name());
+      std::string("ilegal: ") + " - " + term->name());
     return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_UN_POSITIVO(RefPortugolAST op, Type* left) {
-  if (left->isError()) {
+BaseSemanticWalker::evalExpr_UN_POSITIVO(RefPortugolAST op, Type* term) {
+/*
+    * + inteiro --> inteiro
+    * + real --> real 
+*/
+  if (term->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
-      left->equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder->primitiveType(left->primitiveType());
+  if (term->equals(PortugolTokenTypes::T_INTEIRO) ||
+      term->equals(PortugolTokenTypes::T_REAL)) {
+    return _typeBuilder->primitiveType(term->primitiveType());
   } else {
     report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " + " + left->name());
+      std::string("ilegal: ") + " + " + term->name());
     return _typeBuilder->errorType();
   }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_NAO(RefPortugolAST, Type* left) {
-  return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+BaseSemanticWalker::evalExpr_NAO(RefPortugolAST op, Type* term) {
+
+//n?o l?gico --> l?gico
+
+  if (term->isError()) {
+    return _typeBuilder->errorType();
+  }
+
+  if (term->equals(PortugolTokenTypes::T_LOGICO)) {
+    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    report(op->getLine(), op->getColumn(), 
+      std::string("ilegal: ") + " n?o " + term->name());
+    return _typeBuilder->errorType();
+  }
 }
 
 
 Type*
-BaseSemanticWalker::evalExpr_BIT_NAO(RefPortugolAST op, Type* left) {
-  if (left->isError()) {
+BaseSemanticWalker::evalExpr_BIT_NAO(RefPortugolAST op, Type* term) {
+
+//~ inteiro --> inteiro
+
+  if (term->isError()) {
     return _typeBuilder->errorType();
   }
 
-  if (left->equals(PortugolTokenTypes::T_INTEIRO)) {
+  if (term->equals(PortugolTokenTypes::T_INTEIRO)) {
     return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
   } else {
     report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " ~ " + left->name());
+      std::string("ilegal: ") + " ~ " + term->name());
     return _typeBuilder->errorType();
   }
 }
@@ -761,7 +985,6 @@
 using std::cerr;
 using std::endl;
 
-
 void BaseSemanticWalker::report(int line, int col, const std::string& msg) {
   //<file>:<line>: <message>
   //.............<source code>

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 00:52:09 UTC (rev 435)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 00:52:44 UTC (rev 436)
@@ -77,9 +77,11 @@
   void declareStruct(RefPortugolAST, const SymbolList& );
 
 
+  void checkMatrixDimensions(RefPortugolAST, const std::list<int>&);
+
   Type* evalInitStruct(const InitStructList& stc);
   Type* evalInitMatrix(RefPortugolAST, const InitMatrixList& mtx);
-
+  
   Type* evalMatrixSubscript(RefPortugolAST, Type*, int);
   void  evalMatrixSubscriptType(RefPortugolAST,Type*);
 

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-19 00:52:09 UTC (rev 435)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-19 00:52:44 UTC (rev 436)
@@ -154,9 +154,12 @@
                           Type* ofType;
                         }
 
-  : #(T_MATRIZ ofType=tipo dims=dimensoes)
+  : #(m:T_MATRIZ ofType=tipo dims=dimensoes)
 
-                  {type =_typeBuilder->matrixType(ofType,dims);}
+                  {
+                    checkMatrixDimensions(m,dims);
+                    type =_typeBuilder->matrixType(ofType,dims);
+                  }
 
   ;
 
@@ -507,12 +510,16 @@
   ;
 
 literal returns [Type *type]
-  : T_TEXTO_LITERAL         {type = _typeBuilder->primitiveType(T_LITERAL);}
-  | T_INTEIRO_LITERAL       {type = _typeBuilder->primitiveType(T_INTEIRO);}
-  | T_REAL_LITERAL          {type = _typeBuilder->primitiveType(T_REAL);}
-  | T_CARACTERE_LITERAL     {type = _typeBuilder->primitiveType(T_CARACTERE);}
-  | T_VERDADEIRO            {type = _typeBuilder->primitiveType(T_LOGICO);}
-  | T_FALSO                 {type = _typeBuilder->primitiveType(T_LOGICO);}
+                            {RefPortugolAST ast = _t;}
+  : (
+      T_TEXTO_LITERAL       {type = _typeBuilder->primitiveType(T_LITERAL);}
+    | T_INTEIRO_LITERAL     {type = _typeBuilder->primitiveType(T_INTEIRO);}
+    | T_REAL_LITERAL        {type = _typeBuilder->primitiveType(T_REAL);}
+    | T_CARACTERE_LITERAL   {type = _typeBuilder->primitiveType(T_CARACTERE);}
+    | T_VERDADEIRO          {type = _typeBuilder->primitiveType(T_LOGICO);}
+    | T_FALSO               {type = _typeBuilder->primitiveType(T_LOGICO);}
+    )
+    {ast->setEvalType(type);}
   ;
 
 
@@ -523,7 +530,7 @@
                               int dimensions;
                             }
 
-  : #(id:T_IDENTIFICADOR    {type = getSymbolType(id);}
+  : #(lv:T_LVALUE id:T_IDENTIFICADOR    {type = getSymbolType(id);}
 
       (
         dimensions=lvalue_indices
@@ -534,7 +541,10 @@
       (type=lvalue_membro[id,type])?
     )
 
-      {ret.first = id; ret.second = type;}
+      {
+        ret.first = id; ret.second = type;
+        lv->setEvalType(type);
+      }
   ;
 
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:53:24 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:53:24 +0100
Subject: [gpt-commit] r437 - trunk/gpt2/gptc/src
Message-ID: <200712190053.lBJ0rOPm020836@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:53:24 +0100 (Wed, 19 Dec 2007)
New Revision: 437

Removed:
   trunk/gpt2/gptc/src/Makefile.in
Log:
nomsg

Deleted: trunk/gpt2/gptc/src/Makefile.in
===================================================================
--- trunk/gpt2/gptc/src/Makefile.in	2007-12-19 00:52:44 UTC (rev 436)
+++ trunk/gpt2/gptc/src/Makefile.in	2007-12-19 00:53:24 UTC (rev 437)
@@ -1,611 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-bin_PROGRAMS = gptc$(EXEEXT)
-subdir = src
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-libgptc_la_LIBADD =
-am__objects_1 = PortugolLexer.lo PortugolParser.lo SemanticWalker.lo \
-	GptAsmWalker.lo
-am_libgptc_la_OBJECTS = BaseSemanticWalker.lo BaseGptAsmWalker.lo \
-	CompilerError.lo MismatchedUnicodeCharException.lo \
-	PortugolAST.lo Symbol.lo SymbolTable.lo \
-	SymbolTableExceptions.lo Types.lo Arguments.lo AsmProgram.lo \
-	Context.lo Subroutine.lo TextFile.lo Tools.lo $(am__objects_1)
-libgptc_la_OBJECTS = $(am_libgptc_la_OBJECTS)
-am__installdirs = "$(DESTDIR)$(bindir)"
-binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
-PROGRAMS = $(bin_PROGRAMS)
-am_gptc_OBJECTS = main.$(OBJEXT)
-gptc_OBJECTS = $(am_gptc_OBJECTS)
-am__DEPENDENCIES_1 =
-gptc_DEPENDENCIES = libgptc.la $(am__DEPENDENCIES_1)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-LTCXXCOMPILE = $(LIBTOOL) --tag=CXX --mode=compile $(CXX) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CXXFLAGS) $(CXXFLAGS)
-CXXLD = $(CXX)
-CXXLINK = $(LIBTOOL) --tag=CXX --mode=link $(CXXLD) $(AM_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(libgptc_la_SOURCES) $(gptc_SOURCES)
-DIST_SOURCES = $(libgptc_la_SOURCES) $(gptc_SOURCES)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
-AMTAR = @AMTAR@
-ANTLR_BIN = @ANTLR_BIN@
-ANTLR_CFG = @ANTLR_CFG@
-ANTLR_INC = @ANTLR_INC@
-ANTLR_LIB = @ANTLR_LIB@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-ECHO = @ECHO@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
-GREP = @GREP@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-OBJEXT = @OBJEXT@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-RANLIB = @RANLIB@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_F77 = @ac_ct_F77@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
-noinst_LTLIBRARIES = libgptc.la
-gptc_SOURCES = main.cpp
-gptc_LDADD = libgptc.la $(ANTLR_LIB)
-EXTRA_DIST = lexer.g parser.g semantic.g gptasm.g
-BUILT_SOURCES = PortugolLexer.hpp \
-                PortugolLexer.cpp \
-                PortugolParser.hpp \
-                PortugolParser.cpp \
-                SemanticWalker.hpp \
-                SemanticWalker.cpp \
-								GptAsmWalker.hpp \
-								GptAsmWalker.cpp \
-                TokenNames.hpp \
-                TokenLabels.hpp
-
-libgptc_la_SOURCES = BaseSemanticWalker.hpp \
-											BaseSemanticWalker.cpp \
-											BaseGptAsmWalker.hpp \
-											BaseGptAsmWalker.cpp \
-											CompilerError.hpp \
-											CompilerError.cpp \
-											MismatchedUnicodeCharException.hpp \
-											MismatchedUnicodeCharException.cpp \
-											PortugolAST.hpp \
-											PortugolAST.cpp \
-											Symbol.hpp \
-											Symbol.cpp \
-											SymbolTable.hpp \
-											SymbolTable.cpp \
-											SymbolTableExceptions.hpp \
-											SymbolTableExceptions.cpp \
-											Types.hpp \
-											Types.cpp \
-											UnicodeCharBuffer.hpp \
-											UnicodeCharScanner.hpp \
-											GptAsmExpression.hpp \
-											Arguments.hpp \
-											Arguments.cpp \
-											AsmProgram.hpp AsmProgram.cpp \
-										  Context.hpp Context.cpp \
-										  Options.hpp \
-											Subroutine.hpp Subroutine.cpp \
-											TextFile.hpp TextFile.cpp \
-										  Tools.hpp Tools.cpp \
-											$(BUILT_SOURCES)
-
-CLEANFILES = PortugolLexer.cpp \
-             PortugolLexer.hpp \
-             PortugolTokenTypes.hpp \
-             PortugolTokenTypes.txt \
-             PortugolParser.cpp \
-						 PortugolParser.hpp  \
-             PortugolParserTokenTypes.hpp \
-             PortugolParserTokenTypes.txt \
-             SemanticWalker.hpp \
-             SemanticWalker.cpp \
-             SemanticWalkerTokenTypes.hpp \
-             SemanticWalkerTokenTypes.txt \
-             GptAsmWalkerTokenTypes.hpp \
-             GptAsmWalker.cpp \
-						 GptAsmWalker.hpp  \
-             GptAsmWalkerTokenTypes.txt \
-             TokenNames.hpp \
-             TokenLabels.hpp
-
-all: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) all-am
-
-.SUFFIXES:
-.SUFFIXES: .cpp .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  src/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libgptc.la: $(libgptc_la_OBJECTS) $(libgptc_la_DEPENDENCIES) 
-	$(CXXLINK)  $(libgptc_la_LDFLAGS) $(libgptc_la_OBJECTS) $(libgptc_la_LIBADD) $(LIBS)
-install-binPROGRAMS: $(bin_PROGRAMS)
-	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
-	  if test -f $$p \
-	     || test -f $$p1 \
-	  ; then \
-	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
-	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
-	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
-	  else :; fi; \
-	done
-
-uninstall-binPROGRAMS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
-	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
-	done
-
-clean-binPROGRAMS:
-	@list='$(bin_PROGRAMS)'; for p in $$list; do \
-	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
-	  echo " rm -f $$p $$f"; \
-	  rm -f $$p $$f ; \
-	done
-gptc$(EXEEXT): $(gptc_OBJECTS) $(gptc_DEPENDENCIES) 
-	@rm -f gptc$(EXEEXT)
-	$(CXXLINK) $(gptc_LDFLAGS) $(gptc_OBJECTS) $(gptc_LDADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Arguments.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/AsmProgram.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/BaseGptAsmWalker.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/BaseSemanticWalker.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/CompilerError.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Context.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/GptAsmWalker.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/MismatchedUnicodeCharException.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolAST.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolLexer.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/PortugolParser.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SemanticWalker.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Subroutine.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Symbol.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SymbolTable.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/SymbolTableExceptions.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/TextFile.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Tools.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/Types.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/main.Po at am__quote@
-
-.cpp.o:
- at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
- at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
-
-.cpp.obj:
- at am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
- at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-
-.cpp.lo:
- at am__fastdepCXX_TRUE@	if $(LTCXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
- at am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) check-am
-all-am: Makefile $(LTLIBRARIES) $(PROGRAMS)
-installdirs:
-	for dir in "$(DESTDIR)$(bindir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: $(BUILT_SOURCES)
-	$(MAKE) $(AM_MAKEFLAGS) install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
-clean: clean-am
-
-clean-am: clean-binPROGRAMS clean-generic clean-libtool \
-	clean-noinstLTLIBRARIES mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-exec-am: install-binPROGRAMS
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-binPROGRAMS uninstall-info-am
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
-	clean-generic clean-libtool clean-noinstLTLIBRARIES ctags \
-	distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-binPROGRAMS \
-	install-data install-data-am install-exec install-exec-am \
-	install-info install-info-am install-man install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-binPROGRAMS \
-	uninstall-info-am
-
-
-PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
-	$(ANTLR_BIN) $(srcdir)/lexer.g
-
-PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile
-	$(ANTLR_BIN) $(srcdir)/parser.g
-
-SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
-	$(ANTLR_BIN) $(srcdir)/semantic.g
-
-GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
-	$(ANTLR_BIN) $(srcdir)/gptasm.g
-
-TokenNames.hpp: Makefile
-	@echo "#ifndef TOKENNAMES_H" > $@
-	@echo "#define TOKENNAMES_H"  >> $@
-	@echo "static char* g_tokenNames[] = " >> $@
-	@echo '{"", "EOF", "", "",'   >> $@
-	grep = PortugolTokenTypes.txt >> $@
-	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo -n "static int g_tokenNamesSize = " >> $@
-	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc >> $@
-	@echo ";" >> $@
-	@echo "#endif" >> $@
-
-TokenLabels.hpp: Makefile
-	@echo "#ifndef TOKENLABELS_H" > $@
-	@echo "#define TOKENLABELS_H"  >> $@
-	@echo "static char* g_tokenLabels[] = " >> $@
-	@echo '{"", "EOF", "", "",'   >> $@
-	grep '"' PortugolTokenTypes.txt >> $@
-	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo "static int g_tokenLabelsSize = " >> $@
-	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc >> $@
-	@echo ";" >> $@
-	@echo "#endif" >> $@
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:53:53 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:53:53 +0100
Subject: [gpt-commit] r438 - trunk/gpt2/gptc/src
Message-ID: <200712190053.lBJ0rrFi021177@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:53:51 +0100 (Wed, 19 Dec 2007)
New Revision: 438

Added:
   trunk/gpt2/gptc/src/GptAsmExpression.cpp
Modified:
   trunk/gpt2/gptc/src/Arguments.cpp
   trunk/gpt2/gptc/src/AsmProgram.cpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptc/src/Subroutine.cpp
   trunk/gpt2/gptc/src/Subroutine.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
   trunk/gpt2/gptc/src/gptasm.g
   trunk/gpt2/gptc/src/main.cpp
Log:
-Gerando expressoes e atribuicao (lvalues primitivos, apenas)

Modified: trunk/gpt2/gptc/src/Arguments.cpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -27,6 +27,6 @@
 
 	}
 	if (varArgs) {
-		_subroutine->emitMn( "push", itoa( size( ) ) );
+		_subroutine->emit( "push", itoa( size( ) ) );
 	}
 }

Modified: trunk/gpt2/gptc/src/AsmProgram.cpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -10,13 +10,14 @@
 
 void AsmProgram::init()
 {
-	_asmPrg.writeln("// Programa " + _options->filename + ".gasm gerado a partir de " + _options->filename + ".gpt");
-	_asmPrg.writeln("program " + _options->filename);
+	_asmPrg.writeln("// Programa gerado a partir de " + _options->filename);
+	_asmPrg.writeln("program");
 	_asmPrg.writeln();
 }
 
 void AsmProgram::finish()
 {
+  _asmPrg.writeln();
 	_asmPrg.writeln("end-program");
 }
 

Modified: trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -4,6 +4,7 @@
 #include "Symbol.hpp"
 #include "AsmProgram.hpp"
 #include "Types.hpp"
+#include "GptAsmExpression.hpp"
 
 BaseGptAsmWalker::BaseGptAsmWalker(SymbolTable* symtable,
                                    const std::string& filepath)
@@ -12,9 +13,9 @@
   _symtable->setGlobalScope();
 
   _options.filename = _filepath;
-  //options.sourcefile = filename + ".gpt";
-  //options.destfile   = filename + ".gasm";
   _asmPrg = new AsmProgram(&_options);
+
+  _subroutine = _asmPrg->initSubroutine("main");
 }
 
 
@@ -23,53 +24,338 @@
   _asmPrg = NULL;
 }
 
-void BaseGptAsmWalker::declareProgramVars(const std::list<string>& ids) {
-  for (std::list<string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    _asmPrg->emitVarDefinition(
-      *it, _symtable->getSymbol(*it).type()->asmName());
+void BaseGptAsmWalker::declareProgramVars(const std::list<std::string>& ids) {
+  for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
+    Symbol symbol = _symtable->getSymbol(*it);
+    _asmPrg->emitVarDefinition(symbol.identifier(), symbol.type()->asmName(true));
+
+    if (symbol.type()->isMatrix()) {
+      addMatrixInitialization(symbol);
+    }
   }
 }
 
-void BaseGptAsmWalker::declareSubroutineVars(const std::list<string>& ids) {
-  for (std::list<string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
+void BaseGptAsmWalker::addMatrixInitialization(const Symbol& symbol) {
+  std::list<int> dims = symbol.type()->dimensions();
+
+  std::stringstream code;
+
+  if (dims.size() == 1) {
+    code << "m1alloc " << symbol.identifier()
+            << ", " << symbol.type()->ofType()->byteSize()
+            << ", " << dims.front();
+  } else if(dims.size() == 2) {
+    code << "m2alloc " << symbol.identifier()
+            << ", " << symbol.type()->ofType()->byteSize()
+            << ", " << dims.front()
+            << ", " << *(dims.rbegin());
+  }
+  _subroutine->emitAsmCode(code.str());
+}
+
+
+void BaseGptAsmWalker::declareSubroutineVars(const std::list<std::string>& ids) {
+  for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
     _subroutine->emitVarDefinition(
-      *it, _symtable->getSymbol(*it).type()->asmName());
-  }  
+      *it, _symtable->getSymbol(*it).type());
+  }
 }
 
 void BaseGptAsmWalker::declareParameter(const string& lexeme) {
   _subroutine->emitParDefinition(
-    lexeme, _symtable->getSymbol(lexeme).type()->asmName());
+    lexeme, _symtable->getSymbol(lexeme).type());
 }
 
 int BaseGptAsmWalker::getSymbolType(const string& lexeme) {
   return _symtable->getSymbol(lexeme).type()->primitiveType();
 }
 
-std::string BaseGptAsmWalker::expandOffset(const std::string&, const std::list<std::string>&) {
+// std::string BaseGptAsmWalker::expandOffset(const std::string&, const std::list<std::string>&) {
+  //??TODO
+// }
+
+
+void BaseGptAsmWalker::emitAttribution(const Symbol& lv, const std::string& tmp) {
+  switch (lv.type()->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      _subroutine->emit("rset", lv.identifier(), tmp);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      _subroutine->emit("sset", lv.identifier(), tmp);
+      break;
+    case PortugolTokenTypes::T_INTEIRO:
+    case PortugolTokenTypes::T_LOGICO:
+    case PortugolTokenTypes::T_CARACTERE:
+      _subroutine->emit("iset", lv.identifier(), tmp);
+      break;
+    default:
+      throw;
+  }
 }
 
-void BaseGptAsmWalker::expr_MAIS(GptAsmExpression&, const GptAsmExpression&, const GptAsmExpression&) {
+
+
+
+
+GptAsmExpression* BaseGptAsmWalker::expr_OU(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, optype, "lor", left, right);
 }
 
+GptAsmExpression* BaseGptAsmWalker::expr_E(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, optype, "land", left, right);
+}
 
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_OU(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, optype, "bor", left, right);
+}
 
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_XOU(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, optype, "bxor", left, right);
+}
 
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_E(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, optype, "band", left, right);
+}
 
+GptAsmExpression* BaseGptAsmWalker::expr_IGUAL(Type *optype,
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  
+  //lh e rh tem o mesmo tipo
+  switch (left->restype()->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, left->restype(), "req", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, left->restype(), "seq", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, left->restype(), "ieq", left, right);
+      break;
+  }
+}
 
-//      string getAsmProgram( ) const
-//      {
-//         return asmPrg->getAsm( );
-//      }
+GptAsmExpression* BaseGptAsmWalker::expr_DIFERENTE(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  //lh e rh tem o mesmo tipo
+  switch (left->restype()->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, left->restype(), "rne", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, left->restype(), "sne", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, left->restype(), "ine", left, right);
+      break;
+  }
+}
 
-// void BaseGptAsmWalker::declareGlobals(const IDList& ids) {
-//   for (IDList::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-//     _globalarea << "var " << (*it) << " " << getAsmType(*it) << std::endl;
-//   }
-// }
-// 
-// std::string BaseGptAsmWalker::getAsmType(const std::string& id) {
-//   return _symtable->getSymbol(
-//       id, _symtable->currentScope()).type()->asmName();
-// }
+GptAsmExpression* BaseGptAsmWalker::expr_MAIOR(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
 
+  Type *promType;
+  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
+    promType = left->restype()->caracOrLit(right->restype());
+  }
+
+  switch (promType->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, promType, "rgt", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, promType, "sgt", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, promType, "igt", left, right);
+      break;
+  }
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MENOR(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType;
+  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
+    promType = left->restype()->caracOrLit(right->restype());
+  }
+
+  switch (promType->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, promType, "rlt", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, promType, "slt", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, promType, "ilt", left, right);
+      break;
+  }
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MAIOR_EQ(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType;
+  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
+    promType = left->restype()->caracOrLit(right->restype());
+  }
+
+  switch (promType->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, promType, "rge", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, promType, "sge", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, promType, "ige", left, right);
+      break;
+  }
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MENOR_EQ(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  Type *promType;
+  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
+    promType = left->restype()->caracOrLit(right->restype());
+  }
+
+  switch (promType->primitiveType()) {
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, promType, "rle", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, promType, "sle", left, right);
+      break;
+    default: //inteiro, l?gico, caractere
+      return new GptAsmExpression(optype, promType, "ile", left, right);
+      break;
+  }
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_LEFT(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, left->restype(), "bshl", left, right);
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_RIGHT(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, left->restype(), "bshr", left, right);
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MAIS(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType;
+  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
+    promType = left->restype()->caracOrLit(right->restype());
+  }
+
+  switch (optype->primitiveType()) {
+    case PortugolTokenTypes::T_INTEIRO:
+      return new GptAsmExpression(optype, promType, "isum", left, right);
+      break;
+    case PortugolTokenTypes::T_REAL:
+      return new GptAsmExpression(optype, promType, "rsum", left, right);
+      break;
+    case PortugolTokenTypes::T_LITERAL:
+      return new GptAsmExpression(optype, promType, "ssum", left, right);
+      break;
+  }
+  throw;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MENOS(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType = left->restype()->intOrReal(right->restype());
+
+  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return new GptAsmExpression(optype, promType, "isub", left, right);
+  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
+    return new GptAsmExpression(optype, promType, "rsub", left, right);
+  }
+  throw;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_DIV(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType = left->restype()->intOrReal(right->restype());
+
+  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return new GptAsmExpression(optype, promType, "idiv", left, right);
+  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
+    return new GptAsmExpression(optype, promType, "rdiv", left, right);
+  }
+  throw;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MULTIP(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+
+  Type *promType = left->restype()->intOrReal(right->restype());
+
+  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return new GptAsmExpression(optype, promType, "imul", left, right);
+  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
+    return new GptAsmExpression(optype, promType, "rmul", left, right);
+  }
+  throw;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_MOD(Type *optype, 
+                                            GptAsmExpression* left, 
+                                            GptAsmExpression* right) {
+  return new GptAsmExpression(optype, left->restype(), "imod", left, right);
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_UN_NEGATIVO(Type *optype, 
+                                            GptAsmExpression* term) {
+
+  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return new GptAsmExpression(optype, term->restype(), "inet", term);
+  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
+    return new GptAsmExpression(optype, term->restype(), "rneg", term);
+  }
+  throw;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_UN_POSITIVO(Type*,GptAsmExpression* term) {
+  return term;
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_UN_NAO(Type* optype,GptAsmExpression* term) {
+  return new GptAsmExpression(optype, term->restype(), "not", term);
+}
+
+GptAsmExpression* BaseGptAsmWalker::expr_BIT_NAO(Type* optype,GptAsmExpression* term) {
+  return new GptAsmExpression(optype, term->restype(), "bnot", term);
+}
+
+std::string BaseGptAsmWalker::getCode() {
+  return _asmPrg->getAsm();
+}
+

Modified: trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -6,16 +6,20 @@
 #include <list>
 
 #include "Options.hpp"
-#include "AsmProgram.hpp"
 
 class SymbolTable;
+class Symbol;
 class AsmProgram;
 class Subroutine;
 class GptAsmExpression;
+class Type;
 
 class BaseGptAsmWalker : public antlr::TreeParser {
 public:
   BaseGptAsmWalker(SymbolTable*, const std::string&);
+
+  std::string getCode();
+
 protected:
   void finishParser();
   void declareProgramVars(const std::list<std::string>&);
@@ -23,9 +27,35 @@
   void declareParameter(const string&);
   int getSymbolType(const string&);
 
-  std::string expandOffset(const std::string&, const std::list<std::string>&);
-  void expr_MAIS(GptAsmExpression&, const GptAsmExpression&, const GptAsmExpression&);
+  void addMatrixInitialization(const Symbol& symbol);
 
+//   std::string expandOffset(const std::string&, const std::list<std::string>&);
+
+  void emitAttribution(const Symbol&, const std::string&);
+
+  GptAsmExpression* expr_OU(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_E(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_BIT_OU(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_BIT_XOU(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_BIT_E(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_IGUAL(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_DIFERENTE(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MAIOR(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MENOR(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MAIOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MENOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_BIT_SHIFT_LEFT(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_BIT_SHIFT_RIGHT(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MAIS(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MENOS(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_DIV(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MULTIP(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_MOD(Type*, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression* expr_UN_NEGATIVO(Type*,GptAsmExpression*);
+  GptAsmExpression* expr_UN_POSITIVO(Type*,GptAsmExpression*);
+  GptAsmExpression* expr_UN_NAO(Type*,GptAsmExpression*);
+  GptAsmExpression* expr_BIT_NAO(Type*,GptAsmExpression*);
+
 //   void declareGlobals(const IDList&);
 //   void addPrologue(code);
 //   void initStructMembers(const string&, const IDList&, code);

Added: trunk/gpt2/gptc/src/GptAsmExpression.cpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -0,0 +1,128 @@
+#include "GptAsmExpression.hpp"
+#include "PortugolTokenTypes.hpp"
+#include "Types.hpp"
+#include "Subroutine.hpp"
+
+#include <sstream>
+#include <map>
+
+GptAsmExpression::GptAsmExpression(Type* restype,
+                                   const std::string& value) 
+  : _restype(restype), _exprtype(0), _mm(""), _value(value), _op1(0), _op2(0) {
+}
+
+GptAsmExpression::GptAsmExpression(Type* restype, Type *exprtype,
+                                   std::string mm, GptAsmExpression* op1)
+  : _restype(restype), _exprtype(exprtype),
+    _mm(mm), _value(""), _op1(op1), _op2(0) {
+}
+
+GptAsmExpression::GptAsmExpression(Type* restype,
+                   Type *exprtype,
+                   std::string mm,
+                   GptAsmExpression* op1,
+                   GptAsmExpression* op2) 
+  : _restype(restype), _exprtype(exprtype),
+    _mm(mm), _value(""), _op1(op1), _op2(op2) {
+}
+
+
+GptAsmExpression::~GptAsmExpression() {
+  delete _op1;
+  delete _op2;
+}
+
+void GptAsmExpression::expand(const std::string lvalue, Subroutine* sub) {
+  if (isAtom()) {
+    return;
+  }
+
+  if (!_op2) {
+    if (_op1->isAtom()) {
+      sub->emit(_mm, lvalue, _op1->value());
+    } else {
+      std::string t1 = sub->declareTmp(_op1->restype());
+      _op1->expand(t1, sub);
+      sub->emit(_mm, lvalue, t1);
+    }
+  } else {
+    if (_op1->isAtom() && _op2->isAtom()) {
+      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->restype(), sub);
+      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->restype(), sub);
+      sub->emit(_mm, lvalue, cp1, cp2);
+
+    } else if (_op1->isAtom()) {
+      std::string t2 = sub->declareTmp(_op2->restype());
+
+      _op2->expand(t2, sub);
+
+      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->restype(), sub);
+      std::string cp2 = expandCast(lvalue, t2, _op2->restype(), sub);
+
+      sub->emit(_mm, lvalue, cp1, cp2);
+
+    } else if (_op2->isAtom()) {
+      std::string t1 = sub->declareTmp(_op1->restype());
+  
+      _op1->expand(t1, sub);
+  
+      std::string cp1 = expandCast(lvalue, t1, _op1->restype(), sub);
+      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->restype(), sub);
+  
+      sub->emit(_mm, lvalue, cp1, cp2);
+  
+    } else {
+  
+      std::string t1 = sub->declareTmp(_op1->restype());
+      std::string t2 = sub->declareTmp(_op2->restype());
+  
+      _op1->expand(t1, sub);
+      _op2->expand(t2, sub);
+  
+      std::string cp1 = expandCast(lvalue, t1, _op1->restype(), sub);
+      std::string cp2 = expandCast(lvalue, t2, _op2->restype(), sub);
+  
+      sub->emit(_mm, lvalue, cp1, cp2);
+    }
+  }
+}
+
+bool GptAsmExpression::isAtom() {
+  return _value.length() > 0;
+}
+
+const std::string& GptAsmExpression::value() { 
+  return _value;
+}
+
+Type* GptAsmExpression::GptAsmExpression::restype() {
+  return _restype;
+}
+
+Type* GptAsmExpression::GptAsmExpression::exprtype() {
+  return _exprtype;
+}
+
+std::string GptAsmExpression::expandCast(const std::string &lvalue,
+                                         const std::string& op,
+                                         Type *optype,
+                                         Subroutine *sub) {
+  if (!optype->equals(_exprtype)) {
+    sub->emit(opcodeCast(optype, _exprtype), lvalue, op);
+    return lvalue;
+  }
+  return op;
+}
+
+std::string GptAsmExpression::opcodeCast(Type* from, Type* to) {
+  if ((from->primitiveType() == PortugolTokenTypes::T_INTEIRO) &&
+      (to->primitiveType() == PortugolTokenTypes::T_REAL)) {
+    return "i2r";
+  }
+
+  if ((from->primitiveType() == PortugolTokenTypes::T_CARACTERE) &&
+      (to->primitiveType() == PortugolTokenTypes::T_LITERAL)) {
+    return "c2s";
+  }
+  throw;
+}

Modified: trunk/gpt2/gptc/src/GptAsmExpression.hpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -1,107 +1,39 @@
-#ifndef GPTASMEXPRESSION_HPP
-#define GPTASMEXPRESSION_HPP
+#ifndef GPT_ASMEXPRESSION_HPP
+#define GPT_ASMEXPRESSION_HPP
 
-#include "PortugolTokenTypes.hpp"
-#include "Types.hpp"
-
-#include <sstream>
 #include <string>
 
+
+class Type;
+class Subroutine;
+
 class GptAsmExpression {
 public:
+  GptAsmExpression(Type* restype, const std::string& value);
 
-  void set(Type* type,
-           int mm,
-           GptAsmExpression* op1,
-           GptAsmExpression* op2) {
+  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*, GptAsmExpression*);
+  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*);
 
-    _mm   = mm;
-    _op1  = op1;
-    _op2  = op2;
-    _type = type;
-  }
+  ~GptAsmExpression();
 
-  void set(const std::string& value, Type* type) {
-    _value = value;
-    _type = type;
-  }
+  void expand(const std::string lvalue, Subroutine* sub);
 
+  bool isAtom();
 
-  void expand(const std::string lvalue, /*const GptAsmSubprogram& ctx*/ int ctx) {
-    //TODO: check for type promotion
-
-    if (isAtom()) {
-      return;
-    }
-
-    std::stringstream code;
-
-    if (_op1->isAtom() && _op2->isAtom()) {
-      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->type(), ctx);
-      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->type(), ctx);
-//       ctx.emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op1->isAtom()) {
-      std::string t2/* = ctx.declareTmp(_op2->type())*/;
-
-      _op2->expand(t2, ctx);
-
-      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->type(), ctx);
-      std::string cp2 = expandCast(lvalue, t2, _op2->type(), ctx);
-
-//       ctx.emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op2->isAtom()) {
-      std::string t1/* = ctx.declareTmp(_op1->type())*/;
-
-      _op1->expand(t1, ctx);
-
-      std::string cp1 = expandCast(lvalue, t1, _op1->type(), ctx);
-      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->type(), ctx);
-
-//       ctx.emit(_mm, lvalue, cp1, cp2);
-
-    } else {
-
-      std::string t1/* = ctx.declareTmp(_op1->type())*/;
-      std::string t2/* = ctx.declareTmp(_op2->type())*/;
-
-      _op1->expand(t1, ctx);
-      _op2->expand(t2, ctx);
-
-      std::string cp1 = expandCast(lvalue, t1, _op1->type(), ctx);
-      std::string cp2 = expandCast(lvalue, t2, _op2->type(), ctx);
-
-//       ctx.emit(_mm, lvalue, cp1, cp2);
-    }
-  }
-
-  bool isAtom() {
-    return _value.length() > 0;
-  }
-
-  const std::string& value() { return _value; }
-  Type*              type()  { return _type; }
+  const std::string& value();
+  Type*              exprtype();
+  Type*              restype();
 private:
+  std::string expandCast(const std::string&,
+                         const std::string&,
+                         Type*, Subroutine*);
 
-  std::string expandCast(const std::string &lvalue,
-                         const std::string& opval,
-                         Type *optype,
-                         /*const GptAsmSubprogram& */ int ctx) {
-    if (optype->equals(PortugolTokenTypes::T_CORINGA)) {
-      return opval;
-    }
+  std::string opcodeCast(Type* from, Type* to);
 
-    if (_type->equals(optype)) {
-      return opval;
-    } else {
-//       ctx.emit(opcodeCast(optype, _type), lvalue, opval);
-      return lvalue;
-    }
-  }
 
-  Type              *_type;
-  int               _mm;
+  Type              *_restype;
+  Type              *_exprtype;
+  std::string       _mm;
   std::string       _value;
   GptAsmExpression  *_op1;
   GptAsmExpression  *_op2;

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-19 00:53:51 UTC (rev 438)
@@ -44,7 +44,7 @@
 											Types.cpp \
 											UnicodeCharBuffer.hpp \
 											UnicodeCharScanner.hpp \
-											GptAsmExpression.hpp \
+											GptAsmExpression.hpp GptAsmExpression.cpp \
 											Arguments.hpp \
 											Arguments.cpp \
 											AsmProgram.hpp AsmProgram.cpp \

Modified: trunk/gpt2/gptc/src/Subroutine.cpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -4,12 +4,13 @@
 using namespace std;
 
 #include "Tools.hpp"
+#include "Types.hpp"
 
-#include "PortugolParserTokenTypes.hpp"
+#include "PortugolTokenTypes.hpp"
 
 
 Subroutine::Subroutine(Options *options, /*CGptAssemblyFile *file,*/ const string &name)
-	: _options(options), _name(name), _lastSourceLine(0)
+	: _options(options), _name(name), _tmpSuffix(1), _lastSourceLine(0)
 {
 	if (_options->sentences) {
 		//_sourceInfo = new SourceInfo();
@@ -29,6 +30,7 @@
 
 void Subroutine::init()
 {
+  _header.writeln();
 	_header.writeln(string("// Procedure ") + _name);
 	_header.writeln("proc " + _name);
 	_header.incTab();
@@ -61,7 +63,7 @@
 }
 
 
-void Subroutine::emitMn(const string &mn, const string &op1, const string &op2, const string &op3)
+void Subroutine::emit(const string &mn, const string &op1, const string &op2, const string &op3)
 {
 	_body.write(mn);
 	if (op1.empty()) {
@@ -86,7 +88,7 @@
 
 void Subroutine::emitMnWithPrefix(const string &mn, const string &var, const string &op1, const string &op2)
 {
-	emitMn(getMnWithPrefix(mn, var), var, op1, op2);
+	emit(getMnWithPrefix(mn, var), var, op1, op2);
 }
 
 
@@ -99,9 +101,7 @@
 void Subroutine::emitAsmCode(const string &code)
 {
 	_body.writeln();
-	_body.writeln("// asm-begin");
 	_body.writeln(code);
-	_body.writeln("// asm-end");
 	_body.writeln();
 }
 
@@ -136,21 +136,33 @@
 }
 */
 
-void Subroutine::emitVarDefinition(const string &name, const string &type)
+void Subroutine::emitVarDefinition(const string &name, Type* type)
 {
-	_header.writeln("var " + name + " " + type);
+	_header.writeln("var " + name + " " + type->asmName());
+
+  if (type->isPrimitive() && type->equals(PortugolTokenTypes::T_LITERAL)) {
+    _prologue.writeln("salloc " + name);
+  }
 }
 
-
-void Subroutine::emitParDefinition(const string &name, const string &type)
+void Subroutine::emitParDefinition(const string &name, Type* type)
 {
-	_header.writeln("par " + name + " " + type);
+	_header.writeln("par " + name + " " + type->asmName());
 }
 
+string Subroutine::declareTmp(Type* type) {
+  std::stringstream s;
+  s << "tmp" << _tmpSuffix++;
+ 
+  std::string name = s.str();
+  emitVarDefinition(name, type);
+  return name;
+}
 
 string Subroutine::getCode() const
 {
-	return _header.getText() + _body.getText() + _footer.getText();
+	return _header.getText() + _prologue.getText() 
+         + _body.getText() + _footer.getText();
 }
 
 

Modified: trunk/gpt2/gptc/src/Subroutine.hpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -13,6 +13,7 @@
 
 using namespace std;
 
+class Type;
 
 class Subroutine
 {
@@ -22,7 +23,7 @@
 	void init();
 	void finish();
 	void emitPUSHMn(const string &symbol, const bool &pushType = false);
-	void emitMn(const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
+	void emit(const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
 	void emitMnWithPrefix(const string &mn, const string &var, const string &op1 = "", const string &op2 = "");
 
 	void emitLabel(const string &label);
@@ -36,16 +37,20 @@
 	{
 		return _name;
 	}
-	void emitVarDefinition(const string &name, const string &type);
-	void emitParDefinition(const string &name, const string &type);
+	void emitVarDefinition(const string &name, Type* type);
+	void emitParDefinition(const string &name, Type* type);
 	string getCode() const;
+
+  string declareTmp(Type* type);
 private:
 	string getMnWithPrefix(const string &mn, const string &var);
 	Options *_options;
 	vector<string> _params;
 	int _lastSourceLine;
 	string _name;
+  int    _tmpSuffix;
 	TextFile _header;
+  TextFile _prologue;
 	TextFile _body;
 	TextFile _footer;
 };

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -111,7 +111,7 @@
 }
 
 std::string Symbol::identifier() const {
-  return _identifier;
+  return "_" + _identifier;
 }
 
 

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -2,96 +2,9 @@
 #include "TokenLabels.hpp"
 
 #include <iostream>
+#include <sstream>
 
-// Type::StructField::StructField(const std::string& n, Type* t)
-//       : _name(n), _type(t) {
-// }
 
-// bool
-// Type::StructField::isLValueFor(const Type::StructField& other) const {
-//   return _name == other._name && _type->isLValueFor(other._type);
-// }
-
-// bool
-// Type::StructField::operator==(const Type::StructField& other) const {
-//   return _name == other._name && _type->equals(other._type);
-// }
-//
-// Type* Type::StructField::type() const {
-//   return _type;
-// }
-//
-// const std::string& Type::StructField::name() const {
-//   return _name;
-// }
-//
-//
-// bool
-// Type::StructFieldList::isLValueFor(const Type::StructFieldList& other) const {
-//   if (size() != other.size()) {
-//     return false;
-//   }
-//   const_iterator it, jt;
-//   bool found;
-//   for (it = begin(); it != end(); ++it) {
-//     found = false;
-//     for (jt = other.begin(); jt != other.end(); ++jt) {
-//       if ((*it).isLValueFor(*jt)) {
-//         found = true;
-//       }
-//     }
-//     if (!found) {
-//       return false;
-//     }
-//   }
-//   return true;
-// }
-//
-// bool
-// Type::StructFieldList::operator==(const Type::StructFieldList& other) const {
-//   if (size() != other.size()) {
-//     return false;
-//   }
-//   const_iterator it, jt;
-//   bool found;
-//   for (it = begin(); it != end(); ++it) {
-//     found = false;
-//     for (jt = other.begin(); jt != other.end(); ++jt) {
-//       if ((*it) == (*jt)) {
-//         found = true;
-//       }
-//     }
-//     if (!found) {
-//       return false;
-//     }
-//   }
-//   return true;
-// }
-//
-//
-// Type::StructFieldList::const_iterator
-// Type::StructFieldList::find(const std::string& name) const {
-//   const_iterator it;
-//   for (it = begin(); it != end(); ++it) {
-//     if ((*it).name() == name) {
-//       return it;
-//     }
-//   }
-//   return end();
-// }
-//
-// std::string Type::StructFieldList::toString() const {
-//   std::string ret = "{";
-//   std::string v = "";
-//   const_iterator it;
-//   for (it = begin(); it != end(); ++it) {
-//     ret += v + (*it).name() + ":" + (*it).type()->name();
-//     v = ", ";
-//   }
-//   ret += "}";
-//   return ret;
-// }
-
 //************* GENERAL *********************************/
 
 void Type::setConst(bool c) {
@@ -150,7 +63,9 @@
   return _name;
 }
 
-std::string Type::asmName() const {
+std::string Type::asmName(bool complete) const {
+  std::stringstream stream;
+
   switch (_typeId) {
     case PRIMITIVE:
       switch (_id) {
@@ -171,7 +86,12 @@
     case MATRIX:
       return "matrix";
     case STRUCT:
-      return "data";
+      if (!complete) {
+        return "data";
+      } else {
+        stream << "data[" << byteSize() << "]";
+        return stream.str();
+      }
     default:
       throw;
   }
@@ -181,6 +101,35 @@
   return _identifier;
 }
 
+int Type::byteSize() const {
+  int ret = 0;
+  switch (_typeId) {
+    case PRIMITIVE:
+      switch(primitiveType()) {
+        case T_INTEIRO:    
+        case T_CARACTERE:
+        case T_LITERAL:
+        case T_LOGICO:
+        case T_CORINGA:
+          return sizeof(int);
+        case T_REAL:
+          return sizeof(double);
+        default:
+          throw;
+      }
+    case MATRIX:
+      return sizeof(void*);
+    case STRUCT:      
+      for (SymbolList::const_iterator it = _fields.begin(); it != _fields.end(); ++it) {
+        ret += (*it).type()->byteSize();
+      }
+      return ret;
+    case SUBPROGRAM:
+    default:
+      throw;
+  }
+}
+
 bool Type::equals(int id) const {
   return isPrimitive() && (_id == id);
 }
@@ -301,6 +250,7 @@
   return NULL;
 }
 
+
 Type* Type::primitive_attrPromotion(Type* other) {
   if (!other->isPrimitive()) {
     return NULL;
@@ -436,7 +386,7 @@
     _name(name), _identifier(name), _anonymous(false), _fields(fields),
     _unit(unit), _line(line) {
 
-  _name = _identifier + ":{";
+  _name = _name + ":{";
   std::string v = "";
   for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
     _name += v + (*it).lexeme() + ":" + (*it).type()->name();
@@ -448,7 +398,8 @@
 
 Type::Type(TypeBuilder* builder, const SymbolList& fields)
   : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name("<an?nimo>"), _anonymous(true), _fields(fields),
+    _name("<an?nimo>"), _identifier("_an?nimo_"), 
+    _anonymous(true), _fields(fields),
     _unit("<interno>"), _line(-1) {
 
   _name += ":{";

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -46,6 +46,7 @@
   Type* intOrReal(Type* other);
   Type* caracOrLit(Type* other);
 
+
   //Matrix
   Type(TypeBuilder*, Type* ofType, const std::list<int>& dimensions);
 
@@ -86,9 +87,11 @@
   bool isSubprogram() const;
 
   const std::string& name() const;
-  std::string asmName() const;
+  std::string asmName(bool = false) const;
   const std::string& identifier() const;
 
+  int byteSize() const;
+
   bool equals(int id) const;
   bool equals(Type* ofType, int dimensions) const;
 

Modified: trunk/gpt2/gptc/src/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm.g	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/gptasm.g	2007-12-19 00:53:51 UTC (rev 438)
@@ -22,6 +22,8 @@
   #include "BaseGptAsmWalker.hpp"
   #include "PortugolAST.hpp"
   #include "GptAsmExpression.hpp"
+  #include "AsmProgram.hpp"
+  #include "SymbolTable.hpp"
 }
 
 options {
@@ -51,10 +53,11 @@
 
         (declaracoes)?
 
-//         (corpo)?
-
+        (corpo)?
+                                {_asmPrg->finishSubroutine(_subroutine);}
         EOF
      )
+                                {_asmPrg->finish();}
   ;
 
 importacao
@@ -74,9 +77,9 @@
   : #(T_VARIAVEL tipo ids=identificadores
                                           {
                                             if (isLocal) {
+                                              declareSubroutineVars(ids);
+                                            } else {
                                               declareProgramVars(ids);
-                                            } else {
-                                              declareSubroutineVars(ids);
                                             }
                                           }
 //       (
@@ -92,9 +95,9 @@
 
                                           {
                                             if (isLocal) {
+                                              declareSubroutineVars(ids);
+                                            } else {
                                               declareProgramVars(ids);
-                                            } else {
-                                              declareSubroutineVars(ids);
                                             }
                                           }
   ;
@@ -139,93 +142,110 @@
 /************************** EXPRESSOES *************************/
 
 
-expressao [const std::string& lvalue]
+expressao returns [GptAsmExpression* ret]
 
-                                      {GptAsmExpression ret;}
   : #(T_EXPRESSAO ret=expr)
-                                      {ret.expand(lvalue,1/*_subroutine*/);}
   ;
 
-expr returns [GptAsmExpression ret]
+expr returns [GptAsmExpression* ret]
 
-                        {GptAsmExpression l, r;}
+                        {
+                          GptAsmExpression *l, *r;
+                          Type *optype = _t->getEvalType();
+                        }
 
-//   : #(T_OU              l=expr r=expr) {expr_OU(ret, l, r);}
-//   | #(T_E               l=expr r=expr) {expr_E(ret, l, r);}
-//   | #(T_BIT_OU          l=expr r=expr) {expr_BIT_OU(ret, l, r);}
-//   | #(T_BIT_OUX         l=expr r=expr) {expr_BIT_XOU(ret, l, r);}
-//   | #(T_BIT_E           l=expr r=expr) {expr_BIT_E(ret, l, r);}
-//   | #(T_IGUAL           l=expr r=expr) {expr_IGUAL(ret, l, r);}
-//   | #(T_DIFERENTE       l=expr r=expr) {expr_DIFERENTE(ret, l, r);}
-//   | #(T_MAIOR           l=expr r=expr) {expr_MAIOR(ret, l, r);}
-//   | #(T_MENOR           l=expr r=expr) {expr_MENOR(ret, l, r);}
-//   | #(T_MAIOR_EQ        l=expr r=expr) {expr_MAIOR_EQ(ret, l, r);}
-//   | #(T_MENOR_EQ        l=expr r=expr) {expr_MENOR_EQ(ret, l, r);}
-//   | #(T_BIT_SHIFT_LEFT  l=expr r=expr) {expr_BIT_SHIFT_LEFT(ret, l, r);}
-//   | #(T_BIT_SHIFT_RIGHT l=expr r=expr) {expr_BIT_SHIFT_RIGHT(ret, l, r);}
-  : #(T_MAIS            l=expr r=expr) {expr_MAIS(ret, l, r);}
-//   | #(T_MENOS           l=expr r=expr) {expr_MENOS(ret, l, r);}
-//   | #(T_DIV             l=expr r=expr) {expr_DIV(ret, l, r);}
-//   | #(T_MULTIP          l=expr r=expr) {expr_MULTIP(ret, l, r);}
-//   | #(T_MOD             l=expr r=expr) {expr_MOD(ret, l, r);}
-//   | #(T_UN_NEGATIVO     l=elemento)  {expr_UN_NEGATIVO(ret,l);}
-//   | #(T_UN_POSITIVO     l=elemento)  {expr_UN_POSITIVO(ret,l);}
-//   | #(T_NAO             l=elemento)  {expr_UN_NAO(ret,l);}
-//   | #(T_BIT_NAO         l=elemento)  {expr_BIT_NAO(ret,l);}
+  : #(T_OU              l=expr r=expr) {ret=expr_OU(optype, l, r);}
+  | #(T_E               l=expr r=expr) {ret=expr_E(optype, l, r);}
+  | #(T_BIT_OU          l=expr r=expr) {ret=expr_BIT_OU(optype, l, r);}
+  | #(T_BIT_OUX         l=expr r=expr) {ret=expr_BIT_XOU(optype, l, r);}
+  | #(T_BIT_E           l=expr r=expr) {ret=expr_BIT_E(optype, l, r);}
+  | #(T_IGUAL           l=expr r=expr) {ret=expr_IGUAL(optype, l, r);}
+  | #(T_DIFERENTE       l=expr r=expr) {ret=expr_DIFERENTE(optype, l, r);}
+  | #(T_MAIOR           l=expr r=expr) {ret=expr_MAIOR(optype, l, r);}
+  | #(T_MENOR           l=expr r=expr) {ret=expr_MENOR(optype, l, r);}
+  | #(T_MAIOR_EQ        l=expr r=expr) {ret=expr_MAIOR_EQ(optype, l, r);}
+  | #(T_MENOR_EQ        l=expr r=expr) {ret=expr_MENOR_EQ(optype, l, r);}
+  | #(T_BIT_SHIFT_LEFT  l=expr r=expr) {ret=expr_BIT_SHIFT_LEFT(optype, l, r);}
+  | #(T_BIT_SHIFT_RIGHT l=expr r=expr) {ret=expr_BIT_SHIFT_RIGHT(optype, l, r);}
+  | #(T_MAIS            l=expr r=expr) {ret=expr_MAIS(optype, l, r);}
+  | #(T_MENOS           l=expr r=expr) {ret=expr_MENOS(optype, l, r);}
+  | #(T_DIV             l=expr r=expr) {ret=expr_DIV(optype, l, r);}
+  | #(T_MULTIP          l=expr r=expr) {ret=expr_MULTIP(optype, l, r);}
+  | #(T_MOD             l=expr r=expr) {ret=expr_MOD(optype, l, r);}
+  | #(T_UN_NEGATIVO     l=elemento)  {ret=expr_UN_NEGATIVO(optype,l);}
+  | #(T_UN_POSITIVO     l=elemento)  {ret=expr_UN_POSITIVO(optype,l);}
+  | #(T_NAO             l=elemento)  {ret=expr_UN_NAO(optype,l);}
+  | #(T_BIT_NAO         l=elemento)  {ret=expr_BIT_NAO(optype,l);}
   | ret=elemento
   ;
 
 
-elemento returns [GptAsmExpression ret]
-                      {std::string r;}
+elemento returns [GptAsmExpression* ret]
+                      {
+                        Symbol lv;
+                      }
   : ret=literal
-  | r=lvalue
+  | lv=lvalue         {ret = new GptAsmExpression(lv.type(), lv.identifier());}
 //   | ret=chamada_subrotina
-  | expressao[r]
+  | #(T_EXPRESSAO ret=expr)
   ;
 
-literal returns [GptAsmExpression ret]
+literal returns [GptAsmExpression* ret]
 
-  : l:T_TEXTO_LITERAL          {/*ret.set(l->getText());*/}
-  | i:T_INTEIRO_LITERAL        {/*ret.set(i->getText());*/}
-  | r:T_REAL_LITERAL           {/*ret.set(r->getText());*/}
-  | c:T_CARACTERE_LITERAL      {/*ret.set(c->getText());*/}
-  | v:T_VERDADEIRO             {/*ret.set(v->getText());*/}
-  | f:T_FALSO                  {/*ret.set(f->getText());*/}
+                                    {
+                                      Type *type = _t->getEvalType();
+                                      std::string value;
+                                    }
+
+  : (   t:T_TEXTO_LITERAL           {value = '"' + t->getText() + '"';}
+      | i:T_INTEIRO_LITERAL         {value = i->getText();}
+      | r:T_REAL_LITERAL            {value = r->getText();}
+      | c:T_CARACTERE_LITERAL       {value = "'" + c->getText() + "'";}
+      | v:T_VERDADEIRO              {value = "true";}
+      | f:T_FALSO                   {value = "false";}
+    )
+      {ret = new GptAsmExpression(type, value);}
   ;
 
 
-lvalue returns [std::string lv]
+lvalue returns [Symbol ret]
 
-                                      {std::string offset;}
+  : #(lv:T_LVALUE 
+      id:T_IDENTIFICADOR  
 
-  : #(id:T_IDENTIFICADOR              {lv = id->getText();}
-      (offset=lvalue_indices[lv]      {lv += ":" + offset;})?
-//       (lvalue_membro)?
+                     {ret = _symtable->getSymbol(id->getText());}
+
+//       (
+//_subroutine->declareTmp(lv->getEvalType());
+//         lvalue_indices[lv]
+//       )?
+
+//       (
+//         lvalue_membro
+//       )?
     )
-                
   ;
 
 
-lvalue_indices[const std::string id] returns [std::string ret]
+lvalue_indices[const std::string id]
                                 {
                                   std::list<std::string> dimensions;
-                                  std:string tmp;
+                                  std::string tmp;
                                 }
   : #(T_SUBSCRITO
         (
                                 {/*tmp = _subroutine->newTmp();*/}
-          expressao[tmp]
+          expressao
                                 {dimensions.push_back(tmp);}
         )+
     )
-                                {ret = expandOffset(id, dimensions);}
+//                                 {ret = expandOffset(id, dimensions);}
   ;
 
 
-// lvalue_membro
-//   : #(T_MEMBRO lvalue)
-//   ;
+lvalue_membro
+  : #(T_MEMBRO lvalue)
+  ;
 
 
 
@@ -234,37 +254,48 @@
 
 
 
-// corpo
-//   :  corpo_subprograma      (corpo)?
-//   |  bloco_codigo           (corpo_subprograma)*
-//   ;
-// 
-// 
-// bloco_codigo
-//   : #(T_INICIO lista_enunciados)
-//   ;
-// 
-// lista_enunciados
-//   : (enunciado)*
-//   ;
-// 
-// enunciado
-//   : en_atribuicao
-// /*  | en_retorne
-//   | en_se
-//   | en_enquanto
-//   | en_repita
-//   | en_para
-//   | en_caso
-//   | T_SAIR
-//   | chamada_subrotina*/
-//   ;
-// 
-// en_atribuicao
-//                       {std::string lv;}
-//   : #(T_ATRIBUICAO
-//         lv=lvalue      //x / x:offset
-//         expressao[lv]
-//       )
-//   ;
+corpo
+  :  bloco_codigo           /*(corpo_subprograma)**/
+//   |  corpo_subprograma      (corpo)?
+  ;
 
+bloco_codigo
+  : #(T_INICIO lista_enunciados)
+  ;
+
+lista_enunciados
+  : (enunciado)*
+  ;
+
+enunciado
+  : en_atribuicao
+/*  | en_retorne
+  | en_se
+  | en_enquanto
+  | en_repita
+  | en_para
+  | en_caso
+  | T_SAIR
+  | chamada_subrotina*/
+  ;
+
+en_atribuicao
+                      {
+                        Symbol lv;
+                        GptAsmExpression *expr;
+                      }
+  : #(T_ATRIBUICAO
+        lv=lvalue
+
+        expr=expressao
+                      {                        
+                        if (expr->isAtom()) {
+                          emitAttribution(lv, expr->value());
+                        } else {
+                          expr->expand(lv.identifier(), _subroutine);
+                        }
+                        delete expr;
+                      }
+      )
+  ;
+

Modified: trunk/gpt2/gptc/src/main.cpp
===================================================================
--- trunk/gpt2/gptc/src/main.cpp	2007-12-19 00:53:24 UTC (rev 437)
+++ trunk/gpt2/gptc/src/main.cpp	2007-12-19 00:53:51 UTC (rev 438)
@@ -90,14 +90,22 @@
   SemanticWalker semantic(symtable, fname);
   semantic.programa(ast);
 
+  std::cerr << "semantic.g AST:\n";
+  std::cerr << ast->toStringList() << std::endl << std::endl;
+
   GptAsmWalker code(symtable, fname);
   code.programa(ast);
+
+  
+  std::cerr << "\n\n===\n\n" << code.getCode() << std::endl << std::endl;
+
 }
 
 int main(int argc, char** argv) {
 
   if (argc == 2) {
     all(argv[1]);
+    return 0;
   }
 
   if (argc < 3) {



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:54:18 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:54:18 +0100
Subject: [gpt-commit] r439 - trunk/gpt2/gptc/test/tests
Message-ID: <200712190054.lBJ0sIQW021447@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:54:18 +0100 (Wed, 19 Dec 2007)
New Revision: 439

Modified:
   trunk/gpt2/gptc/test/tests/ast.test
Log:
nomsg

Modified: trunk/gpt2/gptc/test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/test/tests/ast.test	2007-12-19 00:53:51 UTC (rev 438)
+++ trunk/gpt2/gptc/test/tests/ast.test	2007-12-19 00:54:18 UTC (rev 439)
@@ -127,7 +127,7 @@
   ast: (T_ALGORITMO
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR (T_VAL_ESTRUTURA
-                        T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                        T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))
                         T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))))
 fim
 
@@ -160,7 +160,7 @@
             T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_VERDADEIRO))))))
 fim
@@ -180,7 +180,7 @@
             T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_TEXTO_LITERAL))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_VERDADEIRO))))))
 fim
@@ -202,8 +202,8 @@
           (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO) T_IDENTIFICADOR
            (T_VALOR
              (T_VAL_MATRIZ
-                (T_EXPRESSAO  T_CARACTERE_LITERAL) 
-                (T_EXPRESSAO  T_CARACTERE_LITERAL) 
+                (T_EXPRESSAO  T_CARACTERE_LITERAL)
+                (T_EXPRESSAO  T_CARACTERE_LITERAL)
                 (T_EXPRESSAO  T_CARACTERE_LITERAL))))
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR))
 fim
@@ -248,7 +248,7 @@
             T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))))))
 fim
@@ -277,11 +277,11 @@
                T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                (T_VALOR
                   (T_VAL_MATRIZ
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                      (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                      (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))))))
 fim
 
 
@@ -313,11 +313,11 @@
                          T_INTEIRO_LITERAL)
                T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                (T_VALOR (T_VAL_MATRIZ
-                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                      (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                      (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))))))
 fim
 
 
@@ -361,7 +361,7 @@
           (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA
-                T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))
                 T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
 fim
 
@@ -424,7 +424,7 @@
              T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL))))))
 fim
@@ -449,13 +449,13 @@
              T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_MATRIZ
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
                     (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA
-                T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)
+                T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))
                 T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
 fim
 
@@ -485,7 +485,7 @@
               T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
               (T_VALOR
                 (T_VAL_MATRIZ
-                  (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                   (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                   (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))))
 fim
@@ -614,11 +614,11 @@
                             T_INTEIRO_LITERAL)
                   T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
                   (T_VALOR (T_VAL_MATRIZ
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))
                         (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_CARACTERE_LITERAL))
                         (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_REAL_LITERAL)))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR))))
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR)))))
             (T_INICIO)))
 fim
 
@@ -642,7 +642,7 @@
   ast: (T_ALGORITMO
          (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
          (T_INICIO
-            (T_ATRIBUICAO T_IDENTIFICADOR
+            (T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR)
               (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))))
 fim
 
@@ -655,7 +655,7 @@
 
   ast: (T_ALGORITMO
          (T_INICIO
-            (T_ATRIBUICAO T_IDENTIFICADOR
+            (T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR)
               (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL
                 (T_MULTIP T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))))
 fim
@@ -680,10 +680,10 @@
   ast:
     (T_ALGORITMO
       (T_INICIO
-        (T_PARA T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
-          (T_PARA T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
+        (T_PARA (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
+          (T_PARA (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL) (T_EXPRESSAO T_INTEIRO_LITERAL)
                 ( T_PASSO T_MENOS T_INTEIRO_LITERAL )
-            ( T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+            ( T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL))))))
 fim
 
 teste
@@ -702,13 +702,13 @@
     (T_ALGORITMO
       (T_INICIO
         (T_ENQUANTO
-          (T_EXPRESSAO (T_MAIOR T_IDENTIFICADOR (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
+          (T_EXPRESSAO (T_MAIOR (T_LVALUE T_IDENTIFICADOR) (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
             (T_REPITA
               (T_SE (T_EXPRESSAO (T_DIFERENTE
-                      (T_MOD T_IDENTIFICADOR T_INTEIRO_LITERAL)
+                      (T_MOD (T_LVALUE T_IDENTIFICADOR) T_INTEIRO_LITERAL)
                       (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
-                (T_CALL T_IDENTIFICADOR (T_EXPRESSAO T_IDENTIFICADOR)))
-              T_ATE (T_EXPRESSAO ( T_MAIOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))))
+                (T_CALL T_IDENTIFICADOR (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))))
+              T_ATE (T_EXPRESSAO (T_MAIOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))))
 fim
 
 teste
@@ -730,8 +730,8 @@
         (T_SAIR)
         (T_SE (T_EXPRESSAO T_VERDADEIRO)
           (T_RETORNE (T_EXPRESSAO (T_BIT_SHIFT_RIGHT
-                        (T_IDENTIFICADOR (T_MEMBRO T_IDENTIFICADOR))
-                        (T_IDENTIFICADOR (T_SUBSCRITO (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+                        (T_LVALUE T_IDENTIFICADOR (T_MEMBRO (T_LVALUE T_IDENTIFICADOR)))
+                        (T_LVALUE T_IDENTIFICADOR (T_SUBSCRITO (T_EXPRESSAO T_INTEIRO_LITERAL))))))
           T_SENAO (T_CALL T_IDENTIFICADOR (T_EXPRESSAO (T_MULTIP
                                             (T_EXPRESSAO (T_MAIS T_INTEIRO_LITERAL
                                                                 T_INTEIRO_LITERAL))
@@ -760,16 +760,16 @@
     fim
   }
 
-  ast: 
+  ast:
       (T_ALGORITMO
         (T_INICIO
-          (T_CASO (T_EXPRESSAO T_IDENTIFICADOR)
+          (T_CASO (T_EXPRESSAO (T_LVALUE T_IDENTIFICADOR))
             (T_FACA T_TEXTO_LITERAL
               (T_CALL T_IDENTIFICADOR (T_EXPRESSAO  T_INTEIRO_LITERAL))
-              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
+              (T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL)))
             (T_FACA T_REAL_LITERAL
-              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL)))
+              (T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL)))
             (T_SENAO
-              (T_ATRIBUICAO T_IDENTIFICADOR (T_EXPRESSAO T_INTEIRO_LITERAL))))))
-          
+              (T_ATRIBUICAO (T_LVALUE T_IDENTIFICADOR) (T_EXPRESSAO T_INTEIRO_LITERAL))))))
+
 fim
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 01:54:36 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 01:54:36 +0100
Subject: [gpt-commit] r440 - trunk/gpt2/gptc/test
Message-ID: <200712190054.lBJ0sauG021679@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 01:54:36 +0100 (Wed, 19 Dec 2007)
New Revision: 440

Added:
   trunk/gpt2/gptc/test/Makefile.am
Log:
nomsg

Added: trunk/gpt2/gptc/test/Makefile.am
===================================================================
--- trunk/gpt2/gptc/test/Makefile.am	2007-12-19 00:54:18 UTC (rev 439)
+++ trunk/gpt2/gptc/test/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
@@ -0,0 +1,44 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/test -I$(top_srcdir)/src -I../src
+
+bin_PROGRAMS = tester
+tester_LDADD = $(top_builddir)/src/libgptc.la $(ANTLR_LIB)
+
+EXTRA_DIST = compiler_test.g
+
+
+BUILT_SOURCES = LangTestLexer.hpp \
+                LangTestLexer.cpp \
+                LangTestParser.hpp \
+                LangTestParser.cpp \
+                testTokenNames.hpp
+
+
+tester_SOURCES = tester.cpp \
+                 TestAST.hpp \
+                 TestAST.cpp \
+                 $(BUILT_SOURCES)
+
+
+CLEANFILES = LangTestLexer.cpp \
+             LangTestLexer.hpp \
+             LangTestTokenTypes.hpp \
+             LangTestTokenTypes.txt \
+             LangTestParser.cpp \
+						 LangTestParser.hpp  \
+             LangTestParserTokenTypes.hpp \
+             LangTestParserTokenTypes.txt \
+             tokenNames.hpp
+
+
+LangTestLexer.cpp LangTestLexer.hpp LangTestParser.hpp LangTestParser.cpp: \
+     Makefile $(srcdir)/compiler_test.g
+	$(ANTLR_BIN) $(srcdir)/compiler_test.g
+
+testTokenNames.hpp: Makefile
+	echo "std::map<int, std::string > testTokenNames;"  > $@
+	grep = LangTestLexerTokenTypes.txt >> $@
+	sed -i -e 's/([^=]*)//' $@
+	sed -i -e 's/"[^"]*"//' $@
+	sed -i -e 's/==/=/' $@
+	sed -i -e 's/()//' $@
+	sed -i -e 's/\([^=]*\)=\(.*\)/testTokenNames[\2]="\1";/' $@



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 03:08:45 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 03:08:45 +0100
Subject: [gpt-commit] r441 - in trunk/gpt2/gptc: . src src/common
	src/gptasm_target src/parser src/semantic src/symboltable test tmp
Message-ID: <200712190208.lBJ28jFT029671@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 03:08:43 +0100 (Wed, 19 Dec 2007)
New Revision: 441

Added:
   trunk/gpt2/gptc/src/common/
   trunk/gpt2/gptc/src/common/CompilerError.cpp
   trunk/gpt2/gptc/src/common/CompilerError.hpp
   trunk/gpt2/gptc/src/common/Makefile.am
   trunk/gpt2/gptc/src/common/PortugolAST.cpp
   trunk/gpt2/gptc/src/common/PortugolAST.hpp
   trunk/gpt2/gptc/src/gptasm_target/
   trunk/gpt2/gptc/src/gptasm_target/Arguments.cpp
   trunk/gpt2/gptc/src/gptasm_target/Arguments.hpp
   trunk/gpt2/gptc/src/gptasm_target/AsmProgram.cpp
   trunk/gpt2/gptc/src/gptasm_target/AsmProgram.hpp
   trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/gptasm_target/Context.cpp
   trunk/gpt2/gptc/src/gptasm_target/Context.hpp
   trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.cpp
   trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/gptasm_target/Makefile.am
   trunk/gpt2/gptc/src/gptasm_target/Options.hpp
   trunk/gpt2/gptc/src/gptasm_target/Subroutine.cpp
   trunk/gpt2/gptc/src/gptasm_target/Subroutine.hpp
   trunk/gpt2/gptc/src/gptasm_target/TextFile.cpp
   trunk/gpt2/gptc/src/gptasm_target/TextFile.hpp
   trunk/gpt2/gptc/src/gptasm_target/Tools.cpp
   trunk/gpt2/gptc/src/gptasm_target/Tools.hpp
   trunk/gpt2/gptc/src/gptasm_target/gptasm.g
   trunk/gpt2/gptc/src/parser/
   trunk/gpt2/gptc/src/parser/Makefile.am
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/src/parser/lexer.g
   trunk/gpt2/gptc/src/parser/parser.g
   trunk/gpt2/gptc/src/semantic/
   trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic/Makefile.am
   trunk/gpt2/gptc/src/semantic/semantic.g
   trunk/gpt2/gptc/src/symboltable/
   trunk/gpt2/gptc/src/symboltable/Makefile.am
   trunk/gpt2/gptc/src/symboltable/Symbol.cpp
   trunk/gpt2/gptc/src/symboltable/Symbol.hpp
   trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/symboltable/Types.cpp
   trunk/gpt2/gptc/src/symboltable/Types.hpp
Removed:
   trunk/gpt2/gptc/src/Arguments.cpp
   trunk/gpt2/gptc/src/Arguments.hpp
   trunk/gpt2/gptc/src/AsmProgram.cpp
   trunk/gpt2/gptc/src/AsmProgram.hpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/CompilerError.cpp
   trunk/gpt2/gptc/src/CompilerError.hpp
   trunk/gpt2/gptc/src/Context.cpp
   trunk/gpt2/gptc/src/Context.hpp
   trunk/gpt2/gptc/src/GptAsmExpression.cpp
   trunk/gpt2/gptc/src/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/Options.hpp
   trunk/gpt2/gptc/src/PortugolAST.cpp
   trunk/gpt2/gptc/src/PortugolAST.hpp
   trunk/gpt2/gptc/src/Subroutine.cpp
   trunk/gpt2/gptc/src/Subroutine.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/TextFile.cpp
   trunk/gpt2/gptc/src/TextFile.hpp
   trunk/gpt2/gptc/src/Tools.cpp
   trunk/gpt2/gptc/src/Tools.hpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
   trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/src/gptasm.g
   trunk/gpt2/gptc/src/lexer.g
   trunk/gpt2/gptc/src/parser.g
   trunk/gpt2/gptc/src/semantic.g
Modified:
   trunk/gpt2/gptc/configure.ac
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptc/test/Makefile.am
   trunk/gpt2/gptc/tmp/tree_teste.gpt
Log:
-Tentando organizar os modulos em diretorios distintos.

Modified: trunk/gpt2/gptc/configure.ac
===================================================================
--- trunk/gpt2/gptc/configure.ac	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/configure.ac	2007-12-19 02:08:43 UTC (rev 441)
@@ -63,8 +63,8 @@
 if test "x${ANTLR_BIN}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr" (ou runantlr) n??o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    O programa "antlr" (ou runantlr) n????o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers????o >= 2.6) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -73,8 +73,8 @@
 if test "x${ANTLR_CFG}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr-config" n??o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    O programa "antlr-config" n????o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers????o >= 2.6) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -89,5 +89,10 @@
 
 AC_CONFIG_FILES([Makefile
                  src/Makefile
+                 src/common/Makefile
+                 src/parser/Makefile
+                 src/semantic/Makefile
+                 src/symboltable/Makefile
+                 src/gptasm_target/Makefile
                  test/Makefile])
 AC_OUTPUT

Deleted: trunk/gpt2/gptc/src/Arguments.cpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,32 +0,0 @@
-#include "Arguments.hpp"
-
-#include "Tools.hpp"
-
-
-Arguments::Arguments( )
-{
-}
-
-void Arguments::init( Subroutine* subroutine, const string &subroutineName )
-{
-	clear();
-	_subroutine     = subroutine;
-	_subroutineName = subroutineName;
-}
-
-void Arguments::emitMnsInSubroutineCall( )
-{
-	iterator argument;
-
-	bool varArgs = _subroutineName == "imprima";
-
-	// se for "imprima" empilha o nro de argumentos e o tipo de cada um
-	// por enquanto imprima eh um caso especial, mas nas proximas versoes isso seria corrigido...
-	for( argument = end() - 1; argument >= begin(); argument-- ) {
-		_subroutine->emitPUSHMn( *argument, varArgs );
-
-	}
-	if (varArgs) {
-		_subroutine->emit( "push", itoa( size( ) ) );
-	}
-}

Deleted: trunk/gpt2/gptc/src/Arguments.hpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Arguments.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,24 +0,0 @@
-#ifndef ARGUMENTS_H
-#define ARGUMENTS_H
-
-#include <vector>
-using namespace std;
-
-#include "Subroutine.hpp"
-
-class Arguments : public vector<string> // usar list :-)
-{
-public:
-	Arguments( );
-	void init( Subroutine* subroutine, const string &subroutineName );
-	void emitMnsInSubroutineCall( );
-	void setSubroutineName( const string &_name ) {
-		_subroutineName = _name;
-	}
-private:
-	string _subroutineName;
-	Subroutine *_subroutine;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/AsmProgram.cpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,85 +0,0 @@
-#include "AsmProgram.hpp"
-
-#include "Tools.hpp"
-
-
-AsmProgram::AsmProgram(Options *options)
-	: _options(options), _context(NULL)
-{
-}
-
-void AsmProgram::init()
-{
-	_asmPrg.writeln("// Programa gerado a partir de " + _options->filename);
-	_asmPrg.writeln("program");
-	_asmPrg.writeln();
-}
-
-void AsmProgram::finish()
-{
-  _asmPrg.writeln();
-	_asmPrg.writeln("end-program");
-}
-
-AsmProgram::~AsmProgram()
-{
-}
-
-Subroutine *AsmProgram::initSubroutine(string name)
-{
-	Subroutine *action = new Subroutine(_options, /*_file,*/ name);
-	action->init();
-
-	return action;
-}
-
-
-void AsmProgram::finishSubroutine(Subroutine *action)
-{
-	action->finish();
-	_asmPrg.write(action->getCode());
-	delete action;
-}
-
-
-/*CContext *AsmProgram::addContext()
-{
-	CContext* context = new CContext();
-	_contexts.push(context);
-	_context = context;
-
-	return context;
-}
-
-
-CContext *AsmProgram::remContext()
-{
-	delete _contexts.top();
-	_contexts.pop();
-	if (_contexts.size() > 0) {
-		_context = _contexts.top();
-		return _contexts.top();
-	} else {
-		_context = NULL;
-		return NULL;
-	}
-}
-
-
-CContext *AsmProgram::getContext()
-{
-	return _context;
-}
-*/
-
-void AsmProgram::emitVarDefinition(const string &name, const string &type)
-{
-	_asmPrg.writeln("var " + name + " " + type);
-}
-
-
-string AsmProgram::getAsm() const
-{
-	return _asmPrg.getText();
-}
-

Deleted: trunk/gpt2/gptc/src/AsmProgram.hpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,33 +0,0 @@
-#ifndef ASM_PROGRAM_H
-#define ASM_PROGRAM_H
-
-#include "Context.hpp"
-#include "Options.hpp"
-
-#include <string>
-#include <stack>
-using namespace std;
-
-class AsmProgram
-{
-public:
-	AsmProgram(Options *options);
-	~AsmProgram();
-	void init();
-	void finish();
-	Subroutine *initSubroutine(string name);
-	void finishSubroutine(Subroutine *subroutine);
-	Context *addContext();
-	Context *remContext();
-	Context *getContext();
-	void emitVarDefinition(const string &name, const string& type);
-	string getAsm() const;
-private:
-	Options *_options;
-	Context *_context;
-	stack<Context*> _contexts;
-	TextFile _asmPrg;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,361 +0,0 @@
-#include "BaseGptAsmWalker.hpp"
-
-#include "SymbolTable.hpp"
-#include "Symbol.hpp"
-#include "AsmProgram.hpp"
-#include "Types.hpp"
-#include "GptAsmExpression.hpp"
-
-BaseGptAsmWalker::BaseGptAsmWalker(SymbolTable* symtable,
-                                   const std::string& filepath)
-  : antlr::TreeParser(), _symtable(symtable), _filepath(filepath) {
-
-  _symtable->setGlobalScope();
-
-  _options.filename = _filepath;
-  _asmPrg = new AsmProgram(&_options);
-
-  _subroutine = _asmPrg->initSubroutine("main");
-}
-
-
-void BaseGptAsmWalker::finishParser() {
-  delete _asmPrg;
-  _asmPrg = NULL;
-}
-
-void BaseGptAsmWalker::declareProgramVars(const std::list<std::string>& ids) {
-  for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    Symbol symbol = _symtable->getSymbol(*it);
-    _asmPrg->emitVarDefinition(symbol.identifier(), symbol.type()->asmName(true));
-
-    if (symbol.type()->isMatrix()) {
-      addMatrixInitialization(symbol);
-    }
-  }
-}
-
-void BaseGptAsmWalker::addMatrixInitialization(const Symbol& symbol) {
-  std::list<int> dims = symbol.type()->dimensions();
-
-  std::stringstream code;
-
-  if (dims.size() == 1) {
-    code << "m1alloc " << symbol.identifier()
-            << ", " << symbol.type()->ofType()->byteSize()
-            << ", " << dims.front();
-  } else if(dims.size() == 2) {
-    code << "m2alloc " << symbol.identifier()
-            << ", " << symbol.type()->ofType()->byteSize()
-            << ", " << dims.front()
-            << ", " << *(dims.rbegin());
-  }
-  _subroutine->emitAsmCode(code.str());
-}
-
-
-void BaseGptAsmWalker::declareSubroutineVars(const std::list<std::string>& ids) {
-  for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    _subroutine->emitVarDefinition(
-      *it, _symtable->getSymbol(*it).type());
-  }
-}
-
-void BaseGptAsmWalker::declareParameter(const string& lexeme) {
-  _subroutine->emitParDefinition(
-    lexeme, _symtable->getSymbol(lexeme).type());
-}
-
-int BaseGptAsmWalker::getSymbolType(const string& lexeme) {
-  return _symtable->getSymbol(lexeme).type()->primitiveType();
-}
-
-// std::string BaseGptAsmWalker::expandOffset(const std::string&, const std::list<std::string>&) {
-  //??TODO
-// }
-
-
-void BaseGptAsmWalker::emitAttribution(const Symbol& lv, const std::string& tmp) {
-  switch (lv.type()->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      _subroutine->emit("rset", lv.identifier(), tmp);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      _subroutine->emit("sset", lv.identifier(), tmp);
-      break;
-    case PortugolTokenTypes::T_INTEIRO:
-    case PortugolTokenTypes::T_LOGICO:
-    case PortugolTokenTypes::T_CARACTERE:
-      _subroutine->emit("iset", lv.identifier(), tmp);
-      break;
-    default:
-      throw;
-  }
-}
-
-
-
-
-
-GptAsmExpression* BaseGptAsmWalker::expr_OU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, "lor", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_E(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, "land", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_OU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, "bor", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_XOU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, "bxor", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_E(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, "band", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_IGUAL(Type *optype,
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  
-  //lh e rh tem o mesmo tipo
-  switch (left->restype()->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, left->restype(), "req", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, left->restype(), "seq", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, left->restype(), "ieq", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_DIFERENTE(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  //lh e rh tem o mesmo tipo
-  switch (left->restype()->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, left->restype(), "rne", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, left->restype(), "sne", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, left->restype(), "ine", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIOR(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
-    promType = left->restype()->caracOrLit(right->restype());
-  }
-
-  switch (promType->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, "rgt", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, "sgt", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, promType, "igt", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOR(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
-    promType = left->restype()->caracOrLit(right->restype());
-  }
-
-  switch (promType->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, "rlt", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, "slt", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, promType, "ilt", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIOR_EQ(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
-    promType = left->restype()->caracOrLit(right->restype());
-  }
-
-  switch (promType->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, "rge", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, "sge", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, promType, "ige", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOR_EQ(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  Type *promType;
-  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
-    promType = left->restype()->caracOrLit(right->restype());
-  }
-
-  switch (promType->primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, "rle", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, "sle", left, right);
-      break;
-    default: //inteiro, l?gico, caractere
-      return new GptAsmExpression(optype, promType, "ile", left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_LEFT(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left->restype(), "bshl", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_RIGHT(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left->restype(), "bshr", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIS(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left->restype()->intOrReal(right->restype())) == NULL) {
-    promType = left->restype()->caracOrLit(right->restype());
-  }
-
-  switch (optype->primitiveType()) {
-    case PortugolTokenTypes::T_INTEIRO:
-      return new GptAsmExpression(optype, promType, "isum", left, right);
-      break;
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, "rsum", left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, "ssum", left, right);
-      break;
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOS(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left->restype()->intOrReal(right->restype());
-
-  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, "isub", left, right);
-  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, "rsub", left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_DIV(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left->restype()->intOrReal(right->restype());
-
-  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, "idiv", left, right);
-  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, "rdiv", left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MULTIP(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left->restype()->intOrReal(right->restype());
-
-  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, "imul", left, right);
-  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, "rmul", left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MOD(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left->restype(), "imod", left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_NEGATIVO(Type *optype, 
-                                            GptAsmExpression* term) {
-
-  if (optype->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, term->restype(), "inet", term);
-  } else if (optype->equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, term->restype(), "rneg", term);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_POSITIVO(Type*,GptAsmExpression* term) {
-  return term;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_NAO(Type* optype,GptAsmExpression* term) {
-  return new GptAsmExpression(optype, term->restype(), "not", term);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_NAO(Type* optype,GptAsmExpression* term) {
-  return new GptAsmExpression(optype, term->restype(), "bnot", term);
-}
-
-std::string BaseGptAsmWalker::getCode() {
-  return _asmPrg->getAsm();
-}
-

Deleted: trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,73 +0,0 @@
-#ifndef BASEGPTASMWALKER_HPP
-#define BASEGPTASMWALKER_HPP
-
-#include <antlr/TreeParser.hpp>
-#include <string>
-#include <list>
-
-#include "Options.hpp"
-
-class SymbolTable;
-class Symbol;
-class AsmProgram;
-class Subroutine;
-class GptAsmExpression;
-class Type;
-
-class BaseGptAsmWalker : public antlr::TreeParser {
-public:
-  BaseGptAsmWalker(SymbolTable*, const std::string&);
-
-  std::string getCode();
-
-protected:
-  void finishParser();
-  void declareProgramVars(const std::list<std::string>&);
-  void declareSubroutineVars(const std::list<std::string>&);
-  void declareParameter(const string&);
-  int getSymbolType(const string&);
-
-  void addMatrixInitialization(const Symbol& symbol);
-
-//   std::string expandOffset(const std::string&, const std::list<std::string>&);
-
-  void emitAttribution(const Symbol&, const std::string&);
-
-  GptAsmExpression* expr_OU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_E(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_OU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_XOU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_E(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_IGUAL(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_DIFERENTE(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIOR(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOR(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_SHIFT_LEFT(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_SHIFT_RIGHT(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIS(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOS(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_DIV(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MULTIP(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MOD(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_UN_NEGATIVO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_UN_POSITIVO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_UN_NAO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_BIT_NAO(Type*,GptAsmExpression*);
-
-//   void declareGlobals(const IDList&);
-//   void addPrologue(code);
-//   void initStructMembers(const string&, const IDList&, code);
-
-//   std::string getAsmType(const std::string&);
-
-  SymbolTable                 *_symtable;
-  std::string                  _filepath;
-
-  Options         _options;
-  AsmProgram      *_asmPrg;
-  Subroutine      *_subroutine;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,1005 +0,0 @@
-
-#include "BaseSemanticWalker.hpp"
-#include "PortugolTokenTypes.hpp"
-#include "SymbolTable.hpp"
-#include "Symbol.hpp"
-#include "Types.hpp"
-#include "SymbolTableExceptions.hpp"
-
-#include <iostream>
-#include <sstream>
-#include <fstream>
-
-bool InitMatrixList::hasUniformDimensions() const {
-  const_iterator it;
-  int d = -1;
-  for (it = begin(); it != end(); ++it) {
-    if (d == -1) {
-      d = (*it).first;
-    } else if (d != (*it).first) {
-      return false;
-    }
-  }
-  return true;
-}
-
-Type* InitMatrixList::elementsDivergeFrom(Type* from) const {
-  if (from->isError()) {
-    return NULL;
-  }
-
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    if (!(*it).second->isError() && !from->attrPromotion((*it).second)) {
-      return (*it).second;
-    }
-  }
-  return NULL;
-}
-
-Type* InitMatrixList::evaluatedElementType(Type* from) const {
-  const_iterator it;
-  Type *ret = from;
-  for (it = begin(); it != end(); ++it) {
-    if (!(*it).second->isError()) {
-      ret = ret->attrPromotion((*it).second);
-    }
-  }
-  return ret;
-}
-
-int InitMatrixList::divergentDimensionFrom(int d) const {
-  const_iterator it;
-  for (it = begin(); it != end(); it++) {
-    if (d == (*it).first) {
-      return d;
-    }
-  }
-  return -1;
-}
-
-int InitMatrixList::dimensions() const {
-  return back().first;
-}
-
-/////////////////////////////////////////////////////////////////////
-
-
-
-BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable,
-                                       const std::string& filepath)
- : antlr::TreeParser(),
-  _symtable(symtable),
-  _typeBuilder(symtable->typeBuilder()),
-  _filepath(filepath) {
-
-  buildSourceLines();
-}
-
-void BaseSemanticWalker::buildSourceLines() {
-  std::ifstream fi(_filepath.c_str());
-  std::string line;
-  while (!fi.eof()) {
-    getline(fi, line);
-    _sourcelines.push_back(line);
-  }
-}
-
-void BaseSemanticWalker::useLib(const std::string& lib) {
-  std::cerr << "Using " << lib << std::endl;
-}
-
-Type* BaseSemanticWalker::getStructType(RefPortugolAST node) {
-  try {
-    return _symtable->getType(node->getText());
-  } catch (UndeclaredTypeException e) {
-    report(node->getLine(), node->getColumn(),
-           std::string("tipo indefinido: ") + node->getText());
-    return _typeBuilder->errorType();
-  }
-}
-
-Type* BaseSemanticWalker::getSymbolType(RefPortugolAST node) {
-  try {
-    return
-      _symtable->getSymbol(node->getText()).type();
-  } catch (UndeclaredSymbolException e) {
-    report(node->getLine(), node->getColumn(),
-           std::string("s?mbolo n?o declarado: ") + node->getText());
-    return _typeBuilder->errorType();
-  }
-}
-
-Type* BaseSemanticWalker::getSymbolType(RefPortugolAST parent,
-                                        Type* sttype, RefPortugolAST id) {
-  if (sttype->isError()) {
-    return sttype;
-  }
-
-  if (!sttype->isStruct()) {
-    report(id->getLine(), id->getColumn(), 
-      std::string("'") + parent->getText() + "' n?o ? uma estrutura");
-    return _typeBuilder->errorType();
-  }
-
-  SymbolList::const_iterator it =
-      sttype->fields().findFirstByLexeme(id->getText());
-
-  if (it == sttype->fields().end()) {
-    report(id->getLine(), id->getColumn(),
-        std::string("estrutura '")  + 
-        sttype->name() + "' n?o possui membro '" + id->getText() + "'");
-    return _typeBuilder->errorType();
-  }
-
-  return (*it).type();
-}
-
-
-void BaseSemanticWalker::setCurrentScope(RefPortugolAST id, 
-                                         const SymbolList& params) {
-  _currentScopeSymbol = 
-      _symtable->getSymbol(id->getText(), params.typeList());
-
-  _symtable->setScope(_currentScopeSymbol);
-}
-
-void
-BaseSemanticWalker::checkMatrixDimensions(RefPortugolAST m, 
-                                          const std::list<int>& dimensions) {
-  if (dimensions.size() > 2) {
-    report(m->getLine(), m->getColumn(), 
-      "matrizes com mais de 2 dimens?es n?o s?o suportadas");
-  }
-
-  bool found_null = false;
-  std::list<int>::const_iterator it = dimensions.begin();
-  for (; it != dimensions.end(); ++it) {
-    if (*it == 0) {
-      found_null = true;
-    } else if (found_null) {
-      report(m->getLine(), m->getColumn(), 
-        "somente as ?ltimas dimens?es podem ter o tamanho omitido");
-    }
-  }
-}
-
-Type* BaseSemanticWalker::evalMatrixSubscript(RefPortugolAST id, Type* type,
-                                              int dimensions) {
-
-  if (type->isError()) {
-    return type;
-  }
-
-  if (type->isMatrix() && (type->dimensions().size() >= (unsigned int) dimensions)) {
-    return type->evalTypeFromSubscript(dimensions);
-  } else if (type->isMatrix()) {
-    std::stringstream s;
-    s << id->getText() 
-    << " tem " << type->dimensions().size() 
-    << " dimens?es"; //dimens?o / dimens?es
-    report(id->getLine(), id->getColumn(), s.str());
-  } else {
-    report(id->getLine(), id->getColumn(), "'" + id->getText() + "' n?o ? uma matriz");
-  }
-  return _typeBuilder->errorType();
-}
-
-void  BaseSemanticWalker::evalMatrixSubscriptType(RefPortugolAST exp,Type* type) {
-  if (type->isError()) {
-    return;
-  }
-
-  if (!type->equals(PortugolTokenTypes::T_INTEIRO)) {
-    report(exp->getLine(), exp->getColumn(), 
-      "subscrito da matriz deve ser do tipo inteiro. Encontrado tipo " + type->name());
-  }
-}
-
-void BaseSemanticWalker::declare(const IDList& ids, Type* type) {
-  IDList::const_iterator it;
-  for (it = ids.begin(); it != ids.end(); ++it) {
-    try {
-      _symtable->insertSymbol(
-        Symbol((*it)->getText(),
-              type,
-              _symtable->currentScope(),
-              _symtable->unit(),
-              (*it)->getLine(),
-              (*it)->getColumn()));
-    } catch (RedeclarationException e) {
-      report((*it)->getLine(), (*it)->getColumn(),
-            std::string("redeclara??o: ") + e.symbol().lexeme());
-    }
-  }
-}
-
-void BaseSemanticWalker::declareProc(RefPortugolAST id,
-                                     SymbolList& params) {
-
-  Type *type = 
-    _typeBuilder->subprogramType(
-        params.typeList(), 
-        _typeBuilder->primitiveType(PortugolTokenTypes::T_NULO));
-
-  Symbol s(id->getText(),
-            type,
-            _symtable->globalScope(),
-            _symtable->unit(),
-            id->getLine(),
-            id->getColumn());
-
-  declareProc(s, params);
-}
-
-void BaseSemanticWalker::declareProc(RefPortugolAST id,
-                                     SymbolList& params,
-                                     Type *rettype) {
-
-  Type *type = _typeBuilder->subprogramType(params.typeList(), rettype);
-
-  Symbol s(id->getText(),
-            type,
-            _symtable->globalScope(),
-            _symtable->unit(),
-            id->getLine(),
-            id->getColumn());
-
-  declareProc(s, params);
-
-}
-
-void BaseSemanticWalker::declareProc(const Symbol& s, 
-                                     SymbolList& params) {
-  try {
-    _symtable->insertSymbol(s);
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-           std::string("redeclara??o: ") + e.symbol().lexeme());
-    _symtable->setIgnoreScope();
-    return;
-  }  
-
-  _symtable->setScope(s);
-  params.setScope(s.identifier());
-
-  try {
-    _symtable->insertSymbols(params);
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-           std::string("redeclara??o: ") + e.symbol().lexeme());
-  }  
-}
-
-void BaseSemanticWalker::declareStruct(RefPortugolAST id,
-                                       const SymbolList& fieldList) {
-
-  try {
-    _symtable->insertType(id->getText(), fieldList, id->getLine());
-  } catch (RedefinedTypeException e) {
-    report(id->getLine(), id->getColumn(), 
-        std::string("redefini??o do tipo '") + e.typeName() + "'");
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-        std::string("redeclara??o: ") + e.symbol().lexeme());
-  }
-}
-
-Type* BaseSemanticWalker::evalInitStruct(const InitStructList& stc) {
-  SymbolList flist;
-  InitStructList::const_iterator it;
-  for (it = stc.begin(); it != stc.end(); ++it) {
-    flist.push_back(Symbol(it->first->getText(), 
-                    it->second, 
-                    _symtable->globalScope(), 
-                    _symtable->unit(),
-                    it->first->getLine(),
-                    it->first->getColumn()));
-  }
-  return _typeBuilder->structType(flist);
-}
-
-Type* BaseSemanticWalker::evalInitMatrix(RefPortugolAST node, const InitMatrixList& mtx) {
-  if (!mtx.hasUniformDimensions()) {
-    std::stringstream s;
-    s << "valores da matriz n?o podem ter dimens?es diferentes";
-
-    report(node->getLine(), node->getColumn(), s.str());
-    return _typeBuilder->errorType();
-  }
-
-
-  Type *ptype = mtx.front().second;
-  Type *dtype;
-  if (dtype = mtx.elementsDivergeFrom(ptype)) {
-    report(node->getLine(), node->getColumn(), 
-                 std::string("matriz heterogenea: ")
-                 + ptype->name()
-                 + " e "
-                 + dtype->name());
-    return _typeBuilder->errorType();
-  }
-
-  Type *ret = _typeBuilder->matrixType(
-        mtx.evaluatedElementType(ptype), mtx.dimensions());
-
-  return ret;
-}
-
-
-
-void BaseSemanticWalker::evalAttribution(RefPortugolAST lastId,
-                                         Type* ltype, Type* rtype) {
-  if (ltype->isError() || rtype->isError()) {
-    return;
-  }
-
-  if (!ltype->isLValueFor(rtype)) {
-    report(lastId->getLine(), lastId->getColumn(),
-            string("vari?vel do tipo '") + ltype->name()
-            + "' n?o pode receber valor do tipo '" + rtype->name() + "'");
-  }
-}
-
-void BaseSemanticWalker::evalAttribution(const ExpressionReturn& l,
-                                         const ExpressionReturn& r) {
-  if (l.second->isError() || r.second->isError()) {
-    return;
-  }
-
-  if (!l.second->isLValueFor(r.second)) {
-    report(r.first->getLine(), r.first->getColumn(),
-            "vari?vel do tipo '" + l.second->name()
-            + "' n?o pode receber valor do tipo '" + r.second->name() + "'");
-  }
-}
-
-Type* BaseSemanticWalker::evalCall(RefPortugolAST id,
-                                   const TypeList& paramTypes) {
-  //TODO
-  //-proibicao de consts passados para parametros "ref" sem constness
-
-// - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
-//   -Avaliacao de qtd e tipos de parametros
-
-  if (paramTypes.hasErrorType()) {
-    return _typeBuilder->errorType();
-  }
-
-  try {
-    return 
-      _symtable->getSymbol(id->getText(), paramTypes).type()->returnType();
-  } catch (UndeclaredSymbolException e) {
-    report(id->getLine(), id->getColumn(), 
-        "fun??o n?o encontrada: '" + id->getText() + "'");
-    return _typeBuilder->errorType();
-  } catch (UnmatchedException e) {
-    report(id->getLine(), id->getColumn(),
-           "Fun??o compat?vel com '" + id->getText() 
-           + "(" + paramTypes.toString() + ")' n?o encontrada");
-    return _typeBuilder->errorType();
-  }
-}
-
-void BaseSemanticWalker::evalRetorne(RefPortugolAST ret,Type* type) {
-  if (type->isError()) {
-    return;
-  }
-
-  if (_symtable->isInGlobalScope()) {
-    report(ret->getLine(), ret->getColumn(), 
-        "n?o h? retorno em escopo global");
-  } else if(!_currentScopeSymbol.type()->returnType()->isLValueFor(type)) {
-    report(ret->getLine(), ret->getColumn(), "tipo de retorno (" 
-           + type->name() + ") incompat?vel com tipo da fun??o (" 
-           + _currentScopeSymbol.type()->returnType()->name() +")");
-  }
-}
-
-
-void BaseSemanticWalker::evalCondicional(const ExpressionReturn& ex) {
-  if (ex.second->isError()) {
-    return;
-  }
-
-  if (!ex.second->equals(PortugolTokenTypes::T_LOGICO)) {
-    report(ex.first->getLine(), ex.first->getColumn(),
-      "enunciado exige express?o l?gica. Tipo '" 
-      + ex.second->name() + "' encontrado.");
-  }
-}
-
-/************************ EXPR ********************************************/
-
-  //TODO: refatorar os copy/pastes dos metodos evalExpr
-
-Type*
-BaseSemanticWalker::evalExpr_OU(RefPortugolAST op,Type* left, Type* right) {
-
-//l?gico ou l?gico --> l?gico
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_LOGICO) &&
-      right->equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(), 
-      std::string("ilegal: ") + left->name() + " ou " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-Type*
-BaseSemanticWalker::evalExpr_E(RefPortugolAST op,Type* left, Type* right) {
-
-//l?gico e l?gico --> l?gico
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_LOGICO) &&
-      right->equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(), 
-      std::string("ilegal: ") + left->name() + " e " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_OU(RefPortugolAST op,Type* left, Type* right) {
-
-//inteiro | inteiro --> inteiro
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(), 
-      std::string("ilegal: ") + left->name() + " | " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_OUX(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro ^ inteiro --> inteiro
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " ^ " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_E(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro & inteiro --> inteiro
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " & " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_IGUAL(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro = inteiro --> l?gico
-    * real = real --> l?gico
-    * caractere = caractere --> l?gico
-    * literal = literal --> l?gico
-    * l?gico = l?gico --> l?gico 
-*/
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->isPrimitive() && 
-      !left->equals(PortugolTokenTypes::T_CORINGA) && 
-      left->equals(right)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " = " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_DIFERENTE(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro <> inteiro --> l?gico
-    * real <> real --> l?gico
-    * caractere <> caractere --> l?gico
-    * literal <> literal --> l?gico
-    * l?gico <> l?gico --> l?gico 
-*/
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->isPrimitive() && 
-      !left->equals(PortugolTokenTypes::T_CORINGA) && 
-      left->equals(right)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " <> " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIOR(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro > inteiro --> l?gico
-    * real > real --> l?gico
-    * caractere > caractere --> l?gico 
-    * literal > literal --> l?gico 
-
-    * inteiro > real --> l?gico
-    * real > inteiro --> l?gico 
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if ((left->isPrimitive() && right->isPrimitive()) &&
-          (left->equals(right) || 
-           left->intOrReal(right) || 
-           left->caracOrLit(right))) {
-
-    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
-        right->equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " > " + right->name());
-      return _typeBuilder->errorType();
-    }
-  
-    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
-        right->equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " > " + right->name());
-      return _typeBuilder->errorType();
-    }
-
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " > " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOR(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro < inteiro --> l?gico
-    * real < real --> l?gico
-    * caractere < caractere --> l?gico 
-    * literal < literal --> l?gico 
-
-    * inteiro < real --> l?gico
-    * real < inteiro --> l?gico 
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->intOrReal(right))) {
-
-    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
-        right->equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " < " + right->name());
-      return _typeBuilder->errorType();
-    }
-  
-    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
-        right->equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " < " + right->name());
-      return _typeBuilder->errorType();
-    }
-
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " < " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIOR_EQ(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro >= inteiro --> l?gico
-    * real >= real --> l?gico
-    * caractere >= caractere --> l?gico 
-    * literal >= literal --> l?gico 
-
-    * inteiro >= real --> l?gico
-    * real >= inteiro --> l?gico 
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->intOrReal(right))) {
-
-    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
-        right->equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " >= " + right->name());
-      return _typeBuilder->errorType();
-    }
-  
-    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
-        right->equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " >= " + right->name());
-      return _typeBuilder->errorType();
-    }
-
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " >= " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOR_EQ(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro <= inteiro --> l?gico
-    * real <= real --> l?gico
-    * caractere <= caractere --> l?gico 
-    * literal <= literal --> l?gico 
-
-    * inteiro >= real --> l?gico
-    * real >= inteiro --> l?gico 
-*/
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if ((left->isPrimitive() && right->isPrimitive()) &&
-      (left->equals(right) || left->intOrReal(right))) {
-
-    if (left->equals(PortugolTokenTypes::T_LOGICO) && 
-        right->equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " <= " + right->name());
-      return _typeBuilder->errorType();
-    }
-  
-    if (left->equals(PortugolTokenTypes::T_CORINGA) && 
-        right->equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op->getLine(), op->getColumn(),
-        std::string("ilegal: ") + left->name() + " <= " + right->name());
-      return _typeBuilder->errorType();
-    }
-
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " <= " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro << inteiro --> inteiro
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " << " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro >> inteiro --> inteiro
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " >> " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIS(RefPortugolAST op, Type* left, Type* right) {
-
-/*
-    * inteiro + inteiro --> inteiro
-    * real + real --> real 
-
-    * inteiro + real --> real
-    * real + inteiro --> real
-
-
-    * literal + literal --> literal
-    * caractere + caractere --> literal
-    * literal + caractere --> literal
-    * caractere + literal --> literal 
-
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  Type* ret;
-  if (ret = left->intOrReal(right)) {
-    //int ou real
-    return ret; 
-  } else if (left->caracOrLit(right)) {
-    //sempre literal
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LITERAL);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " + " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOS(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro - inteiro --> inteiro
-    * real - real --> real 
-
-    * inteiro - real --> real
-    * real - inteiro --> real 
-*/
-
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  Type* ret;
-  if (ret = left->intOrReal(right)) {
-    return ret;
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " - " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_DIV(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro / inteiro --> inteiro
-    * real / real --> real 
-
-    * inteiro / real --> real
-    * real / inteiro --> real 
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  Type* ret;
-  if (ret = left->intOrReal(right)) {
-    return ret;
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " / " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MULTIP(RefPortugolAST op, Type* left, Type* right) {
-
-/*
-    * inteiro * inteiro --> inteiro
-    * real * real --> real 
-
-    * inteiro * real --> real
-    * real * inteiro --> real 
-*/
-  if (left->isError() || right->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  Type* ret;
-  if (ret = left->intOrReal(right)) {
-    return ret;
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " * " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MOD(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro % inteiro --> inteiro
-
-  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
-      right->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + left->name() + " % " + right->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-
-Type*
-BaseSemanticWalker::evalExpr_UN_NEGATIVO(RefPortugolAST op, Type* term) {
-/*
-    * - inteiro --> inteiro
-    * - real --> real 
-*/
-  if (term->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (term->equals(PortugolTokenTypes::T_INTEIRO) ||
-      term->equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder->primitiveType(term->primitiveType());
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " - " + term->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_UN_POSITIVO(RefPortugolAST op, Type* term) {
-/*
-    * + inteiro --> inteiro
-    * + real --> real 
-*/
-  if (term->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (term->equals(PortugolTokenTypes::T_INTEIRO) ||
-      term->equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder->primitiveType(term->primitiveType());
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " + " + term->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_NAO(RefPortugolAST op, Type* term) {
-
-//n?o l?gico --> l?gico
-
-  if (term->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (term->equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op->getLine(), op->getColumn(), 
-      std::string("ilegal: ") + " n?o " + term->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_NAO(RefPortugolAST op, Type* term) {
-
-//~ inteiro --> inteiro
-
-  if (term->isError()) {
-    return _typeBuilder->errorType();
-  }
-
-  if (term->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder->primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op->getLine(), op->getColumn(),
-      std::string("ilegal: ") + " ~ " + term->name());
-    return _typeBuilder->errorType();
-  }
-}
-
-
-/********************************************************************/
-
-
-using std::cerr;
-using std::endl;
-
-void BaseSemanticWalker::report(int line, int col, const std::string& msg) {
-  //<file>:<line>: <message>
-  //.............<source code>
-  //...................^
-
-  std::string space = "                ";
-  std::cerr << _filepath << ":" << line << ": " << msg << std::endl;
-  std::cerr << space << _sourcelines.at(line-1) << std::endl;
-
-  for (unsigned int i = 1; i < col + space.length(); i++) {
-    std::cerr << " ";
-  }
-  std::cerr << "^" << std::endl;
-}
-
-void BaseSemanticWalker::report(int line, const std::string& s) {
-  cerr << "linha " << line << " - " << s << endl;
-}

Deleted: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,133 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef BASESEMANTICWALKER_H
-#define BASESEMANTICWALKER_H
-
-#include <antlr/TreeParser.hpp>
-#include <list>
-#include <vector>
-#include <string>
-
-#include "PortugolAST.hpp"
-#include "Symbol.hpp"
-
-class SymbolTable;
-class Type;
-class TypeList;
-class TypeBuilder;
-
-typedef std::list<RefPortugolAST>                IDList;
-
-//list<pair<field, type>>
-typedef std::list<std::pair<RefPortugolAST,Type*> > InitStructList;
-
-typedef std::pair<RefPortugolAST,Type*>  ExpressionReturn;
-
-//list<pair<dimsize,type>>
-class InitMatrixList : public std::list<std::pair<int,Type*> > {
-public:
-  bool              hasUniformDimensions() const;
-  Type*             elementsDivergeFrom(Type*) const;
-  Type*             evaluatedElementType(Type* from) const;
-  int               divergentDimensionFrom(int) const;
-  int               dimensions() const;
-};
-
-class BaseSemanticWalker : public antlr::TreeParser {
-
-public:
-  BaseSemanticWalker(SymbolTable*, const std::string&);
-
-protected:
-  void useLib(const std::string&);
-
-  Type* getStructType(RefPortugolAST);
-
-  Type* getSymbolType(RefPortugolAST);
-
-  Type* getSymbolType(RefPortugolAST,Type*, RefPortugolAST);
-
-  void setCurrentScope(RefPortugolAST id, const SymbolList& params);
-
-  void declare(const IDList&, Type*);
-
-  void declareProc(RefPortugolAST, SymbolList&);
-  void declareProc(RefPortugolAST, SymbolList&, Type*);
-  void declareProc(const Symbol&,  SymbolList&);
-
-//   void defineStruct(RefPortugolAST, const SymbolList&);
-  void declareStruct(RefPortugolAST, const SymbolList& );
-
-
-  void checkMatrixDimensions(RefPortugolAST, const std::list<int>&);
-
-  Type* evalInitStruct(const InitStructList& stc);
-  Type* evalInitMatrix(RefPortugolAST, const InitMatrixList& mtx);
-  
-  Type* evalMatrixSubscript(RefPortugolAST, Type*, int);
-  void  evalMatrixSubscriptType(RefPortugolAST,Type*);
-
-  void evalAttribution(RefPortugolAST,Type*, Type*);
-  void evalAttribution(const ExpressionReturn&, const ExpressionReturn&);
-
-  Type* evalCall(RefPortugolAST id, const TypeList& paramTypes);
-
-  void evalRetorne(RefPortugolAST,Type*);
-
-  void evalCondicional(const ExpressionReturn&);
-
-  Type* evalExpr_OU(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_E(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_OU(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_OUX(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_E(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_IGUAL(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_DIFERENTE(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIOR(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOR(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIOR_EQ(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOR_EQ(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_LEFT(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIS(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOS(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_DIV(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MULTIP(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MOD(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_UN_NEGATIVO(RefPortugolAST,Type*);
-  Type* evalExpr_UN_POSITIVO(RefPortugolAST,Type*);
-  Type* evalExpr_NAO(RefPortugolAST,Type*);
-  Type* evalExpr_BIT_NAO(RefPortugolAST,Type*);
-
-  void buildSourceLines();
-
-  void report(int, int, const std::string&);
-  void report(int, const std::string&);
-  
-
-  SymbolTable*                 _symtable;
-  TypeBuilder*                 _typeBuilder;
-  std::string                  _filepath;
-  std::vector<std::string>     _sourcelines;
-  Symbol                       _currentScopeSymbol;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/CompilerError.cpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/CompilerError.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1 +0,0 @@
- 

Deleted: trunk/gpt2/gptc/src/CompilerError.hpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/CompilerError.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,15 +0,0 @@
-
-/*
-  Cada gramatica deve ter sua ErrorList
-*/
-
-class ErrorList {
-
-};
-
-class CompilerError {
-  void addError(unit, line, errorCode, message);
-  //tips
-  //verbose, etc
-  std::string toString();
-};

Deleted: trunk/gpt2/gptc/src/Context.cpp
===================================================================
--- trunk/gpt2/gptc/src/Context.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Context.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,35 +0,0 @@
-#include "Context.hpp"
-
-Context::Context( ) : _arity(0), lastStoredVar(NULL)//, lastInvocationType(IT_QU)
-{
-}
-
-
-Context::~Context( )
-{
-}
-
-
-void Context::addArg( const char *name, const int &type, const string &indexVar )
-{
-	//arguments.push_back( new CArgument( name, type, indexVar ) );
-}
-
-
-void Context::initArity( const int &value )
-{
-	_arity = value;
-}
-
-
-void Context::addArity( )
-{
-	_arity++;
-}
-
-
-int Context::getArity( )
-{
-	return _arity;
-}
-

Deleted: trunk/gpt2/gptc/src/Context.hpp
===================================================================
--- trunk/gpt2/gptc/src/Context.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Context.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,32 +0,0 @@
-#ifndef CONTEXT_H
-#define CONTEXT_H
-
-#include <string>
-using namespace std;
-
-#include "Arguments.hpp"
-
-class Context
-{
-private:
-	int _arity;
-public:
-	Context( );
-	~Context( );
-	void addArg( const char *name, const int &type = 0, const string &indexVar = "" );
-	void initArity( const int &value = 0 );
-	void addArity( );
-	int getArity( );
-
-	char *lastStoredVar;
-	string label1;
-	string label2;
-	string tempVar1;
-	string tempVar2;
-//	CArguments arguments;
-//	int lastInvocationType;
-//	int blackboardType;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/GptAsmExpression.cpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,128 +0,0 @@
-#include "GptAsmExpression.hpp"
-#include "PortugolTokenTypes.hpp"
-#include "Types.hpp"
-#include "Subroutine.hpp"
-
-#include <sstream>
-#include <map>
-
-GptAsmExpression::GptAsmExpression(Type* restype,
-                                   const std::string& value) 
-  : _restype(restype), _exprtype(0), _mm(""), _value(value), _op1(0), _op2(0) {
-}
-
-GptAsmExpression::GptAsmExpression(Type* restype, Type *exprtype,
-                                   std::string mm, GptAsmExpression* op1)
-  : _restype(restype), _exprtype(exprtype),
-    _mm(mm), _value(""), _op1(op1), _op2(0) {
-}
-
-GptAsmExpression::GptAsmExpression(Type* restype,
-                   Type *exprtype,
-                   std::string mm,
-                   GptAsmExpression* op1,
-                   GptAsmExpression* op2) 
-  : _restype(restype), _exprtype(exprtype),
-    _mm(mm), _value(""), _op1(op1), _op2(op2) {
-}
-
-
-GptAsmExpression::~GptAsmExpression() {
-  delete _op1;
-  delete _op2;
-}
-
-void GptAsmExpression::expand(const std::string lvalue, Subroutine* sub) {
-  if (isAtom()) {
-    return;
-  }
-
-  if (!_op2) {
-    if (_op1->isAtom()) {
-      sub->emit(_mm, lvalue, _op1->value());
-    } else {
-      std::string t1 = sub->declareTmp(_op1->restype());
-      _op1->expand(t1, sub);
-      sub->emit(_mm, lvalue, t1);
-    }
-  } else {
-    if (_op1->isAtom() && _op2->isAtom()) {
-      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->restype(), sub);
-      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->restype(), sub);
-      sub->emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op1->isAtom()) {
-      std::string t2 = sub->declareTmp(_op2->restype());
-
-      _op2->expand(t2, sub);
-
-      std::string cp1 = expandCast(lvalue, _op1->value(), _op1->restype(), sub);
-      std::string cp2 = expandCast(lvalue, t2, _op2->restype(), sub);
-
-      sub->emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op2->isAtom()) {
-      std::string t1 = sub->declareTmp(_op1->restype());
-  
-      _op1->expand(t1, sub);
-  
-      std::string cp1 = expandCast(lvalue, t1, _op1->restype(), sub);
-      std::string cp2 = expandCast(lvalue, _op2->value(), _op2->restype(), sub);
-  
-      sub->emit(_mm, lvalue, cp1, cp2);
-  
-    } else {
-  
-      std::string t1 = sub->declareTmp(_op1->restype());
-      std::string t2 = sub->declareTmp(_op2->restype());
-  
-      _op1->expand(t1, sub);
-      _op2->expand(t2, sub);
-  
-      std::string cp1 = expandCast(lvalue, t1, _op1->restype(), sub);
-      std::string cp2 = expandCast(lvalue, t2, _op2->restype(), sub);
-  
-      sub->emit(_mm, lvalue, cp1, cp2);
-    }
-  }
-}
-
-bool GptAsmExpression::isAtom() {
-  return _value.length() > 0;
-}
-
-const std::string& GptAsmExpression::value() { 
-  return _value;
-}
-
-Type* GptAsmExpression::GptAsmExpression::restype() {
-  return _restype;
-}
-
-Type* GptAsmExpression::GptAsmExpression::exprtype() {
-  return _exprtype;
-}
-
-std::string GptAsmExpression::expandCast(const std::string &lvalue,
-                                         const std::string& op,
-                                         Type *optype,
-                                         Subroutine *sub) {
-  if (!optype->equals(_exprtype)) {
-    sub->emit(opcodeCast(optype, _exprtype), lvalue, op);
-    return lvalue;
-  }
-  return op;
-}
-
-std::string GptAsmExpression::opcodeCast(Type* from, Type* to) {
-  if ((from->primitiveType() == PortugolTokenTypes::T_INTEIRO) &&
-      (to->primitiveType() == PortugolTokenTypes::T_REAL)) {
-    return "i2r";
-  }
-
-  if ((from->primitiveType() == PortugolTokenTypes::T_CARACTERE) &&
-      (to->primitiveType() == PortugolTokenTypes::T_LITERAL)) {
-    return "c2s";
-  }
-  throw;
-}

Deleted: trunk/gpt2/gptc/src/GptAsmExpression.hpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,42 +0,0 @@
-#ifndef GPT_ASMEXPRESSION_HPP
-#define GPT_ASMEXPRESSION_HPP
-
-#include <string>
-
-
-class Type;
-class Subroutine;
-
-class GptAsmExpression {
-public:
-  GptAsmExpression(Type* restype, const std::string& value);
-
-  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*);
-
-  ~GptAsmExpression();
-
-  void expand(const std::string lvalue, Subroutine* sub);
-
-  bool isAtom();
-
-  const std::string& value();
-  Type*              exprtype();
-  Type*              restype();
-private:
-  std::string expandCast(const std::string&,
-                         const std::string&,
-                         Type*, Subroutine*);
-
-  std::string opcodeCast(Type* from, Type* to);
-
-
-  Type              *_restype;
-  Type              *_exprtype;
-  std::string       _mm;
-  std::string       _value;
-  GptAsmExpression  *_op1;
-  GptAsmExpression  *_op2;
-};
-
-#endif

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,116 +1,13 @@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
+SUBDIRS = parser common semantic symboltable gptasm_target
 
-noinst_LTLIBRARIES = libgptc.la
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/parser \
+	-I$(top_srcdir)/src/common -I$(top_srcdir)/src/semantic -I$(top_srcdir)/src/symboltable \
+	-I$(top_srcdir)/src/gptasm_target -I./parser -I./semantic -I./gptasm_target
 
 bin_PROGRAMS = gptc
 
 gptc_SOURCES = main.cpp
 
-gptc_LDADD = libgptc.la $(ANTLR_LIB)
-
-
-EXTRA_DIST = lexer.g parser.g semantic.g gptasm.g
-
-
-BUILT_SOURCES = PortugolLexer.hpp \
-                PortugolLexer.cpp \
-                PortugolParser.hpp \
-                PortugolParser.cpp \
-                SemanticWalker.hpp \
-                SemanticWalker.cpp \
-								GptAsmWalker.hpp \
-								GptAsmWalker.cpp \
-                TokenNames.hpp \
-                TokenLabels.hpp
-
-
-libgptc_la_SOURCES =  BaseSemanticWalker.hpp \
-											BaseSemanticWalker.cpp \
-											BaseGptAsmWalker.hpp \
-											BaseGptAsmWalker.cpp \
-											CompilerError.hpp \
-											CompilerError.cpp \
-											MismatchedUnicodeCharException.hpp \
-											MismatchedUnicodeCharException.cpp \
-											PortugolAST.hpp \
-											PortugolAST.cpp \
-											Symbol.hpp \
-											Symbol.cpp \
-											SymbolTable.hpp \
-											SymbolTable.cpp \
-											SymbolTableExceptions.hpp \
-											SymbolTableExceptions.cpp \
-											Types.hpp \
-											Types.cpp \
-											UnicodeCharBuffer.hpp \
-											UnicodeCharScanner.hpp \
-											GptAsmExpression.hpp GptAsmExpression.cpp \
-											Arguments.hpp \
-											Arguments.cpp \
-											AsmProgram.hpp AsmProgram.cpp \
-										  Context.hpp Context.cpp \
-										  Options.hpp \
-											Subroutine.hpp Subroutine.cpp \
-											TextFile.hpp TextFile.cpp \
-										  Tools.hpp Tools.cpp \
-											$(BUILT_SOURCES)
-
-
-CLEANFILES = PortugolLexer.cpp \
-             PortugolLexer.hpp \
-             PortugolTokenTypes.hpp \
-             PortugolTokenTypes.txt \
-             PortugolParser.cpp \
-						 PortugolParser.hpp  \
-             PortugolParserTokenTypes.hpp \
-             PortugolParserTokenTypes.txt \
-             SemanticWalker.hpp \
-             SemanticWalker.cpp \
-             SemanticWalkerTokenTypes.hpp \
-             SemanticWalkerTokenTypes.txt \
-             GptAsmWalkerTokenTypes.hpp \
-             GptAsmWalker.cpp \
-						 GptAsmWalker.hpp  \
-             GptAsmWalkerTokenTypes.txt \
-             TokenNames.hpp \
-             TokenLabels.hpp
-
-PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
-	$(ANTLR_BIN) $(srcdir)/lexer.g
-
-PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile
-	$(ANTLR_BIN) $(srcdir)/parser.g
-
-SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
-	$(ANTLR_BIN) $(srcdir)/semantic.g
-
-GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
-	$(ANTLR_BIN) $(srcdir)/gptasm.g
-
-TokenNames.hpp: Makefile
-	@echo "#ifndef TOKENNAMES_H" > $@
-	@echo "#define TOKENNAMES_H"  >> $@
-	@echo "static char* g_tokenNames[] = " >> $@
-	@echo '{"", "EOF", "", "",'   >> $@
-	grep = PortugolTokenTypes.txt >> $@
-	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo -n "static int g_tokenNamesSize = " >> $@
-	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc >> $@
-	@echo ";" >> $@
-	@echo "#endif" >> $@
-
-TokenLabels.hpp: Makefile
-	@echo "#ifndef TOKENLABELS_H" > $@
-	@echo "#define TOKENLABELS_H"  >> $@
-	@echo "static char* g_tokenLabels[] = " >> $@
-	@echo '{"", "EOF", "", "",'   >> $@
-	grep '"' PortugolTokenTypes.txt >> $@
-	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo "static int g_tokenLabelsSize = " >> $@
-	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc >> $@
-	@echo ";" >> $@
-	@echo "#endif" >> $@
-
-
+gptc_LDADD = $(top_builddir)/src/symboltable/libsymboltable.la \
+	$(top_builddir)/src/common/libcommon.la $(top_builddir)/src/gptasm_target/libgptasm.la \
+	$(top_builddir)/src/semantic/libsemantic.la $(top_builddir)/src/parser/libparser.la $(ANTLR_LIB)

Deleted: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,110 +0,0 @@
-
-#include <iostream>
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-#include "MismatchedUnicodeCharException.hpp"
-#include "UnicodeCharScanner.hpp"
-
-
-MismatchedUnicodeCharException::MismatchedUnicodeCharException()
-: RecognitionException("Mismatched char")
-{
-}
-
-// Expected range / not range
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type lower,
-	char_type up,
-	bool matchNot,
-	UnicodeCharScanner* cs
-)
-: RecognitionException("Mismatched char",
-							  cs->getFilename(),
-							  cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_RANGE : RANGE)
-, foundChar(c)
-, expecting(lower)
-, upper(up)
-, scanner(cs)
-{
-}
-
-// Expected char / not char
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type expect,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_CHAR : CHAR)
-, foundChar(c)
-, expecting(expect)
-, scanner(cs)
-{
-}
-
-// Expected BitSet / not BitSet
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	antlr::BitSet s,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_SET : SET)
-, foundChar(c)
-, set(s)
-, scanner(cs)
-{
-}
-
-MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
-
-/**
- * Returns a clean error message (no line number/column information)
- */
-std::string MismatchedUnicodeCharException::getMessage() const
-{
-	ANTLR_USE_NAMESPACE(std)string s;
-
-	switch (mismatchType) {
-	case CHAR :
-		s += "expecting '" + antlr::charName(expecting) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_CHAR :
-		s += "expecting anything but '" + antlr::charName(expecting) + "'; got it anyway";
-		break;
-	case RANGE :
-		s += "expecting token in range: '" + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_RANGE :
-		s += "expecting token NOT in range: " + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case SET :
-	case NOT_SET :
-		{
-			s += ANTLR_USE_NAMESPACE(std)string("expecting ") + (mismatchType == NOT_SET ? "NOT " : "") + "one of (";
-			ANTLR_USE_NAMESPACE(std)vector<unsigned int> elems = set.toArray();
-			for ( unsigned int i = 0; i < elems.size(); i++ )
-			{
-				s += " '";
-				s += antlr::charName(elems[i]);
-				s += "'";
-			}
-			s += "), found '" + antlr::charName(foundChar) + "'";
-		}
-		break;
-	default :
-		s += RecognitionException::getMessage();
-		break;
-	}
-
-	return s;
-}

Deleted: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,82 +0,0 @@
-#ifndef INC_MismatchedUnicodeCharException_hpp__
-#define INC_MismatchedUnicodeCharException_hpp__
-
-/* ANTLR Translator Generator
- * Project led by Terence Parr at http://www.jGuru.com
- * Software rights: http://www.antlr.org/license.html
- *
- * $Id:$
- */
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-
-class UnicodeCharScanner;
-
-class MismatchedUnicodeCharException : public antlr::RecognitionException {
-public:
-	typedef unsigned int char_type;
-	typedef enum {
-		CHAR = 1,
-		NOT_CHAR = 2,
-		RANGE = 3,
-		NOT_RANGE = 4,
-		SET = 5,
-		NOT_SET = 6
-	} MATCH_TYPE;
-
-	MismatchedUnicodeCharException();
-
-	// Expected range / not range
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type lower,
-		char_type up,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected char / not char
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type expect,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected BitSet / not BitSet
-	MismatchedUnicodeCharException(
-		char_type c,
-		antlr::BitSet s,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	~MismatchedUnicodeCharException() throw();
-
-	/**
-	 * Returns a clean error message (no line number/column information)
-	 */
-	std::string getMessage() const;
-private:
-	// One of the above
-	MATCH_TYPE mismatchType;
-
-	// what was found on the input stream
-	char_type foundChar;
-
-	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
-	char_type expecting;
-
-	// For RANGE/NOT_RANGE (expecting is lower bound of range)
-	char_type upper;
-
-	// For SET/NOT_SET
-	antlr::BitSet set;
-	// who knows...they may want to ask scanner questions
-	UnicodeCharScanner* scanner;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/Options.hpp
===================================================================
--- trunk/gpt2/gptc/src/Options.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Options.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,21 +0,0 @@
-#ifndef OPTIONS
-#define OPTIONS
-
-#include <string>
-using namespace std;
-
-class Options {
-public:
-	Options( ) {
-		sentences = false;
-		sourceLine = NULL;
-	}
-	string filename;
-//	string sourcefile;
-//	string destfile;
-	bool sentences;
-	int *sourceLine;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/PortugolAST.cpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,118 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  021110307, USA.             *
- ***************************************************************************/
-
-
-#include "PortugolAST.hpp"
-#include "Types.hpp"
-#include <sstream>
-
-const char* const PortugolAST::TYPE_NAME = "PortugolAST";
-
-PortugolAST::PortugolAST()
-    : CommonAST(), line(0), column(0), type(0) {
-}
-
-PortugolAST::PortugolAST(RefToken t)
-    : CommonAST(t), line(t->getLine()), column(t->getColumn()), type(0) {
-}
-
-PortugolAST::PortugolAST( const CommonAST& other )
-    : CommonAST(other), line(0), column(0), type(0) {
-}
-
-PortugolAST::PortugolAST( const PortugolAST& other )
-    : CommonAST(other), line(other.line), column(other.column), type(0) {
-}
-
-PortugolAST::~PortugolAST() {
-}
-
-RefAST PortugolAST::clone( void ) const
-{
-  PortugolAST *ast = new PortugolAST( *this );
-  return RefAST(ast);
-}
-
-const char* PortugolAST::typeName( void ) const
-{
-  return PortugolAST::TYPE_NAME;
-}
-
-void PortugolAST::initialize(RefToken t)
-{
-  CommonAST::initialize(t);
-  setLine(t->getLine());
-  setColumn(t->getColumn());
-}
-
-void PortugolAST::setLine(int line_) {
-  line = line_;
-}
-
-int PortugolAST::getLine() const {
-    // most of the time the line number is not set if the node is a
-    // imaginary one. Usually this means it has a child. Refer to the
-    // child line number. Of course this could be extended a bit.
-    // based on an example by Peter Morling.
-    if ( line != 0 )
-        return line;
-    if( getFirstChild() )
-        return ( RefPortugolAST(getFirstChild())->getLine() );
-    return 0;
-}
-
-void PortugolAST::setColumn(int c) {
-  column = c;
-}
-
-int PortugolAST::getColumn() const {
-    // most of the time the line number is not set if the node is a
-    // imaginary one. Usually this means it has a child. Refer to the
-    // child line number. Of course this could be extended a bit.
-    // based on an example by Peter Morling.
-    if ( column != 0 )
-        return column;
-    if( getFirstChild() )
-        return ( RefPortugolAST(getFirstChild())->getColumn() );
-    return 0;
-}
-
-void PortugolAST::setEvalType(Type* t) {
-  type = t;
-}
-
-Type* PortugolAST::getEvalType() {
-  return type;
-}
-
-
-std::string PortugolAST::toString() const {
-  std::stringstream s;
-  s << getText();
-//   s << "(" << getLine() << ":" << getColumn() << ")" << getText();
-  if (type) {
-    s << ":" << type->name();
-  }
-  return s.str();
-}
-
-RefAST PortugolAST::factory() {
-  return RefAST(new PortugolAST);
-}

Deleted: trunk/gpt2/gptc/src/PortugolAST.hpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,71 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef PORTUGOLAST_HPP
-#define PORTUGOLAST_HPP
-
-#include <antlr/CommonAST.hpp>
-#include <string>
-
-using namespace std;
-using namespace antlr;
-
-class Type;
-
-class PortugolAST : public CommonAST {
-public:
-  PortugolAST();
-  PortugolAST( RefToken t );
-  PortugolAST( const CommonAST& other );
-  PortugolAST( const PortugolAST& other );
-
-  ~PortugolAST();
-
-  void setLine(int line);
-  int getLine() const;
-
-  void setColumn(int);
-  int getColumn() const;
-
-  void setEvalType(Type*);
-  Type* getEvalType();
-
-  virtual RefAST clone( void ) const;
-
-  virtual void initialize( RefToken t );
-
-  virtual const char* typeName( void ) const;
-
-  virtual std::string toString() const;
-
-  static RefAST factory();
-  static const char* const TYPE_NAME;
-protected:
-  int   line;
-  int   column;
-  Type* type;
-  int endLine;
-  int eval_type; //evaluated type of expression
-  string filename;
-};
-
-typedef ASTRefCount<PortugolAST> RefPortugolAST;
-
-#endif

Deleted: trunk/gpt2/gptc/src/Subroutine.cpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,183 +0,0 @@
-#include "Subroutine.hpp"
-
-#include <iostream>
-using namespace std;
-
-#include "Tools.hpp"
-#include "Types.hpp"
-
-#include "PortugolTokenTypes.hpp"
-
-
-Subroutine::Subroutine(Options *options, /*CGptAssemblyFile *file,*/ const string &name)
-	: _options(options), _name(name), _tmpSuffix(1), _lastSourceLine(0)
-{
-	if (_options->sentences) {
-		//_sourceInfo = new SourceInfo();
-		//_sourceInfo->setFileName(_options->sourcefile);
-	}
-	_body.incTab();
-}
-
-
-Subroutine::~Subroutine()
-{
-	//if (_sourceInfo) {
-	//	delete _sourceInfo;
-	//}
-}
-
-
-void Subroutine::init()
-{
-  _header.writeln();
-	_header.writeln(string("// Procedure ") + _name);
-	_header.writeln("proc " + _name);
-	_header.incTab();
-//	_body.incTab();
-}
-
-
-void Subroutine::finish()
-{
-	if (_name == "main") {
-		_body.writeln("exit_0");
-	}
-//	_body->decTab();
-	_footer.writeln("end-proc");
-
-	_footer.writeln("// Fim da procedure");
-	_footer.writeln();
-}
-
-
-void Subroutine::emitPUSHMn(const string &symbol, const bool &pushType)
-{
-//    SymbolType symbolType = _symbolTable->getSymbol(getName(), symbol, true).getType();
-// 
-//    _body.writeln(string("push ")   + symbol);
-// 
-//    if (pushType) {
-//       _body.writeln(string("push_") + symbolType.toAsmType());
-//    }
-}
-
-
-void Subroutine::emit(const string &mn, const string &op1, const string &op2, const string &op3)
-{
-	_body.write(mn);
-	if (op1.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.write(" " + op1);
-	if (op2.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.write(", " + op2);
-	if (op3.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.writeln(", " + op3);
-}
-
-void Subroutine::emitMnWithPrefix(const string &mn, const string &var, const string &op1, const string &op2)
-{
-	emit(getMnWithPrefix(mn, var), var, op1, op2);
-}
-
-
-void Subroutine::emitLabel(const string &label)
-{
-	_body.writeln(label + string(":"));
-}
-
-
-void Subroutine::emitAsmCode(const string &code)
-{
-	_body.writeln();
-	_body.writeln(code);
-	_body.writeln();
-}
-
-
-/*
-void Subroutine::write(string value)
-{
-//	if (_sourceInfo && *_options->sourceLine > _lastSourceLine) {
-//		string line = _sourceInfo->getLine(*_options->sourceLine);
-//		line = alltrim(wo_ctrl_chrs(line, ' '));
-//		_file->write(
-//				string("// LINE ") + string(itoa(*_options->sourceLine)) + string(" --> ") + line
-//				);
-//		_lastSourceLine = *_options->sourceLine;
-//	}
-
-	_body.write(value);
-}
-
-void Subroutine::writeln(string value)
-{
-//	if (_sourceInfo && *_options->sourceLine > _lastSourceLine) {
-//		string line = _sourceInfo->getLine(*_options->sourceLine);
-//		line = alltrim(wo_ctrl_chrs(line, ' '));
-//		_file->writeln(
-//				string("// LINE ") + string(itoa(*_options->sourceLine)) + string(" --> ") + line
-//				);
-//		_lastSourceLine = *_options->sourceLine;
-//	}
-
-	_body.writeln(value);
-}
-*/
-
-void Subroutine::emitVarDefinition(const string &name, Type* type)
-{
-	_header.writeln("var " + name + " " + type->asmName());
-
-  if (type->isPrimitive() && type->equals(PortugolTokenTypes::T_LITERAL)) {
-    _prologue.writeln("salloc " + name);
-  }
-}
-
-void Subroutine::emitParDefinition(const string &name, Type* type)
-{
-	_header.writeln("par " + name + " " + type->asmName());
-}
-
-string Subroutine::declareTmp(Type* type) {
-  std::stringstream s;
-  s << "tmp" << _tmpSuffix++;
- 
-  std::string name = s.str();
-  emitVarDefinition(name, type);
-  return name;
-}
-
-string Subroutine::getCode() const
-{
-	return _header.getText() + _prologue.getText() 
-         + _body.getText() + _footer.getText();
-}
-
-
-string Subroutine::getMnWithPrefix(const string &mn, const string &var) // TODO: serviria para simbolos tb ???
-{
-// 	int primitiveType = _symbolTable->getSymbol (getName(), var, true).getType().getPrimitiveType();
-
-// 	switch(primitiveType) {
-// 		case PortugolParserTokenTypes::T_KW_INTEIRO:    return "i" + mn;
-// 		case PortugolParserTokenTypes::T_KW_REAL:       return "r" + mn;
-// 		case PortugolParserTokenTypes::T_KW_CARACTERE:  return "i" + mn;
-// 		case PortugolParserTokenTypes::T_KW_LITERAL:    return "s" + mn;
-// 		case PortugolParserTokenTypes::T_KW_LOGICO:     return "i" + mn;
-// 		case PortugolParserTokenTypes::T_KW_MATRIZ:     return "m" + mn;
-// 		default:                                        return "undefined_" + mn;
-// 	}
-}
-

Deleted: trunk/gpt2/gptc/src/Subroutine.hpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,59 +0,0 @@
-#ifndef SUBROUTINE_H
-#define SUBROUTINE_H
-
-#include <string>
-#include <vector>
-
-#include "Options.hpp"
-
-#include <antlr/LLkParser.hpp>
-#include "PortugolParserTokenTypes.hpp"
-
-#include "TextFile.hpp"
-
-using namespace std;
-
-class Type;
-
-class Subroutine
-{
-public:
-	Subroutine(Options *options, const string &name);
-	~Subroutine();
-	void init();
-	void finish();
-	void emitPUSHMn(const string &symbol, const bool &pushType = false);
-	void emit(const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
-	void emitMnWithPrefix(const string &mn, const string &var, const string &op1 = "", const string &op2 = "");
-
-	void emitLabel(const string &label);
-
-	void emitAsmCode(const string &code);
-
-//	void write(string value);
-//	void writeln(string value = "");
-
-	const string& getName() const
-	{
-		return _name;
-	}
-	void emitVarDefinition(const string &name, Type* type);
-	void emitParDefinition(const string &name, Type* type);
-	string getCode() const;
-
-  string declareTmp(Type* type);
-private:
-	string getMnWithPrefix(const string &mn, const string &var);
-	Options *_options;
-	vector<string> _params;
-	int _lastSourceLine;
-	string _name;
-  int    _tmpSuffix;
-	TextFile _header;
-  TextFile _prologue;
-	TextFile _body;
-	TextFile _footer;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,211 +0,0 @@
-#include "Symbol.hpp"
-#include "Types.hpp"
-
-#include <sstream>
-
-Symbol::Symbol()
-  : _type(0) {
-}
-
-Symbol::Symbol(const std::string& lexeme,
-               Type* type,
-               const std::string& scope,
-               const std::string& unit,
-               int line,
-               int column)
-  :   _lexeme(lexeme),
-      _type(type),
-      _scope(scope),
-      _unit(unit),
-      _line(line),
-      _column(column) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-
-}
-
-Symbol::Symbol(const std::string& lexeme,
-               Type* type,
-               const std::string& unit,
-               int line,
-               int column)
-  :   _lexeme(lexeme),
-      _type(type),
-      _unit(unit),
-      _line(line),
-      _column(column) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-}
-
-
-
-Symbol::Symbol(const std::string& lexeme, Type* type) 
-  : _lexeme(lexeme), _type(type), _scope("?"), _unit("?"), 
-    _line(0), _column(0) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-}
-
-
-const std::string& Symbol::lexeme() const {
-  return _lexeme;
-}
-
-Type* Symbol::type() const {
-  return _type;
-}
-
-void Symbol::setScope(const std::string& scope) {
-  _scope = scope;
-}
-
-const std::string& Symbol::scope() const {
-  return _scope;
-}
-
-const std::string& Symbol::unit() const {
-  return _unit;
-}
-
-int Symbol::line() const {
-  return _line;
-}
-
-int Symbol::column() const {
-  return _column;
-}
-
-std::string Symbol::toString() const {
-  std::stringstream ret;
-  ret << _unit << ":" << _line
-      << " (" << _scope << ") -> " << lexeme();
-
-  ret << " : " << _type->name();
-
-  ret << " -- attributes: {";
-  if (_type->isConst()) {
-    ret << "c";
-  }
-
-  if (_type->isRef()) {
-    ret << "r";
-  }
-  ret << "}";
-
-  return ret.str();
-}
-
-std::string 
-Symbol::buildIdentifier(const std::string& name, Type* type) {
-  if (!type->isSubprogram()) {
-    return name;
-  } else {
-    return buildIdentifier(name, type->paramTypes());
-  }
-}
-
-std::string 
-Symbol::buildIdentifier(const std::string& name, const TypeList& list) {
-  return name + "_" + list.toIdentifier();
-}
-
-std::string Symbol::identifier() const {
-  return "_" + _identifier;
-}
-
-
-bool Symbol::equivalent(const Symbol& other) const {
-  return _lexeme == other._lexeme &&
-         _type->equals(other._type);
-}
-
-//-------------------------------------------------------
-
-
-SymbolList::const_iterator SymbolList::duplicated() const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if (count((*it).identifier()) > 1) {
-      return it;
-    }
-  }
-  return end();
-}
-
-int SymbolList::count(const std::string& identifier) const {
-  int c = 0;
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == identifier) {
-      c++;
-    }
-  }
-  return c;
-}
-
-TypeList SymbolList::typeList() const {
-  TypeList list;
-
-  for (const_iterator it = begin(); it != end(); ++it) {
-    list.push_back((*it).type());
-  }
-  return list;
-}
-
-SymbolList
-SymbolList::findAllByLexeme(const std::string& lexeme) const {
-  SymbolList ret;
-  SymbolList::const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == lexeme) {
-      ret.push_back(*it);
-    }
-  }
-  return ret;
-}
-
-SymbolList::const_iterator 
-SymbolList::findFirstByLexeme(const std::string& lexeme) const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == lexeme) {
-      return it;
-    }
-  }
-  return end();
-}
-
-SymbolList::const_iterator 
-SymbolList::findByIdentifier(const std::string& identifier) const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).identifier() == identifier) {
-      return it;
-    }
-  }
-  return end();
-}
-
-void SymbolList::setScope(const std::string& scope) {
-  for (iterator it = begin(); it != end(); ++it) {
-    (*it).setScope(scope);
-  }
-}
-
-std::string SymbolList::toString() const {
-  std::string ret = "";
-  for (const_iterator it = begin(); it != end(); ++it) {
-    ret += (*it).toString() + "\n";
-  }
-  return ret;
-}
-
-bool SymbolList::equivalent(const SymbolList& other) const {
-  const_iterator it, jt;
-  for (it = begin(), jt = other.begin(); 
-       it != end() && jt != other.end(); 
-       ++it, ++jt) {
-    if (!(*it).equivalent(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}

Deleted: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,82 +0,0 @@
-#ifndef SYMBOL_HPP
-#define SYMBOL_HPP
-
-#include <string>
-#include <list>
-
-class Type;
-class TypeList;
-
-class Symbol {
-public:
-  static std::string buildIdentifier(const std::string&, Type*);
-  static std::string buildIdentifier(const std::string&, const TypeList&);
-
-  Symbol();
-
-  Symbol(const std::string& lexeme,
-         Type* type,
-         const std::string& scope,
-         const std::string& unit,
-         int line,
-         int column);
-
-  Symbol(const std::string& lexeme,
-         Type* type,
-         const std::string& unit,
-         int line,
-         int column);
-
-  Symbol(const std::string& lexeme,
-         Type* type);
-
-  const std::string& lexeme() const;
-
-  Type* type() const;
-
-  void setScope(const std::string&);
-  const std::string& scope() const;
-
-  const std::string& unit() const;
-
-  int line() const;
-  int column() const;
-
-  std::string toString() const;
-
-  std::string identifier() const;
-
-  bool equivalent(const Symbol&) const;
-private:
-  std::string      _lexeme;
-  std::string      _identifier;
-  Type*            _type;
-  std::string      _scope;
-  std::string      _unit;
-  int              _line;
-  int              _column;
-};
-
-
-class SymbolList : public std::list<Symbol> {
-public:
-
-  const_iterator duplicated() const;
-
-  TypeList typeList() const;
-
-  SymbolList     findAllByLexeme(const std::string&) const;
-  const_iterator findFirstByLexeme(const std::string&) const;
-  const_iterator findByIdentifier(const std::string&) const;
-  
-
-  int count(const std::string&) const;
-
-  void setScope(const std::string&);
-
-  std::string toString() const;
-
-  bool equivalent(const SymbolList&) const;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,211 +0,0 @@
-#include "SymbolTable.hpp"
-
-#include "Types.hpp"
-#include "PortugolTokenTypes.hpp"
-#include "Symbol.hpp"
-#include "SymbolTableExceptions.hpp"
-
-#include <iostream>
-
-SymbolTable::SymbolTable(const std::string& unit)
-  : _unit(unit), _typeBuilder(new TypeBuilder) {
-
-  setGlobalScope();
-}
-
-void SymbolTable::setGlobalScope() {
-  _scope = globalScope();
-}
-
-bool SymbolTable::isInGlobalScope() {
-  return globalScope() == _scope;
-}
-
-void SymbolTable::setIgnoreScope() {
-  static char r = 1;
-  _scope = "internal" + (r++);
-}
-
-const std::string SymbolTable::globalScope() {
-  return "@global";
-}
-
-void SymbolTable::setScope(const Symbol& scopeSymbol) {  
-  _scope = scopeSymbol.identifier();
-}
-
-const std::string& SymbolTable::currentScope() {
-  return _scope;
-}
-
-const std::string& SymbolTable::unit() {
-  return _unit;
-}
-
-void SymbolTable::insertType(const std::string& name,
-                             const SymbolList& fields,
-                             int line) {
-  
-  //checando por campos duplicados na estrutura
-  SymbolList::const_iterator dup = fields.duplicated();
-  if (dup != fields.end()) {
-    throw RedeclarationException(*dup);
-  }
-
-  //checando por redefinicao da estrutura
-  if (_typeBuilder->typeList().find(name) != _typeBuilder->typeList().end()) {
-    throw RedefinedTypeException(name);
-  }
-
-  _typeBuilder->typeList().push_back(
-    new Type(_typeBuilder, name, fields, _unit, line));
-}
-
-
-// void SymbolTable::insertType(const std::string& name,
-//                              const SymbolList& symbolList,
-//                              int line) {
-// 
-//   //checando por campos duplicados na estrutura
-//   SymbolList::const_iterator dup = symbolList.duplicated();
-//   if (dup != symbolList.end()) {
-//     throw RedeclarationException(*dup);
-//   }
-// 
-//   //checando por redefinicao da estrutura
-//   if (_typeBuilder->typeList().find(name) != _typeBuilder->typeList().end()) {
-//     throw RedefinedTypeException(name);
-//   }
-// 
-//   _typeBuilder->typeList().push_back(
-//     new Type(_typeBuilder, name,
-//              symbolList.toStructFieldList(), _unit, line));
-// }
-
-Type* SymbolTable::getType(const std::string& name) {
-  TypeList::iterator ret = _typeBuilder->typeList().find(name);
-
-  if (ret == _typeBuilder->typeList().end()) {
-    throw UndeclaredTypeException(name);
-  }
-
-  return *ret;
-}
-
-
-void SymbolTable::insertSymbol(const Symbol& symbol) {
-  if (symbolExists(symbol)) {
-    throw RedeclarationException(symbol);
-  }
-  _table[symbol.scope()].push_back(symbol);
-}
-
-void SymbolTable::insertSymbols(const SymbolList& symbols) {
-  for (SymbolList::const_iterator it = symbols.begin();
-       it != symbols.end();
-       ++it) {
-    insertSymbol(*it);
-  }
-}
-
-const Symbol& SymbolTable::getSymbol(const std::string& lexeme,
-                                     const std::string& scope) {
-  SymbolList::const_iterator it = _table[scope].findFirstByLexeme(lexeme);
-  if (it == _table[scope].end()) {
-    throw UndeclaredSymbolException(lexeme);
-  }
-  return (*it);
-}
-
-const Symbol& 
-SymbolTable::getSymbol(const std::string& lexeme, const TypeList& params) {
-  //deve considerar promocao de tipos
-  //    fun??o f(a:real) ...
-  //    f(1);                //resolve para a fun??o "f_real"
-
-
-  SymbolList list = _table[globalScope()].findAllByLexeme(lexeme);
-
-  if (list.size() == 0) {
-    throw UndeclaredSymbolException(lexeme);
-  }
-
-  //try exact version
-  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
-    if ((*it).type()->isSubprogram() &&
-        (*it).type()->paramTypes().equals(params)) {
-      return (*it);
-    }
-  }
-
-  //tentando promocoes...
-  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
-    if ((*it).type()->isSubprogram() &&
-        (*it).type()->paramTypes().isLValueFor(params)) {
-      return (*it);
-    }
-  }
-
-  throw UnmatchedException(lexeme);
-
-//   std::string id = Symbol::buildIdentifier(lexeme, params);
-//   SymbolList::const_iterator it = _table[globalScope()].findByIdentifier(id);
-//   if (it == _table[globalScope()].end()) {
-//     throw UndeclaredSymbolException(id);
-//   }
-//   return (*it);
-}
-
-const Symbol& SymbolTable::getSymbol(const std::string& lexeme) {
-  //buscar primeiro no escopo atual, depois no global
-
-  if (isInGlobalScope()) {
-    return getSymbol(lexeme, _scope);
-  } else {
-    try {
-      return getSymbol(lexeme, _scope);
-    } catch( ... ) {
-      return getSymbol(lexeme, globalScope());
-    }
-  }
-}
-
-bool SymbolTable::symbolExists(const Symbol& s) {
-  SymbolList::const_iterator it = 
-    _table[s.scope()].findByIdentifier(s.identifier());
-
-  if (it == _table[s.scope()].end()) {
-    return false;
-  } else {
-    return true;
-  }
-}
-
-
-// bool SymbolTable::symbolExists(const std::string& id) {
-//   return symbolExists(id, _scope);
-// }
-// 
-// bool SymbolTable::symbolExists(const std::string& id,
-//                                const std::string& scope) {
-// 
-//   return _table[scope].findByIdentifier(id) != _table[scope].end();
-// }
-
-
-void SymbolTable::dump() {
-
-  std::cerr << "=== SymbolTable ===\n";
-  std::cerr << "Identifiers ...\n";
-  std::map<std::string, SymbolList>::iterator it;
-  for (it = _table.begin(); it != _table.end(); ++it) {
-    std::cerr << it->second.toString() << std::endl;
-  }
-  std::cerr << "Types ... " << std::endl;
-  std::cerr << _typeBuilder->typeList().toString() << std::endl;
-  std::cerr << "=== End SymbolTable ===\n\n";
-}
-
-TypeBuilder* SymbolTable::typeBuilder() {
-  return _typeBuilder;
-}

Deleted: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,62 +0,0 @@
-#ifndef SYMBOLTABLE_HPP
-#define SYMBOLTABLE_HPP
-
-#include <string>
-#include <list>
-#include <map>
-
-#include "Types.hpp"
-
-class Symbol;
-class SymbolList;
-class TypeBuilder;
-
-class SymbolTable {
-public:
-  SymbolTable(const std::string& unit);
-
-  void setGlobalScope();
-  bool isInGlobalScope();
-  void setIgnoreScope();
-  void setScope(const Symbol&);
-  const std::string& currentScope();
-  const std::string globalScope();
-
-  const std::string& unit();
-
-  void insertType(const std::string& name,
-                  const SymbolList&,
-                  int line);
-
-  /* recuperar tipo por nome (ex. esruturas) */
-  Type* getType(const std::string& name);
-
-  void insertSymbol(const Symbol& symbol);
-  void insertSymbols(const SymbolList& symbols);
-
-  //(lexeme, scope)
-  const Symbol& getSymbol(const std::string&, const std::string&);
-
-  //(lexeme, params)
-  const Symbol& getSymbol(const std::string&, const TypeList&);
-
-
-  //(lexeme) -> todos os escopos, iniciando pelo atual
-  const Symbol& getSymbol(const std::string&);
-
-  void dump();
-
-  TypeBuilder* typeBuilder();
-private:
-/*  bool symbolExists(const std::string&);
-  bool symbolExists(const std::string&, const std::string&);*/
-  bool symbolExists(const Symbol& s);
-
-  std::string                        _unit;
-  std::string                        _scope;
-
-  TypeBuilder                        *_typeBuilder;
-  std::map<std::string, SymbolList>  _table;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,63 +0,0 @@
-#include "SymbolTableExceptions.hpp"
-#include "TokenNames.hpp"
-
-UndeclaredTypeException::UndeclaredTypeException(const std::string& name)
-  : _id(-1), _name(name) {
-}
-
-UndeclaredTypeException::UndeclaredTypeException(int id)
-  : _id(id) {
-}
-
-std::string UndeclaredTypeException::typeName() const {
-  if (_id == -1) {
-    return _name;
-  } else {
-    return g_tokenNames[_id];
-  }
-}
-
-//--------------------------------------------------------
-
-RedefinedTypeException::RedefinedTypeException(const std::string& name)
-  : _name(name) {
-}
-
-const std::string& RedefinedTypeException::typeName() const {
-  return _name;
-}
-
-
-//--------------------------------------------------------
-
-UndeclaredSymbolException::UndeclaredSymbolException(const std::string& lexeme)
-  : _lexeme(lexeme) {
-}
-
-std::string UndeclaredSymbolException::lexeme() const {
-  return _lexeme;
-}
-
-
-//--------------------------------------------------------
-
-
-RedeclarationException::RedeclarationException(const Symbol& s)
-  : _symbol(s) {
-}
-
-const Symbol& RedeclarationException::symbol() const {
-  return _symbol;
-}
-
-//--------------------------------------------------------
-
-
-UnmatchedException::UnmatchedException(const std::string& l)
-  : _lexeme(l) {
-
-}
-
-const std::string& UnmatchedException::lexeme() {
-  return _lexeme;
-}

Deleted: trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,59 +0,0 @@
-#ifndef SYMBOLTABLEEXCEPTIONS_HPP
-#define SYMBOLTABLEEXCEPTIONS_HPP
-
-#include "Symbol.hpp"
-#include "Types.hpp"
-
-#include <string>
-
-
-class UndeclaredTypeException {
-public:
-  UndeclaredTypeException(const std::string& name);
-  UndeclaredTypeException(int id);
-
-  std::string typeName() const;
-
-private:
-  int _id;
-  std::string _name;
-};
-
-class RedefinedTypeException {
-public:
-  RedefinedTypeException(const std::string& name);
-
-  const std::string& typeName() const;
-private:
-  std::string _name;
-};
-
-class UndeclaredSymbolException {
-public:
-  UndeclaredSymbolException(const std::string& lexeme);
-
-  std::string lexeme() const;
-
-private:
-  std::string _lexeme;
-};
-
-class RedeclarationException {
-public:
-  RedeclarationException(const Symbol&);
-
-  const Symbol& symbol() const;
-private:
-  Symbol _symbol;
-};
-
-class UnmatchedException {
-public:
-  UnmatchedException(const std::string&);
-
-  const std::string& lexeme();
-private:
-  std::string _lexeme;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/TextFile.cpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/TextFile.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,71 +0,0 @@
-#include "TextFile.hpp"
-
-
-TextFile::TextFile( const string &chrTab )
-	: _chrTab( chrTab ), _emitTab( true )
-{
-}
-
-
-TextFile::~TextFile( )
-{
-}
-
-
-void TextFile::writeln( const string &message )
-{
-	if ( _emitTab ) {
-		_txt << _tabs;
-	}
-	_txt << message << endl;
-	_emitTab = true;
-}
-
-
-void TextFile::writeln( )
-{
-	_txt << endl;
-	_emitTab = true;
-}
-
-
-void TextFile::write( const string &message )
-{
-	if ( _emitTab ) {
-		_txt << _tabs;
-	}
-	_txt << message;
-	_emitTab = false;
-}
-
-
-void TextFile::incTab( )
-{
-    _tabs += _chrTab;
-}
-
-
-void TextFile::decTab( )
-{
-    _tabs.erase( _tabs.length( ) - _chrTab.length( ), _chrTab.length( ) );
-}
-
-
-string TextFile::getText( ) const
-{
-	return _txt.str( );
-}
-
-
-bool TextFile::writeToFile( const string &filename )
-{
-	ofstream *_file;
-	_file = new ofstream( filename.c_str( ) );
-	if (_file) {
-		(*_file) << _txt;
-		delete _file;
-		return true;
-	}
-	return false;
-}
-

Deleted: trunk/gpt2/gptc/src/TextFile.hpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/TextFile.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,30 +0,0 @@
-#ifndef GPT_TEXT_FILE_H
-#define GPT_TEXT_FILE_H
-
-#include <string>
-#include <fstream>
-#include <sstream>
-
-using namespace std;
-
-class TextFile
-{
-public:
-	TextFile( const string &chrTab = "\t" );
-	~TextFile( );
-	void writeln( const string &message );
-	void writeln( );
-	void write( const string &message );
-	void incTab( );
-	void decTab( );
-	string getText( ) const;
-	bool writeToFile( const string &filename );
-private:
-	string _chrTab;
-	string _tabs;
-	bool _emitTab;
-	stringstream _txt;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/Tools.cpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Tools.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,299 +0,0 @@
-/*
- * $Id: Tools.cpp,v 1.1.1.1 2005/08/15 15:19:52 asgarzao Exp $
- * MyLibrary version 0.1.0
- * Copyright (C) 2002 Alex Sandro Garz? <alexgarzao at bol.com.br>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-#include "PortugolParserTokenTypes.hpp"
-
-#include "Tools.hpp"
-
-
-int hexToInt(const char* _value) {
-    int result = 0;
-    char *position;
-    char conversionTable[] = "0123456789ABCDEF";
-
-    while (*_value) {
-        position = strchr(conversionTable, *_value);
-        if (position == NULL)
-            return 0;
-
-        result <<= 4;
-        result = result | (position - conversionTable);
-        _value++;
-    }
-
-    return result;
-}
-
-string pad(string _text, unsigned int _size) {
-    if (_size > _text.length())
-        _text.append(_size - _text.length(), ' ');
-
-    return _text;
-}
-
-string lpad(string _text, unsigned int _size) {
-    if (_size > _text.length())
-        _text = string(_size - _text.length(), ' ') + _text;
-
-    return _text;
-}
-
-string intToHex(unsigned int _value, int _size) {
-    string codHex = "0123456789ABCDEF";
-    string result;
-    int nible;
-
-    while (_value > 0) {
-        nible = _value & 0xF;
-        _value >>= 4;
-        result = codHex[nible] + result;
-    }
-
-    if ( _size == -1 )
-        _size = 1;
-
-    return strZero(result, _size);
-    // if (_size == -1)
-    //     return( result );
-    // else
-    //     return( strZero( result, _size ) );
-    //
-}
-
-string strZero(string _value, unsigned int _size) {
-    while (_value.length() < _size) {
-        _value = '0' + _value;
-    }
-
-    return _value;
-}
-
-string strZero(int _value, unsigned int _size) {
-    string result = itoa(_value);
-
-    while (result.length() < _size) {
-        result = '0' + result;
-    }
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = 0; count < _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _start, unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = _start; count - _start < _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-int binToInt(const char* _binValue) {
-    int intValue = 0;
-    int length = strlen(_binValue) - 1;
-    int countBit;
-
-    for (countBit = length; countBit >= 0; countBit--) {
-        if (_binValue[countBit] == '1')
-            intValue += int(pow(2.0, length - countBit));
-    }
-
-    return intValue;
-}
-
-string itoa(int _number) {
-    stringstream s;
-
-    s << _number;
-    return s.str();
-}
-
-string ftos(double _value) {
-    stringstream s;
-
-    s <<  setiosflags(ios::fixed) << _value;
-    
-    return s.str();
-}
-
-string itobool(int _number) {
-    if (_number == 0)
-        return "false";
-    else
-        return "true";
-}
-
-string strtoupper(string str) {
-    unsigned int count;
-
-    for (count = 0; count < str.size(); count++)
-        str[count] = toupper(str[count]);
-
-    return str;
-}
-
-string strToUpperWithEscapeControls(string str) {
-    unsigned int count;
-
-    for (count = 0; count < str.size(); count++) {
-        if (str[count] == '\\')
-            count += 2;
-        else
-            str[count] = toupper(str[count]);
-    }
-
-    return str;
-}
-
-string alltrim(string str) {
-    // crap version...  :-)
-    // precisamos usar `find', `rfind'! --felipek
-    while (str[0] == ' ')
-        str.erase(0, 1);
-
-    while (str[str.length() - 1] == ' ')
-        str.erase(str.length() - 1, 1);
-
-    return str;
-}
-
-string wo_ctrl_chrs(string str, char chr_to_put) {
-    unsigned int chr_number;
-
-    for (chr_number = 0; chr_number < str.size(); chr_number++) {
-        if (str[chr_number] < 32)
-            str[chr_number] = chr_to_put;
-    }
-
-    return str;
-}
-
-/* CRAP!  --felipek
-string& getStringWithTab(string _data, string _tab) {
-	cout << "begin getStringWithTab" << endl;
-	cout << "tab=\"" << _tab << "\"" << endl;
-	cout << "begin datae" << endl;
-	cout << _data << endl;
-	cout << "end datae" << endl;
-	int pos = -1;
- 
-	// test too another new line sequences
-	while( ( pos = _data.find( "\n", pos + 1 ) ) != -1 ) {
-		_data.insert( pos + 1, _tab );
-	}
- 
-	cout << "begin datas" << endl;
-	cout << _data << endl;
-	cout << "end datas" << endl;
-	return( _data );
-}
-*/
-
-bool streamtoken(istringstream& stream, string& key, string& val) {
-     /* FIXME: leak, --felipek */
-     char buffer[8192];
-     unsigned int delim;
-     string entry;
-//     bool ret;
-
-     /* FIXME: ret type, -- felipek */
-     stream.getline(buffer, 8192 - 1);
-     entry = string(buffer);
-     delim = entry.find(' ', 0);
-
-     if (delim != entry.npos) {
-         key = entry.substr(0, delim);
-         val = entry.substr(delim + 1);
-     }
-
-     return !stream.eof();
-}
-
-
-const string typeToText(const int &type)
-{
-//    if (type == PortugolParserTokenTypes::T_INT_LIT) {
-//       return "int";
-//    } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
-//       return "char";
-//    } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
-//       return "string";
-//    } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
-//       return "real";
-//    } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
-//       return "id";
-//    }
-// 
-//    return "ERRO !!!";
-}
-
-const string typeInAsm( const int &type )
-{
-//    if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
-//       return "int";
-//    } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
-//       return "string";
-//    } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
-//       return "char";
-//    } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
-//       return "bool";
-//    } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
-//       return "real";
-//    } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
-//       return "pointer ???";
-//    } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
-//       return "matrix";
-//    }
-
-   return "ERRO !!!";
-}
-
-
-const int typeToLiteral( const int &type )
-{
-//    switch (type) {
-//       case PortugolParserTokenTypes::T_KW_INTEIRO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-//       case PortugolParserTokenTypes::T_KW_LITERAL:
-//          return PortugolParserTokenTypes::T_STRING_LIT;
-//       case PortugolParserTokenTypes::T_KW_CARACTERE:
-//          return PortugolParserTokenTypes::T_CARAC_LIT;
-//       case PortugolParserTokenTypes::T_KW_LOGICO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-// //      case PortugolParserTokenTypes::T_KW_CORINGA:
-// //         return "pointer ???";
-// //      case PortugolParserTokenTypes::T_KW_MATRIZ:
-// //          return PortugolParserTokenTypes::T_MATRIZ;
-//       default:
-//           return 0;
-//           // trow exception ???
-//    }
-}
-

Deleted: trunk/gpt2/gptc/src/Tools.hpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Tools.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,39 +0,0 @@
-#ifndef GPT_TOOLS_H
-#define GPT_TOOLS_H
-
-#include <iomanip>
-
-#include <iostream>
-#include <string>
-#include <cstdlib>
-#include <cstring>
-#include <cmath>
-#include <cstdio>
-#include <sstream>
-using namespace std;
-
-
-int hexToInt(const char *);
-string pad(string, unsigned int);
-string lpad(string, unsigned int);
-string intToHex(unsigned int, int = -1);
-string strZero(string, unsigned int);
-string strZero(int, unsigned int);
-string dataToHex(char *, unsigned int);
-string dataToHex( char *, unsigned int, unsigned int);
-int binToInt(const char *);
-int octToInt(const char *);
-string itoa(int);
-string itobool(int);
-string ftos(double);
-string strtoupper(string);
-string strToUpperWithEscapeControls(string);
-string alltrim(string);
-string wo_ctrl_chrs(string str, char = ' ');
-bool streamtoken(istringstream&, string&, string&);
-// string& getStringWithTab(string, string);
-const string typeToText(const int &type);
-const string typeInAsm( const int &type );
-const int typeToLiteral( const int &type );
-
-#endif

Deleted: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,726 +0,0 @@
-#include "Types.hpp"
-#include "TokenLabels.hpp"
-
-#include <iostream>
-#include <sstream>
-
-
-//************* GENERAL *********************************/
-
-void Type::setConst(bool c) {
-  _isConst = c;
-}
-
-void Type::setRef(bool c) {
-  _isRef = c;
-}
-
-bool Type::isConst() const {
-  return _isConst;
-}
-
-bool Type::isRef()   const {
-  return _isRef;
-}
-
-bool Type::isError() const {
-  if (_typeId == ERROR) {
-    return true;
-  }
-
-  if (isMatrix() && _ofType->isError()) {
-    return true;
-  }
-
-  if (isStruct() && _fields.typeList().hasErrorType()) {
-    return true;
-  }
-
-  if (isSubprogram() &&
-     (_returnType->isError() || _paramTypes.hasErrorType())) {
-    return true;
-  }
-  return false;
-}
-
-bool Type::isPrimitive() const {
-  return _typeId == PRIMITIVE;
-}
-
-bool Type::isMatrix() const {
-  return _typeId == MATRIX;
-}
-
-bool Type::isStruct() const {
-  return _typeId == STRUCT;
-}
-
-bool Type::isSubprogram() const {
-  return _typeId == SUBPROGRAM;
-}
-
-const std::string& Type::name() const {
-  return _name;
-}
-
-std::string Type::asmName(bool complete) const {
-  std::stringstream stream;
-
-  switch (_typeId) {
-    case PRIMITIVE:
-      switch (_id) {
-        case T_INTEIRO:
-          return "int";
-        case T_REAL:
-          return "real";
-        case T_LITERAL:
-          return "string";
-        case T_CARACTERE:
-          return "char";
-        case T_LOGICO:
-          return "bool";
-        case T_CORINGA:
-          return "pointer";
-      }
-      throw;
-    case MATRIX:
-      return "matrix";
-    case STRUCT:
-      if (!complete) {
-        return "data";
-      } else {
-        stream << "data[" << byteSize() << "]";
-        return stream.str();
-      }
-    default:
-      throw;
-  }
-}
-
-const std::string& Type::identifier() const {
-  return _identifier;
-}
-
-int Type::byteSize() const {
-  int ret = 0;
-  switch (_typeId) {
-    case PRIMITIVE:
-      switch(primitiveType()) {
-        case T_INTEIRO:    
-        case T_CARACTERE:
-        case T_LITERAL:
-        case T_LOGICO:
-        case T_CORINGA:
-          return sizeof(int);
-        case T_REAL:
-          return sizeof(double);
-        default:
-          throw;
-      }
-    case MATRIX:
-      return sizeof(void*);
-    case STRUCT:      
-      for (SymbolList::const_iterator it = _fields.begin(); it != _fields.end(); ++it) {
-        ret += (*it).type()->byteSize();
-      }
-      return ret;
-    case SUBPROGRAM:
-    default:
-      throw;
-  }
-}
-
-bool Type::equals(int id) const {
-  return isPrimitive() && (_id == id);
-}
-
-bool Type::equals(Type* ofType, int dimensions) const {
-  return isMatrix() && (dimensions == (int) _dimensions.size()) &&
-          _ofType->equals(ofType);
-}
-
-/************* VIRTUAL *********************************/
-
-Type* Type::attrPromotion(Type* other) {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_attrPromotion(other);
-    case MATRIX:
-      return matrix_attrPromotion(other);
-    case STRUCT:
-      return struct_attrPromotion(other);
-    case SUBPROGRAM:
-      return NULL;
-    default:
-      throw;
-  }
-}
-
-bool Type::equals(const Type* other) const {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_equals(other);
-    case MATRIX:
-      return matrix_equals(other);
-    case STRUCT:
-      return struct_equals(other);
-    case SUBPROGRAM:
-      return subprogram_equals(other);
-    default:
-      throw;
-  }
-}
-
-
-bool Type::isLValueFor(Type* rtype) {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_isLValueFor(rtype);
-    case MATRIX:
-      return matrix_isLValueFor(rtype);
-    case STRUCT:
-      return struct_isLValueFor(rtype);
-    case SUBPROGRAM:
-      return false;
-    default:
-      throw;
-  }
-}
-
-
-
-//************* ERROR *********************************/
-
-
-Type::Type(TypeBuilder* builder)
-  : _typeId(ERROR), _builder(builder), _isConst(false), _isRef(false),
-    _name("erro"), _identifier(_name) {
-}
-
-//************* PRIMITIVE *********************************/
-
-
-
-Type::Type(TypeBuilder* builder, int id, const std::string& name)
-  : _typeId(PRIMITIVE), _builder(builder), _isConst(false), _isRef(false),
-    _name(name), _identifier(name), _id(id) {
-}
-
-int Type::primitiveType() const {
-  return _id;
-}
-
-Type* Type::intOrReal(Type* other) {
-  if (!isPrimitive() || !other->isPrimitive()) {
-    return NULL;
-  }
-
-  if ((_id == T_INTEIRO)
-       &&
-      (other->equals(T_INTEIRO) ||
-       other->equals(T_REAL))) {
-    return _builder->primitiveType(other->primitiveType());
-  } else if ((_id == T_REAL)
-              &&
-             (other->equals(T_INTEIRO) ||
-              other->equals(T_REAL))) {
-    return this;
-  }
-
-  return NULL;
-}
-
-Type* Type::caracOrLit(Type* other) {
-  if (!isPrimitive() || !other->isPrimitive()) {
-    return NULL;
-  }
-
-  if ((_id == T_LITERAL)
-       &&
-      (other->equals(T_LITERAL) ||
-       other->equals(T_CARACTERE))) {
-    return this;
-  } else if (other->equals(T_LITERAL)
-              &&
-             ((_id == T_CARACTERE) ||
-              (_id == T_LITERAL))) {
-    return _builder->primitiveType(other->primitiveType());
-  }
-
-  return NULL;
-}
-
-
-Type* Type::primitive_attrPromotion(Type* other) {
-  if (!other->isPrimitive()) {
-    return NULL;
-  }
-
-  if (primitive_equals(other)) {
-    return other;
-  }
-
-  if (equals(T_CORINGA)) {
-    return other;
-  }
-
-  if (other->equals(T_CORINGA)) {
-    return this;
-  }
-
-  return intOrReal(other);
-}
-
-bool Type::primitive_equals(const Type* other) const {
-  return other->isPrimitive() && (other->_id == _id);
-}
-
-bool Type::primitive_isLValueFor(Type* rvalue) {
-  if (equals(rvalue)) {
-    return true;
-  }
-
-  if ((_id == T_REAL) &&
-      rvalue->equals(T_INTEIRO)) {
-    return true;
-  }
-
-  if (equals(T_CORINGA) || rvalue->equals(T_CORINGA)) {
-    return true;
-  }
-
-  return false;
-}
-
-/************* MATRIX *********************************/
-
-
-Type::Type(TypeBuilder* builder, Type* type, const std::list<int>& dimensions)
-  : _typeId(MATRIX), _builder(builder), _isConst(false), _isRef(false),
-    _ofType(type), _dimensions(dimensions) {
-
-/*
-  if (!_ofType->isPrimitive() && _ofType->isStruct()) {
-    throw; //ofType soh pode ser do tipo primitivo ou estrutura
-  }
-
-  if (_dimensions <= 0) {
-    throw;
-  }
-*/
-
-  _name       = "matriz";
-  _identifier = "matriz";
-
-  for (int i = 0; i < (int)_dimensions.size(); i++) {
-    _name       += "[]";
-    _identifier += "_d";
-  }
-  _name       += " do tipo " + _ofType->name();
-  _identifier += "_tipo_"    + _ofType->identifier();
-}
-
-Type* Type::ofType() const {
-  return _ofType;
-}
-
-const std::list<int>& Type::dimensions() const {
-  return _dimensions;
-}
-
-Type* Type::evalTypeFromSubscript(int dimensions) {
-  if (!isMatrix()) {
-    return NULL;
-  }
-
-  if (dimensions == 0) {
-    return this;
-  } else if (dimensions == (int)_dimensions.size()) {
-    return _ofType;
-  } else {
-    return _builder->matrixType(_ofType, _dimensions.size() - dimensions);
-  }
-}
-
-Type* Type::matrix_attrPromotion(Type* other) {
-  if (!other->isMatrix()) {
-    return NULL;
-  }
-
-  Type *ofProm = _ofType->attrPromotion(other->_ofType);
-  if (!ofProm) {
-    return NULL;
-  } else {
-    return _builder->matrixType(ofProm, _dimensions);
-  }
-}
-
-bool Type::matrix_equals(const Type* other) const {
-  return other->isMatrix() &&
-         equals(other->_ofType, other->_dimensions.size());
-}
-
-bool Type::matrix_isLValueFor(Type* rvalue) {
-  if (rvalue->isMatrix() &&
-      (rvalue->_dimensions.size() == _dimensions.size()) &&
-      _ofType->isLValueFor(rvalue->_ofType)) {
-    return true;
-  }
-
-  if (rvalue->isPrimitive() && rvalue->equals(T_CORINGA)) {
-    return true;
-  }
-  return false;
-}
-
-
-
-/******************** STRUCT *********************************/
-
-
-Type::Type(TypeBuilder* builder,
-           const std::string& name,
-           const SymbolList& fields,
-           const std::string& unit, int line)
-  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name(name), _identifier(name), _anonymous(false), _fields(fields),
-    _unit(unit), _line(line) {
-
-  _name = _name + ":{";
-  std::string v = "";
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
-    v = ",";
-  }
-  _name += "}";
-}
-
-
-Type::Type(TypeBuilder* builder, const SymbolList& fields)
-  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name("<an?nimo>"), _identifier("_an?nimo_"), 
-    _anonymous(true), _fields(fields),
-    _unit("<interno>"), _line(-1) {
-
-  _name += ":{";
-  std::string v = "";
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
-    v = ",";
-  }
-  _name += "}";
-}
-
-const SymbolList& Type::fields() const {
-  return _fields;
-}
-
-Type* Type::struct_attrPromotion(Type* other) {
-  if (!other->isStruct()) {
-    return NULL;
-  }
-
-  SymbolList                 retFieldList;
-  Type                       *promoType;
-  SymbolList::const_iterator otherFieldIt;
-  SymbolList::iterator       it;
-
-
-  for (it = _fields.begin(); it != _fields.end(); ++it) {
-    otherFieldIt = other->fields().findByIdentifier((*it).identifier());
-    if (otherFieldIt == other->fields().end()) { //structs diferentes
-      return NULL;
-    } else {
-      promoType = (*it).type()->attrPromotion((*otherFieldIt).type());
-      if (!promoType) {
-        return NULL;
-      } else {
-        retFieldList.push_back(Symbol((*it).lexeme(), promoType));
-      }
-    }
-  }
-
-  return _builder->structType(retFieldList);
-}
-
-bool Type::struct_equals(const Type* other) const {
-  if (!other->isStruct()) {
-    return false;
-  }
-
-  if ((_anonymous  && other->_anonymous) ||
-      (!_anonymous && !other->_anonymous)) {
-    //comparacao estrutural
-    return _fields.equivalent(other->_fields);
-  } else {
-    //comparacao nominal
-    return _name == other->_name;
-  }
-}
-
-
-bool Type::struct_isLValueFor(Type* rtype) {
-  if (rtype->isPrimitive() && rtype->equals(T_CORINGA)) {
-    return true;
-  }
-
-  if (!rtype->isStruct()) {
-    return false;
-  }
-
-  if (!_anonymous && !rtype->_anonymous) {
-    return equals(rtype);
-  } else {
-    return fieldsIsLValueFor(rtype->_fields);
-  }
-}
-
-bool Type::fieldsIsLValueFor(const SymbolList& others) {
-  if (_fields.size() != others.size()) {
-    return false;
-  }
-
-  SymbolList::const_iterator it, jt;
-  for (it = _fields.begin(); it != _fields.end(); ++it) {
-    jt = others.findByIdentifier((*it).identifier());
-    if (jt == others.end()) {
-      return false;
-    } else if (!(*it).type()->isLValueFor((*jt).type())) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-/******************** SUBPROGRAM *********************************/
-
-Type::Type(TypeBuilder* builder,
-           const TypeList& paramTypes,
-           Type* returnType)
-  : _typeId(SUBPROGRAM), _builder(builder), _isConst(false), _isRef(false),
-    _paramTypes(paramTypes), _returnType(returnType) {
-
-  if (!_returnType) {
-    _name = "proc(";
-  } else {
-    _name = "func(";
-  }
-
-  _name += _paramTypes.toString();
-  _name += ")";
-
-  _identifier = _paramTypes.toIdentifier();
-
-  if (_returnType) {
-    _name       += " : " + _returnType->name();
-  }
-}
-
-
-const TypeList& Type::paramTypes() const {
-  return _paramTypes;
-}
-
-Type* Type::returnType() const {
-  return _returnType;
-}
-
-// bool Type::paramMatches(const TypeList& types) const {
-//   return _paramTypes.matches(types);
-// }
-
-bool Type::subprogram_equals(const Type* other) const {
-  return other->isSubprogram() &&
-         (_paramTypes == other->_paramTypes) &&
-         (_returnType->equals(other->_returnType));
-}
-
-
-
-
-/******************** TYPELIST *********************************/
-
-
-
-
-
-TypeList::iterator TypeList::find(const std::string& lexeme) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)->identifier() == lexeme) {
-      return it;
-    }
-  }
-  return end();
-}
-
-TypeList::iterator TypeList::find(Type* ofType, int dimensions) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)->equals(ofType, dimensions)) {
-      return it;
-    }
-  }
-  return end();
-}
-
-TypeList::iterator TypeList::find(int id) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)->equals(id)) {
-      return it;
-    }
-  }
-  return end();
-}
-
-bool TypeList::equals(const TypeList& other) const {
-  const_iterator it;
-  const_iterator jt;
-
-  if (size() != other.size()) {
-    return false;
-  }
-
-  for (it = begin(), jt = other.begin();
-      (it != end()) && (jt != other.end()); ++it, ++jt) {
-    if (!(*it)->equals(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool TypeList::isLValueFor(const TypeList& other) const {
-  const_iterator it;
-  const_iterator jt;
-
-  if (size() != other.size()) {
-    return false;
-  }
-
-  for (it = begin(), jt = other.begin();
-      (it != end()) && (jt != other.end()); ++it, ++jt) {
-    if (!(*it)->isLValueFor(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool TypeList::hasErrorType() const {
-  const_iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)->isError()) {
-      return true;
-    }
-  }
-  return false;
-}
-
-
-std::string TypeList::toString() const {
-  std::string ret = "";
-  std::string v = "";
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    ret += v + (*it)->name();
-    v = ",";
-  }
-  return ret;
-}
-
-std::string TypeList::toIdentifier() const {
-  std::string ret = "";
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    ret += "_" + (*it)->identifier();
-  }
-  return ret;
-}
-
-/********************************************************************/
-
-Type* TypeBuilder::primitiveType(int id) {
-  Type* ret = new Type(this, id, g_tokenLabels[id]);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::matrixType(Type* ofType,
-                              const std::list<int>& dimensions) {
-  Type* ret = new Type(this, ofType, dimensions);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::matrixType(Type* ofType, int dimensions) {
-  std::list<int> dims(dimensions);
-  Type* ret = new Type(this, ofType, dims);
-  _types.push_back(ret);
-  return ret;
-}
-
-
-Type* TypeBuilder::structType(const std::string& name,
-                    const SymbolList& fields,
-                    const std::string& unit,
-                    int line) {
-
-  Type* ret = new Type(this, name, fields, unit, line);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::structType(const SymbolList& fields) {
-  Type* ret = new Type(this, fields);
-  _types.push_back(ret);
-  return ret;
-}
-
-/*
-  estrutura Par?metro
-    tipo  : literal;
-    valor : coringa;
-  fim-estrutura
-
-  procedimento p( ... args)
-
-  -> args : matriz[] do tipo Par?metro
-*/
-Type* TypeBuilder::reticencesType() {
-  SymbolList fields;
-
-  fields.push_back(Symbol("tipo",
-    primitiveType(PortugolTokenTypes::T_LITERAL)));
-
-  fields.push_back(Symbol("valor",
-    primitiveType(PortugolTokenTypes::T_CORINGA)));
-
-  return matrixType(
-    structType("Par?metro", fields, "<interno>",-1), std::list<int>(1));
-}
-
-Type*
-TypeBuilder::subprogramType(const TypeList& paramTypes, Type* returnType) {
-  Type* ret = new Type(this, paramTypes, returnType);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::errorType() {
-  return new Type(this);
-}
-
-
-TypeList& TypeBuilder::typeList() {
-  return _types;
-}
-

Deleted: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,177 +0,0 @@
-#ifndef TYPES_HPP
-#define TYPES_HPP
-
-#include <string>
-#include <list>
-
-#include "PortugolTokenTypes.hpp"
-#include "Symbol.hpp"
-
-class TypeBuilder;
-class Type;
-
-class TypeList : public std::list<Type*> {
-public:
-
-  iterator find(const std::string& lexeme);
-
-  iterator find(Type* ofType, int dimensions);
-
-  iterator find(int id);
-
-
-  bool isLValueFor(const TypeList&) const;
-  bool equals(const TypeList&) const;
-
-  bool hasErrorType() const;
-
-  std::string toString() const;
-  std::string toIdentifier() const;
-};
-
-
-
-
-class Type : private PortugolTokenTypes {
-public:
-  enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM, ERROR };
-
-  //Error type
-  Type(TypeBuilder*);
-
-  //Primitive
-  Type(TypeBuilder*, int id, const std::string& name);
-  int primitiveType() const;
-
-  Type* intOrReal(Type* other);
-  Type* caracOrLit(Type* other);
-
-
-  //Matrix
-  Type(TypeBuilder*, Type* ofType, const std::list<int>& dimensions);
-
-  Type*                    ofType() const;
-  const std::list<int>&    dimensions() const;
-
-  Type*                    evalTypeFromSubscript(int);
-
-  //Struct
-  Type(TypeBuilder*,
-       const std::string& name,
-       const SymbolList& fields,
-       const std::string& unit, int line);
-
-  Type(TypeBuilder*, const SymbolList& fields);
-
-  const SymbolList& fields() const;
-  bool fieldsIsLValueFor(const SymbolList&);
-
-  //Subprogram
-  Type(TypeBuilder*, const TypeList& paramTypes, Type* returnType);
-
-  const TypeList& paramTypes() const;
-  Type* returnType() const;
-//   bool  paramMatches(const TypeList&) const;
-
-
-  /* General Methods */
-  void setConst(bool);
-  void setRef(bool);
-  bool isConst() const;
-  bool isRef()   const;
-
-  bool isError() const;
-  bool isPrimitive() const;
-  bool isMatrix() const;
-  bool isStruct() const;
-  bool isSubprogram() const;
-
-  const std::string& name() const;
-  std::string asmName(bool = false) const;
-  const std::string& identifier() const;
-
-  int byteSize() const;
-
-  bool equals(int id) const;
-  bool equals(Type* ofType, int dimensions) const;
-
-
-
-  //virtual
-  Type* attrPromotion(Type*);
-  bool  equals(const Type* other) const;
-  bool  isLValueFor(Type* rtype);
-
-
-  //impl primitive
-  Type* primitive_attrPromotion(Type* other);
-  bool  primitive_equals(const Type* other) const;
-  bool  primitive_isLValueFor(Type* rvalue);
-
-  //impl matrix
-  Type* matrix_attrPromotion(Type* other);
-  bool matrix_equals(const Type* other) const;
-  bool matrix_isLValueFor(Type* rvalue);
-
-  //impl struct
-  Type* struct_attrPromotion(Type* other);
-  bool struct_equals(const Type* other) const;
-  bool struct_isLValueFor(Type* rtype);
-
-  //impl subprogram
-  bool subprogram_equals(const Type* other) const;
-
-private:
-  int          _typeId;
-  TypeBuilder* _builder;
-
-  bool         _isConst;
-  bool         _isRef;
-
-  std::string  _name;
-  std::string  _identifier;
-
-  //Primitive
-  int         _id;
-
-  //matrix
-  Type             *_ofType;
-  std::list<int>   _dimensions;
-
-  //struct
-  bool             _anonymous;
-  SymbolList       _fields;
-  std::string      _unit;
-  int              _line;
-
-  //Subprogram
-  TypeList         _paramTypes;
-  Type*            _returnType;
-};
-
-class TypeBuilder {
-public:
-  Type* primitiveType(int id);
-
-  Type* matrixType(Type* ofType, const std::list<int>& dimensions);
-  Type* matrixType(Type* ofType, int);
-
-  Type* structType(const std::string& name,
-                   const SymbolList& fields,
-                   const std::string& unit,
-                   int line);
-
-  Type* structType(const SymbolList& fields);
-
-  Type* reticencesType();
-
-  Type* subprogramType(const TypeList& paramTypes, Type* returnType);
-
-  Type* errorType();
-
-  TypeList& typeList();
-private:
-  TypeList  _types;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,83 +0,0 @@
-#ifndef INC_UnicodeCharBuffer_hpp__
-#define INC_UnicodeCharBuffer_hpp__
-
-#include <istream>
-#include <cassert>
-#include <antlr/config.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/CharStreamIOException.hpp>
-
-class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
-public:
-	typedef unsigned int char_type;	// should be 32 bits!
-
-	/// Create a character buffer
-	UnicodeCharBuffer(std::istream& inp)
-	: input(inp)
-	{
-		//	input.exceptions(std::ios_base::badbit|
-		//						  std::ios_base::failbit);
-	}
-	/// Get the next character from the stream
-	int getChar()
-	{
-		char_type ch = 0;
-		int inchar = input.get();
-		if( inchar == EOF )
-			return -1;
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-		if( (inchar & 0x80) == 0 )
-			return inchar;
-
-		unsigned int need = 0;
-		if( (inchar & 0xF8) == 0xF8 )
-		{
-			ch = inchar & 7;
-			need = 3;
-		}
-		else if( (inchar & 0xE0) == 0xE0 )
-		{
-			ch = inchar & 0xF;
-			need = 2;
-		}
-		else if( (inchar & 0xC0) == 0xC0 )
-		{
-			ch = inchar & 0x1F;
-			need = 1;
-		}
-		else
-		{
-			assert("Invalid UTF8");
-		}
-		while( need )
-		{
-			inchar = input.get();
-			if( inchar == EOF )
-				assert("Invalid UTF8");
-//				throw antlr::CharStreamIOException(std::logic_error());
-			ch <<= 6;
-			ch += inchar & 0x3F;
-			need--;
-		}
-		return ch;
-	}
-private:
-	// character source
-	std::istream& input;
-
-	// NOTE: Unimplemented
-	UnicodeCharBuffer(const UnicodeCharBuffer& other);
-	UnicodeCharBuffer& operator=(const UnicodeCharBuffer& other);
-};
-
-#endif //INC_UnicodeCharBuffer_hpp__

Deleted: trunk/gpt2/gptc/src/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/gptc/src/UnicodeCharScanner.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/UnicodeCharScanner.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,561 +0,0 @@
-#ifndef INC_UnicodeCharScanner_hpp__
-#define INC_UnicodeCharScanner_hpp__
-
-#include <map>
-#include <cctype>
-
-#include <antlr/config.hpp>
-#include <antlr/CommonToken.hpp>
-#include <antlr/TokenStream.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/SemanticException.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/LexerSharedInputState.hpp>
-
-#include "MismatchedUnicodeCharException.hpp"
-
-/** Superclass of generated lexers
- */
-class UnicodeCharScanner : public antlr::TokenStream {
-protected:
-	typedef antlr::RefToken (*factory_type)();
-public:
-	typedef int char_type;
-	typedef std::map<std::string,int> string_map;
-
-	UnicodeCharScanner( antlr::InputBuffer& cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( const antlr::LexerSharedInputState& state, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(state)
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-
-	virtual ~UnicodeCharScanner()
-	{
-	}
-
-	virtual char_type LA(char_type i)
-	{
-		char_type c = inputState->getInput().LA(i);
-		return c;
-	}
-
-	virtual void append(char_type c)
-	{
-		if (saveConsumedInput)
-		{
-			size_t len = text.length();
-
-			if( (len % 256) == 0 )
-				text.reserve(len+256);
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-			if (c < 0x80)
-			{
-				text += c;
-				return;
-			}
-			else if (c < 0x800)
-			{
-				text += ( (c >> 6) | 0xC0 );
-				text += ( c & 0x3F | 0x80 );
-			}
-			else if (c < 0x10000)
-			{
-				text += ( (c >> 12) | 0xE0 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else if (c < 0x200000)
-			{
-				text += ( (c >> 18) | 0xF0 );				// first 3 bits
-				text += ( (((c >> 16) & 0x3) << 4) |
-								 ((c >> 12) & 0xF) | 0x80 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else
-				assert(0);
-		}
-	}
-
-	virtual void append(const std::string& s)
-	{
-		assert(0);
-		if (saveConsumedInput)
-			text+=s;
-	}
-
-	virtual void commit()
-	{
-		inputState->getInput().commit();
-	}
-
-	virtual void consume()
-	{
-		if (inputState->guessing == 0)
-		{
-			char_type c = LA(1);
-			append(c);
-			inputState->column++;
-		}
-		inputState->getInput().consume();
-	}
-
-	/** Consume chars until one matches the given char */
-	virtual void consumeUntil(char_type c)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || la_1 == c )
-				break;
-			consume();
-		}
-	}
-
-	/** Consume chars until one matches the given set */
-	virtual void consumeUntil(const antlr::BitSet& set)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || set.member(la_1) )
-				break;
-			consume();
-		}
-	}
-
-	/// Mark the current position and return a id for it
-	virtual unsigned int mark()
-	{
-		return inputState->getInput().mark();
-	}
-
-	/// Rewind the scanner to a previously marked position
-	virtual void rewind(unsigned int pos)
-	{
-		inputState->getInput().rewind(pos);
-	}
-
-	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
-	virtual void match(char_type c)
-	{
-		char_type la_1 = LA(1);
-		if ( la_1 != c )
-			throw MismatchedUnicodeCharException(la_1, c, false, this);
-		consume();
-	}
-
-	/** See if input contains element from bitset b
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void match(const antlr::BitSet& b)
-	{
-		char_type la_1 = LA(1);
-
-		if ( !b.member(la_1) )
-			throw MismatchedUnicodeCharException( la_1, b, false, this );
-		consume();
-	}
-
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match( const char* s )
-	{
-		while( *s != '\0' )
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (*s++ & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match(const std::string& s)
-	{
-		size_t len = s.length();
-
-		for (size_t i = 0; i < len; i++)
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (s[i] & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input does not contain character 'c'
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchNot(char_type c)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 == c )
-			throw MismatchedUnicodeCharException(la_1, c, true, this);
-
-		consume();
-	}
-	/** See if input contains character in range c1-c2
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchRange(char_type c1, char_type c2)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 < c1 || la_1 > c2 )
-			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
-
-		consume();
-	}
-
-	/// Get the line the scanner currently is in (starts at 1)
-	virtual int getLine() const
-	{
-		return inputState->line;
-	}
-
-	/// set the line number
-	virtual void setLine(int l)
-	{
-		inputState->line = l;
-	}
-
-	/// Get the column the scanner currently is in (starts at 1)
-	virtual int getColumn() const
-	{
-		return inputState->column;
-	}
-	/// set the column number
-	virtual void setColumn(int c)
-	{
-		inputState->column = c;
-	}
-
-	/// get the filename for the file currently used
-	virtual const std::string& getFilename() const
-	{
-		return inputState->filename;
-	}
-	/// Set the filename the scanner is using (used in error messages)
-	virtual void setFilename(const std::string& f)
-	{
-		inputState->filename = f;
-	}
-
-	virtual bool getCommitToPath() const
-	{
-		return commitToPath;
-	}
-
-	virtual void setCommitToPath(bool commit)
-	{
-		commitToPath = commit;
-	}
-
-	/** return a copy of the current text buffer */
-	virtual const std::string& getText() const
-	{
-		return text;
-	}
-
-	virtual void setText(const std::string& s)
-	{
-		text = s;
-	}
-
-	virtual void resetText()
-	{
-		text = "";
-		inputState->tokenStartColumn = inputState->column;
-		inputState->tokenStartLine = inputState->line;
-	}
-
-	virtual antlr::RefToken getTokenObject() const
-	{
-		return _returnToken;
-	}
-
-	///{ These need different handling in unicode case
-
-	virtual bool getCaseSensitiveLiterals() const=0;
-
-	virtual bool getCaseSensitive() const
-	{
-		return caseSensitive;
-	}
-
-	virtual void setCaseSensitive(bool t)
-	{
-		caseSensitive = t;
-	}
-
-	/** Override this method to get more specific case handling
-	 * @note some platforms probably require setting the right locale for
-	 * correct functioning.
-	 */
-	virtual char_type toLower(char_type c) const
-	{
-		return std::tolower(c);
-	}
-
-	/** Used to keep track of line breaks, needs to be called from
-	 * within generated lexers when a \n \r is encountered.
-	 */
-	virtual void newline()
-	{
-		++inputState->line;
-		inputState->column = 1;
-	}
-
-	/** Advance the current column number by an appropriate amount according
-	 * to the tabsize. This method needs to be explicitly called from the
-	 * lexer rules encountering tabs.
-	 */
-	virtual void tab()
-	{
-		int c = getColumn();
-		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
-		setColumn( nc );
-	}
-	/// set the tabsize. Returns the old tabsize
-	int setTabsize( int size )
-	{
-		int oldsize = tabsize;
-		tabsize = size;
-		return oldsize;
-	}
-	/// Return the tabsize used by the scanner
-	int getTabSize() const
-	{
-		return tabsize;
-	}
-	///}
-
-	/** Report exception errors caught in nextToken() */
-	virtual void reportError(const antlr::RecognitionException& ex)
-	{
-		std::cerr << ex.toString().c_str() << std::endl;
-	}
-
-	/** Parser error-reporting function can be overridden in subclass */
-	virtual void reportError(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "error: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
-	}
-
-	/** Parser warning-reporting function can be overridden in subclass */
-	virtual void reportWarning(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "warning: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
-	}
-
-	virtual antlr::InputBuffer& getInputBuffer()
-	{
-		return inputState->getInput();
-	}
-
-	virtual antlr::LexerSharedInputState getInputState()
-	{
-		return inputState;
-	}
-
-	/** set the input state for the lexer.
-	 * @note state is a reference counted object, hence no reference */
-	virtual void setInputState(antlr::LexerSharedInputState state)
-	{
-		inputState = state;
-	}
-
-	/// Set the factory for created tokens
-	virtual void setTokenObjectFactory(factory_type factory)
-	{
-		tokenFactory = factory;
-	}
-
-	/** Test the token text against the literals table
-	 * Override this method to perform a different literals test
-	 */
-	virtual int testLiteralsTable(int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** Test the text passed in against the literals table
-	 * Override this method to perform a different literals test
-	 * This is used primarily when you want to test a portion of
-	 * a token
-	 */
-	virtual int testLiteralsTable(const std::string& text, int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** This method is called by YourLexer::nextToken() when the lexer has
-	 *  hit EOF condition.  EOF is NOT a character.
-	 *  This method is not called if EOF is reached during
-	 *  syntactic predicate evaluation or during evaluation
-	 *  of normal lexical rules, which presumably would be
-	 *  an IOException.  This traps the "normal" EOF condition.
-	 *
-	 *  uponEOF() is called after the complete evaluation of
-	 *  the previous token and only if your parser asks
-	 *  for another token beyond that last non-EOF token.
-	 *
-	 *  You might want to throw token or char stream exceptions
-	 *  like: "Heh, premature eof" or a retry stream exception
-	 *  ("I found the end of this file, go back to referencing file").
-	 */
-	virtual void uponEOF()
-	{
-	}
-
-	/// Methods used to change tracing behavior
-	void traceIndent()
-	{
-		for( int i = 0; i < traceDepth; i++ )
-			std::cout << " ";
-	}
-
-	void traceIn(const char* rname)
-	{
-		traceDepth++;
-		traceIndent();
-		std::cout << "> lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-	}
-
-	void traceOut(const char* rname)
-	{
-		traceIndent();
-		std::cout << "< lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-		traceDepth--;
-	}
-
-#ifndef NO_STATIC_CONSTS
-	static const int EOF_CHAR = EOF;
-#else
-	enum {
-		EOF_CHAR = EOF
-	};
-#endif
-protected:
-	std::string text; ///< Text of current token
- 	/// flag indicating wether consume saves characters
-	bool saveConsumedInput;
-	factory_type tokenFactory;				///< Factory for tokens
-	bool caseSensitive; 						///< Is this lexer case sensitive
-	string_map literals;						 // set by subclass
-
-	antlr::RefToken _returnToken;		///< used to return tokens w/o using return val
-
-	/// Input state, gives access to input stream, shared among different lexers
-	antlr::LexerSharedInputState inputState;
-
-	/** Used during filter mode to indicate that path is desired.
-	 * A subsequent scan error will report an error as usual
-	 * if acceptPath=true;
-	 */
-	bool commitToPath;
-
-	unsigned int tabsize; 	///< tab size the scanner uses.
-
-	/// Create a new RefToken of type t
-	virtual antlr::RefToken makeToken(int t)
-	{
-		antlr::RefToken tok = tokenFactory();
-		// actually at this point you want to convert the stored lexeme text
-		// into the format you want to have it in in the backend...
-		tok->setType(t);
-		tok->setColumn(inputState->tokenStartColumn);
-		tok->setLine(inputState->tokenStartLine);
-		return tok;
-	}
-
-	/** Tracer class, used when -traceLexer is passed to antlr
-	 */
-	class Tracer {
-	private:
-		UnicodeCharScanner* parser;
-		const char* text;
-
-		Tracer(const Tracer& other); 					// undefined
-		Tracer& operator=(const Tracer& other); 	// undefined
-	public:
-		Tracer( UnicodeCharScanner* p, const char* t )
-		: parser(p), text(t)
-		{
-			parser->traceIn(text);
-		}
-		~Tracer()
-		{
-			parser->traceOut(text);
-		}
-	};
-
-	int traceDepth;
-private:
-	UnicodeCharScanner( const UnicodeCharScanner& other ); 		  		// undefined
-	UnicodeCharScanner& operator=( const UnicodeCharScanner& other );	// undefined
-};
-
-#endif //INC_UnicodeCharScanner_hpp__

Copied: trunk/gpt2/gptc/src/common/CompilerError.cpp (from rev 420, trunk/gpt2/gptc/src/CompilerError.cpp)

Copied: trunk/gpt2/gptc/src/common/CompilerError.hpp (from rev 420, trunk/gpt2/gptc/src/CompilerError.hpp)

Added: trunk/gpt2/gptc/src/common/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/common/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/common/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,5 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src/symboltable -I../parser
+
+noinst_LTLIBRARIES = libcommon.la
+libcommon_la_SOURCES = CompilerError.cpp CompilerError.hpp PortugolAST.cpp \
+	PortugolAST.hpp

Copied: trunk/gpt2/gptc/src/common/PortugolAST.cpp (from rev 423, trunk/gpt2/gptc/src/PortugolAST.cpp)

Copied: trunk/gpt2/gptc/src/common/PortugolAST.hpp (from rev 423, trunk/gpt2/gptc/src/PortugolAST.hpp)

Deleted: trunk/gpt2/gptc/src/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/gptasm.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,301 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include "BaseGptAsmWalker.hpp"
-  #include "PortugolAST.hpp"
-  #include "GptAsmExpression.hpp"
-  #include "AsmProgram.hpp"
-  #include "SymbolTable.hpp"
-}
-
-options {
-  language="Cpp";
-}
-
-class GptAsmWalker extends TreeParser("BaseGptAsmWalker");
-options {
-  importVocab    = Portugol;
-  noConstructors = true;
-  genHashLines   = false;
-  ASTLabelType   = "RefPortugolAST";
-}
-
-{
-public:
-  GptAsmWalker::GptAsmWalker(SymbolTable* symtable,
-                             const std::string& filepath)
-	 : BaseGptAsmWalker(symtable, filepath) {}
-}
-
-
-programa
-  : #(T_ALGORITMO                {_asmPrg->init();}
-
-        (importacao)*
-
-        (declaracoes)?
-
-        (corpo)?
-                                {_asmPrg->finishSubroutine(_subroutine);}
-        EOF
-     )
-                                {_asmPrg->finish();}
-  ;
-
-importacao
-  : #(T_USE T_TEXTO_LITERAL)
-  ;
-
-declaracoes
-  : declaracao_variavel[false]    (declaracoes)?
-  | declaracao_constante[false]   (declaracoes)?
-  | declaracao_estrutura          (declaracoes)?
-  ;
-
-declaracao_variavel[bool isLocal]
-
-                                          {std::list<std::string> ids;}
-
-  : #(T_VARIAVEL tipo ids=identificadores
-                                          {
-                                            if (isLocal) {
-                                              declareSubroutineVars(ids);
-                                            } else {
-                                              declareProgramVars(ids);
-                                            }
-                                          }
-//       (
-//         code=valor_inicialiacao            {addPrologue(code);}
-//       )?
-    )
-  ;
-
-declaracao_constante[bool isLocal]
-                                          {std::list<std::string> ids;}
-
-  : #(T_CONSTANTE tipo ids=identificadores /*code=valor_inicialiacao*/)
-
-                                          {
-                                            if (isLocal) {
-                                              declareSubroutineVars(ids);
-                                            } else {
-                                              declareProgramVars(ids);
-                                            }
-                                          }
-  ;
-
-identificadores returns [std::list<std::string> ids]
-  : (id:T_IDENTIFICADOR {ids.push_back(id->getText());})+
-  ;
-
-tipo
-  : T_IDENTIFICADOR
-  | T_MATRIZ
-  | T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-declaracao_estrutura
-  : #(T_ESTRUTURA T_IDENTIFICADOR (campo_estrutura)+)
-  ;
-
-campo_estrutura
-                      {std::list<std::string> ids;}
-
-  : #(T_VARIAVEL tipo ids=identificadores
-//       (
-//         valor_inicialiacao
-//       )?
-    )
-  ;
-
-
-
-
-/////////////////////////////////////////////////////////////
-
-
-
-
-/************************** EXPRESSOES *************************/
-
-
-expressao returns [GptAsmExpression* ret]
-
-  : #(T_EXPRESSAO ret=expr)
-  ;
-
-expr returns [GptAsmExpression* ret]
-
-                        {
-                          GptAsmExpression *l, *r;
-                          Type *optype = _t->getEvalType();
-                        }
-
-  : #(T_OU              l=expr r=expr) {ret=expr_OU(optype, l, r);}
-  | #(T_E               l=expr r=expr) {ret=expr_E(optype, l, r);}
-  | #(T_BIT_OU          l=expr r=expr) {ret=expr_BIT_OU(optype, l, r);}
-  | #(T_BIT_OUX         l=expr r=expr) {ret=expr_BIT_XOU(optype, l, r);}
-  | #(T_BIT_E           l=expr r=expr) {ret=expr_BIT_E(optype, l, r);}
-  | #(T_IGUAL           l=expr r=expr) {ret=expr_IGUAL(optype, l, r);}
-  | #(T_DIFERENTE       l=expr r=expr) {ret=expr_DIFERENTE(optype, l, r);}
-  | #(T_MAIOR           l=expr r=expr) {ret=expr_MAIOR(optype, l, r);}
-  | #(T_MENOR           l=expr r=expr) {ret=expr_MENOR(optype, l, r);}
-  | #(T_MAIOR_EQ        l=expr r=expr) {ret=expr_MAIOR_EQ(optype, l, r);}
-  | #(T_MENOR_EQ        l=expr r=expr) {ret=expr_MENOR_EQ(optype, l, r);}
-  | #(T_BIT_SHIFT_LEFT  l=expr r=expr) {ret=expr_BIT_SHIFT_LEFT(optype, l, r);}
-  | #(T_BIT_SHIFT_RIGHT l=expr r=expr) {ret=expr_BIT_SHIFT_RIGHT(optype, l, r);}
-  | #(T_MAIS            l=expr r=expr) {ret=expr_MAIS(optype, l, r);}
-  | #(T_MENOS           l=expr r=expr) {ret=expr_MENOS(optype, l, r);}
-  | #(T_DIV             l=expr r=expr) {ret=expr_DIV(optype, l, r);}
-  | #(T_MULTIP          l=expr r=expr) {ret=expr_MULTIP(optype, l, r);}
-  | #(T_MOD             l=expr r=expr) {ret=expr_MOD(optype, l, r);}
-  | #(T_UN_NEGATIVO     l=elemento)  {ret=expr_UN_NEGATIVO(optype,l);}
-  | #(T_UN_POSITIVO     l=elemento)  {ret=expr_UN_POSITIVO(optype,l);}
-  | #(T_NAO             l=elemento)  {ret=expr_UN_NAO(optype,l);}
-  | #(T_BIT_NAO         l=elemento)  {ret=expr_BIT_NAO(optype,l);}
-  | ret=elemento
-  ;
-
-
-elemento returns [GptAsmExpression* ret]
-                      {
-                        Symbol lv;
-                      }
-  : ret=literal
-  | lv=lvalue         {ret = new GptAsmExpression(lv.type(), lv.identifier());}
-//   | ret=chamada_subrotina
-  | #(T_EXPRESSAO ret=expr)
-  ;
-
-literal returns [GptAsmExpression* ret]
-
-                                    {
-                                      Type *type = _t->getEvalType();
-                                      std::string value;
-                                    }
-
-  : (   t:T_TEXTO_LITERAL           {value = '"' + t->getText() + '"';}
-      | i:T_INTEIRO_LITERAL         {value = i->getText();}
-      | r:T_REAL_LITERAL            {value = r->getText();}
-      | c:T_CARACTERE_LITERAL       {value = "'" + c->getText() + "'";}
-      | v:T_VERDADEIRO              {value = "true";}
-      | f:T_FALSO                   {value = "false";}
-    )
-      {ret = new GptAsmExpression(type, value);}
-  ;
-
-
-lvalue returns [Symbol ret]
-
-  : #(lv:T_LVALUE 
-      id:T_IDENTIFICADOR  
-
-                     {ret = _symtable->getSymbol(id->getText());}
-
-//       (
-//_subroutine->declareTmp(lv->getEvalType());
-//         lvalue_indices[lv]
-//       )?
-
-//       (
-//         lvalue_membro
-//       )?
-    )
-  ;
-
-
-lvalue_indices[const std::string id]
-                                {
-                                  std::list<std::string> dimensions;
-                                  std::string tmp;
-                                }
-  : #(T_SUBSCRITO
-        (
-                                {/*tmp = _subroutine->newTmp();*/}
-          expressao
-                                {dimensions.push_back(tmp);}
-        )+
-    )
-//                                 {ret = expandOffset(id, dimensions);}
-  ;
-
-
-lvalue_membro
-  : #(T_MEMBRO lvalue)
-  ;
-
-
-
-
-
-
-
-
-corpo
-  :  bloco_codigo           /*(corpo_subprograma)**/
-//   |  corpo_subprograma      (corpo)?
-  ;
-
-bloco_codigo
-  : #(T_INICIO lista_enunciados)
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-  : en_atribuicao
-/*  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-  | T_SAIR
-  | chamada_subrotina*/
-  ;
-
-en_atribuicao
-                      {
-                        Symbol lv;
-                        GptAsmExpression *expr;
-                      }
-  : #(T_ATRIBUICAO
-        lv=lvalue
-
-        expr=expressao
-                      {                        
-                        if (expr->isAtom()) {
-                          emitAttribution(lv, expr->value());
-                        } else {
-                          expr->expand(lv.identifier(), _subroutine);
-                        }
-                        delete expr;
-                      }
-      )
-  ;
-

Copied: trunk/gpt2/gptc/src/gptasm_target/Arguments.cpp (from rev 438, trunk/gpt2/gptc/src/Arguments.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Arguments.hpp (from rev 432, trunk/gpt2/gptc/src/Arguments.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/AsmProgram.cpp (from rev 438, trunk/gpt2/gptc/src/AsmProgram.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/AsmProgram.hpp (from rev 432, trunk/gpt2/gptc/src/AsmProgram.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp (from rev 438, trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.hpp (from rev 438, trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Context.cpp (from rev 432, trunk/gpt2/gptc/src/Context.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Context.hpp (from rev 432, trunk/gpt2/gptc/src/Context.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.cpp (from rev 438, trunk/gpt2/gptc/src/GptAsmExpression.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.hpp (from rev 438, trunk/gpt2/gptc/src/GptAsmExpression.hpp)

Added: trunk/gpt2/gptc/src/gptasm_target/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,22 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I../parser \
+           -I$(top_srcdir)/src/symboltable -I$(top_srcdir)/src/common
+
+noinst_LTLIBRARIES = libgptasm.la
+
+EXTRA_DIST = gptasm.g
+
+BUILT_SOURCES = GptAsmWalker.hpp GptAsmWalker.cpp
+
+
+libgptasm_la_SOURCES = Arguments.cpp Arguments.hpp AsmProgram.cpp AsmProgram.hpp\
+	BaseGptAsmWalker.cpp BaseGptAsmWalker.hpp Context.cpp Context.hpp\
+	GptAsmExpression.cpp GptAsmExpression.hpp Options.hpp Subroutine.cpp\
+	Subroutine.hpp TextFile.cpp TextFile.hpp Tools.cpp Tools.hpp $(BUILT_SOURCES)
+
+CLEANFILES = GptAsmWalkerTokenTypes.hpp \
+             GptAsmWalker.cpp \
+						 GptAsmWalker.hpp  \
+             GptAsmWalkerTokenTypes.txt
+
+GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
+	$(ANTLR_BIN) $(srcdir)/gptasm.g

Copied: trunk/gpt2/gptc/src/gptasm_target/Options.hpp (from rev 432, trunk/gpt2/gptc/src/Options.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Subroutine.cpp (from rev 438, trunk/gpt2/gptc/src/Subroutine.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Subroutine.hpp (from rev 438, trunk/gpt2/gptc/src/Subroutine.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/TextFile.cpp (from rev 432, trunk/gpt2/gptc/src/TextFile.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/TextFile.hpp (from rev 432, trunk/gpt2/gptc/src/TextFile.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Tools.cpp (from rev 432, trunk/gpt2/gptc/src/Tools.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Tools.hpp (from rev 432, trunk/gpt2/gptc/src/Tools.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/gptasm.g (from rev 438, trunk/gpt2/gptc/src/gptasm.g)

Deleted: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/lexer.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,615 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include <string>
-  #include <sstream>
-  #include <iostream>
-  #include <ctype.h>
-  #include "UnicodeCharBuffer.hpp"
-  #include "UnicodeCharScanner.hpp"
-}
-
-options {
-  language="Cpp";
-}
-
-class PortugolLexer extends Lexer("UnicodeCharScanner");
-
-options {
-  k=2;
-  genHashLines   = false;
-  exportVocab    = Portugol;
-  filter         = T_INVALIDO;
-  testLiterals   = false;
-}
-
-tokens {
-  T_ALGORITMO="algoritmo";
-  T_USE="use";
-  T_VARIAVEL="vari?vel";
-  T_VARIAVEIS="vari?veis";
-  T_FIM_VARIAVEIS="fim-vari?veis";
-  T_INTEIRO="inteiro";
-  T_REAL="real";
-  T_CARACTERE="caractere";
-  T_LITERAL="literal";
-  T_LOGICO="l?gico";
-  T_CORINGA="coringa";
-  T_MATRIZ="matriz";
-  T_DO="do";
-  T_TIPO="tipo";
-  T_CONSTANTE="constante";
-  T_CONSTANTES="constantes";
-  T_FIM_CONSTANTES="fim-constantes";
-  T_ESTRUTURA="estrutura";
-  T_FIM_ESTRUTURA="fim-estrutura";
-  T_FUNCAO="fun??o";
-  T_PROCEDIMENTO="procedimento";
-  T_REF="ref";
-  T_INICIO="in?cio";
-  T_FIM="fim";
-  T_SAIR="sair";
-  T_RETORNE="retorne";
-  T_SE="se";
-  T_ENTAO="ent?o";
-  T_SENAO="sen?o";
-  T_FIM_SE="fim-se";
-  T_ENQUANTO="enquanto";
-  T_FACA="fa?a";
-  T_FIM_ENQUANTO="fim-enquanto";
-  T_PARA="para";
-  T_DE="de";
-  T_ATE="at?";
-  T_FIM_PARA="fim-para";
-  T_PASSO="passo";
-  T_REPITA="repita";
-  T_CASO="caso";
-  T_SEJA="seja";
-  T_FIM_SENAO="fim-sen?o";
-  T_FIM_CASO="fim-caso";
-  T_FIM_FACA="fim-fa?a";
-  T_OU="ou";
-  T_E="e";
-  T_NAO="n?o";
-  T_VERDADEIRO="verdadeiro";
-  T_FALSO="falso";
-  T_ASM="asm";
-  T_FIMASM="fim-asm";  
-
-  T_REAL_LITERAL="n?mero real"; //a regra T_INTEIRO_LITERAL lida com reais
-  
-  //imagin?rios para a AST
-
-  T_NULO="nulo";
-  T_LVALUE;
-  
-
-  T_PARAM;
-  T_TIPO_RETORNO;
-
-  T_VALOR;
-  T_VAL_MATRIZ;    //valor da matriz    (literal [])
-  T_VAL_ESTRUTURA; //valor da estrutura (literal {})
-
-  T_EXPRESSAO;
-
-//   T_DIMENSOES;
-  T_SUBSCRITO;
-  T_MEMBRO;
-
-  T_UN_POSITIVO;
-  T_UN_NEGATIVO;
-
-  T_CALL;
-}
-
-
-{
-public:
-  PortugolLexer(std::istream& in, bool case_s)
-   : UnicodeCharScanner(new UnicodeCharBuffer(in), case_s)
-    {
-      initLiterals();
-    }
-
-private:
-
-  std::string toBase10(const std::string& oct, int from) {
-    std::stringstream stream;
-    unsigned long long base10;
-    base10 = strtoull(oct.c_str(), NULL, from);
-    stream << base10;
-    return stream.str();
-  }
-
-  bool isOctal(const std::string& num) {
-    std::stringstream s;
-    if ((num.find("8",0)  != std::string::npos) ||
-        (num.find("9",0)  != std::string::npos)) {
-      return false;
-    } else {
-      for (unsigned int i = 2; i < num.length(); ++i) {
-        if (!isdigit(num[i])) {
-          return false;
-        }
-      }
-    }
-    return true;
-  }
-
-  bool isHex(const std::string& num) {
-    for (unsigned int i = 2; i < num.length(); ++i) {
-      if (!isxdigit(num[i])) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  bool isBin(const std::string& num) {
-    for(unsigned int i = 2; i < num.length(); ++i) {
-      if ((num[i] != '0') && (num[i] != '1')) {
-        return false;
-      }
-    }
-    return true;
-  }
-}
-
-
-//####################################
-//##             Regras             ##
-//####################################
-
-
-
-T_ESPACO :
-  (   ' '
-    | '\t'
-    | '\n' { newline(); }
-    | '\r'
-  )
-  { $setType(antlr::Token::SKIP); }
-  ;
-
-COMENTARIO_CPP
-  : "//" (~('\n'))* ('\n')?
-    {
-      newline();
-      $setType(antlr::Token::SKIP);
-    }
-  ;
-
-COMENTARIO_C
-{int line = getLine();}
-  : "/*"
-    (
-      options { generateAmbigWarnings=false; } :
-        '\n'                     {newline();}
-      | ('\r' '\n')=> '\r' '\n'  {newline();}
-      | '\r'                     {newline();}
-      |~('*'|'\n'|'\r')
-      | ('*' ~'/' )=> '*'
-    )*
-    "*/"
-    {$setType(antlr::Token::SKIP);}
-  ;
-exception
-catch[antlr::RecognitionException] {
-  std::stringstream s;
-  //aviso! n?o ? erro!
-  s << "coment?rio iniciado na linha " << line << " n?o termina com \"*/\".";
-  std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-  $setType(antlr::Token::SKIP);
-}
-
-T_PONTO_VIRGULA
-options {
-  paraphrase = "';'";
-}
-  : ';'
-  ;
-
-T_VIRGULA
-options {
-  paraphrase = "','";
-}
-  : ','
-  ;
-
-T_2_PONTOS
-options {
-  paraphrase = "':'";
-}
-
-  : ':'
-  ;
-
-T_ABRE_CHAVE
-options {
-  paraphrase = "'['";
-}
-  : '['
-  ;
-
-T_FECHA_CHAVE
-options {
-  paraphrase = "']'";
-}
-  : ']'
-  ;
-
-T_ABRE_COLCHETE
-options {
-  paraphrase = "'{'";
-}
-  : '{'
-  ;
-
-T_FECHA_COLCHETE
-options {
-  paraphrase = "'}'";
-}
-  : '}'
-  ;
-
-T_ABRE_PAREN
-options {
-  paraphrase = "'('";
-}
-  : '('
-  ;
-T_FECHA_PAREN
-options {
-  paraphrase = "')'";
-}
-  : ')'
-  ;
-
-T_ATRIBUICAO
-options {
-  paraphrase = "':='";
-}
-  : ":="
-  ;
-
-T_BIT_OU
-options {
-  paraphrase = "operador '|'";
-}
-  : '|'
-  ;
-
-T_BIT_OUX
-options {
-  paraphrase = "operador '^'";
-}
-  : '^'
-  ;
-
-T_BIT_E
-options {
-  paraphrase = "operador '&'";
-}
-  : '&'
-  ;
-
-T_BIT_NAO
-options {
-  paraphrase = "operador '~'";
-}
-  : '~'
-  ;
-
-T_BIT_SHIFT_LEFT
-options {
-  paraphrase = "operador '<<'";
-}
-  : "<<"
-  ;
-
-T_BIT_SHIFT_RIGHT
-options {
-  paraphrase = "operador '>>'";
-}
-
-  : ">>"
-  ;
-
-T_IGUAL
-options {
-  paraphrase = "operador '='";
-}
-  : '='
-  ;
-
-T_DIFERENTE
-options {
-  paraphrase = "operador '<>'";
-}
-  : "<>"
-  ;
-
-T_MAIOR
-options {
-  paraphrase = "operador '>'";
-}
-  : '>'
-  ;
-
-T_MAIOR_EQ
-options {
-  paraphrase = "operador '>='";
-}
-  : ">="
-  ;
-
-T_MENOR
-options {
-  paraphrase = "operador '<'";
-}
-  : '<'
-  ;
-T_MENOR_EQ
-options {
-  paraphrase = "operador '<='";
-}
-  : "<="
-  ;
-
-T_MAIS
-options {
-  paraphrase = "operador '+'";
-}
-  : '+'
-  ;
-
-T_MENOS
-options {
-  paraphrase = "operador '-'";
-}
-  : '-'
-  ;
-
-T_DIV
-options {
-  paraphrase = "operador '/'";
-}
-  : '/'
-  ;
-
-T_MULTIP
-options {
-  paraphrase = "operador '*'";
-}
-  : '*'
-  ;
-
-T_MOD
-options {
-  paraphrase = "operador '%'";
-}
-  : '%'
-  ;
-
-/* Literais */
-
-
-T_INTEIRO_LITERAL
-options {
-  paraphrase = "n?mero inteiro";
-}
-  : ('0' ('c'|'C') )=> T_OCTAL_LIT
-  | ('0' ('x'|'X') )=> T_HEX_LIT
-  | ('0' ('b'|'B') )=> T_BIN_LIT
-  | (T_DIGITO)+
-    (
-      '.' (T_DIGITO)+
-      {$setType(T_REAL_LITERAL);}
-    )?
-  ;
-
-T_TEXTO_LITERAL
-options {
-  paraphrase = "literal";
-}
-  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | T_ESCAPE )* '"'!
-  ;
-
-
-T_CARACTERE_LITERAL
-options {
-  paraphrase = "caractere";
-}
-  : '\''! ( ~( '\'' | '\\' ) | T_ESCAPE )? '\''!
-  ;
-
-
-
-/*
-  Ok, um pouco de malabarismo...
-
-  Eis o problema:
-
-  N?s precisamos que uma string como "fim-vari?veis" seja
-  identificada pelo scanner. Para isso, as keywords em tokens{} devem
-  ser cobertos pelas regras T_*. No caso, T_IDENTIFICADOR
-  costuma ser a regra que identifica keywords.
-
-  Por?m, "fim-vari?veis" n?o ? um identificador v?lido
-  (ambig. com "fim - vari?veis").
-
-  Ent?o, T_IDENTIFICADOR aqui representa a regra mais geral poss?vel,
-  para cobrir as keywords em tokens{}. Mas, para o caso problem?tico
-  de T_IDENTIFICADOres com "-", verificamos se o lexema atual
-  ? uma keyword ou um identificador seguido de T_MENOS, utilizando
-  "testLiteralsTable" manualmente.
-
-  Se testLiteralsTable indicar que o lexema atual com hifen for uma keyword,
-  ? a pr?pria, obviamente.
-
-  Se n?o, trata-se de um ID seguido de T_MENOS. Ent?o, fazemos o rollback
-  at? o ponto do hifen.
-*/
-
-T_IDENTIFICADOR
-options {
-  testLiterals = true;
-}
-  { int m = -1,len; }
-
-  : T_ID_AUX
-      {
-        len = $getText.length();
-        if (LA(1) == '-') {
-          m = mark();
-        }
-      }
-
-    ('-' (T_LETRA_OU_DIGITO)*)?
-  {
-    if ((m != -1) && (testLiteralsTable(_ttype) == T_IDENTIFICADOR)) {
-      rewind(m);
-      std::string s = $getText;
-      $setText(s.substr(0,len));
-    }
-  }
-  ;
-
-
-T_RETICENCIAS
-options {
-  paraphrase = "retic?ncias (...)";
-}
-  : "..."
-  ;
-
-T_PONTO
-options {
-  paraphrase = "ponto (.)";
-}
-  : '.'
-  ;
-
-//####################################
-//##            Protecteds          ##
-//####################################
-
-
-protected
-T_ESCAPE
-  : '\\' .  /* ex. \a */
-  ;
-
-protected
-T_DIGITO
-  : '0'..'9'
-  ;
-
-protected
-T_LETRA
-  : 'a'..'z'|'A'..'Z' | '\u00C0' .. '\u00FF' /* latim-1 */
-  ;
-
-
-protected
-T_LETRA_OU_DIGITO
-  : T_LETRA | T_DIGITO | '_'
-  ;
-
-
-//mais detalhes em T_IDENTIFICADOR
-protected
-T_ID_AUX
-  : (T_LETRA | '_') (T_LETRA_OU_DIGITO)*
-  ;
-
-protected
-T_OCTAL_LIT
-  : '0' ('c'|'C') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isOctal(str)) {
-      $setText(toBase10(str.substr(2), 8));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero octal v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_HEX_LIT
-  : '0' ('x'|'X') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isHex(str)) {
-      $setText(toBase10(str, 16));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero hexadecimal v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_BIN_LIT
-  : '0' ('b'|'B') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isBin(str)) {
-      $setText(toBase10(str.substr(2), 2));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero bin?rio v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_INVALIDO
-  : .
-    {
-      //caracteres de espa?o inexistentes na tabela ascii
-      //([160] == [-96] == ' ' == [32] == 160-128)
-      if ($getText.c_str()[0] == (int)0xffffffa0) {
-        $setType(antlr::Token::SKIP);
-      } else {
-        std::stringstream s;
-        if (($getText != "\"") && ($getText != "'")) {
-          s << "Caractere inv?lido: \"" << $getText << "\".\n";
-          s << "Verifique se a codifica??o do texto est? em UTF-8";
-        } else {
-          s << "Faltando fechar aspas";
-        }
-        std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-      }
-    }
-  ;

Added: trunk/gpt2/gptc/src/parser/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,62 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common
+
+EXTRA_DIST = lexer.g parser.g
+
+noinst_LTLIBRARIES = libparser.la
+
+BUILT_SOURCES = PortugolLexer.hpp \
+                PortugolLexer.cpp \
+                PortugolParser.hpp \
+                PortugolParser.cpp \
+                TokenNames.hpp \
+                TokenLabels.hpp
+
+libparser_la_SOURCES = MismatchedUnicodeCharException.cpp \
+	MismatchedUnicodeCharException.hpp UnicodeCharBuffer.hpp \
+	UnicodeCharScanner.hpp $(BUILT_SOURCES)
+
+
+CLEANFILES = PortugolLexer.cpp \
+             PortugolLexer.hpp \
+             PortugolTokenTypes.hpp \
+             PortugolTokenTypes.txt \
+             PortugolParser.cpp \
+						 PortugolParser.hpp  \
+             PortugolParserTokenTypes.hpp \
+             PortugolParserTokenTypes.txt \
+             TokenNames.hpp \
+             TokenLabels.hpp
+
+PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g
+	$(ANTLR_BIN) $(srcdir)/lexer.g
+	cp PortugolTokenTypes.txt ../semantic
+	cp PortugolTokenTypes.txt ../gptasm_target
+
+PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g
+	$(ANTLR_BIN) $(srcdir)/parser.g
+
+TokenNames.hpp: Makefile
+	@echo "#ifndef TOKENNAMES_H" > $@
+	@echo "#define TOKENNAMES_H"  >> $@
+	@echo "static char* g_tokenNames[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep = PortugolTokenTypes.txt >> $@
+	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo -n "static int g_tokenNamesSize = " >> $@
+	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
+	@echo "#endif" >> $@
+
+TokenLabels.hpp: Makefile
+	@echo "#ifndef TOKENLABELS_H" > $@
+	@echo "#define TOKENLABELS_H"  >> $@
+	@echo "static char* g_tokenLabels[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep '"' PortugolTokenTypes.txt >> $@
+	sed -i -e 's/^T.*\("[^"]*"\).*/\1,/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo "static int g_tokenLabelsSize = " >> $@
+	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc >> $@
+	@echo ";" >> $@
+	@echo "#endif" >> $@
\ No newline at end of file

Copied: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp (from rev 420, trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp)

Copied: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp (from rev 420, trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp)

Copied: trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp (from rev 420, trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp)

Copied: trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp (from rev 420, trunk/gpt2/gptc/src/UnicodeCharScanner.hpp)

Copied: trunk/gpt2/gptc/src/parser/lexer.g (from rev 435, trunk/gpt2/gptc/src/lexer.g)

Copied: trunk/gpt2/gptc/src/parser/parser.g (from rev 435, trunk/gpt2/gptc/src/parser.g)

Deleted: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/parser.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,565 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-header {
-  #include <antlr/NoViableAltException.hpp>
-  #include <antlr/SemanticException.hpp>
-
-  #include "PortugolAST.hpp"
-  using namespace antlr;
-}
-
-options {
-  language="Cpp";
-}
-
-class PortugolParser extends Parser;
-options {
-  importVocab    = Portugol;
-  genHashLines   = false;
-  buildAST       = true;
-  ASTLabelType   = "RefPortugolAST";
-  noConstructors = true;
-}
-
-{
-public:
-  PortugolParser(antlr::TokenBuffer& tokenBuf, bool report = true)
-  : antlr::LLkParser(tokenBuf,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  PortugolParser(antlr::TokenStream& lexer, bool report = true)
-  : antlr::LLkParser(lexer,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  void reportError(const RecognitionException& ex) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    std::cerr << ex.toString().c_str() << std::endl;
-  }
-
-  void reportError(const std::string& s) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    if (getFilename() == "") {
-      std::cerr << "error: " << s.c_str() << std::endl;
-    } else {
-      std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
-    }
-  }
-
-  void reportWarning(const std::string& s) {
-    if (!_reportErrors) return;
-    if (getFilename() == "") {
-      std::cerr << "warning: " << s.c_str() << std::endl;
-    } else {
-      std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
-    }
-  }
-
-  bool hasErorrs() {
-    return _hasErrors;
-  }
-
-private:
-  void createRootNode(antlr::ASTPair& ast, antlr::RefToken token) {
-    astFactory->makeASTRoot(ast, astFactory->create(token));
-  }
-
-  void createRootNode(antlr::ASTPair& ast, int token, std::string txt = "") {
-    astFactory->makeASTRoot(ast, astFactory->create(token, txt));
-  }
-
-  void addChildNode(antlr::ASTPair& ast, antlr::RefToken token) {
-    astFactory->addASTChild(ast, astFactory->create(token));
-  }
-
-  void addChildNode(antlr::ASTPair& ast, RefAST child) {
-    astFactory->addASTChild(ast, child);
-  }
-
-  antlr::RefAST createNode(int type, const std::string& txt) {
-    return astFactory->create(type, txt);
-  }
-
-  bool _reportErrors;
-  bool _hasErrors;
-}
-
-
-
-//####################################
-//##             In?cio             ##
-//####################################
-
-programa
-{createRootNode(currentAST, T_ALGORITMO, "&algoritmo");}
-
-  : (declaracao_algoritmo)?
-
-    (importacao)*
-
-    (   declaracao_variaveis
-      | declaracao_constantes
-      | bloco_declaracao_estrutura
-    )*
-
-    corpo
-
-    EOF
-  ;
-
-declaracao_algoritmo!
-  : T_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
-  ;
-
-importacao
-  : T_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
-  ;
-
-corpo
-  :  declaracao_subprograma corpo
-  |  bloco_codigo           (declaracao_subprograma)*
-  |  /*vazio*/
-  ;
-
-
-
-//####################################
-//##    Declara??o de Vari?veis     ##
-//####################################
-
-declaracao_variaveis
-  : bloco_declaracao_variaveis
-  | T_VARIAVEL! declaracao_variavel_uniq
-  ;
-
-bloco_declaracao_variaveis
-  : T_VARIAVEIS! (declaracao_variavel)+ T_FIM_VARIAVEIS!
-  ;
-
-declaracao_variavel!
-  : ids:lista_identificadores   T_2_PONTOS
-    t:tipo (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,"&var"], t,ids);
-              } else {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,"&var"], t,ids,([T_VALOR,"&valor"],l));
-              }
-            }
-  ;
-
-lista_identificadores
-  : T_IDENTIFICADOR (T_VIRGULA! T_IDENTIFICADOR)*
-  ;
-
-declaracao_variavel_uniq!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel_uniq=
-                    #([T_VARIAVEL,"&var"], t,id);
-              } else {
-                #declaracao_variavel_uniq =
-                    #([T_VARIAVEL,"&var"], t,id,([T_VALOR,"&valor"],l));
-              }
-            }
-  ;
-
-tipo
-  : tipo_primitivo
-  | tipo_matriz
-  | T_IDENTIFICADOR
-  ;
-
-lista_inicializacao
-  : T_ATRIBUICAO! (expressao | inicializacao_composta)
-  ;
-
-inicializacao_composta!
-  : ch:T_ABRE_CHAVE!
-      idx:inicializacao_indices
-    T_FECHA_CHAVE!
-
-                 {
-                   #inicializacao_composta = #([T_VAL_MATRIZ, "&vmatriz"],idx);
-                   #inicializacao_composta->setLine(ch->getLine());
-                 }
-
-  | co:T_ABRE_COLCHETE!
-      mem:inicializacao_membros
-    T_FECHA_COLCHETE!
-
-                 {
-                   #inicializacao_composta =
-                       #([T_VAL_ESTRUTURA, "&vestr"],mem);
-                   #inicializacao_composta->setLine(co->getLine());
-                 }
-  ;
-
-inicializacao_indices
-  : (expressao | inicializacao_composta) (T_VIRGULA! inicializacao_indices)?
-  ;
-
-inicializacao_membros
-  : T_IDENTIFICADOR T_ATRIBUICAO! (expressao | inicializacao_composta)
-    (T_VIRGULA! inicializacao_membros)?
-  ;
-
-tipo_primitivo
-  : T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-tipo_matriz!
-  : m:T_MATRIZ dim:matriz_dimensoes
-    T_DO T_TIPO t:tipo_da_matriz
-
-                    {#tipo_matriz = #(m, t,dim);}
-  ;
-
-matriz_dimensoes
-  : ( T_ABRE_CHAVE!
-      ( T_INTEIRO_LITERAL
-        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULO,"&null"));}
-      )
-      T_FECHA_CHAVE!
-    )+
-  ;
-
-tipo_da_matriz
-  : tipo_primitivo | T_IDENTIFICADOR
-  ;
-
-
-
-//####################################
-//##    Declara??o de Constantes    ##
-//####################################
-
-
-declaracao_constantes
-  : bloco_declaracao_constantes
-  | T_CONSTANTE! declaracao_constante
-  ;
-
-bloco_declaracao_constantes
-  : T_CONSTANTES! (declaracao_constante)+ T_FIM_CONSTANTES!
-  ;
-
-declaracao_constante!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    l:lista_inicializacao T_PONTO_VIRGULA
-               {#declaracao_constante =
-                    #([T_CONSTANTE,"&const"],t,id,([T_VALOR,"&valor"],l));}
-  ;
-
-
-
-
-//####################################
-//##    Declara??o de Estruturas    ##
-//####################################
-
-
-bloco_declaracao_estrutura
-  : T_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_FIM_ESTRUTURA!
-  ;
-
-
-
-
-//####################################
-//##    Declara??o de Subrotinas    ##
-//####################################
-
-
-declaracao_subprograma
-  : declaracao_funcao
-  | declaracao_procedimento
-  ;
-
-declaracao_funcao
-  : T_FUNCAO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo_retorno
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-declaracao_procedimento
-  : T_PROCEDIMENTO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-tipo_retorno!
-  : t:tipo {#tipo_retorno = #([T_TIPO_RETORNO,"&ret"],t);}
-  ;
-
-lista_parametros
-  : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
-  ;
-
-param_reticencias!
-  : ret:T_RETICENCIAS id:T_IDENTIFICADOR
-                       {#param_reticencias = #([T_PARAM,"&param"],ret,id);}
-  ;
-
-parametro!
-  : (r:T_REF (c:T_CONSTANTE)?)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-
-                          {#parametro = #([T_PARAM,"&param"],t,id,r,c);}
-  ;
-
-
-//####################################
-//##         Bloco de c?digo        ##
-//####################################
-
-bloco_codigo
-  : T_INICIO^ lista_enunciados T_FIM!
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-  : (lvalue T_ATRIBUICAO)=> en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-
-  | en_asm
-
-  | T_SAIR^ T_PONTO_VIRGULA!
-  | T_PONTO_VIRGULA!
-
-//  TODO: retirar da gramatica ou resolver a ambiguidade
-//        se esta producao vingar, retirar enunciado::chamada_subrotina
-//   | expressao  T_PONTO_VIRGULA!
-
-  | chamada_subrotina T_PONTO_VIRGULA!
-  ;
-
-en_atribuicao
-  : lvalue T_ATRIBUICAO^ expressao T_PONTO_VIRGULA!
-  ;
-
-
-en_retorne
-  : T_RETORNE^ (expressao)? T_PONTO_VIRGULA!
-  ;
-
-lvalue!
-  : id:T_IDENTIFICADOR (m:lvalue_indices)? (T_PONTO es:lvalue_membro)?
-    {#lvalue = #([T_LVALUE,"&lvalue"], id, m, es);}
-  ;
-
-lvalue_membro!
-  : l:lvalue             {#lvalue_membro = #([T_MEMBRO,"&membro"], l);}
-  ;
-
-lvalue_indices
-  : i:indices_matriz     {#lvalue_indices = #([T_SUBSCRITO,"&subscrito"], i);}
-  ;
-
-indices_matriz
-  : ( T_ABRE_CHAVE!
-      expressao
-      T_FECHA_CHAVE!
-    )+
-  ;
-
-en_se
-  : T_SE^ expressao T_ENTAO!
-      lista_enunciados (T_SENAO lista_enunciados)? T_FIM_SE!
-  ;
-
-en_enquanto
-  : T_ENQUANTO^ expressao T_FACA! lista_enunciados T_FIM_ENQUANTO!
-  ;
-
-en_para
-  : T_PARA^ lvalue T_DE! expressao
-    T_ATE! expressao (passo)? T_FACA!
-      lista_enunciados T_FIM_PARA!
-  ;
-
-passo
-  : T_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
-  ;
-
-en_repita
-  : T_REPITA^ lista_enunciados T_ATE expressao
-  ;
-
-en_caso
-  : T_CASO^ expressao
-      T_SEJA! (teste_caso)+
-      (caso_senao)? T_FIM_CASO!
-  ;
-
-teste_caso
-  : literal T_FACA^ lista_enunciados T_FIM_FACA!
-  ;
-
-caso_senao
-  : T_SENAO^ lista_enunciados T_FIM_SENAO!
-  ;
-
-
-//TODO: codigo ilustrativo.
-en_asm!
-  : T_ASM (~(T_FIMASM))* T_FIMASM
-  ;
-
-
-//####################################
-//##            Express?es          ##
-//####################################
-
-expressao!
-  : ou:expr_ou {#expressao = #([T_EXPRESSAO,"&expr"], ou);}
-  ;
-
-expr_ou
-  : expr_e (T_OU^ expr_e)*
-  ;
-
-expr_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_ou (T_E^ expr_bit_ou)*
-  ;
-
-expr_bit_ou
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
-  ;
-
-expr_bit_oux
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
-  ;
-
-expr_bit_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_eq (T_BIT_E^ expr_eq)*
-  ;
-
-expr_eq
-options {
-  defaultErrorHandler=false;
-}
-  : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
-  ;
-
-expr_relacional
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_shift ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_bit_shift)*
-  ;
-
-expr_bit_shift
-options {
-  defaultErrorHandler=false;
-}
-  : expr_soma ((T_BIT_SHIFT_LEFT^ | T_BIT_SHIFT_RIGHT^) expr_soma)*
-  ;
-
-expr_soma
-options {
-  defaultErrorHandler=false;
-}
-  : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
-  ;
-
-expr_multip
-options {
-  defaultErrorHandler=false;
-}
-  : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
-  ;
-
-expr_unario!
-options {
-  defaultErrorHandler=false;
-}
-  : o:op_unario e:expr_elemento {#expr_unario = #(o,e);}
-  ;
-
-op_unario!
-  : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
-    | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
-    | n:T_NAO      {#op_unario = #n;}
-    | bn:T_BIT_NAO {#op_unario = #bn;}
-    )?
-  ;
-
-expr_elemento
-  :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
-  |  lvalue
-  |  literal
-  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
-  ;
-
-
-chamada_subrotina!
-  : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
-
-                        {#chamada_subrotina = #([T_CALL,"&call"], id, args);}
-  ;
-
-lista_argumentos
-  : expressao (T_VIRGULA! expressao)*
-  ;
-
-literal
-  : T_TEXTO_LITERAL
-  | T_INTEIRO_LITERAL
-  | T_REAL_LITERAL
-  | T_CARACTERE_LITERAL
-  | T_VERDADEIRO
-  | T_FALSO
-  ;

Copied: trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp (from rev 436, trunk/gpt2/gptc/src/BaseSemanticWalker.cpp)

Copied: trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.hpp (from rev 436, trunk/gpt2/gptc/src/BaseSemanticWalker.hpp)

Added: trunk/gpt2/gptc/src/semantic/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,21 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common \
+           -I$(top_srcdir)/src/symboltable -I../parser -I../semantic
+
+noinst_LTLIBRARIES = libsemantic.la
+
+EXTRA_DIST = semantic.g
+
+BUILT_SOURCES = SemanticWalker.hpp SemanticWalker.cpp
+
+libsemantic_la_SOURCES = BaseSemanticWalker.hpp \
+	  										 BaseSemanticWalker.cpp \
+ 											   $(BUILT_SOURCES)
+
+
+CLEANFILES = SemanticWalker.hpp \
+             SemanticWalker.cpp \
+             SemanticWalkerTokenTypes.hpp \
+             SemanticWalkerTokenTypes.txt
+
+SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g
+	$(ANTLR_BIN) $(srcdir)/semantic.g

Copied: trunk/gpt2/gptc/src/semantic/semantic.g (from rev 436, trunk/gpt2/gptc/src/semantic.g)

Deleted: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,745 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include "BaseSemanticWalker.hpp"
-  #include "PortugolAST.hpp"
-  #include "Symbol.hpp"
-  #include "SymbolTable.hpp"
-}
-
-options {
-  language="Cpp";
-}
-
-class SemanticWalker extends TreeParser("BaseSemanticWalker");
-options {
-  importVocab    = Portugol;
-  noConstructors = true;
-  genHashLines   = false;
-  ASTLabelType   = "RefPortugolAST";
-}
-
-{
-public:
-  SemanticWalker::SemanticWalker(SymbolTable* symtable,
-                                 const std::string& filepath)
-	 : BaseSemanticWalker(symtable, filepath),
-    _analisingInitializationList(false) { }
-
-private:
-  bool _analisingInitializationList;
-}
-
-
-programa
-                                      {RefPortugolAST inicio;}
-  : #(T_ALGORITMO
-
-        (importacao)*
-
-        (declaracoes)?
-
-                                      //recuperando declaracoes globais e
-                                      //de subprogramas para a symtable
-                                      {inicio = _t; /*backup da posicao*/}
-        (declaracoes_subprogramas)?
-
-        EOF
-                                      //analise semantica dos blocos
-                                      {_t = inicio; /*rollback*/}
-        (corpo)?
-        EOF
-     )
-  ;
-
-importacao
-  : #(T_USE lib:T_TEXTO_LITERAL)      {useLib(lib->getText());}
-  ;
-
-
-/*********************** DECLARACOES *******************************/
-
-declaracoes
-  : declaracao_variavel    (declaracoes)?
-  | declaracao_constante   (declaracoes)?
-  | declaracao_estrutura   (declaracoes)?
-  ;
-
-declaracao_variavel
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : #(T_VARIAVEL
-        type=tipo
-        ids=identificadores     {declare(ids, type);}
-
-        (
-          rtype=v:valor_inicialiacao
-
-                                {evalAttribution(ids.back(), type, rtype);}
-        )?
-    )
-  ;
-
-declaracao_constante
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : #(T_CONSTANTE
-        type=tipo
-        ids=identificadores
-        rtype=valor_inicialiacao)
-
-                                {
-                                  type->setConst(true);
-                                  declare(ids, type);
-                                  evalAttribution(ids.back(),type, rtype);
-                                }
-  ;
-
-identificadores returns [IDList list]
-  : (
-      id:T_IDENTIFICADOR        {list.push_back(id);}
-    )+
-  ;
-
-tipo returns [Type *type]
-  : id:T_IDENTIFICADOR          {type = getStructType(id);}
-  | type=tipo_primitivo
-  | type=tipo_matriz
-  ;
-
-tipo_primitivo returns [Type *type]
-
-                      {RefPortugolAST prim = _t;}
-  : (
-        T_INTEIRO
-      | T_REAL
-      | T_CARACTERE
-      | T_LITERAL
-      | T_LOGICO
-      | T_CORINGA
-    )
-                      {type = _typeBuilder->primitiveType(prim->getType());}
-  ;
-
-tipo_matriz returns [Type *type]
-
-                        {
-                          std::list<int> dims;
-                          Type* ofType;
-                        }
-
-  : #(m:T_MATRIZ ofType=tipo dims=dimensoes)
-
-                  {
-                    checkMatrixDimensions(m,dims);
-                    type =_typeBuilder->matrixType(ofType,dims);
-                  }
-
-  ;
-
-dimensoes returns [std::list<int> dims]
-
-                        {int dsize;}
-  : (
-      dsize=dimensao
-                        {dims.push_back(dsize);}
-    )+
-  ;
-
-dimensao returns [int size]
-  : i:T_INTEIRO_LITERAL     {size = atoi(i->getText().c_str());}
-  | n:T_NULO                {size = 0;}
-  ;
-
-
-
-
-declaracao_estrutura
-                                {SymbolList fields;}
-
-  : #(T_ESTRUTURA id:T_IDENTIFICADOR fields=campos_estrutura)
-
-                                {declareStruct(id, fields);}
-  ;
-
-campos_estrutura returns [SymbolList fields]
-
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : (
-      #(T_VARIAVEL type=tipo ids=identificadores
-            (
-              rtype=valor_inicialiacao
-
-                                {evalAttribution(ids.back(), type, rtype);}
-
-            )?
-    )
-
-                                {
-                                  for (IDList::iterator it = ids.begin();
-                                         it != ids.end(); ++it) {
-                                    fields.push_back(
-                                      Symbol((*it)->getText(),
-                                                    type,
-                                                    _symtable->currentScope(),
-                                                    _symtable->unit(),
-                                                    (*it)->getLine(),
-                                                    (*it)->getColumn()));
-                                  }
-                                }
-    )+
-  ;
-
-
-/********************** INICIALIZACAO *************************/
-
-
-valor_inicialiacao returns [Type *rtype]
-
-                          {
-                            _analisingInitializationList = true;
-                          }
-
-  : #(v:T_VALOR rtype=valor)
-
-                          {
-                            _analisingInitializationList = false;
-                          }
-  ;
-
-valor returns [Type *rtype]
-                          {
-                            InitMatrixList         mtx;
-                            InitStructList         stc;
-                          }
-  : rtype=expressao_
-
-  | #(m:T_VAL_MATRIZ
-        (valor_matriz[1,mtx])+)
-
-                          {rtype = evalInitMatrix(m, mtx);}
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id,stc])+)
-
-                          {rtype = evalInitStruct(stc);}
-  ;
-
-valor_matriz [int dimension, InitMatrixList& mtx]
-
-                              {
-                                Type *type;
-                                InitStructList stc;
-                              }
-
-  : type=expressao_      {mtx.push_back(std::pair<int,Type*>(dimension, type));}
-
-  | #(T_VAL_MATRIZ
-      (valor_matriz[dimension+1, mtx])+)
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id, stc])+)
-
-                       {mtx.push_back(std::pair<int,Type*>(dimension,
-                            evalInitStruct(stc)));}
-  ;
-
-valor_estrutura [RefPortugolAST field, InitStructList& stc]
-                              {
-                                Type *type;
-                                InitMatrixList mtx;
-                                InitStructList stc_;
-                              }
-  : type=expressao_
-                              {
-                                stc.push_back(
-                                  std::pair<RefPortugolAST,Type*>(
-                                    field, type));
-                              }
-
-  | #(m:T_VAL_MATRIZ
-      (valor_matriz[1, mtx])+)
-
-                              {
-                                type = evalInitMatrix(m, mtx);
-                                stc.push_back(
-                                  std::pair<RefPortugolAST,Type*>(
-                                    field, type));
-                              }
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id,stc_])+)
-
-                              {
-                                type = evalInitStruct(stc_);
-                                stc.push_back(
-                                  std::pair<RefPortugolAST,Type*>(
-                                    field, type));
-                              }
-  ;
-
-
-
-
-/********************* DECLARACAO SUBPROGRAMAS ****************************/
-
-declaracoes_subprogramas
-  : declaracao_subprograma (declaracoes_subprogramas)?
-  | T_INICIO               (declaracoes_subprogramas)?//pula o bloco principal
-  ;
-
-declaracao_subprograma
-  : declaracao_funcao
-  | declaracao_procedimento
-  ;
-
-declaracao_procedimento
-                                      {SymbolList params;}
-
-  : #(T_PROCEDIMENTO
-        id:T_IDENTIFICADOR
-        params=lista_parametros
-
-                                      {
-                                        declareProc(id, params);
-                                      }
-
-      (declaracao_variavel | declaracao_constante)*)
-
-                                      {_symtable->setGlobalScope();}
-  ;
-
-declaracao_funcao
-                                      {
-                                        SymbolList params;
-                                        Type *type;
-                                      }
-  : #(T_FUNCAO
-        id:T_IDENTIFICADOR
-        params=lista_parametros
-        type=tipo_retorno
-                                      {
-                                        declareProc(id, params, type);
-                                      }
-
-      (declaracao_variavel | declaracao_constante)*)
-
-                                      {_symtable->setGlobalScope();}
-  ;
-
-tipo_retorno returns [Type* type]
-  : #(T_TIPO_RETORNO type=tipo)
-  ;
-
-lista_parametros returns [SymbolList list]
-
-                                 {Symbol symbol;}
-
-  : (#(T_PARAM symbol=parametro) {list.push_back(symbol);})*
-  ;
-
-parametro returns [Symbol symbol]
-
-                                  {Type* type;}
-
-  : type=tipo id:T_IDENTIFICADOR (r:T_REF)? (c:T_CONSTANTE)?
-
-                                  {
-                                    if (c != antlr::nullAST) {
-                                      type->setConst(true);
-                                    }
-
-                                    if (r != antlr::nullAST) {
-                                      type->setRef(true);
-                                    }
-
-                                    symbol =
-                                        Symbol(id->getText(),
-                                          type,
-                                          _symtable->unit(),
-                                          id->getLine(),
-                                          id->getColumn());
-                                  }
-
-  | T_RETICENCIAS idret:T_IDENTIFICADOR
-
-                                  {
-                                    symbol = Symbol(idret->getText(),
-                                              _typeBuilder->reticencesType(),
-                                              _symtable->unit(),
-                                              idret->getLine(),
-                                              idret->getColumn());
-                                  }
-  ;
-
-
-/* ************************* EXPRESSOES *************************/
-
-
-expressao returns [ExpressionReturn ret]
-
-                                {
-                                  Type *type;
-                                }
-
-  : #(e:T_EXPRESSAO type=expr)  {ret.first = e; ret.second = type;}
-  ;
-
-expressao_ returns [Type *type]
-  : #(T_EXPRESSAO type=expr)
-  ;
-
-
-expr returns [Type *type]
-                                      {
-                                        Type *l, *r;
-                                        RefPortugolAST op = _t;
-                                      }
-  : (
-
-      #(T_OU              l=expr r=expr)
-                                      {type = evalExpr_OU(op, l,r);}
-
-    | #(T_E               l=expr r=expr)
-                                      {type = evalExpr_E(op, l,r);}
-
-    | #(T_BIT_OU          l=expr r=expr)
-                                      {type = evalExpr_BIT_OU(op, l,r);}
-
-    | #(T_BIT_OUX         l=expr r=expr)
-                                      {type = evalExpr_BIT_OUX(op, l,r);}
-
-    | #(T_BIT_E           l=expr r=expr)
-                                      {type = evalExpr_BIT_E(op, l,r);}
-
-    | #(T_IGUAL           l=expr r=expr)
-                                      {type = evalExpr_IGUAL(op, l,r);}
-
-    | #(T_DIFERENTE       l=expr r=expr)
-                                      {type = evalExpr_DIFERENTE(op, l,r);}
-
-    | #(T_MAIOR           l=expr r=expr)
-                                      {type = evalExpr_MAIOR(op, l,r);}
-
-    | #(T_MENOR           l=expr r=expr)
-                                      {type = evalExpr_MENOR(op, l,r);}
-
-    | #(T_MAIOR_EQ        l=expr r=expr)
-                                      {type = evalExpr_MAIOR_EQ(op, l,r);}
-
-    | #(T_MENOR_EQ        l=expr r=expr)
-                                      {type = evalExpr_MENOR_EQ(op, l,r);}
-
-    | #(T_BIT_SHIFT_LEFT  l=expr r=expr)
-                                      {type = evalExpr_BIT_SHIFT_LEFT(op, l,r);}
-
-    | #(T_BIT_SHIFT_RIGHT l=expr r=expr)
-                                      {type = evalExpr_BIT_SHIFT_RIGHT(op, l,r);}
-
-    | #(T_MAIS            l=expr r=expr)
-                                      {type = evalExpr_MAIS(op, l,r);}
-
-    | #(T_MENOS           l=expr r=expr)
-                                      {type = evalExpr_MENOS(op, l,r);}
-
-    | #(T_DIV             l=expr r=expr)
-                                      {type = evalExpr_DIV(op, l,r);}
-
-    | #(T_MULTIP          l=expr r=expr)
-                                      {type = evalExpr_MULTIP(op, l,r);}
-
-    | #(T_MOD             l=expr r=expr)
-                                      {type = evalExpr_MOD(op, l,r);}
-
-    | #(T_UN_NEGATIVO     l=elemento)
-                                      {type = evalExpr_UN_NEGATIVO(op,l);}
-
-    | #(T_UN_POSITIVO     l=elemento)
-                                      {type = evalExpr_UN_POSITIVO(op,l);}
-
-    | #(T_NAO             l=elemento)
-                                      {type = evalExpr_NAO(op,l);}
-
-    | #(T_BIT_NAO         l=elemento)
-                                      {type = evalExpr_BIT_NAO(op,l);}
-
-    )
-                       {op->setEvalType(type);}
-
-  | type=elemento
-  ;
-
-
-elemento returns [Type *type]
-                               {ExpressionReturn lv;}
-  : type=literal
-  | lv=lvalue                  {type = lv.second;}
-  | type=chamada_subrotina
-  | type=expressao_
-  ;
-
-literal returns [Type *type]
-                            {RefPortugolAST ast = _t;}
-  : (
-      T_TEXTO_LITERAL       {type = _typeBuilder->primitiveType(T_LITERAL);}
-    | T_INTEIRO_LITERAL     {type = _typeBuilder->primitiveType(T_INTEIRO);}
-    | T_REAL_LITERAL        {type = _typeBuilder->primitiveType(T_REAL);}
-    | T_CARACTERE_LITERAL   {type = _typeBuilder->primitiveType(T_CARACTERE);}
-    | T_VERDADEIRO          {type = _typeBuilder->primitiveType(T_LOGICO);}
-    | T_FALSO               {type = _typeBuilder->primitiveType(T_LOGICO);}
-    )
-    {ast->setEvalType(type);}
-  ;
-
-
-lvalue returns [ExpressionReturn ret]
-
-                            {
-                              Type *type;
-                              int dimensions;
-                            }
-
-  : #(lv:T_LVALUE id:T_IDENTIFICADOR    {type = getSymbolType(id);}
-
-      (
-        dimensions=lvalue_indices
-
-                           {type = evalMatrixSubscript(id, type, dimensions);}
-      )?
-
-      (type=lvalue_membro[id,type])?
-    )
-
-      {
-        ret.first = id; ret.second = type;
-        lv->setEvalType(type);
-      }
-  ;
-
-
-lvalue_membro [RefPortugolAST parent, Type *sttype] returns [Type *type]
-
-  : #(T_MEMBRO type=lvalue_struct[parent,sttype])
-  ;
-
-lvalue_struct[RefPortugolAST parent, Type *sttype] returns [Type *type]
-
-                              {
-                                int dimensions;
-                              }
-
-  : #(id:T_IDENTIFICADOR     {type = getSymbolType(parent,sttype,id);}
-
-      (
-        dimensions=lvalue_indices
-
-                             {type = evalMatrixSubscript(id,
-                                                         type, dimensions);}
-      )?
-
-      (type=lvalue_membro[id,type])?
-    )
-  ;
-
-lvalue_indices returns [int dimensions]
-
-                                {
-                                  ExpressionReturn ex;
-                                  dimensions = 0;
-                                }
-  : #(s:T_SUBSCRITO
-      (
-        ex=expressao
-                                {
-                                  dimensions++;
-                                  evalMatrixSubscriptType(ex.first, ex.second);
-                                }
-      )+
-    )
-  ;
-
-
-
-
-chamada_subrotina returns [Type *type]
-
-                                  {
-                                    TypeList params;
-                                  }
-
-  : #(T_CALL id:T_IDENTIFICADOR params=lista_argumentos)
-
-                                  {
-                                    if (!_analisingInitializationList) {
-                                      type = evalCall(id, params);
-                                    } else {
-                                      type = _typeBuilder->errorType();
-                                      report(id->getLine(),
-                                        "ilegal: fcall em lista de inicializa??o");
-                                    }
-                                  }
-  ;
-
-lista_argumentos returns [TypeList list]
-
-                                   {Type *type;}
-  : (
-      type=expressao_                   {list.push_back(type);}
-    )*
-  ;
-
-
-
-
-/************************** CORPO *************************/
-
-corpo
-  :  corpo_subprograma      (corpo)?
-  |  bloco_codigo           (corpo_subprograma)*
-  ;
-
-
-corpo_subprograma
-                      {SymbolList params;}
-
-  : #(T_FUNCAO   f:T_IDENTIFICADOR
-                 params=lista_parametros {setCurrentScope(f, params);}
-                 T_TIPO_RETORNO
-                 (T_VARIAVEL|T_CONSTANTE)*
-                 bloco_codigo            {_symtable->setGlobalScope();}
-    )
-
-  | #(T_PROCEDIMENTO p:T_IDENTIFICADOR
-                 params=lista_parametros {setCurrentScope(p, params);}
-                 (T_VARIAVEL|T_CONSTANTE)*
-                 bloco_codigo)           {_symtable->setGlobalScope();}
-  ;
-
-
-
-bloco_codigo
-  : #(T_INICIO lista_enunciados)
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-                    {Type *devnull;}
-  : en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-  | T_SAIR //TODO: deve estar dentro de uma itera??o
-  | devnull=chamada_subrotina
-  ;
-
-en_atribuicao
-                        {ExpressionReturn lret, rret;}
-
-  : #(at:T_ATRIBUICAO lret=lvalue rret=expressao)
-
-                        {evalAttribution(at, lret.second, rret.second);}
-  ;
-
-en_retorne
-                        {Type *type;}
-
-  : #(ret:T_RETORNE type=expressao_)
-
-                        {evalRetorne(ret, type);}
-  ;
-
-en_se
-                        {ExpressionReturn ex;}
-
-  : #(se:T_SE
-
-      ex=expressao    {evalCondicional(ex);}
-      lista_enunciados
-      (T_SENAO lista_enunciados)?
-    )
-  ;
-
-en_enquanto
-                        {ExpressionReturn ex;}
-  : #(enq:T_ENQUANTO
-      ex=expressao      {evalCondicional(ex);}
-      lista_enunciados
-    )
-  ;
-
-en_repita
-                              {ExpressionReturn ex;}
-  : #(T_REPITA
-      lista_enunciados
-      T_ATE ex=expressao      {evalCondicional(ex);}
-    )
-  ;
-
-en_para
-                              {ExpressionReturn lv, from, to;}
-
-  : #(p:T_PARA lv=lvalue
-        from=expressao        {evalAttribution(lv, from);}
-        to=expressao          {evalAttribution(lv, to);}
-        (T_PASSO)?
-        lista_enunciados)
-  ;
-
-  //TODO: checar por op??es repetidas nos testes
-
-en_caso
-                              {Type *type;}
-
-  : #(c:T_CASO type=expressao_ (teste_caso[type])+ (caso_senao)?)
-  ;
-
-teste_caso[Type *ltype]
-
-                               {Type *rtype;}
-
-  : #(T_FACA
-      rtype=lit:literal            {evalExpr_IGUAL(lit, ltype, rtype);}
-      lista_enunciados
-    )
-  ;
-
-caso_senao
-  : #(T_SENAO lista_enunciados)
-  ;

Added: trunk/gpt2/gptc/src/symboltable/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/symboltable/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,6 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I../parser
+
+noinst_LTLIBRARIES = libsymboltable.la
+
+libsymboltable_la_SOURCES = Symbol.cpp Symbol.hpp SymbolTable.cpp SymbolTable.hpp\
+	SymbolTableExceptions.cpp SymbolTableExceptions.hpp Types.cpp Types.hpp

Copied: trunk/gpt2/gptc/src/symboltable/Symbol.cpp (from rev 438, trunk/gpt2/gptc/src/Symbol.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/Symbol.hpp (from rev 423, trunk/gpt2/gptc/src/Symbol.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp (from rev 420, trunk/gpt2/gptc/src/SymbolTable.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp (from rev 420, trunk/gpt2/gptc/src/SymbolTable.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp (from rev 420, trunk/gpt2/gptc/src/SymbolTableExceptions.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp (from rev 420, trunk/gpt2/gptc/src/SymbolTableExceptions.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/Types.cpp (from rev 438, trunk/gpt2/gptc/src/Types.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/Types.hpp (from rev 438, trunk/gpt2/gptc/src/Types.hpp)

Modified: trunk/gpt2/gptc/test/Makefile.am
===================================================================
--- trunk/gpt2/gptc/test/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/test/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,7 +1,10 @@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/test -I$(top_srcdir)/src -I../src
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/test -I$(top_srcdir)/src \
+           -I../src/parser -I$(top_srcdir)/src/parser -I$(top_srcdir)/src/common
 
 bin_PROGRAMS = tester
-tester_LDADD = $(top_builddir)/src/libgptc.la $(ANTLR_LIB)
+tester_LDADD = $(top_builddir)/src/parser/libparser.la \
+               $(top_builddir)/src/common/libcommon.la \
+               $(top_builddir)/src/symboltable/libsymboltable.la $(ANTLR_LIB)
 
 EXTRA_DIST = compiler_test.g
 
@@ -31,7 +34,7 @@
 
 
 LangTestLexer.cpp LangTestLexer.hpp LangTestParser.hpp LangTestParser.cpp: \
-     Makefile $(srcdir)/compiler_test.g
+     $(srcdir)/compiler_test.g
 	$(ANTLR_BIN) $(srcdir)/compiler_test.g
 
 testTokenNames.hpp: Makefile

Modified: trunk/gpt2/gptc/tmp/tree_teste.gpt
===================================================================
--- trunk/gpt2/gptc/tmp/tree_teste.gpt	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/tmp/tree_teste.gpt	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,110 +1,7 @@
-// algoritmo teste;
+algoritmo teste;
 
-// use "bib1";
-// use "bib2";
-// use "bib3";
-// use "bib4";
-
-// vari?vel q : T;
-
-vari?veis
-//   p : T;
-//   a,b : real;
-//   c : inteiro := 10;
-  j : matriz[] do tipo inteiro := [1,2,3];
-//   es,e2 : T := {nome:="foo",id:=6};
-//   e4    : matriz[] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3}];
-fim-vari?veis
-
-
-
-// vari?vel j : K := "oi";
-// vari?vel m : matriz[] do tipo I := [9,8,7];
-// vari?vel z : T := {i:=10, j:=20};
-// vari?vel e4    : matriz[10][20] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3}];
-
-// constantes
-//   z  : inteiro := 3;
-//   j  : matriz[] do tipo inteiro := [1,2,3];
-//   es : T := {nome:="foo",id:=6};
-//   e4 : matriz[] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3},{k:=[9,8,7]}];
-// fim-constantes
-//
-// constante x : inteiro := {z := [1,2,3]};
-
-// estrutura T
-//   z   : inteiro := 1;
-//   j,z : kkk;
-// fim-estrutura
-/*
-fun??o f(a:I,k:matriz[1][2] do tipo I) : T
+vari?vel x   : inteiro;
+vari?vel p?  : literal;
 in?cio
-  x := 2;
-fim*/
-
-
-
-// in?cio
-//   x := 10;
-//   z[1] := 9;
-//   z[0][0] := n?o(~1 + -2 * +3);
-
-//   se x > 2 ent?o
-//     x := 2;
-//   fim-se
-//
-//   se z = "oi" ent?o
-//     z := 1;
-//   sen?o
-//     z := 2;
-//   fim-se
-
-// enquanto x > 2 fa?a
-//   x := 2;
-// fim-enquanto
-
-// repita
-//   x := 2;
-//   k := 3;
-// at? x > 3
-
-// para x de 1+2 at? 10+100 fa?a
-//   x := 3;
-// fim-para
-
-// para x[y] de 0 at? 100 passo -1 fa?a
-//   x := 3;
-// fim-para
-
-// caso x seja
-//   "oi" fa?a
-//     x := 1;
-//     z := 2;
-//   fim-fa?a
-//
-//   10 fa?a
-//     x:=3;
-//     sair;
-//   fim-fa?a
-//
-//   sen?o
-//     x:= 10;
-//   fim-sen?o
-// fim-caso
-//
-//   retorne 10+10;
-
-//   f(10, 1+2, g());
-
-//   "se" x > 10
-/*  asm
-    ola  as "sss" 1 se ent?o
-    adasd "fim-asm"
-  fim-asm*/
-// fim
-
-
-// procedimento p(a:I,k:matriz[1][2] do tipo I)
-// in?cio
-//   z := 2;
-// fim
+  x := p? + 1;
+fim
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 03:25:14 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 03:25:14 +0100
Subject: [gpt-commit] r442 - trunk/gpt2
Message-ID: <200712190225.lBJ2PEVu030340@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 03:25:14 +0100 (Wed, 19 Dec 2007)
New Revision: 442

Removed:
   trunk/gpt2/doc/
Log:
nosg



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 04:38:57 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 04:38:57 +0100
Subject: [gpt-commit] r443 - in trunk/gpt2: . common common/src gptasm
	gptasm/src gptc gptc/src/gptasm_target gptc/src/semantic
	gptc/test gptvm gptvm/src
Message-ID: <200712190338.lBJ3cvbT000504@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 04:38:52 +0100 (Wed, 19 Dec 2007)
New Revision: 443

Added:
   trunk/gpt2/AUTHORS
   trunk/gpt2/COPYING
   trunk/gpt2/ChangeLog
   trunk/gpt2/INSTALL
   trunk/gpt2/Makefile.am
   trunk/gpt2/Makefile.boot
   trunk/gpt2/NEWS
   trunk/gpt2/README
   trunk/gpt2/common/Makefile.am
   trunk/gpt2/common/Makefile.boot
   trunk/gpt2/common/configure.ac
   trunk/gpt2/common/src/Makefile.am
   trunk/gpt2/configure.ac
   trunk/gpt2/gptasm/AUTHORS
   trunk/gpt2/gptasm/COPYING
   trunk/gpt2/gptasm/ChangeLog
   trunk/gpt2/gptasm/INSTALL
   trunk/gpt2/gptasm/Makefile.am
   trunk/gpt2/gptasm/Makefile.boot
   trunk/gpt2/gptasm/NEWS
   trunk/gpt2/gptasm/README
   trunk/gpt2/gptasm/configure.ac
   trunk/gpt2/gptasm/src/Makefile.am
   trunk/gpt2/gptc/Makefile.boot
   trunk/gpt2/gptvm/AUTHORS
   trunk/gpt2/gptvm/COPYING
   trunk/gpt2/gptvm/ChangeLog
   trunk/gpt2/gptvm/INSTALL
   trunk/gpt2/gptvm/Makefile.am
   trunk/gpt2/gptvm/Makefile.boot
   trunk/gpt2/gptvm/NEWS
   trunk/gpt2/gptvm/README
   trunk/gpt2/gptvm/configure.ac
   trunk/gpt2/gptvm/src/Makefile.am
Removed:
   trunk/gpt2/gptasm/src/Makefile
   trunk/gpt2/gptc/bootstrap.sh
   trunk/gpt2/gptvm/src/Makefile
Modified:
   trunk/gpt2/gptc/configure.ac
   trunk/gpt2/gptc/src/gptasm_target/Makefile.am
   trunk/gpt2/gptc/src/semantic/Makefile.am
   trunk/gpt2/gptc/test/Makefile.am
Log:
-Integrando o build system nos subprojetos

Added: trunk/gpt2/AUTHORS
===================================================================

Added: trunk/gpt2/COPYING
===================================================================
--- trunk/gpt2/COPYING	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/COPYING	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/gpt2/ChangeLog
===================================================================

Added: trunk/gpt2/INSTALL
===================================================================
--- trunk/gpt2/INSTALL	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/INSTALL	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+

Added: trunk/gpt2/Makefile.am
===================================================================
--- trunk/gpt2/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1 @@
+SUBDIRS = common gptasm gptc gptvm

Added: trunk/gpt2/Makefile.boot
===================================================================
--- trunk/gpt2/Makefile.boot	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/Makefile.boot	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,26 @@
+all: self
+	@echo   "[boostraping common...]" 
+	cd common && $(MAKE) -f Makefile.boot
+	@echo   "[boostraping gptasm...]" 
+	cd gptasm && $(MAKE) -f Makefile.boot
+	@echo   "[boostraping gptc...]" 
+	cd gptc && $(MAKE) -f Makefile.boot
+	@echo   "[boostraping gptvm...]" 
+	cd gptvm && $(MAKE) -f Makefile.boot
+
+self:
+	@echo   "[boostraping self...]" 
+	aclocal
+	autoheader
+	libtoolize -c -f
+	automake -ac
+	autoconf
+
+distclean: clean-self
+	cd common && $(MAKE) -f Makefile.boot distclean
+	cd gptc && $(MAKE) -f Makefile.boot distclean
+	cd gptvm && $(MAKE) -f Makefile.boot distclean
+	cd gptasm && $(MAKE) -f Makefile.boot distclean
+
+clean-self:
+	rm -rf autom4te.cache aclocal.m4 config.* configure depcomp install-sh missing ltmain.sh

Added: trunk/gpt2/NEWS
===================================================================

Added: trunk/gpt2/README
===================================================================

Added: trunk/gpt2/common/Makefile.am
===================================================================
--- trunk/gpt2/common/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/common/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1 @@
+SUBDIRS = src 

Added: trunk/gpt2/common/Makefile.boot
===================================================================
--- trunk/gpt2/common/Makefile.boot	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/common/Makefile.boot	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,12 @@
+all:
+	touch NEWS README AUTHORS ChangeLog
+	aclocal
+	autoheader
+	libtoolize -c -f
+	automake -ac
+	autoconf
+	rm -rf NEWS README AUTHORS ChangeLog COPYING INSTALL
+
+distclean:
+	rm -rf autom4te.cache AUTHORS COPYING ChangeLog INSTALL NEWS README \
+         aclocal.m4 config.* configure depcomp install-sh missing ltmain.sh

Added: trunk/gpt2/common/configure.ac
===================================================================
--- trunk/gpt2/common/configure.ac	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/common/configure.ac	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,55 @@
+AC_PREREQ(2.60)
+
+AC_INIT(gptcommon, 1.0)
+AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE(gptcommon, 1.0)
+
+AC_LANG(C++)
+AC_PROG_CXX
+AM_PROG_LIBTOOL
+
+#------------------------------
+# debug options
+#------------------------------
+
+AC_ARG_ENABLE(debug,
+        AC_HELP_STRING([--enable-debug=ARG],[enables debug symbols (yes|no|full) [default=no]]),
+[
+  case $enableval in
+    yes)
+      use_debug_code="yes"
+      use_debug_define=yes
+      ;;
+    full)
+      use_debug_code="full"
+      use_debug_define=yes
+      ;;
+    *)
+      use_debug_code="no"
+      use_debug_define=no
+      ;;
+  esac
+],
+  [use_debug_code="no"
+    use_debug_define=no
+])
+
+CXXFLAGS=
+if test "$use_debug_code" != "no"; then
+  if test $use_debug_code = "full"; then
+    CXXFLAGS="-g3 $CXXFLAGS"
+  else
+    CXXFLAGS="-g -O2 $CXXFLAGS"
+  fi
+else
+  CXXFLAGS="-O2 $CXXFLAGS"
+fi
+
+if test "$use_debug_define" = "yes"; then
+  CXXFLAGS="-DDEBUG $CXXFLAGS"
+fi
+
+
+AC_CONFIG_FILES([Makefile
+                 src/Makefile])
+AC_OUTPUT

Added: trunk/gpt2/common/src/Makefile.am
===================================================================
--- trunk/gpt2/common/src/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/common/src/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,8 @@
+INCLUDES = -I$(top_srcdir)/.
+
+noinst_LTLIBRARIES = libgptcommon.la
+
+libgptcommon_la_SOURCES = CBinString.cpp  CHeader.cpp  COptions.hpp  CSymbol.hpp \
+                          CSymbolList.hpp   CSymbolTable.hpp  Makefile.am  Tools.hpp \
+                          CBinString.hpp  CHeader.hpp  CSymbol.cpp   CSymbolList.cpp  \
+                          CSymbolTable.cpp  Common.hpp  Tools.cpp

Added: trunk/gpt2/configure.ac
===================================================================
--- trunk/gpt2/configure.ac	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/configure.ac	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,17 @@
+AC_PREREQ(2.60)
+
+AC_INIT(gptproject, 2.0)
+AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE(gptproject, 2.0)
+
+AC_LANG(C++)
+AC_PROG_CXX
+AM_PROG_LIBTOOL
+
+AC_CONFIG_SUBDIRS(common)
+AC_CONFIG_SUBDIRS(gptasm)
+AC_CONFIG_SUBDIRS(gptc)
+AC_CONFIG_SUBDIRS(gptvm)
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT

Added: trunk/gpt2/gptasm/AUTHORS
===================================================================

Added: trunk/gpt2/gptasm/COPYING
===================================================================
--- trunk/gpt2/gptasm/COPYING	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/COPYING	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/gpt2/gptasm/ChangeLog
===================================================================

Added: trunk/gpt2/gptasm/INSTALL
===================================================================
--- trunk/gpt2/gptasm/INSTALL	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/INSTALL	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+

Added: trunk/gpt2/gptasm/Makefile.am
===================================================================
--- trunk/gpt2/gptasm/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1 @@
+SUBDIRS = src 

Added: trunk/gpt2/gptasm/Makefile.boot
===================================================================
--- trunk/gpt2/gptasm/Makefile.boot	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/Makefile.boot	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,9 @@
+all:
+	aclocal
+	autoheader
+	libtoolize -c -f
+	automake -ac
+	autoconf
+
+distclean:
+	rm -rf autom4te.cache aclocal.m4 config.* configure depcomp install-sh missing ltmain.sh

Added: trunk/gpt2/gptasm/NEWS
===================================================================

Added: trunk/gpt2/gptasm/README
===================================================================

Added: trunk/gpt2/gptasm/configure.ac
===================================================================
--- trunk/gpt2/gptasm/configure.ac	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/configure.ac	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,92 @@
+AC_PREREQ(2.60)
+
+AC_INIT(gptasm, 1.0)
+AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE(gptasm, 1.0)
+
+AC_LANG(C++)
+AC_PROG_CXX
+AM_PROG_LIBTOOL
+
+#------------------------------
+# debug options
+#------------------------------
+
+AC_ARG_ENABLE(debug,
+        AC_HELP_STRING([--enable-debug=ARG],[enables debug symbols (yes|no|full) [default=no]]),
+[
+  case $enableval in
+    yes)
+      use_debug_code="yes"
+      use_debug_define=yes
+      ;;
+    full)
+      use_debug_code="full"
+      use_debug_define=yes
+      ;;
+    *)
+      use_debug_code="no"
+      use_debug_define=no
+      ;;
+  esac
+],
+  [use_debug_code="no"
+    use_debug_define=no
+])
+
+CXXFLAGS=
+if test "$use_debug_code" != "no"; then
+  if test $use_debug_code = "full"; then
+    CXXFLAGS="-g3 $CXXFLAGS"
+  else
+    CXXFLAGS="-g -O2 $CXXFLAGS"
+  fi
+else
+  CXXFLAGS="-O2 $CXXFLAGS"
+fi
+
+if test "$use_debug_define" = "yes"; then
+  CXXFLAGS="-DDEBUG $CXXFLAGS"
+fi
+
+#------------------------------
+# Checks for ANTLR
+#------------------------------
+
+AC_PATH_PROG(ANTLR_BIN, antlr)
+
+if test "x${ANTLR}" = "x"; then
+  AC_PATH_PROG(ANTLR_BIN, runantlr)
+fi
+
+if test "x${ANTLR_BIN}" = "x"; then
+  AC_MSG_ERROR(
+  [
+    O programa "antlr" (ou runantlr) n?o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers?o >= 2.6) instalado.
+    Baixe em: http://www.antlr.org
+  ])
+fi
+
+AC_PATH_PROG(ANTLR_CFG, antlr-config)
+if test "x${ANTLR_CFG}" = "x"; then
+  AC_MSG_ERROR(
+  [
+    O programa "antlr-config" n?o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers?o >= 2.6) instalado.
+    Baixe em: http://www.antlr.org
+  ])
+fi
+
+ANTLR_LIB=`${ANTLR_CFG} --libs`
+ANTLR_INC=`${ANTLR_CFG} --cflags`
+
+AC_SUBST(ANTLR_BIN)
+AC_SUBST(ANTLR_INC)
+AC_SUBST(ANTLR_LIB)
+
+
+
+AC_CONFIG_FILES([Makefile
+                 src/Makefile])
+AC_OUTPUT

Deleted: trunk/gpt2/gptasm/src/Makefile
===================================================================
--- trunk/gpt2/gptasm/src/Makefile	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/src/Makefile	2007-12-19 03:38:52 UTC (rev 443)
@@ -1,31 +0,0 @@
-COMMON_DIR=../../common/src/
-
-INCLUDE_DIR=-I/usr/include/antlr/ -I$(COMMON_DIR)
-CC=g++
-CCFLAGS=-g -Wall
-
-objects = GptAssemblyLexer.o GptAssemblyParser.o main.o CGptAsm.o CGenBytecode.o \
-	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CHeader.o \
-        CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o $(COMMON_DIR)Tools.o
-
-all: $(objects)
-	g++ -o gptasm $(objects) /usr/local/lib/libantlr.a
-
-GptAssemblyLexer.hpp GptAssemblyLexer.cpp: lexer.g
-	antlr lexer.g
-
-GptAssemblyParser.hpp GptAssemblyParser.cpp: parser.g
-	antlr parser.g
-
-
-%.o: %.cpp %.hpp
-	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
-
-%.o: %.cpp
-	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
-
-
-clean:
-	rm -f *.o $(COMMON_DIR)*.o GptAssemblyLexer.cpp GptAssemblyLexer.hpp GptAssemblyLexerTokenTypes.hpp \
-	GptAssemblyLexerTokenTypes.txt GptAssemblyParser.cpp GptAssemblyParser.hpp gptasm \
-	GptAssemblyParserTokenTypes.hpp GptAssemblyParserTokenTypes.txt 

Added: trunk/gpt2/gptasm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptasm/src/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptasm/src/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,31 @@
+COMMON_IDIR = ../../../common/src
+COMMON_LDIR = ../../common/src
+
+
+INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
+
+bin_PROGRAMS = gptasm
+
+gptasm_LDADD = $(COMMON_LDIR)/libgptcommon.la $(ANTLR_LIB)
+
+
+BUILT_SOURCES = GptAssemblyLexer.hpp \
+                GptAssemblyLexer.cpp \
+                GptAssemblyParser.hpp \
+                GptAssemblyParser.cpp 
+
+gptasm_SOURCES = CData.cpp  CData.hpp  CGenBytecode.cpp  CGenBytecode.hpp  CGptAsm.cpp  \
+                  CGptAsm.hpp  main.cpp $(BUILT_SOURCES)
+
+EXTRA_DIST = lexer.g parser.g
+
+CLEANFILES = $(BUILT_SOURCES) GptAssemblyLexerTokenTypes.* GptAssemblyParserTokenTypes.*
+
+
+
+
+GptAssemblyLexer.cpp GptAssemblyLexer.hpp: $(srcdir)/lexer.g
+	$(ANTLR_BIN) $(srcdir)/lexer.g
+
+GptAssemblyParser.hpp GptAssemblyParser.cpp: $(srcdir)/parser.g
+	$(ANTLR_BIN) $(srcdir)/parser.g

Added: trunk/gpt2/gptc/Makefile.boot
===================================================================
--- trunk/gpt2/gptc/Makefile.boot	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/Makefile.boot	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,9 @@
+all:
+	aclocal
+	autoheader
+	libtoolize -c -f
+	automake -ac
+	autoconf
+
+distclean:
+	rm -rf autom4te.cache aclocal.m4 config.* configure depcomp install-sh missing ltmain.sh

Deleted: trunk/gpt2/gptc/bootstrap.sh
===================================================================
--- trunk/gpt2/gptc/bootstrap.sh	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/bootstrap.sh	2007-12-19 03:38:52 UTC (rev 443)
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-aclocal
-autoheader
-libtoolize -c -f
-automake -ac
-autoconf

Modified: trunk/gpt2/gptc/configure.ac
===================================================================
--- trunk/gpt2/gptc/configure.ac	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/configure.ac	2007-12-19 03:38:52 UTC (rev 443)
@@ -63,8 +63,8 @@
 if test "x${ANTLR_BIN}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr" (ou runantlr) n????????o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers????????o >= 2.6) instalado.
+    O programa "antlr" (ou runantlr) n??o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -73,8 +73,8 @@
 if test "x${ANTLR_CFG}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr-config" n????????o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers????????o >= 2.6) instalado.
+    O programa "antlr-config" n??o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi

Modified: trunk/gpt2/gptc/src/gptasm_target/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -16,7 +16,8 @@
 CLEANFILES = GptAsmWalkerTokenTypes.hpp \
              GptAsmWalker.cpp \
 						 GptAsmWalker.hpp  \
-             GptAsmWalkerTokenTypes.txt
+             GptAsmWalkerTokenTypes.txt \
+             PortugolTokenTypes.txt
 
 GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
 	$(ANTLR_BIN) $(srcdir)/gptasm.g

Modified: trunk/gpt2/gptc/src/semantic/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -15,7 +15,8 @@
 CLEANFILES = SemanticWalker.hpp \
              SemanticWalker.cpp \
              SemanticWalkerTokenTypes.hpp \
-             SemanticWalkerTokenTypes.txt
+             SemanticWalkerTokenTypes.txt \
+             PortugolTokenTypes.txt
 
 SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g
 	$(ANTLR_BIN) $(srcdir)/semantic.g

Modified: trunk/gpt2/gptc/test/Makefile.am
===================================================================
--- trunk/gpt2/gptc/test/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptc/test/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -30,7 +30,9 @@
 						 LangTestParser.hpp  \
              LangTestParserTokenTypes.hpp \
              LangTestParserTokenTypes.txt \
-             tokenNames.hpp
+             LangTestLexerTokenTypes.hpp \
+             LangTestLexerTokenTypes.txt \
+             testTokenNames.hpp
 
 
 LangTestLexer.cpp LangTestLexer.hpp LangTestParser.hpp LangTestParser.cpp: \

Added: trunk/gpt2/gptvm/AUTHORS
===================================================================

Added: trunk/gpt2/gptvm/COPYING
===================================================================
--- trunk/gpt2/gptvm/COPYING	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/COPYING	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/gpt2/gptvm/ChangeLog
===================================================================

Added: trunk/gpt2/gptvm/INSTALL
===================================================================
--- trunk/gpt2/gptvm/INSTALL	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/INSTALL	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+

Added: trunk/gpt2/gptvm/Makefile.am
===================================================================
--- trunk/gpt2/gptvm/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1 @@
+SUBDIRS = src 

Added: trunk/gpt2/gptvm/Makefile.boot
===================================================================
--- trunk/gpt2/gptvm/Makefile.boot	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/Makefile.boot	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,9 @@
+all:
+	aclocal
+	autoheader
+	libtoolize -c -f
+	automake -ac
+	autoconf
+
+distclean:
+	rm -rf autom4te.cache aclocal.m4 config.* configure depcomp install-sh missing ltmain.sh

Added: trunk/gpt2/gptvm/NEWS
===================================================================

Added: trunk/gpt2/gptvm/README
===================================================================

Added: trunk/gpt2/gptvm/configure.ac
===================================================================
--- trunk/gpt2/gptvm/configure.ac	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/configure.ac	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,55 @@
+AC_PREREQ(2.60)
+
+AC_INIT(gptvm, 1.0)
+AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE(gptvm, 1.0)
+
+AC_LANG(C++)
+AC_PROG_CXX
+AM_PROG_LIBTOOL
+
+#------------------------------
+# debug options
+#------------------------------
+
+AC_ARG_ENABLE(debug,
+        AC_HELP_STRING([--enable-debug=ARG],[enables debug symbols (yes|no|full) [default=no]]),
+[
+  case $enableval in
+    yes)
+      use_debug_code="yes"
+      use_debug_define=yes
+      ;;
+    full)
+      use_debug_code="full"
+      use_debug_define=yes
+      ;;
+    *)
+      use_debug_code="no"
+      use_debug_define=no
+      ;;
+  esac
+],
+  [use_debug_code="no"
+    use_debug_define=no
+])
+
+CXXFLAGS=
+if test "$use_debug_code" != "no"; then
+  if test $use_debug_code = "full"; then
+    CXXFLAGS="-g3 $CXXFLAGS"
+  else
+    CXXFLAGS="-g -O2 $CXXFLAGS"
+  fi
+else
+  CXXFLAGS="-O2 $CXXFLAGS"
+fi
+
+if test "$use_debug_define" = "yes"; then
+  CXXFLAGS="-DDEBUG $CXXFLAGS"
+fi
+
+
+AC_CONFIG_FILES([Makefile
+                 src/Makefile])
+AC_OUTPUT

Deleted: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/src/Makefile	2007-12-19 03:38:52 UTC (rev 443)
@@ -1,25 +0,0 @@
-COMMON_DIR=../../common/src/
-
-INCLUDE_DIR=-I$(COMMON_DIR)
-CC=g++
-CCFLAGS=-g -Wall
-
-GPTASM=../gptasm/
-
-objects = main.o CGptVm.o CRunBytecode.o CBytecode.o CDataStack.o \
-          $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
-          $(COMMON_DIR)CHeader.o $(COMMON_DIR)Tools.o\
-          $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
-          
-all: $(objects)
-	g++ -o gptvm $(objects) -ldl
-
-%.o: %.cpp %.hpp
-	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
-
-%.o: %.cpp
-	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
-
-
-clean:
-	rm -f *.o $(COMMON_DIR)*.o gptvm

Added: trunk/gpt2/gptvm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 02:25:14 UTC (rev 442)
+++ trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 03:38:52 UTC (rev 443)
@@ -0,0 +1,11 @@
+COMMON_IDIR = ../../../common/src
+COMMON_LDIR = ../../common/src
+
+INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
+
+bin_PROGRAMS = gpt
+
+gpt_SOURCES = CBytecode.cpp  CDataStack.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
+						  CBytecode.hpp  CDataStack.hpp  CGptVm.hpp  CRunBytecode.hpp  
+
+gpt_LDADD = $(COMMON_LDIR)/libgptcommon.la -ldl
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 14:41:08 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 14:41:08 +0100
Subject: [gpt-commit] r444 - in trunk/gpt2/bindings/gptbind: src test
Message-ID: <200712191341.lBJDf8VI013423@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-19 14:41:08 +0100 (Wed, 19 Dec 2007)
New Revision: 444

Modified:
   trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
   trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
   trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
   trunk/gpt2/bindings/gptbind/src/lexer.g
   trunk/gpt2/bindings/gptbind/src/main.cpp
   trunk/gpt2/bindings/gptbind/src/parser.g
   trunk/gpt2/bindings/gptbind/test/test.sld
Log:
DEVNULL:
* O GptBind esta gerando codigo mais correto para os bindings.
  Com pequenos ajustes esse codigo ja pode ser compilado.


Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-19 13:41:08 UTC (rev 444)
@@ -1,13 +1,11 @@
 #include "CBindSources.hpp"
 
 
-#include <map>
-
-
-CBindSources::CBindSources(const std::string &filename, const std::string &prefix)
+CBindSources::CBindSources(const std::string &filename)
       : _filename(filename)
-      , _prefix(prefix)
 {
+   _mapGptToCppType["string"] = "const char *";
+   _mapGptToCppType["real"]   = "double";
 }
 
 
@@ -16,6 +14,13 @@
    hppSource.writeln( "#ifndef GPTBIND_" + _filename + "_HPP" );
    hppSource.writeln( "#define GPTBIND_" + _filename + "_HPP" );
    hppSource.writeln();
+
+   for(std::list<std::string>::iterator header = _headerList.begin(); header != _headerList.end(); header++) {
+      std::string sheader = (*header).substr(1, (*header).length()-2);
+      hppSource.writeln( "#include <" + sheader + ">" );
+   }
+   hppSource.writeln();
+
    hppSource.writeln( "extern \"C\" {" );
    hppSource.incTab();
 
@@ -27,22 +32,32 @@
 }
 
 
-void CBindSources::addProcedureBind(
-      const std::string &name, 
+void CBindSources::addSubroutineBind(
+      const std::string &name,
+      const std::string &returnType,
       std::vector<std::pair<std::string, std::string> > parameters,
       const std::string &functionBind,
       std::vector<std::string> arguments )
 {
-   hppSource.writeln( "void " + _prefix + name + "( CDataStack &dataStack );" );
+   hppSource.writeln( "void gsl_" + name + "( CDataStack &dataStack );" );
 
    cppSource.writeln();
-   cppSource.writeln( "void " + _prefix + name + "( CDataStack &dataStack )" );
+   cppSource.writeln( "void gsl_" + name + "( CDataStack &dataStack )" );
    cppSource.writeln( "{" );
    cppSource.incTab();
+
    for(std::vector<std::pair<std::string, std::string> >::iterator param = parameters.begin(); param != parameters.end(); param++) {
-      cppSource.writeln (sourceToGetParameter (param->first, param->second));
+      cppSource.writeln (sourceToPopParameter (param->first, param->second));
    }
+
+   if (!returnType.empty()) {
+      cppSource.writeln(_mapGptToCppType[returnType] + " result;");
+      cppSource.writeln();
+      cppSource.write( "result=" );
+   }
+
    cppSource.write(functionBind + "(");
+
    for(std::vector<std::string>::iterator arg = arguments.begin(); arg != arguments.end(); arg++) {
       if (arg != arguments.begin()) {
          cppSource.write(", ");
@@ -54,27 +69,43 @@
       }
    }
    cppSource.writeln(");");
+   if (!returnType.empty()) {
+      cppSource.writeln();
+      cppSource.writeln(sourceToPushResult("result", returnType));
+   }
    cppSource.decTab();
    cppSource.writeln( "}" );
 }
 
 
-std::string CBindSources::sourceToGetParameter(const std::string &name, const std::string &type)
+std::string CBindSources::sourceToPopParameter(const std::string &name, const std::string &type)
 {
    std::string result;
 
-   std::map<std::string, std::string> mapType;
-   mapType["string"] = "const char *";
-
    std::map<std::string, std::string> mapPop;
    mapPop["string"] = "dataStack.popString().c_str()";
+   mapPop["real"]   = "dataStack.popReal()";
 
-   result = mapType[type] + " c" + name + "=" + mapPop[type] + ";";
+   result = _mapGptToCppType[type] + " c" + name + "=" + mapPop[type] + ";";
 
    return result;
 }
 
 
+std::string CBindSources::sourceToPushResult(const std::string &name, const std::string &type)
+{
+   std::string result;
+
+   std::map<std::string, std::string> mapPush;
+   mapPush["real"  ] = "dataStack.pushReal(" + name + ")";
+   mapPush["string"] = "dataStack.pushString(" + name + ")";
+
+   result = mapPush[type] + ";";
+
+   return result;
+}
+
+
 void CBindSources::writeFooters()
 {
    hppSource.decTab();
@@ -83,3 +114,15 @@
    hppSource.writeln( "#endif" );
 }
 
+
+void CBindSources::addLinkerLib(const std::string &lib)
+{
+   _linkerLibList.push_back(lib);
+}
+
+
+void CBindSources::addHeader(const std::string &header)
+{
+   _headerList.push_back(header);
+}
+

Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-19 13:41:08 UTC (rev 444)
@@ -5,19 +5,24 @@
 
 #include <string>
 #include <vector>
+#include <map>
+#include <list>
 
 class CBindSources
 {
 public:
-   CBindSources(const std::string &filename, const std::string &prefix);
+   CBindSources(const std::string &filename);
    void writeHeaders();
-   void addProcedureBind(
+   void addSubroutineBind(
          const std::string &name, 
+         const std::string &returnType,
          std::vector<std::pair<std::string, std::string> > parameters,
          const std::string &functionBind,
          std::vector<std::string> arguments
    );
    void writeFooters();
+   void addLinkerLib(const std::string &lib);
+   void addHeader(const std::string &header);
    std::string getHppSource()
    {
       return hppSource.getText();
@@ -30,13 +35,17 @@
    {
       return makefileSource.getText();
    }
-   std::string sourceToGetParameter(const std::string &name, const std::string &type);
 private:
    std::string _filename;
-   std::string _prefix;
    CTextFile hppSource;
    CTextFile cppSource;
    CTextFile makefileSource;
+   std::map<std::string, std::string> _mapGptToCppType;
+   std::list<std::string> _linkerLibList;
+   std::list<std::string> _headerList;
+
+   std::string sourceToPopParameter(const std::string &name, const std::string &type);
+   std::string sourceToPushResult(const std::string &name, const std::string &type);
 };
 
 #endif

Modified: trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-19 13:41:08 UTC (rev 444)
@@ -13,12 +13,12 @@
 
 bool CGptBind::run( )
 {
-   ifstream in(_options->sourcefile.c_str());
+   ifstream in((_options->sourcefile+".sld").c_str());
    GptBindLexer lexer(in);
    GptBindParser parser(lexer);
 
 //   string asmProgram = parser.program(_options->sourcefile);
-   parser.sld_grammar();
+   parser.sld_grammar(_options->sourcefile);
 
    string cppOutput = parser.getCpp();
    string hppOutput = parser.getHpp();

Modified: trunk/gpt2/bindings/gptbind/src/lexer.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-19 13:41:08 UTC (rev 444)
@@ -36,7 +36,6 @@
    T_KW_POINTER="pointer";
    T_KW_MATRIX="matrix";
    T_KW_DATA="data";
-   T_KW_LIBNAME="libname";
    T_KW_FUNCTIONPREFIX="functionprefix";
    T_KW_LINKERLIB="linkerlib";
    T_REAL_VALUE="n?mero real"; //nondeterminism T_INT_LIT & T_REAL_LIT

Modified: trunk/gpt2/bindings/gptbind/src/main.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/main.cpp	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/main.cpp	2007-12-19 13:41:08 UTC (rev 444)
@@ -37,8 +37,8 @@
       return EXIT_FAILURE;
    }
 
-   options.sourcefile = string(argv[0]) + ".sld";
-   options.destfile   = string(argv[0]) + ".gvm";
+   options.sourcefile = argv[0];
+   options.destfile   = argv[0];
 
    cout << "Binding " << options.sourcefile << "..." << endl;
 

Modified: trunk/gpt2/bindings/gptbind/src/parser.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-19 13:41:08 UTC (rev 444)
@@ -26,9 +26,9 @@
 {  
    public:
 //      CGenBytecode bytecode;
-      void init()
+      void init(std::string sourcefile)
       {
-         sources = new CBindSources( "teste", "gptbind_" );
+         sources = new CBindSources( sourcefile );
       }
       antlr::RefToken getLastToken()
       {
@@ -64,9 +64,9 @@
 //###############
 
 //-----------
-  sld_grammar
+  sld_grammar [std::string sourcefile]
 //-----------
-   : { init(); }
+   : { init(sourcefile); }
      (optionsdef)?
      (headersdef)?
      {
@@ -98,7 +98,7 @@
 ///----------
    optionname
 ///----------
-   : "libname" | "functionprefix" | "linkerlib"
+   : "linkerlib" { sources->addLinkerLib(getLastTokenText()); }
    ;
 
 //#############
@@ -114,7 +114,7 @@
 //------
   headerdef
 //------
-   : T_STRING_VALUE T_SEMICOLON
+   : T_STRING_VALUE {sources->addHeader(getLastTokenText());} T_SEMICOLON
    ;
 
 //#############
@@ -134,13 +134,12 @@
 {
    std::vector<std::pair<std::string, std::string> > parameters;
    std::vector<std::string> arguments;
-//   std::vector<std::pair<std::string, int> > arguments;
 }
    : "procedure" tk_procname:T_ID (parameters_declaration[parameters])
      T_MAPINTO
      tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
      {
-        sources->addProcedureBind(tk_procname->getText(), parameters, tk_mapname->getText(), arguments);
+        sources->addSubroutineBind(tk_procname->getText(), "", parameters, tk_mapname->getText(), arguments);
      }
    ;
 
@@ -150,11 +149,14 @@
 {
    std::vector<std::pair<std::string, std::string> > parameters;
    std::vector<std::string> arguments;
-//   std::vector<std::pair<std::string, int> > arguments;
+   std::string resultType;
 }
-   : "function" T_ID (parameters_declaration[parameters]) T_COLON type
+   : "function" tk_procname:T_ID (parameters_declaration[parameters]) T_COLON resultType=type
      T_MAPINTO
-     T_ID (arguments_declaration[arguments])? T_SEMICOLON
+     tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
+     {
+        sources->addSubroutineBind(tk_procname->getText(), resultType, parameters, tk_mapname->getText(), arguments);
+     }
    ;
 
 ///----------------------
@@ -165,10 +167,10 @@
 }
    : T_ABREP
      (
-        type {typeValue = getLastTokenText();} tk_id:T_ID
+        typeValue=type tk_id:T_ID
         {parameters.push_back(std::pair<std::string, std::string>(tk_id->getText(), typeValue));} 
         (
-           T_COMMA type {typeValue = getLastTokenText();} tk_id2:T_ID
+           T_COMMA typeValue=type tk_id2:T_ID
            {parameters.push_back(std::pair<std::string, std::string>(tk_id2->getText(), typeValue));} 
         )*
      )?
@@ -219,16 +221,19 @@
   ;
 
 ///----
-   type
+   type returns [std::string result]
 ///----
-   : "int"
-   | "real"
-   | "char"
-   | "string"
-   | "bool"
-   | "pointer"
-   | "matrix"
-   | "data"
+   :
+   ( "int"
+     | "real"
+     | "char"
+     | "string"
+     | "bool"
+     | "pointer"
+     | "matrix"
+     | "data"
+   )
+   {result = getLastTokenText();}
    ;
 
 /////----

Modified: trunk/gpt2/bindings/gptbind/test/test.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-19 13:41:08 UTC (rev 444)
@@ -1,7 +1,5 @@
 options {
-   libname        = "math";
-   functionprefix = "math_"; // poderia ser libname + "_"
-   linkerlib      = "math";
+   linkerlib = "math";
 }
 
 headers {
@@ -14,9 +12,6 @@
 
 procedure mensagem_personalizada(string msg) ::= puts(msg);
 
-// Acho que esse formato eh o foto da versao .1 do gerador
-procedure outra_mensagem_personalizada(string msg) ::= puts(msg);
+function sqrt(real value) : real ::= sqrt(value);
 
-function sqrt(real value) : real ::= puts(msg);
-
 function exponencial(real valor) : real ::= exp(valor);



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 14:43:02 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 14:43:02 +0100
Subject: [gpt-commit] r445 - trunk/gpt2/gptvm/src
Message-ID: <200712191343.lBJDh2Hl013498@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 14:43:02 +0100 (Wed, 19 Dec 2007)
New Revision: 445

Modified:
   trunk/gpt2/gptvm/src/Makefile.am
Log:
-bin_PROGRAMS = gptvm

Modified: trunk/gpt2/gptvm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 13:41:08 UTC (rev 444)
+++ trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 13:43:02 UTC (rev 445)
@@ -3,9 +3,9 @@
 
 INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
 
-bin_PROGRAMS = gpt
+bin_PROGRAMS = gptvm
 
-gpt_SOURCES = CBytecode.cpp  CDataStack.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
+gptvm_SOURCES = CBytecode.cpp  CDataStack.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
 						  CBytecode.hpp  CDataStack.hpp  CGptVm.hpp  CRunBytecode.hpp  
 
-gpt_LDADD = $(COMMON_LDIR)/libgptcommon.la -ldl
\ No newline at end of file
+gptvm_LDADD = $(COMMON_LDIR)/libgptcommon.la -ldl
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 14:48:11 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 14:48:11 +0100
Subject: [gpt-commit] r446 - in trunk/gpt2: common/src gptasm/src gptvm/src
Message-ID: <200712191348.lBJDmBIu013675@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 14:48:10 +0100 (Wed, 19 Dec 2007)
New Revision: 446

Modified:
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/common/src/Tools.hpp
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
Log:
-Adicionado codigo para opcode c2s
-Adicionado suporte para caracteres constantes

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-19 13:43:02 UTC (rev 445)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-19 13:48:10 UTC (rev 446)
@@ -313,3 +313,66 @@
    return address;
 }
 
+int toUTF8Char(const std::string& chr)
+{
+  int ch = 0;
+  int inchar = chr[0];
+
+  if( (inchar & 0x80) == 0 )
+    return inchar;
+
+  unsigned int need = 0;
+  if( (inchar & 0xF8) == 0xF8 )
+  {
+    ch = inchar & 7;
+    need = 3;
+  }
+  else if( (inchar & 0xE0) == 0xE0 )
+  {
+    ch = inchar & 0xF;
+    need = 2;
+  }
+  else if( (inchar & 0xC0) == 0xC0 )
+  {
+    ch = inchar & 0x1F;
+    need = 1;
+  }  
+
+  int i = 1;
+  while( need )
+  {
+    inchar = chr[i++];
+    ch <<= 6;
+    ch += inchar & 0x3F;
+    need--;
+  }
+  return ch;
+}
+
+void appendUTF8Char(std::string& text, int c)
+{
+  if (c < 0x80)
+  {
+    text += c;
+    return;
+  }
+  else if (c < 0x800)
+  {
+    text += ( (c >> 6) | 0xC0 );
+    text += ( c & 0x3F | 0x80 );
+  }
+  else if (c < 0x10000)
+  {
+    text += ( (c >> 12) | 0xE0 );
+    text += ( ((c >> 6) & 0x3F) | 0x80 );
+    text += ( (c & 0x3F) | 0x80 );
+  }
+  else if (c < 0x200000)
+  {
+    text += ( (c >> 18) | 0xF0 );				// first 3 bits
+    text += ( (((c >> 16) & 0x3) << 4) |
+              ((c >> 12) & 0xF) | 0x80 );
+    text += ( ((c >> 6) & 0x3F) | 0x80 );
+    text += ( (c & 0x3F) | 0x80 );
+  }  
+}
\ No newline at end of file

Modified: trunk/gpt2/common/src/Tools.hpp
===================================================================
--- trunk/gpt2/common/src/Tools.hpp	2007-12-19 13:43:02 UTC (rev 445)
+++ trunk/gpt2/common/src/Tools.hpp	2007-12-19 13:48:10 UTC (rev 446)
@@ -39,5 +39,7 @@
 int realAddress(int address);
 std::string realAddressString(int address);
 int sumAddress(int address, int value);
+int  toUTF8Char(const std::string&);
+void appendUTF8Char(std::string& text, int c);
 
 #endif

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-12-19 13:43:02 UTC (rev 445)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-12-19 13:48:10 UTC (rev 446)
@@ -65,6 +65,8 @@
       writeInt(atoi(name.c_str()));
    } else if (type == CSymbol::REAL) {
       writeReal(atof(name.c_str()));
+   } else if (type == CSymbol::CHAR) {
+      writeInt(toUTF8Char(name));
    }
 
    return symbol;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-19 13:43:02 UTC (rev 445)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-19 13:48:10 UTC (rev 446)
@@ -1,6 +1,8 @@
 header {
    #include <string>
    #include <sstream>
+   #include "UnicodeCharBuffer.hpp"
+   #include "UnicodeCharScanner.hpp"
 }
 
 
@@ -9,14 +11,15 @@
 }
 
 
-class GptAssemblyLexer extends Lexer;
+class GptAssemblyLexer extends Lexer("UnicodeCharScanner");
 
 
 options {
    k=2;
    charVocabulary='\0'..'\377';
    exportVocab=GptAssemblyLexer;
-  testLiterals = true;
+   testLiterals = true;
+   noConstructors=true;
 //  testLiterals = false;
 //  filter=T_INVALID;
 //  genHashLines=false;//no #line
@@ -180,8 +183,9 @@
 
 {
 public:  
-
-private:
+   GptAssemblyLexer(std::istream& in)
+    : UnicodeCharScanner(new UnicodeCharBuffer(in), true) {
+   }
 }
 
 
@@ -259,7 +263,7 @@
 options {
    paraphrase = "char";
 }
-   : '\'' ( ~( '\'' | '\\' ) | ESC )? '\''
+   : '\''! ( ~( '\'' | '\\' ) | ESC )? '\''!
    ;
 
 T_STRING_VALUE

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-19 13:43:02 UTC (rev 445)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-19 13:48:10 UTC (rev 446)
@@ -967,7 +967,15 @@
 
 void CRunBytecode::c2sOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("c2s opcode");
+
+   int varAddress = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+
+   std::string op1 = _dataStack.getString(varAddress);
+
+   appendUTF8Char(op1, _dataStack.getInt(val1Address));
+   _dataStack.setString(varAddress,  op1);
 }
 
 void CRunBytecode::r2sOpcode()



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 14:49:27 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 14:49:27 +0100
Subject: [gpt-commit] r447 - in trunk/gpt2: common/src gptc/src
	gptc/src/gptasm_target gptc/src/parser
Message-ID: <200712191349.lBJDnRYc013766@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 14:49:26 +0100 (Wed, 19 Dec 2007)
New Revision: 447

Added:
   trunk/gpt2/common/src/MismatchedUnicodeCharException.cpp
   trunk/gpt2/common/src/MismatchedUnicodeCharException.hpp
   trunk/gpt2/common/src/UnicodeCharBuffer.hpp
   trunk/gpt2/common/src/UnicodeCharScanner.hpp
Removed:
   trunk/gpt2/gptc/src/gptasm_target/Tools.cpp
   trunk/gpt2/gptc/src/gptasm_target/Tools.hpp
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp
Modified:
   trunk/gpt2/common/src/Makefile.am
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptc/src/gptasm_target/Makefile.am
   trunk/gpt2/gptc/src/parser/Makefile.am
Log:
-Movendo codigo comum para gpt2/common

Modified: trunk/gpt2/common/src/Makefile.am
===================================================================
--- trunk/gpt2/common/src/Makefile.am	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/common/src/Makefile.am	2007-12-19 13:49:26 UTC (rev 447)
@@ -5,4 +5,7 @@
 libgptcommon_la_SOURCES = CBinString.cpp  CHeader.cpp  COptions.hpp  CSymbol.hpp \
                           CSymbolList.hpp   CSymbolTable.hpp  Makefile.am  Tools.hpp \
                           CBinString.hpp  CHeader.hpp  CSymbol.cpp   CSymbolList.cpp  \
-                          CSymbolTable.cpp  Common.hpp  Tools.cpp
+                          CSymbolTable.cpp  Common.hpp  Tools.cpp \
+                          MismatchedUnicodeCharException.hpp \
+                          MismatchedUnicodeCharException.cpp \
+                          UnicodeCharBuffer.hpp UnicodeCharScanner.hpp

Copied: trunk/gpt2/common/src/MismatchedUnicodeCharException.cpp (from rev 443, trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp)

Copied: trunk/gpt2/common/src/MismatchedUnicodeCharException.hpp (from rev 443, trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp)

Copied: trunk/gpt2/common/src/UnicodeCharBuffer.hpp (from rev 443, trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp)

Copied: trunk/gpt2/common/src/UnicodeCharScanner.hpp (from rev 443, trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp)
===================================================================
--- trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp	2007-12-19 03:38:52 UTC (rev 443)
+++ trunk/gpt2/common/src/UnicodeCharScanner.hpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -0,0 +1,562 @@
+#ifndef INC_UnicodeCharScanner_hpp__
+#define INC_UnicodeCharScanner_hpp__
+
+#include <map>
+#include <cctype>
+#include <iostream>
+
+#include <antlr/config.hpp>
+#include <antlr/CommonToken.hpp>
+#include <antlr/TokenStream.hpp>
+#include <antlr/RecognitionException.hpp>
+#include <antlr/SemanticException.hpp>
+#include <antlr/InputBuffer.hpp>
+#include <antlr/BitSet.hpp>
+#include <antlr/LexerSharedInputState.hpp>
+
+#include "MismatchedUnicodeCharException.hpp"
+
+/** Superclass of generated lexers
+ */
+class UnicodeCharScanner : public antlr::TokenStream {
+protected:
+	typedef antlr::RefToken (*factory_type)();
+public:
+	typedef int char_type;
+	typedef std::map<std::string,int> string_map;
+
+	UnicodeCharScanner( antlr::InputBuffer& cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( const antlr::LexerSharedInputState& state, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(state)
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+
+	virtual ~UnicodeCharScanner()
+	{
+	}
+
+	virtual char_type LA(char_type i)
+	{
+		char_type c = inputState->getInput().LA(i);
+		return c;
+	}
+
+	virtual void append(char_type c)
+	{
+		if (saveConsumedInput)
+		{
+			size_t len = text.length();
+
+			if( (len % 256) == 0 )
+				text.reserve(len+256);
+
+// This is how UTF8 is encoded
+// +---------------------------+----------+----------+----------+----------+
+// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
+// +---------------------------+----------+----------+----------+----------+
+// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
+// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
+// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
+// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
+// +---------------------------+----------+----------+----------+----------+
+
+			if (c < 0x80)
+			{
+				text += c;
+				return;
+			}
+			else if (c < 0x800)
+			{
+				text += ( (c >> 6) | 0xC0 );
+				text += ( c & 0x3F | 0x80 );
+			}
+			else if (c < 0x10000)
+			{
+				text += ( (c >> 12) | 0xE0 );
+				text += ( ((c >> 6) & 0x3F) | 0x80 );
+				text += ( (c & 0x3F) | 0x80 );
+			}
+			else if (c < 0x200000)
+			{
+				text += ( (c >> 18) | 0xF0 );				// first 3 bits
+				text += ( (((c >> 16) & 0x3) << 4) |
+								 ((c >> 12) & 0xF) | 0x80 );
+				text += ( ((c >> 6) & 0x3F) | 0x80 );
+				text += ( (c & 0x3F) | 0x80 );
+			}
+			else
+				assert(0);
+		}
+	}
+
+	virtual void append(const std::string& s)
+	{
+		assert(0);
+		if (saveConsumedInput)
+			text+=s;
+	}
+
+	virtual void commit()
+	{
+		inputState->getInput().commit();
+	}
+
+	virtual void consume()
+	{
+		if (inputState->guessing == 0)
+		{
+			char_type c = LA(1);
+			append(c);
+			inputState->column++;
+		}
+		inputState->getInput().consume();
+	}
+
+	/** Consume chars until one matches the given char */
+	virtual void consumeUntil(char_type c)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast<char_type>(EOF_CHAR) == la_1 || la_1 == c )
+				break;
+			consume();
+		}
+	}
+
+	/** Consume chars until one matches the given set */
+	virtual void consumeUntil(const antlr::BitSet& set)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast<char_type>(EOF_CHAR) == la_1 || set.member(la_1) )
+				break;
+			consume();
+		}
+	}
+
+	/// Mark the current position and return a id for it
+	virtual unsigned int mark()
+	{
+		return inputState->getInput().mark();
+	}
+
+	/// Rewind the scanner to a previously marked position
+	virtual void rewind(unsigned int pos)
+	{
+		inputState->getInput().rewind(pos);
+	}
+
+	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
+	virtual void match(char_type c)
+	{
+		char_type la_1 = LA(1);
+		if ( la_1 != c )
+			throw MismatchedUnicodeCharException(la_1, c, false, this);
+		consume();
+	}
+
+	/** See if input contains element from bitset b
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void match(const antlr::BitSet& b)
+	{
+		char_type la_1 = LA(1);
+
+		if ( !b.member(la_1) )
+			throw MismatchedUnicodeCharException( la_1, b, false, this );
+		consume();
+	}
+
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match( const char* s )
+	{
+		while( *s != '\0' )
+		{
+			// the & 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (*s++ & 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match(const std::string& s)
+	{
+		size_t len = s.length();
+
+		for (size_t i = 0; i < len; i++)
+		{
+			// the & 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (s[i] & 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input does not contain character 'c'
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchNot(char_type c)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 == c )
+			throw MismatchedUnicodeCharException(la_1, c, true, this);
+
+		consume();
+	}
+	/** See if input contains character in range c1-c2
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchRange(char_type c1, char_type c2)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 < c1 || la_1 > c2 )
+			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
+
+		consume();
+	}
+
+	/// Get the line the scanner currently is in (starts at 1)
+	virtual int getLine() const
+	{
+		return inputState->line;
+	}
+
+	/// set the line number
+	virtual void setLine(int l)
+	{
+		inputState->line = l;
+	}
+
+	/// Get the column the scanner currently is in (starts at 1)
+	virtual int getColumn() const
+	{
+		return inputState->column;
+	}
+	/// set the column number
+	virtual void setColumn(int c)
+	{
+		inputState->column = c;
+	}
+
+	/// get the filename for the file currently used
+	virtual const std::string& getFilename() const
+	{
+		return inputState->filename;
+	}
+	/// Set the filename the scanner is using (used in error messages)
+	virtual void setFilename(const std::string& f)
+	{
+		inputState->filename = f;
+	}
+
+	virtual bool getCommitToPath() const
+	{
+		return commitToPath;
+	}
+
+	virtual void setCommitToPath(bool commit)
+	{
+		commitToPath = commit;
+	}
+
+	/** return a copy of the current text buffer */
+	virtual const std::string& getText() const
+	{
+		return text;
+	}
+
+	virtual void setText(const std::string& s)
+	{
+		text = s;
+	}
+
+	virtual void resetText()
+	{
+		text = "";
+		inputState->tokenStartColumn = inputState->column;
+		inputState->tokenStartLine = inputState->line;
+	}
+
+	virtual antlr::RefToken getTokenObject() const
+	{
+		return _returnToken;
+	}
+
+	///{ These need different handling in unicode case
+
+	virtual bool getCaseSensitiveLiterals() const=0;
+
+	virtual bool getCaseSensitive() const
+	{
+		return caseSensitive;
+	}
+
+	virtual void setCaseSensitive(bool t)
+	{
+		caseSensitive = t;
+	}
+
+	/** Override this method to get more specific case handling
+	 * @note some platforms probably require setting the right locale for
+	 * correct functioning.
+	 */
+	virtual char_type toLower(char_type c) const
+	{
+		return std::tolower(c);
+	}
+
+	/** Used to keep track of line breaks, needs to be called from
+	 * within generated lexers when a \n \r is encountered.
+	 */
+	virtual void newline()
+	{
+		++inputState->line;
+		inputState->column = 1;
+	}
+
+	/** Advance the current column number by an appropriate amount according
+	 * to the tabsize. This method needs to be explicitly called from the
+	 * lexer rules encountering tabs.
+	 */
+	virtual void tab()
+	{
+		int c = getColumn();
+		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
+		setColumn( nc );
+	}
+	/// set the tabsize. Returns the old tabsize
+	int setTabsize( int size )
+	{
+		int oldsize = tabsize;
+		tabsize = size;
+		return oldsize;
+	}
+	/// Return the tabsize used by the scanner
+	int getTabSize() const
+	{
+		return tabsize;
+	}
+	///}
+
+	/** Report exception errors caught in nextToken() */
+	virtual void reportError(const antlr::RecognitionException& ex)
+	{
+		std::cerr << ex.toString().c_str() << std::endl;
+	}
+
+	/** Parser error-reporting function can be overridden in subclass */
+	virtual void reportError(const std::string& s)
+	{
+		if (getFilename() == "")
+			std::cerr << "error: " << s.c_str() << std::endl;
+		else
+			std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
+	}
+
+	/** Parser warning-reporting function can be overridden in subclass */
+	virtual void reportWarning(const std::string& s)
+	{
+		if (getFilename() == "")
+			std::cerr << "warning: " << s.c_str() << std::endl;
+		else
+			std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
+	}
+
+	virtual antlr::InputBuffer& getInputBuffer()
+	{
+		return inputState->getInput();
+	}
+
+	virtual antlr::LexerSharedInputState getInputState()
+	{
+		return inputState;
+	}
+
+	/** set the input state for the lexer.
+	 * @note state is a reference counted object, hence no reference */
+	virtual void setInputState(antlr::LexerSharedInputState state)
+	{
+		inputState = state;
+	}
+
+	/// Set the factory for created tokens
+	virtual void setTokenObjectFactory(factory_type factory)
+	{
+		tokenFactory = factory;
+	}
+
+	/** Test the token text against the literals table
+	 * Override this method to perform a different literals test
+	 */
+	virtual int testLiteralsTable(int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** Test the text passed in against the literals table
+	 * Override this method to perform a different literals test
+	 * This is used primarily when you want to test a portion of
+	 * a token
+	 */
+	virtual int testLiteralsTable(const std::string& text, int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** This method is called by YourLexer::nextToken() when the lexer has
+	 *  hit EOF condition.  EOF is NOT a character.
+	 *  This method is not called if EOF is reached during
+	 *  syntactic predicate evaluation or during evaluation
+	 *  of normal lexical rules, which presumably would be
+	 *  an IOException.  This traps the "normal" EOF condition.
+	 *
+	 *  uponEOF() is called after the complete evaluation of
+	 *  the previous token and only if your parser asks
+	 *  for another token beyond that last non-EOF token.
+	 *
+	 *  You might want to throw token or char stream exceptions
+	 *  like: "Heh, premature eof" or a retry stream exception
+	 *  ("I found the end of this file, go back to referencing file").
+	 */
+	virtual void uponEOF()
+	{
+	}
+
+	/// Methods used to change tracing behavior
+	void traceIndent()
+	{
+		for( int i = 0; i < traceDepth; i++ )
+			std::cout << " ";
+	}
+
+	void traceIn(const char* rname)
+	{
+		traceDepth++;
+		traceIndent();
+		std::cout << "> lexer " << rname
+			<< "; c==" << LA(1) << std::endl;
+	}
+
+	void traceOut(const char* rname)
+	{
+		traceIndent();
+		std::cout << "< lexer " << rname
+			<< "; c==" << LA(1) << std::endl;
+		traceDepth--;
+	}
+
+#ifndef NO_STATIC_CONSTS
+	static const int EOF_CHAR = EOF;
+#else
+	enum {
+		EOF_CHAR = EOF
+	};
+#endif
+protected:
+	std::string text; ///< Text of current token
+ 	/// flag indicating wether consume saves characters
+	bool saveConsumedInput;
+	factory_type tokenFactory;				///< Factory for tokens
+	bool caseSensitive; 						///< Is this lexer case sensitive
+	string_map literals;						 // set by subclass
+
+	antlr::RefToken _returnToken;		///< used to return tokens w/o using return val
+
+	/// Input state, gives access to input stream, shared among different lexers
+	antlr::LexerSharedInputState inputState;
+
+	/** Used during filter mode to indicate that path is desired.
+	 * A subsequent scan error will report an error as usual
+	 * if acceptPath=true;
+	 */
+	bool commitToPath;
+
+	unsigned int tabsize; 	///< tab size the scanner uses.
+
+	/// Create a new RefToken of type t
+	virtual antlr::RefToken makeToken(int t)
+	{
+		antlr::RefToken tok = tokenFactory();
+		// actually at this point you want to convert the stored lexeme text
+		// into the format you want to have it in in the backend...
+		tok->setType(t);
+		tok->setColumn(inputState->tokenStartColumn);
+		tok->setLine(inputState->tokenStartLine);
+		return tok;
+	}
+
+	/** Tracer class, used when -traceLexer is passed to antlr
+	 */
+	class Tracer {
+	private:
+		UnicodeCharScanner* parser;
+		const char* text;
+
+		Tracer(const Tracer& other); 					// undefined
+		Tracer& operator=(const Tracer& other); 	// undefined
+	public:
+		Tracer( UnicodeCharScanner* p, const char* t )
+		: parser(p), text(t)
+		{
+			parser->traceIn(text);
+		}
+		~Tracer()
+		{
+			parser->traceOut(text);
+		}
+	};
+
+	int traceDepth;
+private:
+	UnicodeCharScanner( const UnicodeCharScanner& other ); 		  		// undefined
+	UnicodeCharScanner& operator=( const UnicodeCharScanner& other );	// undefined
+};
+
+#endif //INC_UnicodeCharScanner_hpp__

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,8 +1,12 @@
 SUBDIRS = parser common semantic symboltable gptasm_target
 
+COMMON_IDIR = ../../../common/src
+COMMON_LDIR = ../../common/src
+
 INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/parser \
 	-I$(top_srcdir)/src/common -I$(top_srcdir)/src/semantic -I$(top_srcdir)/src/symboltable \
-	-I$(top_srcdir)/src/gptasm_target -I./parser -I./semantic -I./gptasm_target
+	-I$(top_srcdir)/src/gptasm_target -I./parser -I./semantic -I./gptasm_target \
+  -I$(COMMON_IDIR)
 
 bin_PROGRAMS = gptc
 
@@ -10,4 +14,5 @@
 
 gptc_LDADD = $(top_builddir)/src/symboltable/libsymboltable.la \
 	$(top_builddir)/src/common/libcommon.la $(top_builddir)/src/gptasm_target/libgptasm.la \
-	$(top_builddir)/src/semantic/libsemantic.la $(top_builddir)/src/parser/libparser.la $(ANTLR_LIB)
+	$(top_builddir)/src/semantic/libsemantic.la $(top_builddir)/src/parser/libparser.la \
+  $(COMMON_LDIR)/libgptcommon.la $(ANTLR_LIB)

Modified: trunk/gpt2/gptc/src/gptasm_target/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,5 +1,7 @@
+COMMON_IDIR = ../../../../common/src
 INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I../parser \
-           -I$(top_srcdir)/src/symboltable -I$(top_srcdir)/src/common
+           -I$(top_srcdir)/src/symboltable -I$(top_srcdir)/src/common \
+           -I$(COMMON_IDIR)
 
 noinst_LTLIBRARIES = libgptasm.la
 
@@ -11,7 +13,7 @@
 libgptasm_la_SOURCES = Arguments.cpp Arguments.hpp AsmProgram.cpp AsmProgram.hpp\
 	BaseGptAsmWalker.cpp BaseGptAsmWalker.hpp Context.cpp Context.hpp\
 	GptAsmExpression.cpp GptAsmExpression.hpp Options.hpp Subroutine.cpp\
-	Subroutine.hpp TextFile.cpp TextFile.hpp Tools.cpp Tools.hpp $(BUILT_SOURCES)
+	Subroutine.hpp TextFile.cpp TextFile.hpp $(BUILT_SOURCES)
 
 CLEANFILES = GptAsmWalkerTokenTypes.hpp \
              GptAsmWalker.cpp \

Deleted: trunk/gpt2/gptc/src/gptasm_target/Tools.cpp
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Tools.cpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/gptasm_target/Tools.cpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,299 +0,0 @@
-/*
- * $Id: Tools.cpp,v 1.1.1.1 2005/08/15 15:19:52 asgarzao Exp $
- * MyLibrary version 0.1.0
- * Copyright (C) 2002 Alex Sandro Garz? <alexgarzao at bol.com.br>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-#include "PortugolParserTokenTypes.hpp"
-
-#include "Tools.hpp"
-
-
-int hexToInt(const char* _value) {
-    int result = 0;
-    char *position;
-    char conversionTable[] = "0123456789ABCDEF";
-
-    while (*_value) {
-        position = strchr(conversionTable, *_value);
-        if (position == NULL)
-            return 0;
-
-        result <<= 4;
-        result = result | (position - conversionTable);
-        _value++;
-    }
-
-    return result;
-}
-
-string pad(string _text, unsigned int _size) {
-    if (_size > _text.length())
-        _text.append(_size - _text.length(), ' ');
-
-    return _text;
-}
-
-string lpad(string _text, unsigned int _size) {
-    if (_size > _text.length())
-        _text = string(_size - _text.length(), ' ') + _text;
-
-    return _text;
-}
-
-string intToHex(unsigned int _value, int _size) {
-    string codHex = "0123456789ABCDEF";
-    string result;
-    int nible;
-
-    while (_value > 0) {
-        nible = _value & 0xF;
-        _value >>= 4;
-        result = codHex[nible] + result;
-    }
-
-    if ( _size == -1 )
-        _size = 1;
-
-    return strZero(result, _size);
-    // if (_size == -1)
-    //     return( result );
-    // else
-    //     return( strZero( result, _size ) );
-    //
-}
-
-string strZero(string _value, unsigned int _size) {
-    while (_value.length() < _size) {
-        _value = '0' + _value;
-    }
-
-    return _value;
-}
-
-string strZero(int _value, unsigned int _size) {
-    string result = itoa(_value);
-
-    while (result.length() < _size) {
-        result = '0' + result;
-    }
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = 0; count < _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _start, unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = _start; count - _start < _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-int binToInt(const char* _binValue) {
-    int intValue = 0;
-    int length = strlen(_binValue) - 1;
-    int countBit;
-
-    for (countBit = length; countBit >= 0; countBit--) {
-        if (_binValue[countBit] == '1')
-            intValue += int(pow(2.0, length - countBit));
-    }
-
-    return intValue;
-}
-
-string itoa(int _number) {
-    stringstream s;
-
-    s << _number;
-    return s.str();
-}
-
-string ftos(double _value) {
-    stringstream s;
-
-    s <<  setiosflags(ios::fixed) << _value;
-    
-    return s.str();
-}
-
-string itobool(int _number) {
-    if (_number == 0)
-        return "false";
-    else
-        return "true";
-}
-
-string strtoupper(string str) {
-    unsigned int count;
-
-    for (count = 0; count < str.size(); count++)
-        str[count] = toupper(str[count]);
-
-    return str;
-}
-
-string strToUpperWithEscapeControls(string str) {
-    unsigned int count;
-
-    for (count = 0; count < str.size(); count++) {
-        if (str[count] == '\\')
-            count += 2;
-        else
-            str[count] = toupper(str[count]);
-    }
-
-    return str;
-}
-
-string alltrim(string str) {
-    // crap version...  :-)
-    // precisamos usar `find', `rfind'! --felipek
-    while (str[0] == ' ')
-        str.erase(0, 1);
-
-    while (str[str.length() - 1] == ' ')
-        str.erase(str.length() - 1, 1);
-
-    return str;
-}
-
-string wo_ctrl_chrs(string str, char chr_to_put) {
-    unsigned int chr_number;
-
-    for (chr_number = 0; chr_number < str.size(); chr_number++) {
-        if (str[chr_number] < 32)
-            str[chr_number] = chr_to_put;
-    }
-
-    return str;
-}
-
-/* CRAP!  --felipek
-string& getStringWithTab(string _data, string _tab) {
-	cout << "begin getStringWithTab" << endl;
-	cout << "tab=\"" << _tab << "\"" << endl;
-	cout << "begin datae" << endl;
-	cout << _data << endl;
-	cout << "end datae" << endl;
-	int pos = -1;
- 
-	// test too another new line sequences
-	while( ( pos = _data.find( "\n", pos + 1 ) ) != -1 ) {
-		_data.insert( pos + 1, _tab );
-	}
- 
-	cout << "begin datas" << endl;
-	cout << _data << endl;
-	cout << "end datas" << endl;
-	return( _data );
-}
-*/
-
-bool streamtoken(istringstream& stream, string& key, string& val) {
-     /* FIXME: leak, --felipek */
-     char buffer[8192];
-     unsigned int delim;
-     string entry;
-//     bool ret;
-
-     /* FIXME: ret type, -- felipek */
-     stream.getline(buffer, 8192 - 1);
-     entry = string(buffer);
-     delim = entry.find(' ', 0);
-
-     if (delim != entry.npos) {
-         key = entry.substr(0, delim);
-         val = entry.substr(delim + 1);
-     }
-
-     return !stream.eof();
-}
-
-
-const string typeToText(const int &type)
-{
-//    if (type == PortugolParserTokenTypes::T_INT_LIT) {
-//       return "int";
-//    } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
-//       return "char";
-//    } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
-//       return "string";
-//    } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
-//       return "real";
-//    } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
-//       return "id";
-//    }
-// 
-//    return "ERRO !!!";
-}
-
-const string typeInAsm( const int &type )
-{
-//    if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
-//       return "int";
-//    } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
-//       return "string";
-//    } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
-//       return "char";
-//    } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
-//       return "bool";
-//    } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
-//       return "real";
-//    } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
-//       return "pointer ???";
-//    } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
-//       return "matrix";
-//    }
-
-   return "ERRO !!!";
-}
-
-
-const int typeToLiteral( const int &type )
-{
-//    switch (type) {
-//       case PortugolParserTokenTypes::T_KW_INTEIRO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-//       case PortugolParserTokenTypes::T_KW_LITERAL:
-//          return PortugolParserTokenTypes::T_STRING_LIT;
-//       case PortugolParserTokenTypes::T_KW_CARACTERE:
-//          return PortugolParserTokenTypes::T_CARAC_LIT;
-//       case PortugolParserTokenTypes::T_KW_LOGICO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-// //      case PortugolParserTokenTypes::T_KW_CORINGA:
-// //         return "pointer ???";
-// //      case PortugolParserTokenTypes::T_KW_MATRIZ:
-// //          return PortugolParserTokenTypes::T_MATRIZ;
-//       default:
-//           return 0;
-//           // trow exception ???
-//    }
-}
-

Deleted: trunk/gpt2/gptc/src/gptasm_target/Tools.hpp
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Tools.hpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/gptasm_target/Tools.hpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,39 +0,0 @@
-#ifndef GPT_TOOLS_H
-#define GPT_TOOLS_H
-
-#include <iomanip>
-
-#include <iostream>
-#include <string>
-#include <cstdlib>
-#include <cstring>
-#include <cmath>
-#include <cstdio>
-#include <sstream>
-using namespace std;
-
-
-int hexToInt(const char *);
-string pad(string, unsigned int);
-string lpad(string, unsigned int);
-string intToHex(unsigned int, int = -1);
-string strZero(string, unsigned int);
-string strZero(int, unsigned int);
-string dataToHex(char *, unsigned int);
-string dataToHex( char *, unsigned int, unsigned int);
-int binToInt(const char *);
-int octToInt(const char *);
-string itoa(int);
-string itobool(int);
-string ftos(double);
-string strtoupper(string);
-string strToUpperWithEscapeControls(string);
-string alltrim(string);
-string wo_ctrl_chrs(string str, char = ' ');
-bool streamtoken(istringstream&, string&, string&);
-// string& getStringWithTab(string, string);
-const string typeToText(const int &type);
-const string typeInAsm( const int &type );
-const int typeToLiteral( const int &type );
-
-#endif

Modified: trunk/gpt2/gptc/src/parser/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,4 +1,6 @@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common
+COMMON_IDIR = ../../../../common/src
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common \
+           -I$(COMMON_IDIR)
 
 EXTRA_DIST = lexer.g parser.g
 
@@ -11,9 +13,7 @@
                 TokenNames.hpp \
                 TokenLabels.hpp
 
-libparser_la_SOURCES = MismatchedUnicodeCharException.cpp \
-	MismatchedUnicodeCharException.hpp UnicodeCharBuffer.hpp \
-	UnicodeCharScanner.hpp $(BUILT_SOURCES)
+libparser_la_SOURCES = $(BUILT_SOURCES)
 
 
 CLEANFILES = PortugolLexer.cpp \

Deleted: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,110 +0,0 @@
-
-#include <iostream>
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-#include "MismatchedUnicodeCharException.hpp"
-#include "UnicodeCharScanner.hpp"
-
-
-MismatchedUnicodeCharException::MismatchedUnicodeCharException()
-: RecognitionException("Mismatched char")
-{
-}
-
-// Expected range / not range
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type lower,
-	char_type up,
-	bool matchNot,
-	UnicodeCharScanner* cs
-)
-: RecognitionException("Mismatched char",
-							  cs->getFilename(),
-							  cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_RANGE : RANGE)
-, foundChar(c)
-, expecting(lower)
-, upper(up)
-, scanner(cs)
-{
-}
-
-// Expected char / not char
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type expect,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_CHAR : CHAR)
-, foundChar(c)
-, expecting(expect)
-, scanner(cs)
-{
-}
-
-// Expected BitSet / not BitSet
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	antlr::BitSet s,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_SET : SET)
-, foundChar(c)
-, set(s)
-, scanner(cs)
-{
-}
-
-MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
-
-/**
- * Returns a clean error message (no line number/column information)
- */
-std::string MismatchedUnicodeCharException::getMessage() const
-{
-	ANTLR_USE_NAMESPACE(std)string s;
-
-	switch (mismatchType) {
-	case CHAR :
-		s += "expecting '" + antlr::charName(expecting) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_CHAR :
-		s += "expecting anything but '" + antlr::charName(expecting) + "'; got it anyway";
-		break;
-	case RANGE :
-		s += "expecting token in range: '" + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_RANGE :
-		s += "expecting token NOT in range: " + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case SET :
-	case NOT_SET :
-		{
-			s += ANTLR_USE_NAMESPACE(std)string("expecting ") + (mismatchType == NOT_SET ? "NOT " : "") + "one of (";
-			ANTLR_USE_NAMESPACE(std)vector<unsigned int> elems = set.toArray();
-			for ( unsigned int i = 0; i < elems.size(); i++ )
-			{
-				s += " '";
-				s += antlr::charName(elems[i]);
-				s += "'";
-			}
-			s += "), found '" + antlr::charName(foundChar) + "'";
-		}
-		break;
-	default :
-		s += RecognitionException::getMessage();
-		break;
-	}
-
-	return s;
-}

Deleted: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,82 +0,0 @@
-#ifndef INC_MismatchedUnicodeCharException_hpp__
-#define INC_MismatchedUnicodeCharException_hpp__
-
-/* ANTLR Translator Generator
- * Project led by Terence Parr at http://www.jGuru.com
- * Software rights: http://www.antlr.org/license.html
- *
- * $Id:$
- */
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-
-class UnicodeCharScanner;
-
-class MismatchedUnicodeCharException : public antlr::RecognitionException {
-public:
-	typedef unsigned int char_type;
-	typedef enum {
-		CHAR = 1,
-		NOT_CHAR = 2,
-		RANGE = 3,
-		NOT_RANGE = 4,
-		SET = 5,
-		NOT_SET = 6
-	} MATCH_TYPE;
-
-	MismatchedUnicodeCharException();
-
-	// Expected range / not range
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type lower,
-		char_type up,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected char / not char
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type expect,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected BitSet / not BitSet
-	MismatchedUnicodeCharException(
-		char_type c,
-		antlr::BitSet s,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	~MismatchedUnicodeCharException() throw();
-
-	/**
-	 * Returns a clean error message (no line number/column information)
-	 */
-	std::string getMessage() const;
-private:
-	// One of the above
-	MATCH_TYPE mismatchType;
-
-	// what was found on the input stream
-	char_type foundChar;
-
-	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
-	char_type expecting;
-
-	// For RANGE/NOT_RANGE (expecting is lower bound of range)
-	char_type upper;
-
-	// For SET/NOT_SET
-	antlr::BitSet set;
-	// who knows...they may want to ask scanner questions
-	UnicodeCharScanner* scanner;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,83 +0,0 @@
-#ifndef INC_UnicodeCharBuffer_hpp__
-#define INC_UnicodeCharBuffer_hpp__
-
-#include <istream>
-#include <cassert>
-#include <antlr/config.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/CharStreamIOException.hpp>
-
-class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
-public:
-	typedef unsigned int char_type;	// should be 32 bits!
-
-	/// Create a character buffer
-	UnicodeCharBuffer(std::istream& inp)
-	: input(inp)
-	{
-		//	input.exceptions(std::ios_base::badbit|
-		//						  std::ios_base::failbit);
-	}
-	/// Get the next character from the stream
-	int getChar()
-	{
-		char_type ch = 0;
-		int inchar = input.get();
-		if( inchar == EOF )
-			return -1;
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-		if( (inchar & 0x80) == 0 )
-			return inchar;
-
-		unsigned int need = 0;
-		if( (inchar & 0xF8) == 0xF8 )
-		{
-			ch = inchar & 7;
-			need = 3;
-		}
-		else if( (inchar & 0xE0) == 0xE0 )
-		{
-			ch = inchar & 0xF;
-			need = 2;
-		}
-		else if( (inchar & 0xC0) == 0xC0 )
-		{
-			ch = inchar & 0x1F;
-			need = 1;
-		}
-		else
-		{
-			assert("Invalid UTF8");
-		}
-		while( need )
-		{
-			inchar = input.get();
-			if( inchar == EOF )
-				assert("Invalid UTF8");
-//				throw antlr::CharStreamIOException(std::logic_error());
-			ch <<= 6;
-			ch += inchar & 0x3F;
-			need--;
-		}
-		return ch;
-	}
-private:
-	// character source
-	std::istream& input;
-
-	// NOTE: Unimplemented
-	UnicodeCharBuffer(const UnicodeCharBuffer& other);
-	UnicodeCharBuffer& operator=(const UnicodeCharBuffer& other);
-};
-
-#endif //INC_UnicodeCharBuffer_hpp__

Deleted: trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp	2007-12-19 13:48:10 UTC (rev 446)
+++ trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp	2007-12-19 13:49:26 UTC (rev 447)
@@ -1,561 +0,0 @@
-#ifndef INC_UnicodeCharScanner_hpp__
-#define INC_UnicodeCharScanner_hpp__
-
-#include <map>
-#include <cctype>
-
-#include <antlr/config.hpp>
-#include <antlr/CommonToken.hpp>
-#include <antlr/TokenStream.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/SemanticException.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/LexerSharedInputState.hpp>
-
-#include "MismatchedUnicodeCharException.hpp"
-
-/** Superclass of generated lexers
- */
-class UnicodeCharScanner : public antlr::TokenStream {
-protected:
-	typedef antlr::RefToken (*factory_type)();
-public:
-	typedef int char_type;
-	typedef std::map<std::string,int> string_map;
-
-	UnicodeCharScanner( antlr::InputBuffer& cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( const antlr::LexerSharedInputState& state, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(state)
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-
-	virtual ~UnicodeCharScanner()
-	{
-	}
-
-	virtual char_type LA(char_type i)
-	{
-		char_type c = inputState->getInput().LA(i);
-		return c;
-	}
-
-	virtual void append(char_type c)
-	{
-		if (saveConsumedInput)
-		{
-			size_t len = text.length();
-
-			if( (len % 256) == 0 )
-				text.reserve(len+256);
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-			if (c < 0x80)
-			{
-				text += c;
-				return;
-			}
-			else if (c < 0x800)
-			{
-				text += ( (c >> 6) | 0xC0 );
-				text += ( c & 0x3F | 0x80 );
-			}
-			else if (c < 0x10000)
-			{
-				text += ( (c >> 12) | 0xE0 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else if (c < 0x200000)
-			{
-				text += ( (c >> 18) | 0xF0 );				// first 3 bits
-				text += ( (((c >> 16) & 0x3) << 4) |
-								 ((c >> 12) & 0xF) | 0x80 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else
-				assert(0);
-		}
-	}
-
-	virtual void append(const std::string& s)
-	{
-		assert(0);
-		if (saveConsumedInput)
-			text+=s;
-	}
-
-	virtual void commit()
-	{
-		inputState->getInput().commit();
-	}
-
-	virtual void consume()
-	{
-		if (inputState->guessing == 0)
-		{
-			char_type c = LA(1);
-			append(c);
-			inputState->column++;
-		}
-		inputState->getInput().consume();
-	}
-
-	/** Consume chars until one matches the given char */
-	virtual void consumeUntil(char_type c)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || la_1 == c )
-				break;
-			consume();
-		}
-	}
-
-	/** Consume chars until one matches the given set */
-	virtual void consumeUntil(const antlr::BitSet& set)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || set.member(la_1) )
-				break;
-			consume();
-		}
-	}
-
-	/// Mark the current position and return a id for it
-	virtual unsigned int mark()
-	{
-		return inputState->getInput().mark();
-	}
-
-	/// Rewind the scanner to a previously marked position
-	virtual void rewind(unsigned int pos)
-	{
-		inputState->getInput().rewind(pos);
-	}
-
-	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
-	virtual void match(char_type c)
-	{
-		char_type la_1 = LA(1);
-		if ( la_1 != c )
-			throw MismatchedUnicodeCharException(la_1, c, false, this);
-		consume();
-	}
-
-	/** See if input contains element from bitset b
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void match(const antlr::BitSet& b)
-	{
-		char_type la_1 = LA(1);
-
-		if ( !b.member(la_1) )
-			throw MismatchedUnicodeCharException( la_1, b, false, this );
-		consume();
-	}
-
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match( const char* s )
-	{
-		while( *s != '\0' )
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (*s++ & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match(const std::string& s)
-	{
-		size_t len = s.length();
-
-		for (size_t i = 0; i < len; i++)
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (s[i] & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input does not contain character 'c'
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchNot(char_type c)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 == c )
-			throw MismatchedUnicodeCharException(la_1, c, true, this);
-
-		consume();
-	}
-	/** See if input contains character in range c1-c2
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchRange(char_type c1, char_type c2)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 < c1 || la_1 > c2 )
-			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
-
-		consume();
-	}
-
-	/// Get the line the scanner currently is in (starts at 1)
-	virtual int getLine() const
-	{
-		return inputState->line;
-	}
-
-	/// set the line number
-	virtual void setLine(int l)
-	{
-		inputState->line = l;
-	}
-
-	/// Get the column the scanner currently is in (starts at 1)
-	virtual int getColumn() const
-	{
-		return inputState->column;
-	}
-	/// set the column number
-	virtual void setColumn(int c)
-	{
-		inputState->column = c;
-	}
-
-	/// get the filename for the file currently used
-	virtual const std::string& getFilename() const
-	{
-		return inputState->filename;
-	}
-	/// Set the filename the scanner is using (used in error messages)
-	virtual void setFilename(const std::string& f)
-	{
-		inputState->filename = f;
-	}
-
-	virtual bool getCommitToPath() const
-	{
-		return commitToPath;
-	}
-
-	virtual void setCommitToPath(bool commit)
-	{
-		commitToPath = commit;
-	}
-
-	/** return a copy of the current text buffer */
-	virtual const std::string& getText() const
-	{
-		return text;
-	}
-
-	virtual void setText(const std::string& s)
-	{
-		text = s;
-	}
-
-	virtual void resetText()
-	{
-		text = "";
-		inputState->tokenStartColumn = inputState->column;
-		inputState->tokenStartLine = inputState->line;
-	}
-
-	virtual antlr::RefToken getTokenObject() const
-	{
-		return _returnToken;
-	}
-
-	///{ These need different handling in unicode case
-
-	virtual bool getCaseSensitiveLiterals() const=0;
-
-	virtual bool getCaseSensitive() const
-	{
-		return caseSensitive;
-	}
-
-	virtual void setCaseSensitive(bool t)
-	{
-		caseSensitive = t;
-	}
-
-	/** Override this method to get more specific case handling
-	 * @note some platforms probably require setting the right locale for
-	 * correct functioning.
-	 */
-	virtual char_type toLower(char_type c) const
-	{
-		return std::tolower(c);
-	}
-
-	/** Used to keep track of line breaks, needs to be called from
-	 * within generated lexers when a \n \r is encountered.
-	 */
-	virtual void newline()
-	{
-		++inputState->line;
-		inputState->column = 1;
-	}
-
-	/** Advance the current column number by an appropriate amount according
-	 * to the tabsize. This method needs to be explicitly called from the
-	 * lexer rules encountering tabs.
-	 */
-	virtual void tab()
-	{
-		int c = getColumn();
-		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
-		setColumn( nc );
-	}
-	/// set the tabsize. Returns the old tabsize
-	int setTabsize( int size )
-	{
-		int oldsize = tabsize;
-		tabsize = size;
-		return oldsize;
-	}
-	/// Return the tabsize used by the scanner
-	int getTabSize() const
-	{
-		return tabsize;
-	}
-	///}
-
-	/** Report exception errors caught in nextToken() */
-	virtual void reportError(const antlr::RecognitionException& ex)
-	{
-		std::cerr << ex.toString().c_str() << std::endl;
-	}
-
-	/** Parser error-reporting function can be overridden in subclass */
-	virtual void reportError(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "error: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
-	}
-
-	/** Parser warning-reporting function can be overridden in subclass */
-	virtual void reportWarning(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "warning: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
-	}
-
-	virtual antlr::InputBuffer& getInputBuffer()
-	{
-		return inputState->getInput();
-	}
-
-	virtual antlr::LexerSharedInputState getInputState()
-	{
-		return inputState;
-	}
-
-	/** set the input state for the lexer.
-	 * @note state is a reference counted object, hence no reference */
-	virtual void setInputState(antlr::LexerSharedInputState state)
-	{
-		inputState = state;
-	}
-
-	/// Set the factory for created tokens
-	virtual void setTokenObjectFactory(factory_type factory)
-	{
-		tokenFactory = factory;
-	}
-
-	/** Test the token text against the literals table
-	 * Override this method to perform a different literals test
-	 */
-	virtual int testLiteralsTable(int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** Test the text passed in against the literals table
-	 * Override this method to perform a different literals test
-	 * This is used primarily when you want to test a portion of
-	 * a token
-	 */
-	virtual int testLiteralsTable(const std::string& text, int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** This method is called by YourLexer::nextToken() when the lexer has
-	 *  hit EOF condition.  EOF is NOT a character.
-	 *  This method is not called if EOF is reached during
-	 *  syntactic predicate evaluation or during evaluation
-	 *  of normal lexical rules, which presumably would be
-	 *  an IOException.  This traps the "normal" EOF condition.
-	 *
-	 *  uponEOF() is called after the complete evaluation of
-	 *  the previous token and only if your parser asks
-	 *  for another token beyond that last non-EOF token.
-	 *
-	 *  You might want to throw token or char stream exceptions
-	 *  like: "Heh, premature eof" or a retry stream exception
-	 *  ("I found the end of this file, go back to referencing file").
-	 */
-	virtual void uponEOF()
-	{
-	}
-
-	/// Methods used to change tracing behavior
-	void traceIndent()
-	{
-		for( int i = 0; i < traceDepth; i++ )
-			std::cout << " ";
-	}
-
-	void traceIn(const char* rname)
-	{
-		traceDepth++;
-		traceIndent();
-		std::cout << "> lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-	}
-
-	void traceOut(const char* rname)
-	{
-		traceIndent();
-		std::cout << "< lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-		traceDepth--;
-	}
-
-#ifndef NO_STATIC_CONSTS
-	static const int EOF_CHAR = EOF;
-#else
-	enum {
-		EOF_CHAR = EOF
-	};
-#endif
-protected:
-	std::string text; ///< Text of current token
- 	/// flag indicating wether consume saves characters
-	bool saveConsumedInput;
-	factory_type tokenFactory;				///< Factory for tokens
-	bool caseSensitive; 						///< Is this lexer case sensitive
-	string_map literals;						 // set by subclass
-
-	antlr::RefToken _returnToken;		///< used to return tokens w/o using return val
-
-	/// Input state, gives access to input stream, shared among different lexers
-	antlr::LexerSharedInputState inputState;
-
-	/** Used during filter mode to indicate that path is desired.
-	 * A subsequent scan error will report an error as usual
-	 * if acceptPath=true;
-	 */
-	bool commitToPath;
-
-	unsigned int tabsize; 	///< tab size the scanner uses.
-
-	/// Create a new RefToken of type t
-	virtual antlr::RefToken makeToken(int t)
-	{
-		antlr::RefToken tok = tokenFactory();
-		// actually at this point you want to convert the stored lexeme text
-		// into the format you want to have it in in the backend...
-		tok->setType(t);
-		tok->setColumn(inputState->tokenStartColumn);
-		tok->setLine(inputState->tokenStartLine);
-		return tok;
-	}
-
-	/** Tracer class, used when -traceLexer is passed to antlr
-	 */
-	class Tracer {
-	private:
-		UnicodeCharScanner* parser;
-		const char* text;
-
-		Tracer(const Tracer& other); 					// undefined
-		Tracer& operator=(const Tracer& other); 	// undefined
-	public:
-		Tracer( UnicodeCharScanner* p, const char* t )
-		: parser(p), text(t)
-		{
-			parser->traceIn(text);
-		}
-		~Tracer()
-		{
-			parser->traceOut(text);
-		}
-	};
-
-	int traceDepth;
-private:
-	UnicodeCharScanner( const UnicodeCharScanner& other ); 		  		// undefined
-	UnicodeCharScanner& operator=( const UnicodeCharScanner& other );	// undefined
-};
-
-#endif //INC_UnicodeCharScanner_hpp__



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 16:08:43 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 16:08:43 +0100
Subject: [gpt-commit] r449 - in trunk/gpt2: gptasm gptasm/src gptc gptc/src
	gptvm gptvm/src
Message-ID: <200712191508.lBJF8hNn017348@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 16:08:42 +0100 (Wed, 19 Dec 2007)
New Revision: 449

Modified:
   trunk/gpt2/gptasm/configure.ac
   trunk/gpt2/gptasm/src/Makefile.am
   trunk/gpt2/gptc/Makefile.am
   trunk/gpt2/gptc/configure.ac
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptvm/configure.ac
   trunk/gpt2/gptvm/src/Makefile.am
Log:
-Adicionado --with-common aos scripts 'configure'

Modified: trunk/gpt2/gptasm/configure.ac
===================================================================
--- trunk/gpt2/gptasm/configure.ac	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptasm/configure.ac	2007-12-19 15:08:42 UTC (rev 449)
@@ -63,7 +63,7 @@
   AC_MSG_ERROR(
   [
     O programa "antlr" (ou runantlr) n?o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers?o >= 2.6) instalado.
+    GPT precisa do ANTLR (vers?o 2) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -73,7 +73,7 @@
   AC_MSG_ERROR(
   [
     O programa "antlr-config" n?o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers?o >= 2.6) instalado.
+    GPT precisa do ANTLR (vers?o 2) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -85,8 +85,21 @@
 AC_SUBST(ANTLR_INC)
 AC_SUBST(ANTLR_LIB)
 
+#------------------------------
+# Common lib
+#------------------------------
 
+AC_ARG_WITH(common,
+        AC_HELP_STRING([--with-common],[libgptcommon.la path]),
+[
+  COMMON_LIB=`pwd`/$withval
+],[
+  COMMON_LIB="../../common/src/libgptcommon.la"
+])
 
+AC_SUBST(COMMON_LIB)
+
+
 AC_CONFIG_FILES([Makefile
                  src/Makefile])
 AC_OUTPUT

Modified: trunk/gpt2/gptasm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptasm/src/Makefile.am	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptasm/src/Makefile.am	2007-12-19 15:08:42 UTC (rev 449)
@@ -1,12 +1,10 @@
 COMMON_IDIR = ../../../common/src
-COMMON_LDIR = ../../common/src
 
-
 INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
 
 bin_PROGRAMS = gptasm
 
-gptasm_LDADD = $(COMMON_LDIR)/libgptcommon.la $(ANTLR_LIB)
+gptasm_LDADD = $(COMMON_LIB) $(ANTLR_LIB)
 
 
 BUILT_SOURCES = GptAssemblyLexer.hpp \
@@ -15,7 +13,7 @@
                 GptAssemblyParser.cpp 
 
 gptasm_SOURCES = CData.cpp  CData.hpp  CGenBytecode.cpp  CGenBytecode.hpp  CGptAsm.cpp  \
-                  CGptAsm.hpp  main.cpp $(BUILT_SOURCES)
+                 CGptAsm.hpp  main.cpp $(BUILT_SOURCES)
 
 EXTRA_DIST = lexer.g parser.g
 

Modified: trunk/gpt2/gptc/Makefile.am
===================================================================
--- trunk/gpt2/gptc/Makefile.am	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptc/Makefile.am	2007-12-19 15:08:42 UTC (rev 449)
@@ -1 +1 @@
-SUBDIRS = src test
\ No newline at end of file
+SUBDIRS = src 
\ No newline at end of file

Modified: trunk/gpt2/gptc/configure.ac
===================================================================
--- trunk/gpt2/gptc/configure.ac	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptc/configure.ac	2007-12-19 15:08:42 UTC (rev 449)
@@ -63,8 +63,8 @@
 if test "x${ANTLR_BIN}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr" (ou runantlr) n??o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    O programa "antlr" (ou runantlr) n????o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers????o 2) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -73,8 +73,8 @@
 if test "x${ANTLR_CFG}" = "x"; then
   AC_MSG_ERROR(
   [
-    O programa "antlr-config" n??o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    O programa "antlr-config" n????o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers????o 2) instalado.
     Baixe em: http://www.antlr.org
   ])
 fi
@@ -86,7 +86,21 @@
 AC_SUBST(ANTLR_INC)
 AC_SUBST(ANTLR_LIB)
 
+#------------------------------
+# Common lib
+#------------------------------
 
+AC_ARG_WITH(common,
+        AC_HELP_STRING([--with-common],[libgptcommon.la path]),
+[
+  COMMON_LIB=`pwd`/$withval
+],[
+  COMMON_LIB="../../common/src/libgptcommon.la"
+])
+
+AC_SUBST(COMMON_LIB)
+
+
 AC_CONFIG_FILES([Makefile
                  src/Makefile
                  src/common/Makefile

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-19 15:08:42 UTC (rev 449)
@@ -1,7 +1,6 @@
 SUBDIRS = parser common semantic symboltable gptasm_target
 
 COMMON_IDIR = ../../../common/src
-COMMON_LDIR = ../../common/src
 
 INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/parser \
 	-I$(top_srcdir)/src/common -I$(top_srcdir)/src/semantic -I$(top_srcdir)/src/symboltable \
@@ -15,4 +14,4 @@
 gptc_LDADD = $(top_builddir)/src/symboltable/libsymboltable.la \
 	$(top_builddir)/src/common/libcommon.la $(top_builddir)/src/gptasm_target/libgptasm.la \
 	$(top_builddir)/src/semantic/libsemantic.la $(top_builddir)/src/parser/libparser.la \
-  $(COMMON_LDIR)/libgptcommon.la $(ANTLR_LIB)
+  $(COMMON_LIB) $(ANTLR_LIB)

Modified: trunk/gpt2/gptvm/configure.ac
===================================================================
--- trunk/gpt2/gptvm/configure.ac	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptvm/configure.ac	2007-12-19 15:08:42 UTC (rev 449)
@@ -49,7 +49,22 @@
   CXXFLAGS="-DDEBUG $CXXFLAGS"
 fi
 
+#------------------------------
+# Common lib
+#------------------------------
 
+AC_ARG_WITH(common,
+        AC_HELP_STRING([--with-common],[libgptcommon.la path]),
+[
+  COMMON_LIB=`pwd`/$withval
+],[
+  COMMON_LIB="../../common/src/libgptcommon.la"
+])
+
+AC_SUBST(COMMON_LIB)
+
+
+
 AC_CONFIG_FILES([Makefile
                  src/Makefile])
 AC_OUTPUT

Modified: trunk/gpt2/gptvm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 15:07:36 UTC (rev 448)
+++ trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 15:08:42 UTC (rev 449)
@@ -1,5 +1,4 @@
 COMMON_IDIR = ../../../common/src
-COMMON_LDIR = ../../common/src
 
 INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
 
@@ -8,4 +7,4 @@
 gptvm_SOURCES = CBytecode.cpp  CDataStack.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
 						  CBytecode.hpp  CDataStack.hpp  CGptVm.hpp  CRunBytecode.hpp  
 
-gptvm_LDADD = $(COMMON_LDIR)/libgptcommon.la -ldl
\ No newline at end of file
+gptvm_LDADD = $(COMMON_LIB) -ldl
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 16:07:36 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 16:07:36 +0100
Subject: [gpt-commit] r448 - trunk/gpt2/common/src
Message-ID: <200712191507.lBJF7aAW017247@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 16:07:36 +0100 (Wed, 19 Dec 2007)
New Revision: 448

Modified:
   trunk/gpt2/common/src/Tools.cpp
Log:
nomsg

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-19 13:49:26 UTC (rev 447)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-19 15:07:36 UTC (rev 448)
@@ -375,4 +375,4 @@
     text += ( ((c >> 6) & 0x3F) | 0x80 );
     text += ( (c & 0x3F) | 0x80 );
   }  
-}
\ No newline at end of file
+}



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 17:15:33 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 17:15:33 +0100
Subject: [gpt-commit] r450 - trunk/gpt2/gptasm/src
Message-ID: <200712191615.lBJGFXmk022125@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 17:15:32 +0100 (Wed, 19 Dec 2007)
New Revision: 450

Modified:
   trunk/gpt2/gptasm/src/lexer.g
Log:
-Faltou inicializar a tabela de keywords

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-12-19 15:08:42 UTC (rev 449)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-12-19 16:15:32 UTC (rev 450)
@@ -185,6 +185,7 @@
 public:  
    GptAssemblyLexer(std::istream& in)
     : UnicodeCharScanner(new UnicodeCharBuffer(in), true) {
+      initLiterals();
    }
 }
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 19:29:02 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 19:29:02 +0100
Subject: [gpt-commit] r451 - in trunk/gpt2: bindings/gptbind/src
	bindings/gptbind/test common/src gptasm gptasm/test/wikki gptvm/src
Message-ID: <200712191829.lBJIT21K015560@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-19 19:29:01 +0100 (Wed, 19 Dec 2007)
New Revision: 451

Added:
   trunk/gpt2/bindings/gptbind/test/math.sld
   trunk/gpt2/bindings/gptbind/test/messages.sld
   trunk/gpt2/common/src/CDataStack.cpp
   trunk/gpt2/common/src/CDataStack.hpp
Removed:
   trunk/gpt2/bindings/gptbind/test/test.sld
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
Modified:
   trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
   trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
   trunk/gpt2/bindings/gptbind/src/parser.g
   trunk/gpt2/gptasm/configure.ac
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
Log:
DEVNULL:
* Primeira versao funcional do gerador de bindings
  - A partir de um .sld gera o .cpp, .hpp e Makefile
  - Compilando o Makefile gera o .so que pode ser utilizado na VM
* Movendo a classe CDataStack para o diretorio common


Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-19 18:29:01 UTC (rev 451)
@@ -21,14 +21,21 @@
    }
    hppSource.writeln();
 
+   hppSource.writeln( "#include \"CDataStack.hpp\"" );
+   hppSource.writeln();
+
    hppSource.writeln( "extern \"C\" {" );
    hppSource.incTab();
 
    cppSource.writeln( "#include \"" + _filename + ".hpp\"" );
    cppSource.writeln();
-   cppSource.writeln( "#include \"CDataStack.hpp\"" );
    cppSource.writeln( "#include \"CSymbol.hpp\"" );
    cppSource.writeln();
+
+   makefileSource.writeln("COMMON_DIR=../../../common/src/");
+   makefileSource.writeln("INCLUDE_DIR=-I$(COMMON_DIR)");// -I../../../gptvm/src/");
+   makefileSource.writeln("CC=g++");
+   makefileSource.writeln("CCFLAGS=-g -Wall");
 }
 
 
@@ -112,6 +119,34 @@
    hppSource.writeln("}");
    hppSource.writeln();
    hppSource.writeln( "#endif" );
+
+   makefileSource.write("LIBS=");
+
+   for(std::list<std::string>::iterator lib = _linkerLibList.begin(); lib != _linkerLibList.end(); lib++) {
+      std::string slib = (*lib).substr(1, (*lib).length()-2);
+      makefileSource.write("-l" + slib + " ");
+   }
+   makefileSource.writeln();
+   makefileSource.writeln();
+
+   makefileSource.writeln("objects = " + _filename + ".o $(COMMON_DIR)/CDataStack.o $(COMMON_DIR)/CBinString.o $(COMMON_DIR)/Tools.o");
+   makefileSource.writeln();
+
+   makefileSource.writeln("all: $(objects)");
+   makefileSource.writeln("\tg++ -shared $(objects) $(LIBS) -o lib" + _filename + ".so");
+   makefileSource.writeln();
+
+   makefileSource.writeln("%.o: %.cpp %.hpp");
+   makefileSource.writeln("\t$(CC) -shared $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@");
+   makefileSource.writeln();
+
+   makefileSource.writeln("%.o: %.cpp");
+   makefileSource.writeln("\t$(CC) -shared $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@");
+   makefileSource.writeln();
+
+   makefileSource.writeln("clean:");
+   makefileSource.writeln("\trm -f *.o lib" + _filename + ".so");
+   makefileSource.writeln();
 }
 
 

Modified: trunk/gpt2/bindings/gptbind/src/CGptBind.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/src/CGptBind.cpp	2007-12-19 18:29:01 UTC (rev 451)
@@ -40,6 +40,14 @@
 
    hppFile << hppOutput;
 
+   ofstream makefileFile(("Makefile." + _options->destfile).c_str(), ios_base::out);
+   if (!makefileFile) {
+      cout << "ERRO: n?o foi poss?vel abrir o arquivo: \"" << _options->destfile << "\"" << endl;
+      return false;
+   }
+
+   makefileFile << makefileOutput;
+
    return true;
 }
 

Modified: trunk/gpt2/bindings/gptbind/src/parser.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-19 18:29:01 UTC (rev 451)
@@ -86,19 +86,19 @@
 //-------
   optionsdef
 //-------
-   : "options" T_ABREC (optiondef)+ T_FECHAC
+   : "options" T_ABREC (optiondef)* T_FECHAC
    ;
 
 //------
   optiondef
 //------
-   : optionname T_EQUAL T_STRING_VALUE T_SEMICOLON
+   : linkerlibOption T_SEMICOLON
    ;
 
 ///----------
-   optionname
+   linkerlibOption
 ///----------
-   : "linkerlib" { sources->addLinkerLib(getLastTokenText()); }
+   : "linkerlib" T_EQUAL T_STRING_VALUE { sources->addLinkerLib(getLastTokenText()); }
    ;
 
 //#############

Added: trunk/gpt2/bindings/gptbind/test/math.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/math.sld	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/test/math.sld	2007-12-19 18:29:01 UTC (rev 451)
@@ -0,0 +1,13 @@
+options {
+}
+
+headers {
+   "math.h";
+}
+
+function sqrt(real value) : real ::= sqrt(value);
+
+function exponencial(real valor) : real ::= exp(valor);
+
+function pow(real value1, real value2) : real ::= pow(value1, value2);
+

Added: trunk/gpt2/bindings/gptbind/test/messages.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/messages.sld	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/test/messages.sld	2007-12-19 18:29:01 UTC (rev 451)
@@ -0,0 +1,12 @@
+options {
+//   linkerlib = "math";
+}
+
+headers {
+   "stdlib.h";
+   "iostream";
+}
+
+procedure mensagem_padrao() ::= puts("Hello !!!");
+
+procedure imprime_mensagem(string msg) ::= puts(msg);

Deleted: trunk/gpt2/bindings/gptbind/test/test.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/bindings/gptbind/test/test.sld	2007-12-19 18:29:01 UTC (rev 451)
@@ -1,17 +0,0 @@
-options {
-   linkerlib = "math";
-}
-
-headers {
-   "stdlib.h";
-   "math.h";
-   "iostream";
-}
-
-procedure mensagem_padrao() ::= puts("Hello !!!");
-
-procedure mensagem_personalizada(string msg) ::= puts(msg);
-
-function sqrt(real value) : real ::= sqrt(value);
-
-function exponencial(real valor) : real ::= exp(valor);

Copied: trunk/gpt2/common/src/CDataStack.cpp (from rev 433, trunk/gpt2/gptvm/src/CDataStack.cpp)

Copied: trunk/gpt2/common/src/CDataStack.hpp (from rev 433, trunk/gpt2/gptvm/src/CDataStack.hpp)

Modified: trunk/gpt2/gptasm/configure.ac
===================================================================
--- trunk/gpt2/gptasm/configure.ac	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptasm/configure.ac	2007-12-19 18:29:01 UTC (rev 451)
@@ -94,7 +94,7 @@
 [
   COMMON_LIB=`pwd`/$withval
 ],[
-  COMMON_LIB="../../common/src/libgptcommon.la"
+  COMMON_LIB="../../common/_build/src/libgptcommon.la"
 ])
 
 AC_SUBST(COMMON_LIB)

Modified: trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_1.gasm	2007-12-19 18:29:01 UTC (rev 451)
@@ -2,12 +2,12 @@
 // use io
 
 proc main
-    lcall io, imprime_hello
+    lcall messages, mensagem_padrao
 
-    lcall io, imprime_hello
+    lcall messages, mensagem_padrao
 
     pushsv "Oi !!!!"
-    lcall io, imprime_mensagem
+    lcall messages, imprime_mensagem
 
     exit 0
 endproc

Deleted: trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_2.gasm	2007-12-19 18:29:01 UTC (rev 451)
@@ -1,20 +0,0 @@
-program exemplo
-// use io
-
-var t1 int
-
-proc main
-    pushiv 2
-    pushiv 4
-    lcall io, soma
-    popiv t1
-
-    pushiv t1
-    pushit
-    push_1
-    lcall io, imprima
-
-    exit 0
-endproc
-
-endprogram

Modified: trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_3.gasm	2007-12-19 18:29:01 UTC (rev 451)
@@ -6,7 +6,7 @@
 proc main
     pushrv 3
     pushrv 9
-    lcall io, pow
+    lcall math, pow
     poprv t1
 
     pushrv t1

Modified: trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_4.gasm	2007-12-19 18:29:01 UTC (rev 451)
@@ -5,7 +5,7 @@
 
 proc main
     pushrv 9
-    lcall io, sqrt
+    lcall math, sqrt
     poprv t1
 
     pushrv t1

Deleted: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-12-19 18:29:01 UTC (rev 451)
@@ -1,313 +0,0 @@
-#include "CDataStack.hpp"
-
-#include "Common.hpp"
-
-#include "Tools.hpp"
-#include "CSymbol.hpp"
-
-
-
-#include <iostream>
-
-
-CDataStack::CDataStack()
-   : _BS(0)
-   , _SP(0)
-{
-}
-
-
-CDataStack::~CDataStack()
-{
-}
-
-void CDataStack::setInt(const int &address, const int &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      CBinString::setInt(_BS + realAddress(address), value);
-   } else {
-      CBinString::setInt(realAddress(address), value);
-   }
-//   CBinString::setInt(_BS * IS_LOCAL_ADDRESS(address) + realAddress(address), value);
-}
-
-
-
-int CDataStack::getInt(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return CBinString::getInt(_BS + realAddress(address));
-   } else {
-      return CBinString::getInt(realAddress(address));
-   }
-//   return CBinString::getInt(_BS * IS_LOCAL_ADDRESS(address) + realAddress(address));
-}
-
-
-//void CDataStack::setInt(const int &address, const int &value)
-//{
-////   std::cout << "setInt ";
-//   if (IS_LOCAL_ADDRESS(address)) {
-////      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
-//      CBinString::setInt(_BS + realAddress(address), value);
-//   } else {
-//      std::cout << "ERRO !!! Invocando setInt com global address: " << address << std::endl;
-//   }
-//}
-
-
-
-//int CDataStack::getInt(const int &address)
-//{
-////   std::cout << "getInt ";
-//   if (IS_LOCAL_ADDRESS(address)) {
-////      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
-//      return CBinString::getInt(_BS + realAddress(address));
-//   } else {
-//      std::cout << "ERRO !!! Invocando getInt com global address: " << address << std::endl;
-//      return -1;
-//   }
-//}
-
-
-void CDataStack::pushInt(const int &value)
-{
-   CBinString::pushInt(value);
-   _SP+=sizeof(int);
-}
-
-
-int CDataStack::popInt()
-{
-   int result = CBinString::popInt();
-   _SP-=sizeof(int);
-   return result;
-}
-
-
-void CDataStack::pushByte(const char &value)
-{
-   CBinString::pushByte(value);
-   _SP+=sizeof(char);
-}
-
-
-char CDataStack::popByte()
-{
-   char result = CBinString::popByte();
-   _SP-=sizeof(char);
-   return result;
-}
-
-
-void CDataStack::setReal(const int &address, const double &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      CBinString::setReal(_BS + realAddress(address), value);
-   } else {
-      CBinString::setReal(realAddress(address), value);
-   }
-}
-
-
-double CDataStack::getReal(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return CBinString::getReal(_BS + realAddress(address));
-   } else {
-      return CBinString::getReal(realAddress(address));
-   }
-}
-
-
-void CDataStack::pushReal(const double &value)
-{
-   CBinString::pushReal(value);
-   _SP+=sizeof(double);
-}
-
-
-double CDataStack::popReal()
-{
-   double result = CBinString::popReal();
-   _SP-=sizeof(double);
-   return result;
-}
-
-
-void CDataStack::setBytes(const int &address, const std::string &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      CBinString::setBytes(_BS + realAddress(address), value);
-   } else {
-      CBinString::setBytes(realAddress(address), value);
-   }
-}
-
-
-void CDataStack::pushBytes(const std::string &value)
-{
-   CBinString::pushBytes(value);
-   _SP+=value.size();
-}
-
-
-std::string CDataStack::popBytes(const int &size)
-{
-   std::string result = CBinString::popBytes(size);
-   _SP-=size;
-   return result;
-}
-
-
-std::string CDataStack::getBytes(const int &address, const int &size)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return CBinString::getBytes(_BS + realAddress(address), size);
-   } else {
-      return CBinString::getBytes(realAddress(address), size);
-   }
-}
-
-
-void CDataStack::setString(int address, const std::string &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      address = _BS + realAddress(address);
-   } else {
-      address = realAddress(address);
-   }
-
-   char type = getByte(address);
-   address++;
-
-   if (type == CSymbol::CONST) {
-      CBinString::setCString(address, value);
-   } else {
-      *((std::string*)(CBinString::getInt(address))) = value;
-   }
-}
-
-
-std::string CDataStack::getString(int address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      address = _BS + realAddress(address);
-   } else {
-      address = realAddress(address);
-   }
-
-   char type = CBinString::getByte(address);
-   address++;
-
-   if (type == CSymbol::CONST) {
-      return CBinString::getCString(address);
-//      return CBinString::getCString(CBinString::getInt(address)+1);
-   } else {
-      return *((std::string*)CBinString::getInt(address));
-   }
-}
-
-
-std::string CDataStack::popString()
-{
-   int dataSize = sizeof(char)+sizeof(std::string*);
-   std::string result = getString(size()-dataSize);
-   CBinString::popBytes(dataSize);
-   return result;
-}
-
-void CDataStack::pushBytes(const int &number)
-{
-   CBinString::pushBytes(number);
-   _SP += number;
-}
-
-
-void CDataStack::discardBytes(const int &number)
-{
-   CBinString::popBytes(number);
-   _SP -= number;
-}
-
-
-void CDataStack::setBS(const int &value)
-{
-   _BS = value;
-}
-
-
-void CDataStack::setSP(const int &value)
-{
-   CBinString::resize(value);
-   _SP = value;
-}
-
-
-void CDataStack::decSP(const int &value)
-{
-   CBinString::popBytes(value);
-   _SP -= value;
-}
-
-
-int CDataStack::getBS() const
-{
-   return _BS;
-}
-
-
-int CDataStack::getSP() const
-{
-   return _SP;
-}
-
-void CDataStack::readString(std::string &value)
-{
-   CBinString::readString(value);
-   setBS(size());
-}
-
-
-void CDataStack::setByte(const int &address, const char &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      CBinString::setByte(_BS + realAddress(address), value);
-   } else {
-      CBinString::setByte(realAddress(address), value);
-   }
-}
-
-
-char CDataStack::getByte(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return CBinString::getByte(_BS + realAddress(address));
-   } else {
-      return CBinString::getByte(realAddress(address));
-   }
-}
-
-
-void *CDataStack::getPointer(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return (void*)(data() + _BS + realAddress(address));
-   } else {
-      return (void*)(data() + realAddress(address));
-   }
-}
-
-
-void CDataStack::pushBytes(const void* data, const int &size)
-{
-   const char* bytes = (const char*) data;
-   for(int i=0; i<size; i++) {
-      CBinString::pushByte(*bytes);
-      bytes++;
-   }
-
-   _SP+=size;
-}
-
-

Deleted: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-12-19 18:29:01 UTC (rev 451)
@@ -1,48 +0,0 @@
-#ifndef GPT_DATA_STACK_H
-#define GPT_DATA_STACK_H
-
-
-#include "CBinString.hpp"
-
-
-class CDataStack : public CBinString
-{
-public:
-   CDataStack();
-   ~CDataStack();
-   void setInt(const int &address, const int &value);
-   int getInt(const int &address);
-   void pushInt(const int &value);
-   int popInt();
-   void setReal(const int &address, const double &value);
-   double getReal(const int &address);
-   void pushReal(const double &value);
-   double popReal();
-   void setBytes(const int &address, const std::string &value);
-   std::string getBytes(const int &address, const int &size);
-   void pushBytes(const std::string &value);
-   std::string popBytes(const int &size);
-   void pushBytes(const int &number);
-   void discardBytes(const int &number);
-   void setBS(const int &value);
-   void setSP(const int &value);
-   void decSP(const int &value);
-   int getBS() const;
-   int getSP() const;
-   void readString(std::string &value);
-   std::string getString(int address);
-   std::string popString();
-   void setString(int address, const std::string &value);
-   void setByte(const int &address, const char &value);
-   char getByte(const int &address);
-   void pushByte(const char &value);
-   char popByte();
-   void *getPointer(const int &address);
-   void pushBytes(const void* data, const int &size);
-private:
-   int _BS;
-   int _SP; // TODO: SP eh equivalente a size() ???
-};
-
-#endif
-

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-19 16:15:32 UTC (rev 450)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-19 18:29:01 UTC (rev 451)
@@ -396,7 +396,7 @@
 
    if (ithandler == syslibHandlerList.end()) {
       // TODO: path absoluto ??? nem pensar :-)
-      dlhandler = dlopen(("../../../syslib/src/lib" + libname + ".so").c_str(), RTLD_LAZY);
+      dlhandler = dlopen(("../../../bindings/gptbind/test/lib" + libname + ".so").c_str(), RTLD_LAZY);
       if (!dlhandler) {
          fprintf (stderr, "%s\n", dlerror());
          exit(1);
@@ -475,9 +475,10 @@
       } else if (procname == "leia") {
          procLeia();
       } else {
-//         error("lcall invocando subrotina desconhecida !!!");
-         callSyslib(libname, procname);
+         error("lcall invocando subrotina desconhecida !!!");
       }
+   } else {
+      callSyslib(libname, procname);
    }
 
    _dataStack.setBS(_executionStack.top());



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 19:54:06 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 19:54:06 +0100
Subject: [gpt-commit] r452 - trunk/gpt2/gptasm
Message-ID: <200712191854.lBJIs6lv016822@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 19:54:06 +0100 (Wed, 19 Dec 2007)
New Revision: 452

Modified:
   trunk/gpt2/gptasm/configure.ac
Log:
-Correcao do caminho COMMON_LIB

Modified: trunk/gpt2/gptasm/configure.ac
===================================================================
--- trunk/gpt2/gptasm/configure.ac	2007-12-19 18:29:01 UTC (rev 451)
+++ trunk/gpt2/gptasm/configure.ac	2007-12-19 18:54:06 UTC (rev 452)
@@ -94,7 +94,7 @@
 [
   COMMON_LIB=`pwd`/$withval
 ],[
-  COMMON_LIB="../../common/_build/src/libgptcommon.la"
+  COMMON_LIB="../../common/src/libgptcommon.la"
 ])
 
 AC_SUBST(COMMON_LIB)



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 20:00:42 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 20:00:42 +0100
Subject: [gpt-commit] r453 - in trunk/gpt2: common/src gptvm/src
Message-ID: <200712191900.lBJJ0gJJ017348@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 20:00:42 +0100 (Wed, 19 Dec 2007)
New Revision: 453

Modified:
   trunk/gpt2/common/src/Makefile.am
   trunk/gpt2/gptvm/src/Makefile.am
Log:
nomsg

Modified: trunk/gpt2/common/src/Makefile.am
===================================================================
--- trunk/gpt2/common/src/Makefile.am	2007-12-19 18:54:06 UTC (rev 452)
+++ trunk/gpt2/common/src/Makefile.am	2007-12-19 19:00:42 UTC (rev 453)
@@ -8,4 +8,5 @@
                           CSymbolTable.cpp  Common.hpp  Tools.cpp \
                           MismatchedUnicodeCharException.hpp \
                           MismatchedUnicodeCharException.cpp \
-                          UnicodeCharBuffer.hpp UnicodeCharScanner.hpp
+                          UnicodeCharBuffer.hpp UnicodeCharScanner.hpp \
+                          CDataStack.hpp CDataStack.cpp

Modified: trunk/gpt2/gptvm/src/Makefile.am
===================================================================
--- trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 18:54:06 UTC (rev 452)
+++ trunk/gpt2/gptvm/src/Makefile.am	2007-12-19 19:00:42 UTC (rev 453)
@@ -1,10 +1,10 @@
 COMMON_IDIR = ../../../common/src
 
-INCLUDES = -I$(top_srcdir)/.  -I$(COMMON_IDIR)
+INCLUDES = -I$(top_srcdir)/. -I$(COMMON_IDIR)
 
 bin_PROGRAMS = gptvm
 
-gptvm_SOURCES = CBytecode.cpp  CDataStack.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
-						  CBytecode.hpp  CDataStack.hpp  CGptVm.hpp  CRunBytecode.hpp  
+gptvm_SOURCES = CBytecode.cpp  CGptVm.cpp  CRunBytecode.cpp  main.cpp \
+						    CBytecode.hpp  CGptVm.hpp  CRunBytecode.hpp  
 
-gptvm_LDADD = $(COMMON_LIB) -ldl
\ No newline at end of file
+gptvm_LDADD = $(COMMON_LIB) -ldl



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 21:07:56 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 21:07:56 +0100
Subject: [gpt-commit] r454 - in trunk/gpt2/gptc/src: gptasm_target semantic
Message-ID: <200712192007.lBJK7uJ1020121@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-19 21:07:56 +0100 (Wed, 19 Dec 2007)
New Revision: 454

Modified:
   trunk/gpt2/gptc/src/gptasm_target/gptasm.g
   trunk/gpt2/gptc/src/semantic/semantic.g
Log:
DEVNULL:
* Retirado erros de compilacao gerados so no gcc 4


Modified: trunk/gpt2/gptc/src/gptasm_target/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/gptasm.g	2007-12-19 19:00:42 UTC (rev 453)
+++ trunk/gpt2/gptc/src/gptasm_target/gptasm.g	2007-12-19 20:07:56 UTC (rev 454)
@@ -40,7 +40,7 @@
 
 {
 public:
-  GptAsmWalker::GptAsmWalker(SymbolTable* symtable,
+  GptAsmWalker(SymbolTable* symtable,
                              const std::string& filepath)
 	 : BaseGptAsmWalker(symtable, filepath) {}
 }

Modified: trunk/gpt2/gptc/src/semantic/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic/semantic.g	2007-12-19 19:00:42 UTC (rev 453)
+++ trunk/gpt2/gptc/src/semantic/semantic.g	2007-12-19 20:07:56 UTC (rev 454)
@@ -39,7 +39,7 @@
 
 {
 public:
-  SemanticWalker::SemanticWalker(SymbolTable* symtable,
+  SemanticWalker(SymbolTable* symtable,
                                  const std::string& filepath)
 	 : BaseSemanticWalker(symtable, filepath),
     _analisingInitializationList(false) { }



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 22:09:42 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 22:09:42 +0100
Subject: [gpt-commit] r455 - in trunk/gpt2: common/src gptasm/test
	gptvm/test gptvm/test/gerados_pelo_gptasm
Message-ID: <200712192109.lBJL9gio022508@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-19 22:09:41 +0100 (Wed, 19 Dec 2007)
New Revision: 455

Added:
   trunk/gpt2/common/src/CTextFile.cpp
   trunk/gpt2/common/src/CTextFile.hpp
Modified:
   trunk/gpt2/gptasm/test/asm.sh
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/run.sh
Log:
DEVNULL:
* Ajustes final apos o merge


Added: trunk/gpt2/common/src/CTextFile.cpp
===================================================================
--- trunk/gpt2/common/src/CTextFile.cpp	2007-12-19 20:07:56 UTC (rev 454)
+++ trunk/gpt2/common/src/CTextFile.cpp	2007-12-19 21:09:41 UTC (rev 455)
@@ -0,0 +1,71 @@
+#include "CTextFile.hpp"
+
+
+CTextFile::CTextFile( const string &chrTab )
+	: _chrTab( chrTab ), _emitTab( true )
+{
+}
+
+
+CTextFile::~CTextFile( )
+{
+}
+
+
+void CTextFile::writeln( const string &message )
+{
+	if ( _emitTab ) {
+		_txt << _tabs;
+	}
+	_txt << message << endl;
+	_emitTab = true;
+}
+
+
+void CTextFile::writeln( )
+{
+	_txt << endl;
+	_emitTab = true;
+}
+
+
+void CTextFile::write( const string &message )
+{
+	if ( _emitTab ) {
+		_txt << _tabs;
+	}
+	_txt << message;
+	_emitTab = false;
+}
+
+
+void CTextFile::incTab( )
+{
+    _tabs += _chrTab;
+}
+
+
+void CTextFile::decTab( )
+{
+    _tabs.erase( _tabs.length( ) - _chrTab.length( ), _chrTab.length( ) );
+}
+
+
+string CTextFile::getText( ) const
+{
+	return _txt.str( );
+}
+
+
+bool CTextFile::writeToFile( const string &filename )
+{
+	ofstream *_file;
+	_file = new ofstream( filename.c_str( ) );
+	if (_file) {
+		(*_file) << _txt;
+		delete _file;
+		return true;
+	}
+	return false;
+}
+


Property changes on: trunk/gpt2/common/src/CTextFile.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/common/src/CTextFile.hpp
===================================================================
--- trunk/gpt2/common/src/CTextFile.hpp	2007-12-19 20:07:56 UTC (rev 454)
+++ trunk/gpt2/common/src/CTextFile.hpp	2007-12-19 21:09:41 UTC (rev 455)
@@ -0,0 +1,30 @@
+#ifndef GPT_CTEXT_FILE_H
+#define GPT_CTEXT_FILE_H
+
+#include <string>
+#include <fstream>
+#include <sstream>
+
+using namespace std;
+
+class CTextFile
+{
+public:
+	CTextFile( const string &chrTab = "\t" );
+	~CTextFile( );
+	void writeln( const string &message );
+	void writeln( );
+	void write( const string &message );
+	void incTab( );
+	void decTab( );
+	string getText( ) const;
+	bool writeToFile( const string &filename );
+private:
+	string _chrTab;
+	string _tabs;
+	bool _emitTab;
+	stringstream _txt;
+};
+
+#endif
+


Property changes on: trunk/gpt2/common/src/CTextFile.hpp
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/gpt2/gptasm/test/asm.sh
===================================================================
--- trunk/gpt2/gptasm/test/asm.sh	2007-12-19 20:07:56 UTC (rev 454)
+++ trunk/gpt2/gptasm/test/asm.sh	2007-12-19 21:09:41 UTC (rev 455)
@@ -1,7 +1,7 @@
 rm $1.gvm 1>/dev/null 2>&1
 #rm $1.stdout 1>/dev/null 2>&1
 
-../../src/gptasm $1
+../../../_build/gptasm/src/gptasm $1
 if [ $? -ne 0 ]
 then
 	echo "Erro: nao foi possivel assemblar $1.gasm"

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/run.sh
===================================================================
--- trunk/gpt2/gptvm/test/run.sh	2007-12-19 20:07:56 UTC (rev 454)
+++ trunk/gpt2/gptvm/test/run.sh	2007-12-19 21:09:41 UTC (rev 455)
@@ -1,6 +1,6 @@
 rm $1.stdout 1>/dev/null 2>&1
 
-../../src/gptvm $1 > $1.stdout
+../../../_build/gptvm/src/gptvm $1 > $1.stdout
 if [ $? -ne 0 ]
 then
 	echo "Erro: nao foi possivel executar $1.gvm"



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:16:02 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:16:02 +0100
Subject: [gpt-commit] r456 - trunk/gpt2/gptc/src/symboltable
Message-ID: <200712192216.lBJMG225026293@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:16:01 +0100 (Wed, 19 Dec 2007)
New Revision: 456

Modified:
   trunk/gpt2/gptc/src/symboltable/Types.cpp
   trunk/gpt2/gptc/src/symboltable/Types.hpp
Log:
-Adicionado flag para o tipo 'reticencias'
-Melhorado retorno de name()

Modified: trunk/gpt2/gptc/src/symboltable/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Types.cpp	2007-12-19 21:09:41 UTC (rev 455)
+++ trunk/gpt2/gptc/src/symboltable/Types.cpp	2007-12-19 22:16:01 UTC (rev 456)
@@ -23,6 +23,14 @@
   return _isRef;
 }
 
+void Type::setReticences(bool c) {
+  _isReticences = c;
+}
+
+bool Type::isReticences() const {
+  return _isReticences;
+}
+
 bool Type::isError() const {
   if (_typeId == ERROR) {
     return true;
@@ -59,10 +67,23 @@
   return _typeId == SUBPROGRAM;
 }
 
-const std::string& Type::name() const {
-  return _name;
+void Type::setName(const std::string& name) {
+  _name = name;
 }
 
+std::string Type::name() const {
+  std::stringstream ret;
+  if (isRef()) {
+    ret << "ref ";
+  }
+
+  if (isConst()) {
+    ret << "constante ";
+  }
+  ret << _name;
+  return ret.str();
+}
+
 std::string Type::asmName(bool complete) const {
   std::stringstream stream;
 
@@ -386,13 +407,13 @@
     _name(name), _identifier(name), _anonymous(false), _fields(fields),
     _unit(unit), _line(line) {
 
-  _name = _name + ":{";
-  std::string v = "";
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
-    v = ",";
-  }
-  _name += "}";
+//   _name = _name + ":{";
+//   std::string v = "";
+//   for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
+//     _name += v + (*it).lexeme() + ":" + (*it).type()->name();
+//     v = ",";
+//   }
+//   _name += "}";
 }
 
 
@@ -402,13 +423,13 @@
     _anonymous(true), _fields(fields),
     _unit("<interno>"), _line(-1) {
 
-  _name += ":{";
-  std::string v = "";
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + ":" + (*it).type()->name();
-    v = ",";
-  }
-  _name += "}";
+//   _name += ":{";
+//   std::string v = "";
+//   for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
+//     _name += v + (*it).lexeme() + ":" + (*it).type()->name();
+//     v = ",";
+//   }
+//   _name += "}";
 }
 
 const SymbolList& Type::fields() const {
@@ -501,19 +522,12 @@
   : _typeId(SUBPROGRAM), _builder(builder), _isConst(false), _isRef(false),
     _paramTypes(paramTypes), _returnType(returnType) {
 
-  if (!_returnType) {
-    _name = "proc(";
-  } else {
-    _name = "func(";
-  }
+  _name = "(" + _paramTypes.toString() + ")";
 
-  _name += _paramTypes.toString();
-  _name += ")";
-
   _identifier = _paramTypes.toIdentifier();
 
-  if (_returnType) {
-    _name       += " : " + _returnType->name();
+  if (_returnType && _returnType->name() != g_tokenLabels[PortugolTokenTypes::T_NULO]) {
+    _name += " : " + _returnType->name();
   }
 }
 
@@ -704,8 +718,12 @@
   fields.push_back(Symbol("valor",
     primitiveType(PortugolTokenTypes::T_CORINGA)));
 
-  return matrixType(
-    structType("Par?metro", fields, "<interno>",-1), std::list<int>(1));
+  Type *ret = matrixType(
+      structType("Par?metro", fields, "<interno>",-1), std::list<int>(1));
+
+  ret->setName("...");
+  ret->setReticences(true);
+  return ret;
 }
 
 Type*

Modified: trunk/gpt2/gptc/src/symboltable/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Types.hpp	2007-12-19 21:09:41 UTC (rev 455)
+++ trunk/gpt2/gptc/src/symboltable/Types.hpp	2007-12-19 22:16:01 UTC (rev 456)
@@ -80,13 +80,17 @@
   bool isConst() const;
   bool isRef()   const;
 
+  void setReticences(bool);
+  bool isReticences() const;
+
   bool isError() const;
   bool isPrimitive() const;
   bool isMatrix() const;
   bool isStruct() const;
   bool isSubprogram() const;
 
-  const std::string& name() const;
+  void setName(const std::string&);
+  std::string name() const;
   std::string asmName(bool = false) const;
   const std::string& identifier() const;
 
@@ -127,6 +131,7 @@
 
   bool         _isConst;
   bool         _isRef;
+  bool         _isReticences;
 
   std::string  _name;
   std::string  _identifier;



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:16:38 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:16:38 +0100
Subject: [gpt-commit] r457 - trunk/gpt2/gptc/src/symboltable
Message-ID: <200712192216.lBJMGchx026356@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:16:38 +0100 (Wed, 19 Dec 2007)
New Revision: 457

Modified:
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp
Log:
-Adicionado AmbiguousDeclarationException

Modified: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp	2007-12-19 22:16:01 UTC (rev 456)
+++ trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp	2007-12-19 22:16:38 UTC (rev 457)
@@ -61,3 +61,18 @@
 const std::string& UnmatchedException::lexeme() {
   return _lexeme;
 }
+
+//--------------------------------------------------------
+
+
+AmbiguousDeclarationException::AmbiguousDeclarationException(const Symbol& s, const Symbol& o)
+  : _symbol(s), _otherSymbol(o) {
+}
+
+const Symbol& AmbiguousDeclarationException::symbol() const {
+  return _symbol;
+}
+
+const Symbol& AmbiguousDeclarationException::otherSymbol() const {
+  return _otherSymbol;
+}

Modified: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp	2007-12-19 22:16:01 UTC (rev 456)
+++ trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp	2007-12-19 22:16:38 UTC (rev 457)
@@ -56,4 +56,15 @@
   std::string _lexeme;
 };
 
+class AmbiguousDeclarationException {
+public:
+  AmbiguousDeclarationException(const Symbol&, const Symbol&);
+
+  const Symbol& symbol() const;
+  const Symbol& otherSymbol() const;
+private:
+  Symbol _symbol;
+  Symbol _otherSymbol;
+};
+
 #endif



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:16:58 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:16:58 +0100
Subject: [gpt-commit] r458 - trunk/gpt2/gptc/src/symboltable
Message-ID: <200712192216.lBJMGwfH026390@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:16:58 +0100 (Wed, 19 Dec 2007)
New Revision: 458

Modified:
   trunk/gpt2/gptc/src/symboltable/Symbol.cpp
   trunk/gpt2/gptc/src/symboltable/Symbol.hpp
Log:
-adicionado name()

Modified: trunk/gpt2/gptc/src/symboltable/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Symbol.cpp	2007-12-19 22:16:38 UTC (rev 457)
+++ trunk/gpt2/gptc/src/symboltable/Symbol.cpp	2007-12-19 22:16:58 UTC (rev 458)
@@ -76,6 +76,17 @@
   return _column;
 }
 
+std::string Symbol::name() const {
+  std::stringstream ret;
+  ret << _lexeme;
+
+  if (!_type->isSubprogram()) {
+    ret << " : ";
+  }
+  ret << _type->name();
+  return ret.str();
+}
+
 std::string Symbol::toString() const {
   std::stringstream ret;
   ret << _unit << ":" << _line

Modified: trunk/gpt2/gptc/src/symboltable/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Symbol.hpp	2007-12-19 22:16:38 UTC (rev 457)
+++ trunk/gpt2/gptc/src/symboltable/Symbol.hpp	2007-12-19 22:16:58 UTC (rev 458)
@@ -42,6 +42,7 @@
   int line() const;
   int column() const;
 
+  std::string name()     const;
   std::string toString() const;
 
   std::string identifier() const;



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:17:21 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:17:21 +0100
Subject: [gpt-commit] r459 - trunk/gpt2/gptc/src/parser
Message-ID: <200712192217.lBJMHLXL026422@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:17:21 +0100 (Wed, 19 Dec 2007)
New Revision: 459

Modified:
   trunk/gpt2/gptc/src/parser/parser.g
Log:
-avaliando, a nivel de gramatica, o posicionamento e quantidade de parametros T_RETICENCIA

Modified: trunk/gpt2/gptc/src/parser/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser/parser.g	2007-12-19 22:16:58 UTC (rev 458)
+++ trunk/gpt2/gptc/src/parser/parser.g	2007-12-19 22:17:21 UTC (rev 459)
@@ -326,7 +326,8 @@
   ;
 
 lista_parametros
-  : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
+  : param_reticencias 
+  | parametro (T_VIRGULA! lista_parametros)?
   ;
 
 param_reticencias!



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:17:44 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:17:44 +0100
Subject: [gpt-commit] r460 - trunk/gpt2/gptc/src/parser
Message-ID: <200712192217.lBJMHiji026457@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:17:44 +0100 (Wed, 19 Dec 2007)
New Revision: 460

Modified:
   trunk/gpt2/gptc/src/parser/lexer.g
Log:
-permitindo o uso de 'nulo' como T_IDENTIFICADOR

Modified: trunk/gpt2/gptc/src/parser/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/parser/lexer.g	2007-12-19 22:17:21 UTC (rev 459)
+++ trunk/gpt2/gptc/src/parser/lexer.g	2007-12-19 22:17:44 UTC (rev 460)
@@ -98,7 +98,7 @@
   
   //imagin?rios para a AST
 
-  T_NULO="nulo";
+  T_NULO="<nulo>";
   T_LVALUE;
   
 



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:19:11 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:19:11 +0100
Subject: [gpt-commit] r461 - trunk/gpt2/gptc/src/symboltable
Message-ID: <200712192219.lBJMJBe7026558@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:19:11 +0100 (Wed, 19 Dec 2007)
New Revision: 461

Modified:
   trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp
Log:
-Adicionado checagem de subprogramas ambiguos
-getSymbol -> getFirstSymbol

Modified: trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp	2007-12-19 22:17:44 UTC (rev 460)
+++ trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp	2007-12-19 22:19:11 UTC (rev 461)
@@ -96,6 +96,8 @@
 void SymbolTable::insertSymbol(const Symbol& symbol) {
   if (symbolExists(symbol)) {
     throw RedeclarationException(symbol);
+  } else { 
+    checkAmbiguity(symbol);
   }
   _table[symbol.scope()].push_back(symbol);
 }
@@ -108,7 +110,7 @@
   }
 }
 
-const Symbol& SymbolTable::getSymbol(const std::string& lexeme,
+const Symbol& SymbolTable::getFirstSymbol(const std::string& lexeme,
                                      const std::string& scope) {
   SymbolList::const_iterator it = _table[scope].findFirstByLexeme(lexeme);
   if (it == _table[scope].end()) {
@@ -117,13 +119,22 @@
   return (*it);
 }
 
+SymbolList SymbolTable::getSymbols(const std::string& lexeme) {
+  return _table[globalScope()].findAllByLexeme(lexeme);
+}
+
 const Symbol& 
 SymbolTable::getSymbol(const std::string& lexeme, const TypeList& params) {
   //deve considerar promocao de tipos
   //    fun??o f(a:real) ...
   //    f(1);                //resolve para a fun??o "f_real"
 
+//checar:
+//  f(a : inteiro)
+//  f(b : real)
+//  f(2); //primeira vers?o, sempre!
 
+
   SymbolList list = _table[globalScope()].findAllByLexeme(lexeme);
 
   if (list.size() == 0) {
@@ -156,20 +167,21 @@
 //   return (*it);
 }
 
-const Symbol& SymbolTable::getSymbol(const std::string& lexeme) {
+const Symbol& SymbolTable::getFirstSymbol(const std::string& lexeme) {
   //buscar primeiro no escopo atual, depois no global
 
   if (isInGlobalScope()) {
-    return getSymbol(lexeme, _scope);
+    return getFirstSymbol(lexeme, _scope);
   } else {
     try {
-      return getSymbol(lexeme, _scope);
+      return getFirstSymbol(lexeme, _scope);
     } catch( ... ) {
-      return getSymbol(lexeme, globalScope());
+      return getFirstSymbol(lexeme, globalScope());
     }
   }
 }
 
+
 bool SymbolTable::symbolExists(const Symbol& s) {
   SymbolList::const_iterator it = 
     _table[s.scope()].findByIdentifier(s.identifier());
@@ -181,7 +193,43 @@
   }
 }
 
+void SymbolTable::checkAmbiguity(const Symbol& s) {
+//  f(a : inteiro)
+//  f(b : inteiro, ... resto)
+//  -> declaracao ambigua
 
+  if (!s.type()->isSubprogram()) {
+    return;
+  }
+
+  SymbolList list = 
+    _table[globalScope()].findAllByLexeme(s.lexeme());
+
+  if (list.size() == 0) {
+    return;
+  }
+
+  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
+    if (!(*it).type()->isSubprogram()) {
+      continue;
+    }
+
+    int size = (*it).type()->paramTypes().size();
+    if ((size + 1) == s.type()->paramTypes().size()) {
+      Type *sss = s.type()->paramTypes().back();
+      bool bn = sss->isReticences();
+      if (s.type()->paramTypes().back()->isReticences()) {
+        throw AmbiguousDeclarationException(s, *it);
+      }
+    } else if ((size - 1) == s.type()->paramTypes().size()) {
+      if ((*it).type()->paramTypes().back()->isReticences()) {
+        throw AmbiguousDeclarationException(s, *it);
+      }
+    }
+  }
+}
+
+
 // bool SymbolTable::symbolExists(const std::string& id) {
 //   return symbolExists(id, _scope);
 // }

Modified: trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp	2007-12-19 22:17:44 UTC (rev 460)
+++ trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp	2007-12-19 22:19:11 UTC (rev 461)
@@ -35,14 +35,16 @@
   void insertSymbols(const SymbolList& symbols);
 
   //(lexeme, scope)
-  const Symbol& getSymbol(const std::string&, const std::string&);
+  const Symbol& getFirstSymbol(const std::string&, const std::string&);
 
   //(lexeme, params)
   const Symbol& getSymbol(const std::string&, const TypeList&);
 
+  //(lexeme) escopo global
+  SymbolList getSymbols(const std::string&);
 
   //(lexeme) -> todos os escopos, iniciando pelo atual
-  const Symbol& getSymbol(const std::string&);
+  const Symbol& getFirstSymbol(const std::string&);
 
   void dump();
 
@@ -51,6 +53,7 @@
 /*  bool symbolExists(const std::string&);
   bool symbolExists(const std::string&, const std::string&);*/
   bool symbolExists(const Symbol& s);
+  void checkAmbiguity(const Symbol& s);
 
   std::string                        _unit;
   std::string                        _scope;



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:21:04 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:21:04 +0100
Subject: [gpt-commit] r462 - trunk/gpt2/gptc/src/gptasm_target
Message-ID: <200712192221.lBJML44O026858@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:21:03 +0100 (Wed, 19 Dec 2007)
New Revision: 462

Modified:
   trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/gptasm_target/gptasm.g
Log:
-getSymbol -> getFirstSymbol

Modified: trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp	2007-12-19 22:19:11 UTC (rev 461)
+++ trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp	2007-12-19 22:21:03 UTC (rev 462)
@@ -26,7 +26,7 @@
 
 void BaseGptAsmWalker::declareProgramVars(const std::list<std::string>& ids) {
   for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    Symbol symbol = _symtable->getSymbol(*it);
+    Symbol symbol = _symtable->getFirstSymbol(*it);
     _asmPrg->emitVarDefinition(symbol.identifier(), symbol.type()->asmName(true));
 
     if (symbol.type()->isMatrix()) {
@@ -57,17 +57,17 @@
 void BaseGptAsmWalker::declareSubroutineVars(const std::list<std::string>& ids) {
   for (std::list<std::string>::const_iterator it = ids.begin(); it != ids.end(); ++it) {
     _subroutine->emitVarDefinition(
-      *it, _symtable->getSymbol(*it).type());
+      *it, _symtable->getFirstSymbol(*it).type());
   }
 }
 
 void BaseGptAsmWalker::declareParameter(const string& lexeme) {
   _subroutine->emitParDefinition(
-    lexeme, _symtable->getSymbol(lexeme).type());
+    lexeme, _symtable->getFirstSymbol(lexeme).type());
 }
 
 int BaseGptAsmWalker::getSymbolType(const string& lexeme) {
-  return _symtable->getSymbol(lexeme).type()->primitiveType();
+  return _symtable->getFirstSymbol(lexeme).type()->primitiveType();
 }
 
 // std::string BaseGptAsmWalker::expandOffset(const std::string&, const std::list<std::string>&) {

Modified: trunk/gpt2/gptc/src/gptasm_target/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/gptasm.g	2007-12-19 22:19:11 UTC (rev 461)
+++ trunk/gpt2/gptc/src/gptasm_target/gptasm.g	2007-12-19 22:21:03 UTC (rev 462)
@@ -213,7 +213,7 @@
   : #(lv:T_LVALUE 
       id:T_IDENTIFICADOR  
 
-                     {ret = _symtable->getSymbol(id->getText());}
+                     {ret = _symtable->getFirstSymbol(id->getText());}
 
 //       (
 //_subroutine->declareTmp(lv->getEvalType());



From gpt-commit-noreply at mail.berlios.de  Wed Dec 19 23:21:39 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 19 Dec 2007 23:21:39 +0100
Subject: [gpt-commit] r463 - trunk/gpt2/gptc/src/semantic
Message-ID: <200712192221.lBJMLdv9026934@sheep.berlios.de>

Author: thiago_silva
Date: 2007-12-19 23:21:39 +0100 (Wed, 19 Dec 2007)
New Revision: 463

Modified:
   trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp
Log:
-Checando por declaracoes ambiguas de subprogramas
-getSymbol -> getFirstSymbol


Modified: trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp	2007-12-19 22:21:03 UTC (rev 462)
+++ trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp	2007-12-19 22:21:39 UTC (rev 463)
@@ -102,7 +102,7 @@
 Type* BaseSemanticWalker::getSymbolType(RefPortugolAST node) {
   try {
     return
-      _symtable->getSymbol(node->getText()).type();
+      _symtable->getFirstSymbol(node->getText()).type();
   } catch (UndeclaredSymbolException e) {
     report(node->getLine(), node->getColumn(),
            std::string("s?mbolo n?o declarado: ") + node->getText());
@@ -251,6 +251,11 @@
 
 void BaseSemanticWalker::declareProc(const Symbol& s, 
                                      SymbolList& params) {
+//checar ambiguidades:
+//  f(a : inteiro)
+//  f(b : inteiro, ... resto)
+//  -> declaracao ambigua
+
   try {
     _symtable->insertSymbol(s);
   } catch (RedeclarationException e) {
@@ -258,8 +263,12 @@
            std::string("redeclara??o: ") + e.symbol().lexeme());
     _symtable->setIgnoreScope();
     return;
-  }  
-
+  } catch (AmbiguousDeclarationException e) {
+    report(e.symbol().line(), e.symbol().column(),
+           "declara??o amb?gua com: " + e.otherSymbol().name());
+    _symtable->setIgnoreScope();
+    return;
+  }
   _symtable->setScope(s);
   params.setScope(s.identifier());
 
@@ -356,12 +365,24 @@
 
 Type* BaseSemanticWalker::evalCall(RefPortugolAST id,
                                    const TypeList& paramTypes) {
+
   //TODO
   //-proibicao de consts passados para parametros "ref" sem constness
 
 // - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
 //   -Avaliacao de qtd e tipos de parametros
 
+//checar: 
+//  f(a : inteiro)
+//  f(b : inteiro, ... resto)
+//  f(a) //ambiguo
+
+//checar:
+//  f(a : inteiro)
+//  f(b : real)
+//  f(2); //primeira vers?o, sempre!
+
+
   if (paramTypes.hasErrorType()) {
     return _typeBuilder->errorType();
   }
@@ -370,12 +391,12 @@
     return 
       _symtable->getSymbol(id->getText(), paramTypes).type()->returnType();
   } catch (UndeclaredSymbolException e) {
-    report(id->getLine(), id->getColumn(), 
+    report(id->getLine(), id->getColumn(),
         "fun??o n?o encontrada: '" + id->getText() + "'");
     return _typeBuilder->errorType();
   } catch (UnmatchedException e) {
     report(id->getLine(), id->getColumn(),
-           "Fun??o compat?vel com '" + id->getText() 
+           "Fun??o compat?vel com '" + id->getText()
            + "(" + paramTypes.toString() + ")' n?o encontrada");
     return _typeBuilder->errorType();
   }



From gpt-commit-noreply at mail.berlios.de  Thu Dec 20 20:21:37 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 20 Dec 2007 20:21:37 +0100
Subject: [gpt-commit] r464 - in trunk/gpt2: bindings/gptbind/src
	bindings/gptbind/test common/src gptasm/test/wikki
Message-ID: <200712201921.lBKJLbYP028844@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-20 20:21:36 +0100 (Thu, 20 Dec 2007)
New Revision: 464

Added:
   trunk/gpt2/bindings/gptbind/test/file.sld
   trunk/gpt2/gptasm/test/wikki/chamada_sistema_5.gasm
Modified:
   trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
   trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
   trunk/gpt2/bindings/gptbind/src/lexer.g
   trunk/gpt2/bindings/gptbind/src/parser.g
   trunk/gpt2/common/src/Tools.cpp
Log:
DEVNULL:
* Melhorias nos bindings
  - No arquivo sld os pointer indicam o tipo em C
  - Teste com bind de fopen, fputs e fclose funcional
* Tipo pointer nao estava funcionando ok no GptASM


Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-20 19:21:36 UTC (rev 464)
@@ -4,8 +4,11 @@
 CBindSources::CBindSources(const std::string &filename)
       : _filename(filename)
 {
-   _mapGptToCppType["string"] = "const char *";
-   _mapGptToCppType["real"]   = "double";
+   _mapGptToCppType["string" ] = "const char *";
+   _mapGptToCppType["real"   ] = "double";
+   _mapGptToCppType["int"    ] = "int";
+   _mapGptToCppType["char"   ] = "char";
+   _mapGptToCppType["bool"   ] = "boolean";
 }
 
 
@@ -41,8 +44,8 @@
 
 void CBindSources::addSubroutineBind(
       const std::string &name,
-      const std::string &returnType,
-      std::vector<std::pair<std::string, std::string> > parameters,
+      const std::pair<std::string, std::string> &returnType,
+      std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters,
       const std::string &functionBind,
       std::vector<std::string> arguments )
 {
@@ -53,12 +56,12 @@
    cppSource.writeln( "{" );
    cppSource.incTab();
 
-   for(std::vector<std::pair<std::string, std::string> >::iterator param = parameters.begin(); param != parameters.end(); param++) {
+   for(std::vector<std::pair<std::string, std::pair<std::string,std::string> > >::iterator param = parameters.begin(); param != parameters.end(); param++) {
       cppSource.writeln (sourceToPopParameter (param->first, param->second));
    }
 
-   if (!returnType.empty()) {
-      cppSource.writeln(_mapGptToCppType[returnType] + " result;");
+   if (!returnType.first.empty()) {
+      cppSource.writeln(getMapGptToCppType(returnType) + " result;");
       cppSource.writeln();
       cppSource.write( "result=" );
    }
@@ -76,7 +79,7 @@
       }
    }
    cppSource.writeln(");");
-   if (!returnType.empty()) {
+   if (!returnType.first.empty()) {
       cppSource.writeln();
       cppSource.writeln(sourceToPushResult("result", returnType));
    }
@@ -85,29 +88,43 @@
 }
 
 
-std::string CBindSources::sourceToPopParameter(const std::string &name, const std::string &type)
+std::string CBindSources::sourceToPopParameter(const std::string &name, const std::pair<std::string,std::string> &type)
 {
    std::string result;
 
    std::map<std::string, std::string> mapPop;
    mapPop["string"] = "dataStack.popString().c_str()";
-   mapPop["real"]   = "dataStack.popReal()";
+   mapPop["real"  ] = "dataStack.popReal()";
+   mapPop["int"   ] = "dataStack.popInt()";
+   mapPop["char"  ] = "dataStack.popInt()";
+   mapPop["bool"  ] = "dataStack.popInt()";
 
-   result = _mapGptToCppType[type] + " c" + name + "=" + mapPop[type] + ";";
+   result = getMapGptToCppType(type) + " c" + name + "=";
 
+   if (type.first == "pointer") {
+      result += "(" + type.second + ")" + mapPop["int"];
+   } else {
+      result += mapPop[type.first];
+   }
+   result += ";";
+
    return result;
 }
 
 
-std::string CBindSources::sourceToPushResult(const std::string &name, const std::string &type)
+std::string CBindSources::sourceToPushResult(const std::string &name, const std::pair<std::string,std::string> &type)
 {
    std::string result;
 
    std::map<std::string, std::string> mapPush;
+   mapPush["string"] = "dataStack.pushString(" + name + ")";
    mapPush["real"  ] = "dataStack.pushReal(" + name + ")";
-   mapPush["string"] = "dataStack.pushString(" + name + ")";
+   mapPush["int"   ] = "dataStack.pushInt(" + name + ")";
+   mapPush["char"  ] = "dataStack.pushInt(" + name + ")";
+   mapPush["bool"  ] = "dataStack.pushBool(" + name + ")";
+   mapPush["pointer"] = "dataStack.pushInt((int)" + name + ")";
 
-   result = mapPush[type] + ";";
+   result = mapPush[type.first] + ";";
 
    return result;
 }
@@ -161,3 +178,13 @@
    _headerList.push_back(header);
 }
 
+
+std::string CBindSources::getMapGptToCppType(const std::pair<std::string,std::string> &type)
+{
+   if (type.first == "pointer") {
+      return type.second;
+   } else {
+      return _mapGptToCppType[type.first];
+   }
+}
+

Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.hpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.hpp	2007-12-20 19:21:36 UTC (rev 464)
@@ -15,8 +15,8 @@
    void writeHeaders();
    void addSubroutineBind(
          const std::string &name, 
-         const std::string &returnType,
-         std::vector<std::pair<std::string, std::string> > parameters,
+         const std::pair<std::string,std::string> &returnType,
+         std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters,
          const std::string &functionBind,
          std::vector<std::string> arguments
    );
@@ -44,8 +44,9 @@
    std::list<std::string> _linkerLibList;
    std::list<std::string> _headerList;
 
-   std::string sourceToPopParameter(const std::string &name, const std::string &type);
-   std::string sourceToPushResult(const std::string &name, const std::string &type);
+   std::string sourceToPopParameter(const std::string &name, const std::pair<std::string,std::string> &type);
+   std::string sourceToPushResult(const std::string &name, const std::pair<std::string,std::string> &type);
+   std::string getMapGptToCppType(const std::pair<std::string,std::string> &type);
 };
 
 #endif

Modified: trunk/gpt2/bindings/gptbind/src/lexer.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-20 19:21:36 UTC (rev 464)
@@ -174,6 +174,7 @@
   : '}'
   ;
 
+
 T_ABREP
 options {
   paraphrase = "'('";

Modified: trunk/gpt2/bindings/gptbind/src/parser.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-20 19:21:36 UTC (rev 464)
@@ -132,14 +132,14 @@
   procedure_bind
 //--------------
 {
-   std::vector<std::pair<std::string, std::string> > parameters;
+   std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters;
    std::vector<std::string> arguments;
 }
    : "procedure" tk_procname:T_ID (parameters_declaration[parameters])
      T_MAPINTO
      tk_mapname:T_ID (arguments_declaration[arguments])? T_SEMICOLON
      {
-        sources->addSubroutineBind(tk_procname->getText(), "", parameters, tk_mapname->getText(), arguments);
+        sources->addSubroutineBind(tk_procname->getText(), std::pair<std::string,std::string>("",""), parameters, tk_mapname->getText(), arguments);
      }
    ;
 
@@ -147,9 +147,9 @@
   function_bind
 //-------------
 {
-   std::vector<std::pair<std::string, std::string> > parameters;
+   std::vector<std::pair<std::string, std::pair<std::string, std::string> > > parameters;
    std::vector<std::string> arguments;
-   std::string resultType;
+   std::pair<std::string,std::string> resultType;
 }
    : "function" tk_procname:T_ID (parameters_declaration[parameters]) T_COLON resultType=type
      T_MAPINTO
@@ -160,18 +160,18 @@
    ;
 
 ///----------------------
-   parameters_declaration[std::vector<std::pair<std::string, std::string> > &parameters]
+   parameters_declaration[std::vector<std::pair<std::string, std::pair<std::string,std::string> > > &parameters]
 ///----------------------
 {
-   std::string typeValue;
+   std::pair<std::string,std::string> typeValue;
 }
    : T_ABREP
      (
         typeValue=type tk_id:T_ID
-        {parameters.push_back(std::pair<std::string, std::string>(tk_id->getText(), typeValue));} 
+        {parameters.push_back(std::pair<std::string, std::pair<std::string,std::string> >(tk_id->getText(), typeValue));} 
         (
            T_COMMA typeValue=type tk_id2:T_ID
-           {parameters.push_back(std::pair<std::string, std::string>(tk_id2->getText(), typeValue));} 
+           {parameters.push_back(std::pair<std::string, std::pair<std::string,std::string> >(tk_id2->getText(), typeValue));} 
         )*
      )?
      T_FECHAP
@@ -221,19 +221,23 @@
   ;
 
 ///----
-   type returns [std::string result]
+   type returns [std::pair<std::string,std::string> result]
 ///----
    :
-   ( "int"
-     | "real"
-     | "char"
-     | "string"
-     | "bool"
-     | "pointer"
-     | "matrix"
-     | "data"
+   ( "int" {result.first = getLastTokenText();}
+   | "real" {result.first = getLastTokenText();}
+   | "char" {result.first = getLastTokenText();}
+   | "string" {result.first = getLastTokenText();}
+   | "bool" {result.first = getLastTokenText();}
+   | ( "pointer" T_STRING_VALUE
+      {
+         result.first = "pointer";
+         result.second = getLastTokenText();
+         result.second = result.second.substr(1, result.second.length()-2);
+      } )
+   | "matrix" {result.first = getLastTokenText();}
+   | "data" {result.first = getLastTokenText();}
    )
-   {result = getLastTokenText();}
    ;
 
 /////----

Added: trunk/gpt2/bindings/gptbind/test/file.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/file.sld	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/bindings/gptbind/test/file.sld	2007-12-20 19:21:36 UTC (rev 464)
@@ -0,0 +1,13 @@
+options {
+}
+
+headers {
+   "stdio.h";
+}
+
+function fopen(string name, string mode) : pointer "FILE*" ::= fopen(name, mode);
+
+function fputs(string text, pointer "FILE*" file) : int ::= fputs(text, file);
+
+function fclose(pointer "FILE*" file) : int ::= fclose(file);
+

Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/common/src/Tools.cpp	2007-12-20 19:21:36 UTC (rev 464)
@@ -251,6 +251,7 @@
    case CSymbol::STRING:
       return sizeof(char)+sizeof(void*);
    case CSymbol::MATRIX:
+   case CSymbol::POINTER:
       return sizeof(void*);
    }
    return 0;

Added: trunk/gpt2/gptasm/test/wikki/chamada_sistema_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/chamada_sistema_5.gasm	2007-12-19 22:21:39 UTC (rev 463)
+++ trunk/gpt2/gptasm/test/wikki/chamada_sistema_5.gasm	2007-12-20 19:21:36 UTC (rev 464)
@@ -0,0 +1,26 @@
+program exemplo
+// use io
+
+var f pointer
+//var f int // pointer...
+var result int
+
+proc main
+    pushsv "w+"
+    pushsv "arquivo.txt"
+    lcall file, fopen
+    popiv f
+
+    pushiv f
+    pushsv "Uma linha !!!"
+    lcall file, fputs
+    popiv result
+
+    pushiv f
+    lcall file, fclose
+    popiv result
+
+    exit 0
+endproc
+
+endprogram



From gpt-commit-noreply at mail.berlios.de  Fri Dec 21 18:38:16 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 21 Dec 2007 18:38:16 +0100
Subject: [gpt-commit] r465 - in trunk/gpt2: bindings/gptbind/src
	bindings/gptbind/test gptasm/src gptvm/src
Message-ID: <200712211738.lBLHcGid016662@sheep.berlios.de>

Author: alexgarzao
Date: 2007-12-21 18:38:15 +0100 (Fri, 21 Dec 2007)
New Revision: 465

Modified:
   trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
   trunk/gpt2/bindings/gptbind/src/lexer.g
   trunk/gpt2/bindings/gptbind/src/parser.g
   trunk/gpt2/bindings/gptbind/test/file.sld
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
Log:
DEVNULL:
BUG:
* Geracao do gvm estava errada quando utilizada o tipo BOOL
* Troca no formato do .sld
  - pointer[TIPO]


Modified: trunk/gpt2/bindings/gptbind/src/CBindSources.cpp
===================================================================
--- trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/bindings/gptbind/src/CBindSources.cpp	2007-12-21 17:38:15 UTC (rev 465)
@@ -4,11 +4,11 @@
 CBindSources::CBindSources(const std::string &filename)
       : _filename(filename)
 {
-   _mapGptToCppType["string" ] = "const char *";
-   _mapGptToCppType["real"   ] = "double";
-   _mapGptToCppType["int"    ] = "int";
-   _mapGptToCppType["char"   ] = "char";
-   _mapGptToCppType["bool"   ] = "boolean";
+   _mapGptToCppType["string"] = "const char*";
+   _mapGptToCppType["real"  ] = "double";
+   _mapGptToCppType["int"   ] = "int";
+   _mapGptToCppType["char"  ] = "char";
+   _mapGptToCppType["bool"  ] = "boolean";
 }
 
 
@@ -102,7 +102,7 @@
    result = getMapGptToCppType(type) + " c" + name + "=";
 
    if (type.first == "pointer") {
-      result += "(" + type.second + ")" + mapPop["int"];
+      result += "(" + type.second + "*)" + mapPop["int"];
    } else {
       result += mapPop[type.first];
    }
@@ -182,7 +182,7 @@
 std::string CBindSources::getMapGptToCppType(const std::pair<std::string,std::string> &type)
 {
    if (type.first == "pointer") {
-      return type.second;
+      return type.second + "*";
    } else {
       return _mapGptToCppType[type.first];
    }

Modified: trunk/gpt2/bindings/gptbind/src/lexer.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/bindings/gptbind/src/lexer.g	2007-12-21 17:38:15 UTC (rev 465)
@@ -174,7 +174,21 @@
   : '}'
   ;
 
+T_ABRECO
+options {
+  paraphrase = "'['";
+}
+  : '['
+  ;
 
+T_FECHACO
+options {
+  paraphrase = "']'";
+}
+  : ']'
+  ;
+
+
 T_ABREP
 options {
   paraphrase = "'('";

Modified: trunk/gpt2/bindings/gptbind/src/parser.g
===================================================================
--- trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/bindings/gptbind/src/parser.g	2007-12-21 17:38:15 UTC (rev 465)
@@ -229,11 +229,10 @@
    | "char" {result.first = getLastTokenText();}
    | "string" {result.first = getLastTokenText();}
    | "bool" {result.first = getLastTokenText();}
-   | ( "pointer" T_STRING_VALUE
+   | ( "pointer" T_ABRECO tkid:T_ID T_FECHACO
       {
          result.first = "pointer";
-         result.second = getLastTokenText();
-         result.second = result.second.substr(1, result.second.length()-2);
+         result.second = tkid->getText();
       } )
    | "matrix" {result.first = getLastTokenText();}
    | "data" {result.first = getLastTokenText();}

Modified: trunk/gpt2/bindings/gptbind/test/file.sld
===================================================================
--- trunk/gpt2/bindings/gptbind/test/file.sld	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/bindings/gptbind/test/file.sld	2007-12-21 17:38:15 UTC (rev 465)
@@ -5,9 +5,9 @@
    "stdio.h";
 }
 
-function fopen(string name, string mode) : pointer "FILE*" ::= fopen(name, mode);
+function fopen(string name, string mode) : pointer[FILE] ::= fopen(name, mode);
 
-function fputs(string text, pointer "FILE*" file) : int ::= fputs(text, file);
+function fputs(string text, pointer[FILE] file) : int ::= fputs(text, file);
 
-function fclose(pointer "FILE*" file) : int ::= fclose(file);
+function fclose(pointer[FILE] file) : int ::= fclose(file);
 

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-12-21 17:38:15 UTC (rev 465)
@@ -63,10 +63,15 @@
       writeString(name, false);
    } else if (type == CSymbol::INT) {
       writeInt(atoi(name.c_str()));
+   } else if (type == CSymbol::BOOL) {
+      writeInt(atoi(name.c_str()));
    } else if (type == CSymbol::REAL) {
       writeReal(atof(name.c_str()));
    } else if (type == CSymbol::CHAR) {
       writeInt(toUTF8Char(name));
+   } else {
+     std::cout << "Ta faltando algum tipo ???" << endl;
+     abort();
    }
 
    return symbol;

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-20 19:21:36 UTC (rev 464)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-12-21 17:38:15 UTC (rev 465)
@@ -396,7 +396,7 @@
 
    if (ithandler == syslibHandlerList.end()) {
       // TODO: path absoluto ??? nem pensar :-)
-      dlhandler = dlopen(("../../../bindings/gptbind/test/lib" + libname + ".so").c_str(), RTLD_LAZY);
+      dlhandler = dlopen(("../../bindings/gptbind/test/lib" + libname + ".so").c_str(), RTLD_LAZY);
       if (!dlhandler) {
          fprintf (stderr, "%s\n", dlerror());
          exit(1);



From gpt-commit-noreply at mail.berlios.de  Thu Dec 27 23:51:19 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 27 Dec 2007 23:51:19 +0100
Subject: [gpt-commit] r466 - trunk/gpt/exemplos
Message-ID: <200712272251.lBRMpJVw008120@sheep.berlios.de>

Author: adorilson
Date: 2007-12-27 23:51:14 +0100 (Thu, 27 Dec 2007)
New Revision: 466

Modified:
   trunk/gpt/exemplos/olamundo.gpt
Log:
Adicao inicial do pacote .deb

Modified: trunk/gpt/exemplos/olamundo.gpt
===================================================================
--- trunk/gpt/exemplos/olamundo.gpt	2007-12-21 17:38:15 UTC (rev 465)
+++ trunk/gpt/exemplos/olamundo.gpt	2007-12-27 22:51:14 UTC (rev 466)
@@ -1,3 +1,4 @@
+avi?o
 algoritmo olamundo;
 
 in?cio
@@ -2,2 +3,2 @@
   imprima("Ol? Mundo!");
-fim
\ No newline at end of file
+fim



From gpt-commit-noreply at mail.berlios.de  Thu Dec 27 23:56:57 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 27 Dec 2007 23:56:57 +0100
Subject: [gpt-commit] r467 - in trunk/gpt: . packages packages/deb
	packages/deb/DEBIAN packages/deb/usr packages/deb/usr/local
	packages/deb/usr/local/bin packages/deb/usr/local/lib
	packages/deb/usr/local/lib/gpt
Message-ID: <200712272256.lBRMuvCd008339@sheep.berlios.de>

Author: adorilson
Date: 2007-12-27 23:54:24 +0100 (Thu, 27 Dec 2007)
New Revision: 467

Added:
   trunk/gpt/packages/
   trunk/gpt/packages/deb/
   trunk/gpt/packages/deb/DEBIAN/
   trunk/gpt/packages/deb/DEBIAN/control
   trunk/gpt/packages/deb/usr/
   trunk/gpt/packages/deb/usr/local/
   trunk/gpt/packages/deb/usr/local/bin/
   trunk/gpt/packages/deb/usr/local/bin/gpt
   trunk/gpt/packages/deb/usr/local/lib/
   trunk/gpt/packages/deb/usr/local/lib/gpt/
   trunk/gpt/packages/deb/usr/local/lib/gpt/base.gpt
   trunk/gpt/packages/gpt_1.0.1_i386.deb
Log:
Adicao inicial do pacote .deb

Added: trunk/gpt/packages/deb/DEBIAN/control
===================================================================
--- trunk/gpt/packages/deb/DEBIAN/control	2007-12-27 22:51:14 UTC (rev 466)
+++ trunk/gpt/packages/deb/DEBIAN/control	2007-12-27 22:54:24 UTC (rev 467)
@@ -0,0 +1,13 @@
+Package: gpt
+Priority: optional
+Version: 1.0.1
+Architecture: i386
+Maintainer: Adorilson Bezerra de Ara?jo
+Depends:
+Description: O compilador da linguagem G-Portugol. Permite:
+    * Compilar programas para MS Windows e GNU/Linux;
+    * Traduzir programas para C;
+    * Interpretar programas;
+    * Depurar programas (recomend?vel usar com o front-end GPTEditor).
+
+

Added: trunk/gpt/packages/deb/usr/local/bin/gpt
===================================================================
(Binary files differ)


Property changes on: trunk/gpt/packages/deb/usr/local/bin/gpt
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt/packages/deb/usr/local/lib/gpt/base.gpt
===================================================================
--- trunk/gpt/packages/deb/usr/local/lib/gpt/base.gpt	2007-12-27 22:51:14 UTC (rev 466)
+++ trunk/gpt/packages/deb/usr/local/lib/gpt/base.gpt	2007-12-27 22:54:24 UTC (rev 467)
@@ -0,0 +1,84 @@
+/*
+ * Biblioteca padr?o da linguagem G-Portugol (v1.0).
+ * Autor: Thiago Silva
+ *
+ * Nota: as fun??es dessa biblioteca suprem apenas
+ * funcionalidades e cen?rios simples. Melhorias e 
+ * adi??es s?o bem vindas.
+ * 
+ */
+
+fun??o arredonda(num: real) : real
+  trunc : inteiro;
+in?cio
+  trunc := num + 0.5;
+fim
+
+fun??o absoluto(num: real) : real
+in?cio
+  se num < 0 ent?o
+    retorne -num;
+  sen?o
+    retorne num;
+  fim-se
+fim
+
+fun??o potencia(base: real, exp: real) : real
+  i    : inteiro;
+  res  : real;
+  expi : inteiro;
+in?cio
+  se exp = 0 ent?o
+    retorne 1;
+  fim-se
+
+  se exp = 1 ent?o
+    retorne base;
+  fim-se
+
+  se exp = -1 ent?o
+    retorne 1 / base;
+  fim-se
+
+  res := 1;
+  expi := exp;
+  para i de 0 at? expi-1 fa?a
+    res := res * base;
+  fim-para
+  retorne res;
+fim
+
+/*
+ * Encontra a raiz usando o m?todo Newton-Raphson
+ * baseado no c?digo da p?gina:
+ * http://en.literateprograms.org/Newton-Raphson's_method_for_root_finding_(C)
+ */
+fun??o raiz_quadrada(num: real) : real
+  x     : real;
+  xn    : real;
+  iters : inteiro;
+  i     : inteiro;
+  n     : inteiro;
+  val   : real;
+in?cio
+  n := num;
+  para i de 0 at? n fa?a
+    val := i * i - num;
+    se val = 0 ent?o
+      retorne i;
+    fim-se  
+
+    se val > 0 ent?o
+      xn := (i+(i-1))/2.0;
+      i := n+1; //sair do loop!
+    fim-se
+  fim-para
+
+  enquanto n?o ((iters  >= 100) ou (x = xn)) fa?a
+    iters := iters + 1;
+    x := xn;
+    xn := x - (x * x - n) / (2 * x);
+  fim-enquanto
+  
+  retorne xn;
+fim

Added: trunk/gpt/packages/gpt_1.0.1_i386.deb
===================================================================
(Binary files differ)


Property changes on: trunk/gpt/packages/gpt_1.0.1_i386.deb
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



