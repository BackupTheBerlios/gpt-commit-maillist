From gpt-commit-noreply at mail.berlios.de  Mon Feb 16 02:45:14 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 16 Feb 2009 02:45:14 +0100
Subject: [gpt-commit] r519 - trunk/gpt/doc/manual
Message-ID: <200902160145.n1G1jEWp030126@sheep.berlios.de>

Author: adorilson
Date: 2009-02-16 02:45:00 +0100 (Mon, 16 Feb 2009)
New Revision: 519

Modified:
   trunk/gpt/doc/manual/manual.tex
Log:
Correcoes no portugues


Modified: trunk/gpt/doc/manual/manual.tex
===================================================================
--- trunk/gpt/doc/manual/manual.tex	2009-01-13 14:09:04 UTC (rev 518)
+++ trunk/gpt/doc/manual/manual.tex	2009-02-16 01:45:00 UTC (rev 519)
@@ -53,7 +53,7 @@
 \fancyhead[LO]{\rightmark} %Displays the lower-level (chapter) information - as
 
 
-\usepackage[brazilian]{babel} %traduz data, ``capitulo'', etc...
+\usepackage[brazilian]{babel} %traduz data, ''capitulo'', etc...
 \usepackage[latin1]{inputenc} %permite acentos diretamente
 \usepackage[T1]{fontenc} %to get the hyphenation right.
 %\usepackage{times}
@@ -183,7 +183,7 @@
 \label{ch:intro}
 
 G-Portugol ? um dialeto da linguagem/pseudo-c?digo portugol (ou
-portug?s estruturado), que ? muito usada para descrever algoritmos em
+portugu?s estruturado), que ? muito usada para descrever algoritmos em
 portugu?s, de forma livre e espont?nea. Em geral, livros dedicados ao ensino
 de algoritmos, l?gica e estruturas de dados utilizam alguma forma
 dessa linguagem.
@@ -191,15 +191,15 @@
 A proposta de G-Portugol ? disponibilizar uma implementa??o da
 linguagem portugol, fornecendo ferramentas que ofere?am recursos de edi??o,
 compila??o, execu??o e depura??o de programas escritos nessa linguagem, de forma
-a favorecer estudantes que d?o os primeiros passos no aprendizado de
+a favorecer aos estudantes que d?o os primeiros passos no aprendizado de
 desenvolvimento de softwares, bem como professores que ensinam disciplinas
 relacionadas a computa??o. Portanto, seu foco ? primariamente did?tico.
 
-Se encontram dispon?veis atualmente um compilador, tradutor e interpretador para
+Encontram-se dispon?veis atualmente um compilador, tradutor e interpretador para
 a linguagem (GPT) e um ambiente visual simples (GPTEditor) que permite a
 edi??o, execu??o e depura??o de programas escritos em G-Portugol.
 
-A seguir ? apresentado os assuntos abordados nos cap?tulos seguintes:
+A seguir s?o apresentados os assuntos abordados nos cap?tulos seguintes:
 
 \begin{itemize}
  \item 
@@ -208,7 +208,7 @@
   \item
   Cap?tulo 3: aborda a programa??o em G-Portugol, suas estruturas e recursos, utilizando exemplos ilustrativos e 
   comparando com linguagens populares. Embora o cap?tulo trate da programa??o, ele n?o tem como objetivo explicar 
-  programa??o em si ou a teoria/historia por traz das estruturas abordadas. 
+  programa??o em si ou a teoria/hist?ria por tr?s das estruturas abordadas. 
 
   \item
   Cap?tulo 4: trata da implementa??o da linguagem. Discute as decis?es de design e recursos oferecidos por G-Portugol.
@@ -233,7 +233,7 @@
 portugol. Semelhante ? linguagens como Pascal e C, ? uma linguagem imperativa, com comandos de 
 controle de fluxo, manipula??o de dados e recursos de entrada e sa?da b?sicos.
 A linguagem em \textit{case sensitive}, o que significa que, por exemplo, uma
-fun??o chamada ``leia'' ? diferente de uma fun??o chamada ``Leia''.
+fun??o chamada ''leia'' ? diferente de uma fun??o chamada ''Leia''.
 
 \section{Tipos de dados}
 
@@ -252,7 +252,7 @@
     inteiro & 19 \\
     real & 2.5 \\
     caractere & 'a' \\
-    literal & ``uma frase'' \\
+    literal & ''uma frase'' \\
     l?gico & verdadeiro \\
     \hline
   \end{tabular}
@@ -261,7 +261,7 @@
 \end{center}
 \end{table}
 
-Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ``n''
+Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ''n''
 dimensionais. Tipos mais complexos n?o s?o suportados.
 
 
@@ -269,8 +269,8 @@
 
 O conjunto de estruturas de controle s?o os mais primitivos. Uma
 estrutura condicional (se/sen?o) e duas estruturas de repeti??o (enquanto/para)
-s?o suportadas. Embora a estrutura ``para'' seja uma especializa??o de um la?o
-simples como o ``enquanto'', ela foi implementada, visto que uma variedade
+s?o suportadas. Embora a estrutura ''para'' seja uma especializa??o de um la?o
+simples como o ''enquanto'', ela foi implementada, visto que uma variedade
 de livros e muitos professores os discutem.
 
 \begin{table}[h!t]
@@ -330,14 +330,14 @@
   imprima("Ol? mundo!");
 fim
   \end{verbatim}
-  \caption{``Ol? Mundo'' em G-Portugol.}
+  \caption{''Ol? Mundo'' em G-Portugol.}
 \end{program}
 
 \noindent 
 Ap?s salvar o arquivo, digite o seguinte na linha de comando:
 \newline
 
-No linux:
+No Linux:
 \begin{verbatim}
 $ gpt -o olamundo olamundo.gpt
 \end{verbatim}
@@ -348,16 +348,16 @@
 \end{verbatim}
 
 Esse comando compila o algoritmo e salva o arquivo bin?rio resultante como
-``olamundo'' (ou ``olamundo.exe'') no diret?rio atual. Se a op??o ``-o
+''olamundo'' (ou ''olamundo.exe'') no diret?rio atual. Se a op??o ''-o
 <arquivo>'' n?o for informada, o GPT criar? o execut?vel usando o nome do
-algoritmo. Ap?s executar o programa criado, ? exibido o texto ``Ola mundo!'' na
+algoritmo. Ap?s executar o programa criado, ? exibido o texto ''Ola mundo!'' na
 tela.
 \newline
 
 Como j? deve ter assumido, coment?rios ao estilo C (/**/) e C++ (//) s?o
 permitidos e o que estiver entre aspas duplas (") ? tratado como uma string ou
 constante literal. Escapes s?o permitidos como EOL ($\backslash$n), tabula??o
-($\backslash$t) dentre outros. N?o ? permitido a concatena??o em multiplas
+($\backslash$t) dentre outros. N?o ? permitido a concatena??o em m?ltiplas
 linhas como na linguagem C:
 
 \begin{verbatim}
@@ -365,14 +365,14 @@
           "Concatena??o"); //erro!
 \end{verbatim}
 
-Outro detalhe ? a pontua??o. Da mesma forma que em C, o ``;'' ? utilizado como
+Outro detalhe ? a pontua??o. Da mesma forma que em C, o '';'' ? utilizado como
 finalizador de enunciados.
 
 \section{Vari?veis}
 
 A declara??o de vari?veis deve ser feita dentro de um bloco espec?fico, que deve aparecer logo ap?s a 
-declara??o do algoritmo. O bloco ? iniciado pela palavra-chave ``vari?veis'' (sim, com acento) e 
-termina com a palavra chave ``fim-vari?veis''. Pelo menos uma vari?vel deve
+declara??o do algoritmo. O bloco ? iniciado pela palavra-chave ''vari?veis'' (sim, com acento) e 
+termina com a palavra chave ''fim-vari?veis''. Pelo menos uma vari?vel deve
 ser declarada dentro do bloco (embora o bloco em si seja opcional) e apenas
 um bloco em escopo global deve ser declarado. Eis um exemplo para estudo:
 
@@ -402,44 +402,44 @@
 \end{verbatim}
 
 Isso ?, um ou mais identificadores separados por virgula, seguido de um
-``:'', seguido de um tipo, seguido, finalmente, de ``;''. Como pode-se notar, ?
+'':'', seguido de um tipo, seguido, finalmente, de '';''. Como pode-se notar, ?
 parecido com Pascal. Assim que um programa ? executado, todas as vari?veis,
 primitivas ou vetores/matrizes, declaradas s?o iniciadas com um valor nulo ou
-``0'' automaticamente. Vale ressaltar que constantes (const, final, etc) n?o s?o
+''0'' automaticamente. Vale ressaltar que constantes (const, final, etc) n?o s?o
 suportados. Os tipos primitivos suportados encontram-se na tabela
 \ref{tb_tipos_primitivos}
 
-A fim explorar melhor os aspectos da declara??o, seguem-se alguns coment?rios a
+A fim de explorar melhor os aspectos da declara??o, seguem-se alguns coment?rios a
 respeito do ?ltimo exemplo (programa \ref{programa_inutil})
 
 \begin{itemize}
  \item 
-  Observe que o nome do algoritmo (``teste\_variaveis'')
+  Observe que o nome do algoritmo (''teste\_variaveis'')
 n?o tem
-acento. Se declarar o algoritmo como ``teste\_vari?veis'' e tentar
+acento. Se declarar o algoritmo como ''teste\_vari?veis'' e tentar
 compilar o c?digo, o seguinte erro ser? exibido:
 
-  \textbf{Linha: 1 - ``teste\_vari?veis'' n?o pode ter caracteres
+  \textbf{Linha: 1 - ''teste\_vari?veis'' n?o pode ter caracteres
 especiais.}
 
   Portanto, identificadores (nomes de vari?veis, fun??es e do algoritmo) n?o
   podem ter acentos ou caracteres especiais como \$, \#, etc. A defini??o
   de um identificador em   G-Portugol ? equivalente ao das linguagens populares:
   uma letra (a-z ou A-Z) seguido de qualquer n?mero de letras ou n?meros.
-  Finalmente, underlines s?o permitidos.   Cedilhas, portanto, tamb?m n?o
+  Finalmente, underlines (_) s?o permitidos. Cedilhas, portanto, tamb?m n?o
   formam identificadores v?lidos. 
 
  \item 
-  O segundo ponto, ? a palavra-chave ``vari?veis'': ela tem acento, e isso ?
+  O segundo ponto, ? a palavra-chave ''vari?veis'': ela tem acento, e isso ?
 permitido e obrigat?rio. 
 
   \item
   O terceiro, ? a defini??o do bloco e sua (falta de) semelhan?a com o Pascal. Todas os blocos em G-Portugol 
-  tentam seguir o formato ``nome/fim-nome'', em favor da uniformidade e em detrimento de exce??es lingu?sticas 
+  tentam seguir o formato ''nome/fim-nome'', em favor da uniformidade e em detrimento de exce??es lingu?sticas 
   que confundem os estudantes.
 
   \item 
-  E, finalmente, o quarto ponto ? a aus?ncia de c?digo entre ``in?cio'' e ``fim''. 
+  E, finalmente, o quarto ponto ? a aus?ncia de c?digo entre ''in?cio'' e ''fim''. 
   O programa n?o ? obrigado a ter enunciados ou comandos.
 \end{itemize}
 
@@ -450,7 +450,7 @@
 \subsection{Vetores e matrizes (conjuntos)}
 
 
-Vetores e matrizes ``n'' dimensionais de tipos primitivos s?o suportados. Um
+Vetores e matrizes ''n'' dimensionais de tipos primitivos s?o suportados. Um
 exemplo de declara??o de uma matriz:
 
 
@@ -461,22 +461,22 @@
 fim-vari?veis 
 \end{verbatim}
 
-O tipo do vetor ou matriz ? dado pelo nome do tipo no plural (``inteiros'' para tipo inteiro, ``literais'' 
-para tipo literal, etc). Os subscritos na declara??o (delimitados por ``[]'') indicam o tamanho da matriz, 
-e sua dimens?o ? informada pelo numero de subscritos. Portanto, ``bitset'' ? um vetor de 10 valores l?gicos,
-enquanto ``quadr'' ? uma matriz bidimensional, onde as duas dimens?es tem tamanho 4.
+O tipo do vetor ou matriz ? dado pelo nome do tipo no plural (''inteiros'' para tipo inteiro, ''literais'' 
+para tipo literal, etc). Os subscritos na declara??o (delimitados por ''[]'') indicam o tamanho da matriz, 
+e sua dimens?o ? informada pelo n?mero de subscritos. Portanto, ''bitset'' ? um vetor de 10 valores l?gicos,
+enquanto ''quadr'' ? uma matriz bidimensional, onde as duas dimens?es tem tamanho 4.
 
-? importante observar que matrizes s?o ``0 based'', isso ?, iniciam no
-?ndice 0 e seus ?ndices s?o sempre inteiros positivos. Logo, a matriz ``bitset''
+? importante observar que matrizes s?o ''0 based'', isso ?, iniciam no
+?ndice 0 e seus ?ndices s?o sempre inteiros positivos. Logo, a matriz ''bitset''
 pode ser usada do ?ndice 0 at? o ?ndice 9 (inclusive). Seu ?ndice 10 n?o ?
 v?lido e seu uso poder? acarretar em erros de execu??o (\textit{runtime
 errors}). Matrizes, assim como vari?veis de tipos primitivos, s?o inicializadas
-com o valor ``0'' ou ``nulo'' em todas as suas posi??es. Quando usadas como
+com o valor ''0'' ou ''nulo'' em todas as suas posi??es. Quando usadas como
 argumentos de fun??es, matrizes s?o passadas \textit{por valor}.
 
 \begin{quotation}
-  \textit{``O mundo ? divido em dois grupos: aqueles que come?am a
-contar a partir do ''0``, e aqueles que n?o.''}
+  \textit{''O mundo ? divido em dois grupos: aqueles que come?am a
+contar a partir do ''0'', e aqueles que n?o.''}
    \begin{flushright}
   -- An?nimo
   \end{flushright}
@@ -488,7 +488,7 @@
 demais estruturas utilizam express?es, que s?o avaliadas para que uma
 decis?o seja tomada (repetir execu??o, selecionar bloco de instru??es,
 etc). Qualquer express?o pode ser avaliada como express?o l?gica.
-Express?es num?ricas de valor ``0'' s?o avaliadas como falso. Demais valores
+Express?es num?ricas de valor ''0'' s?o avaliadas como falso. Demais valores
 num?ricos s?o avaliados como verdadeiro. Valores literais nulos, da mesma forma,
 s?o avaliados como falso, e demais textos, como verdadeiro. Para maiores
 detalhes sobre express?es, veja a se??o \ref{sec:expr}.
@@ -544,22 +544,22 @@
 
 \begin{itemize}
   \item 
-  O nome do algoritmo ? ``idade'', assim como o nome de uma vari?vel. N?o h?
+  O nome do algoritmo ? ''idade'', assim como o nome de uma vari?vel. N?o h?
 conflitos.
 
   \item
-  O operador de atribui??o ? o \textit{pascal-like} ``:=''.
+  O operador de atribui??o ? o \textit{pascal-like} '':=''.
 
   \item
-  A fun??o interna ``leia'' pode ser usada por vari?veis primitivas de qualquer
+  A fun??o interna ''leia'' pode ser usada por vari?veis primitivas de qualquer
 tipo.
 
   \item
-  A fun??o ``imprima'' recebe um n?mero de argumentos vari?veis, que podem ser
-  constantes literais (n?meros, textos entre aspas, caracteres entre aspas
-simples,...), vari?veis primitivas ou ?ndices de vetores/matrizes. Os
-  valores s?o concatenados e adicionados de um caractere EOL (end of line, ou
-  fim de linha).
+  A fun??o ''imprima'' recebe um n?mero vari?vel de argumentos de qualquer tipo primitivo,
+sendo que pelo menos um argumento deve ser passado, que podem ser constantes literais 
+(n?meros, textos entre aspas, caracteres entre aspas simples,...), vari?veis primitivas ou 
+?ndices de vetores/matrizes. Os valores s?o concatenados e adicionados de um caractere EOL 
+(end of line, ou fim de linha).
 
   \item
   J? vimos que strings/literais constantes s?o denotados por texto entre aspas duplas ("). Tal qual em C, 
@@ -567,15 +567,15 @@
 tamb?m, permite escapes para representar caracteres como EOL ('$\backslash$n').
 
   \item
-  Assim como a palavra-chave ``vari?veis'', ``ent?o'' e ``sen?o'' devem ser acentuadas. 
+  Assim como a palavra-chave ''vari?veis'', ''ent?o'' e ''sen?o'' devem ser acentuadas. 
 
   \item 
-  Par?ntesis ao redor da express?o da estrutura ``se/ent?o'' s?o opcionais.
+  Par?ntesis ao redor da express?o da estrutura ''se/ent?o'' s?o opcionais.
 
   \item
-  Como em ``vari?veis/fim-vari?veis'', blocos ``se'' tem seus respectivos e obrigat?rios ``fim-se''. 
+  Como em ''vari?veis/fim-vari?veis'', blocos ''se'' tem seus respectivos e obrigat?rios ''fim-se''. 
   N?o h? a op??o de ignorar a defini??o do bloco quando apenas um enunciado ?
-  usado, como na linguagem C onde o uso de ``\{\}'' ? opcional. Tamb?m, n?o h? 
+  usado, como na linguagem C onde o uso de ''\{\}'' ? opcional. Tamb?m, n?o h? 
   imposi??es  sobre a indenta??o. O programa \ref{programa_se_incorreto}
 ilustra esse assunto.
 
@@ -599,11 +599,11 @@
 
 \section{Estruturas de repeti??o}
 
-\subsection{A estrutura ``enquanto''}
+\subsection{A estrutura ''enquanto''}
 
-A estrutura ``enquanto'' ? a mais b?sica e comum das estruturas de repeti??o. Seu funcionamento ? o mesmo que
+A estrutura ''enquanto'' ? a mais b?sica e comum das estruturas de repeti??o. Seu funcionamento ? o mesmo que
 em outras linguagens populares, onde um conjunto de instru??es ? executado repetidamente enquanto o valor 
-l?gico de uma dada express?o for avaliado como ``verdadeiro''.
+l?gico de uma dada express?o for avaliado como ''verdadeiro''.
 
 \begin{program}
   \begin{verbatim}
@@ -630,20 +630,20 @@
   imprima("fatorial de ",fat," ? igual a ",res);  
 fim
   \end{verbatim}
-  \caption{Exemplo de programa que utiliza a estrutura ``enquanto''.}
+  \caption{Exemplo de programa que utiliza a estrutura ''enquanto''.}
 \end{program}
 
 
-Assim como na estrutura ``se/ent?o'', par?nteses em volta da express?o s?o
+Assim como na estrutura ''se/ent?o'', par?nteses em volta da express?o s?o
 opcionais e as express?es seguem as mesmas regras.
 
-\subsection{A estrutura ``para''}
+\subsection{A estrutura ''para''}
 
-A estrutura ``para'' ? uma especializa??o da estrutura ``enquanto'', e costuma ser ensinada em cursos de programa??o.
-Sua sint?xe ? semelhante ao que se v? em literatura sobre algoritmos e estruturas de dados, entretanto, ? uma sintaxe
+A estrutura ''para'' ? uma especializa??o da estrutura ''enquanto'', e costuma ser ensinada em cursos de programa??o.
+Sua sintaxe ? semelhante ao que se v? em literatura sobre algoritmos e estruturas de dados, entretanto, ? uma sintaxe
 diferente de linguagens populares como C e Java.
 
-A estrutura ``para'' tem a seguinte forma:
+A estrutura ''para'' tem a seguinte forma:
 
 \begin{verbatim}
  para <vari?vel> de <express?o> at? <express?o> [passo <inteiro>] fa?a
@@ -655,18 +655,18 @@
 Onde:
 \begin{itemize}
  \item 
-  ``vari?vel'' deve ser uma vari?vel num?rica;
+  ''vari?vel'' deve ser uma vari?vel num?rica;
   \item
-  ``express?o'' deve ser uma express?o que tem seu valor avaliado como num?rico;
+  ''express?o'' deve ser uma express?o que tem seu valor avaliado como num?rico;
   \item
-  ``passo'', se existir, deve ser seguido por um inteiro constante.
+  ''passo'', se existir, deve ser seguido por um inteiro constante.
 \end{itemize}
   
 As express?es de/at? controlam os valores que a vari?vel num?rica ter? no
 in?cio e no fim do la?o, respectivamente. Tanto o controle da frequ?ncia, quanto
 a decis?o de incrementar ou decrementar a vari?vel de controle ? feita pelo
-termo opcional ``passo'', e seu valor padr?o ? 1. Por exemplo, para iterar o
-valor de uma vari?vel num?rica ``x'' de 0 at? 10, escreve-se: 
+termo opcional ''passo'', e seu valor padr?o ? 1. Por exemplo, para iterar o
+valor de uma vari?vel num?rica ''x'' de 0 at? 10, escreve-se: 
 
   \begin{verbatim}
 para x de 0 at? 10 fa?a
@@ -709,35 +709,35 @@
 fim
 
   \end{verbatim}
-  \caption{Exemplo de programa que utiliza a estrutura ''para``.}
+  \caption{Exemplo de programa que utiliza a estrutura ''para''.}
 \end{program}
 
 
-Em compara??o com a estrutura ``for'' de linguagens com sintaxe baseadas em C,
-h? diferen?as n?o s? de sintaxe, mas de implementa??o. Um ``for'' que itera
+Em compara??o com a estrutura ''for'' de linguagens com sintaxe baseadas em C,
+h? diferen?as n?o s? de sintaxe, mas de implementa??o. Um ''for'' que itera
 sobre uma vari?vel num?rica de 0 at? (incluindo) 10, ao sair do la?o, o
 valor dessa vari?vel ser? 11. Em G-Portugol, a vari?vel ter? o valor 10 ao
-sair do la?o. Essa diferen?a acontece porque a sintaxe do ``para'' induz a esse
-comportamento, diferente da sintaxe do ``for'', que tem um aspecto de mais
+sair do la?o. Essa diferen?a acontece porque a sintaxe do ''para'' induz a esse
+comportamento, diferente da sintaxe do ''for'', que tem um aspecto de mais
 baixo n?vel.
 
 \begin{verbatim}  
 //c?digo em C
 for(x = 0; x <= 10; x++);
-printf("%d", x); //imprime ``11''
+printf("%d", x); //imprime ''11''
 //--------------
 
 //c?digo equivalente em G-Portugol
 para x de 0 at? 10 fa?a
 fim-para
 
-imprima(x); //imprime ``10''
+imprima(x); //imprime ''10''
 \end{verbatim}
 
-Ademais, da mesma forma que o ``for'', ? poss?vel que a vari?vel de controle tenha seu valor
+Ademais, da mesma forma que o ''for'', ? poss?vel que a vari?vel de controle tenha seu valor
 alterado pelos comandos aninhados. Isso permite que o la?o seja encerrado prematuramente, como tamb?m ? comum
-em estruturas como ``enquanto''. A utilidade dessa t?cnica est? no fato de G-Portugol n?o incorporar mecanismos
-para refinar o controle de la?os (como ``break'' e ``continue'', encontrados em linguagens populares).
+em estruturas como ''enquanto''. A utilidade dessa t?cnica est? no fato de G-Portugol n?o incorporar mecanismos
+para refinar o controle de la?os (como ''break'' e ''continue'', encontrados em linguagens populares).
 
 \section{Fun??es}
 
@@ -747,10 +747,10 @@
 retorno, que deve ser de tipo primitivo. Tanto o retorno de dados como a
 passagem de argumentos s?o feitos \textit{por valor}.
 
-Para retorno prematuro ou retorno de dados, a palavra chave ``retorne'' ? usada. Para fun??es que retornam dados,
-``retorne'' deve ser seguido de um operando, que ? uma express?o cujo valor deve ser compat?vel com o tipo da fun??o.
-J? fun??es que n?o declaram um tipo de retorno expliticamente  (equivalente a fun??es de retorno ``void'' em C), 
-``retorne'' deve ser usado sem operando.
+Para retorno prematuro ou retorno de dados, a palavra chave ''retorne'' ? usada. Para fun??es que retornam dados,
+''retorne'' deve ser seguido de um operando, que ? uma express?o cujo valor deve ser compat?vel com o tipo da fun??o.
+J? fun??es que n?o declaram um tipo de retorno expliticamente  (equivalente a fun??es de retorno ''void'' em C), 
+''retorne'' deve ser usado sem operando.
 
 \begin{program}[h!t]
  \begin{verbatim}
@@ -782,20 +782,20 @@
 \subsection{Fun??es internas}
 \label{sec:func_internas}
 
-Como j? foi visto em exemplos anteriores, G-Portugol oferece duas fun??es internas: ``leia'' e ``imprima'', que
+Como j? foi visto em exemplos anteriores, G-Portugol oferece duas fun??es internas: ''leia'' e ''imprima'', que
 permitem uso b?sico de entrada e sa?da, respectivamente.
 
-A fun??o ``leia'' n?o recebe argumentos e retorna o valor lido da entrada padr?o
-(``STDIN''), o que significa, geralmente, ler os dados que o usu?rio digitar
-no teclado, seguido do caractere ``nova linha'' (em geral, associado a
-tecla ``Enter'' no teclado). O tipo de dado retornado por ``leia''
+A fun??o ''leia'' n?o recebe argumentos e retorna o valor lido da entrada padr?o
+(''STDIN''), o que significa, geralmente, ler os dados que o usu?rio digitar
+no teclado, seguido do caractere ''nova linha'' (em geral, associado a
+tecla ''Enter'' no teclado). O tipo de dado retornado por ''leia''
 ? implicitamente convertido para o tipo primitivo exigido no contexto em que ela
 ? usada.
 
-A fun??o ``imprima'' recebe um n?mero vari?vel de argumentos de qualquer tipo
+A fun??o ''imprima'' recebe um n?mero vari?vel de argumentos de qualquer tipo
 primitivo, sendo que pelo menos um argumento deve ser passado. Os
 valores passados como argumentos s?o convertidos para texto, concatenados
-na ordem definida e enviados para ``STDOUT'' (em geral, associado ao
+na ordem definida e enviados para ''STDOUT'' (em geral, associado ao
 \textit{display} ou monitor). N?o h? retorno de valor para esta fun??o.
 
 \begin{program}
@@ -827,7 +827,7 @@
 fim
   \end{verbatim}
 
-  \caption{Exemplo de usos das fun??es internas ``leia'' e ``imprima''.}
+  \caption{Exemplo de usos das fun??es internas ''leia'' e ''imprima''.}
 \end{program}
 
 
@@ -882,7 +882,7 @@
 interessantes e, talvez, mais eficientes como ferramentas de ensino,
 mas G-Portugol est?, no momento, comprometida com a compatibilidade.
 
-A seguir, alguns t?picos ser?o comentados quanto as diretrizes por traz
+A seguir, alguns t?picos ser?o comentados quanto as diretrizes por tr?s
 das formas l?xicas e gramaticais da linguagem G-Portugol.
 
 \subsection{Diretrizes para o design da linguagem}
@@ -900,7 +900,7 @@
 usu?rios (estudantes e professores) a se ater mais com o estudo da linguagem do
 que com o estudo da disciplina em quest?o. Isso ?, a aus?ncia de acentos, por
 exemplo, obriga o usu?rio a aprender seus termos excepcionais. Al?m do mais,
-o uso de termos como ``nao'', chama a aten??o constante do usu?rio para o fato
+o uso de termos como ''nao'', chama a aten??o constante do usu?rio para o fato
 de a palavra n?o estar acentuada, o que costuma desviar aten??o do estudo.
 
 Consequentemente, o uso de acentos permite que a linguagem seja o mais pr?ximo
@@ -908,7 +908,7 @@
 si. Ademais, o c?digo fica mais leg?vel e permite uma leitura mais agrad?vel.
 
 Al?m dos acentos, ? exigido que as palavras-chave usadas sejam completas ou por
-extenso, sem permitir abrevia??es (ex. ``proc'', ``func'', ``char'', ``int'',
+extenso, sem permitir abrevia??es (ex. ''proc'', ''func'', ''char'', ''int'',
 ...), o que dificulta a leitura de programas por um leigo.
 
 H? tamb?m decis?es quanto a forma verbal de comandos e fun??es. Em geral,
@@ -922,7 +922,7 @@
 literaturas sobre algoritmos.
 
 \begin{quotation}
-  \textit{``Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para m?quinas executarem.''}
+  \textit{''Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para m?quinas executarem.''}
    \begin{flushright}
   -- Abelson e Sussman
   \end{flushright}
@@ -949,7 +949,7 @@
 
 Essa diretriz diz respeito a permitir que a linguagem mude em certos aspectos
 (ou disponibilizar meios simples para realizar essas mudan?as) de acordo com
-o gosto do professor, ou como modo de adapatar a forma de portugol de uma
+o gosto do professor, ou como modo de adaptar a forma de portugol de uma
 dada literatura. Dialetos e formas da linguagem portugol variam de
 literatura para literatura, e pode ser interessante permitir que a linguagem se
 adapte ou oferecer diferentes formas da linguagem.
@@ -959,7 +959,7 @@
 estruturas, como algumas declara??es e enunciados. 
 
 Por exemplo, pode ser interessante que, para se declarar uma var?avel, n?o se
-use um bloco iniciado por ``vari?veis'' e terminado por ``fim-vari?veis'', mas
+use um bloco iniciado por ''vari?veis'' e terminado por ''fim-vari?veis'', mas
 como um bloco parecido com a declara??o de vari?veis em Pascal, ou at? em C (que
 sequer exige delimita??o de bloco de vari?veis).
 
@@ -969,7 +969,7 @@
 mais direta e que aproveita melhor os conhecimentos do estudante.
 
 Atualmente, o programa GPT n?o implementa mecanismos para esse tipo de
-mudan?a, sendo nescessario modificar seu c?digo fonte e recompil?-lo. 
+mudan?a, sendo necess?rio modificar seu c?digo fonte e recompil?-lo. 
 
 \section{Formato Estrutural}
 
@@ -1010,24 +1010,24 @@
 \end{verbatim}
 
 Esse formato difere de linguagens como Pascal e C. Em Pascal, o bloco n?o tem um
-delimitador final (como ``fim-vari?veis'') e em C, n?o existe qualquer
+delimitador final (como ''fim-vari?veis'') e em C, n?o existe qualquer
 delimitador.
 
 Delimitar o bloco permite maior consist?ncia com outras formas gramaticais
 como os blocos de comando e estruturas de controle, e torna o c?digo mais
-claro e explicito, embora adicione constru??es redundantes.
+claro e expl?cito, embora adicione constru??es redundantes.
 
 Os tipos primitivos englobam os tipos mais b?sicos das linguagens populares.
 No momento, agregados heterog?neos como, por exemplo, estruturas/registros
-(``struct'' em C) n?o s?o suportados. Para uma lista dos tipos suportados, veja
+(''struct'' em C) n?o s?o suportados. Para uma lista dos tipos suportados, veja
 a tabela \ref{tb_tipos_primitivos}.
   
 \subsection{Bloco Principal}
 
-As linguagens de programa??o devem, de alguma forma, oferecer um ``entry point''
+As linguagens de programa??o devem, de alguma forma, oferecer um ''entry point''
 (ponto de entrada), de onde se inicia a execu??o do programa. O ponto de entrada
 pode ser uma fun??o ou um bloco an?nimo. Na literatura, em geral, o bloco
-principal ? delimitado pelos termos ``in?cio''e ``fim'' e G-Portugol segue
+principal ? delimitado pelos termos ''in?cio''e ''fim'' e G-Portugol segue
 essa conven??o. Essa decis?o mant?m um n?vel satisfat?rio de coer?ncia
 com o bloco de vari?veis globais e estruturas de controle, embora n?o sejam
 intimamente relacionados.
@@ -1040,20 +1040,20 @@
 
 Estruturas de controle s?o formadas por um cabe?alho seguido por
 um bloco de comandos e terminados por um delimitador final. Embora os
-delimitadores do bloco n?o sejam ``in?cio'' e ``fim'', h? um grau de semelhan?a
+delimitadores do bloco n?o sejam ''in?cio'' e ''fim'', h? um grau de semelhan?a
 mantido: o delimitador inicial ? omitido (uma vez que o cabe?alho ? entendido
-como delimitador inicial) e o delimitador final ? o termo ``fim-'' seguido do
+como delimitador inicial) e o delimitador final ? o termo ''fim-'' seguido do
 nome da estrutura.
 
-No cabe?alho das estruturas como ``enquanto'' e ``se'', as express?es n?o
-precisam ser delimitadas por par?ntesis.
+No cabe?alho das estruturas como ''enquanto'' e ''se'', as express?es n?o
+precisam ser delimitadas por par?nteses.
 
 
   \subsubsection{Express?es}
   \label{sec:expr}
 
 Express?es s?o opera??es que sintetizam, ao final, um valor. Em geral
-constituem valores ou opera??es aritim?ticas com um ou mais termos que podem
+constituem valores ou opera??es aritm?ticas com um ou mais termos que podem
 ser vari?veis, constantes ou chamadas a fun??es e s?o usadas em atribui??es,
 estruturas de controle e subscritos de matrizes e vetores. Enunciados (como
 atribui??es) n?o podem ser avaliados como express?es.
@@ -1065,49 +1065,49 @@
  \item 
   Inteiros: Podem ser representados em base decimal, hexadecimal, octal e
 bin?ria. Representa??es decimais s?o formadas, opcionalmente, por um sinal
-(``+'' ou ``-'') seguido de um mais algarismos(ex.``120'', ``+5'', e ``-2'').
-Representa??es hexadecimais s?o representadas com o prefixo ``0x'' ou
-`` 0X'', seguido de algarismos entre ``0'' e ``9'' e letras entre ``a'' e ``f''
-ou ``A'' e ``F'' (ex. ``0xF1A5''). Representa??es octais s?o representadas com o
-prefixo ``0c'' ou ``0C'', seguido de algarismos entre ``0'' e ``7'' (ex.
-``0c61''). Finalmente, representa??es bin?rias s?o formadas pelo prefixo ``0b''
-ou ``0B'', seguido de algarismos ``0'' e ``1'' (ex. ``0b101'').
+(''+'' ou ''-'') seguido de um mais algarismos(ex.''120'', ''+5'', e ''-2'').
+Representa??es hexadecimais s?o representadas com o prefixo ''0x'' ou
+'' 0X'', seguido de algarismos entre ''0'' e ''9'' e letras entre ''a'' e ''f''
+ou ''A'' e ''F'' (ex. ''0xF1A5''). Representa??es octais s?o representadas com o
+prefixo ''0c'' ou ''0C'', seguido de algarismos entre ''0'' e ''7'' (ex.
+''0c61''). Finalmente, representa??es bin?rias s?o formadas pelo prefixo ''0b''
+ou ''0B'', seguido de algarismos ''0'' e ''1'' (ex. ''0b101'').
 
   \item
-  Reais: s?o representados por, opcionalmente, um sinal (``+ ou
-''-``), seguido de algarismos separados por um ``.'' como ``-1.2345''.
+  Reais: s?o representados por, opcionalmente, um sinal (''+ ou
+''-''), seguido de algarismos separados por um ''.'' como ''-1.2345''.
 
   \item
   Caracteres: s?o representados por um ?nico simbolo entre aspas simples.
-Alguns caracteres especiais s?o representados com escape (``$\backslash$'')
-seguido de s?mbolo identificador. Esses caracteres s?o o LF (``$\backslash$n''),
-CR (``$\backslash$r'') e barra invertida (``$\backslash$$\backslash$''). A
-aus?ncia de s?mbolos entre as aspas simples indica um caractere ``nulo''.
+Alguns caracteres especiais s?o representados com escape (''$\backslash$'')
+seguido de s?mbolo identificador. Esses caracteres s?o o LF (''$\backslash$n''),
+CR (''$\backslash$r'') e barra invertida (''$\backslash$$\backslash$''). A
+aus?ncia de s?mbolos entre as aspas simples indica um caractere ''nulo''.
 Internamente, caracteres s?o representados como n?meros inteiros, o que permite
 sua compatibilidade num?rica.
 
   \item
   Literais: s?o representados por um conjunto de caracteres entre aspas duplas.
-Eles podem conter caracteres especiais como ``$\backslash$n'' e devem ser
+Eles podem conter caracteres especiais como ''$\backslash$n'' e devem ser
 definidos em apenas uma linha de c?digo. Valores literais s?o os ?nicos que n?o
 tem uma representa??o num?rica, impedindo sua participa??o em express?es com
 operadores aritm?ticos (soma, divis?o, etc). Compara??es de igualdade
 para valores literais s?o feitas caractere por caractere em \textit{case
-sensitive}. Portanto, a express?o ``portugol'' = ``Portugol'' ? avaliada como
+sensitive}. Portanto, a express?o ''portugol'' = ''Portugol'' ? avaliada como
 falsa. J? compara??es de grandeza s?o feitos calculando o n?mero de caracteres
-que comp?em os valores literais. Ent?o, a express?o ``maria'' > ``jos?'' ?
+que comp?em os valores literais. Ent?o, a express?o ''maria'' > ''jos?'' ?
 avaliada como verdadeira.
 
   \item
-  L?gicos: s?o representados pelas palavras ``verdadeiro'' e ``falso''.
-Numericamente, qualquer valor diferente de ``0'' representa o valor verdadeiro e
-``0'' representa o valor falso.
+  L?gicos: s?o representados pelas palavras ''verdadeiro'' e ''falso''.
+Numericamente, qualquer valor diferente de ''0'' representa o valor verdadeiro e
+''0'' representa o valor falso.
 
 \end{itemize}
 
 A preced?ncia de operadores ? mostrada na tabela \ref{tb_precedencia_op} (da
-menor preced?ncia para a maior) e pode ser expl?cicamente modificada com o uso
-de par?ntesis.
+menor preced?ncia para a maior) e pode ser explicicamente modificada com o uso
+de par?nteses.
 
 
 \begin{table}[ht]
@@ -1130,7 +1130,7 @@
     \symbol{42}, /, \%     & operadores aritm?ticos multiplica??o,
 divis?o, m?dulo \\
     +, -, \~{}, n?o, () & operadores un?rios positivo, negativo, NOT bin?rio, NOT
-l?gico, par?ntesis \\
+l?gico, par?nteses \\
     \hline
   \end{tabular}
   \caption{Preced?ncia de Operadores \label{tb_precedencia_op}}
@@ -1139,7 +1139,7 @@
 
 
 Em G-Portugol, n?o h? coer??o ou \textit{casting} de tipos expliticamente.
-Todos os tipos num?ricos (inteiro, real, l?gico e caractere) s?o compativeis
+Todos os tipos num?ricos (inteiro, real, l?gico e caractere) s?o compat?veis
 entre si. ? importante ressaltar que express?es envolvendo igualdade ou 
 diferen?a de valores reais n?o s?o apropriadas dado a forma como esses valores 
 s?o representados internamente. Tais compara??es podem ter resultados 
@@ -1149,13 +1149,13 @@
 Existem dois casos em que ocorre uma coer??o impl?cita. O primeiro caso ocorre
 durante a avalia??o de uma express?o que tem operandos de tipos diferentes (mas
 compat?veis entre si), onde n?o h? perda de dados e um dos termos ? promovido
-para o tipo do seu termo complementar. Por exemplo, na express?o ``2 + 1.5'', o
-termo ``2'' ? promovido para o tipo ``real'', tendo o valor ``2.0'' antes
- que  a soma seja processada. Da mesma forma, sendo ``x'' uma vari?vel de tipo
-real, a express?o ``x := 5 / 2'' atribuir? a ``x'' o valor ``2.00''. Esse
-comportamento n?o muito ?bvio ? similar ao da linguagem C, onde ``5 / 2'' ?
+para o tipo do seu termo complementar. Por exemplo, na express?o ''2 + 1.5'', o
+termo ''2'' ? promovido para o tipo ''real'', tendo o valor ''2.0'' antes
+ que  a soma seja processada. Da mesma forma, sendo ''x'' uma vari?vel de tipo
+real, a express?o ''x := 5 / 2'' atribuir? a ''x'' o valor ''2.00''. Esse
+comportamento n?o muito ?bvio ? similar ao da linguagem C, onde ''5 / 2'' ?
 avaliado como uma divis?o de inteiros, onde apenas o valor inteiro final ?
-relevante. Para obter o resultado real, a express?o deve ser ``5.0 / 2'', para
+relevante. Para obter o resultado real, a express?o deve ser ''5.0 / 2'', para
 informar ao compilador que a divis?o usar? valores reais, produzindo a promo??o
 de tipos mencionada anteriormente.
 
@@ -1166,8 +1166,8 @@
   \subsection{Atribui??es}
   \label{subsec:atribuicoes}
 Atribui??es permitem a manipula??o de valores na mem?ria. Em G-Portugol,
-como j? foi visto, ? usado o operador ``:='', onde o termo a esquerda ou
-``\textit{lvalue}'' deve ser uma vari?vel primitiva ou ?ndice de uma
+como j? foi visto, ? usado o operador '':='', onde o termo a esquerda ou
+''\textit{lvalue}'' deve ser uma vari?vel primitiva ou ?ndice de uma
 matriz/vetor, e o termo a direita, uma express?o que, quando avaliada, tem seu
 tipo compat?vel com o \textit{lvalue}.
 
@@ -1205,23 +1205,23 @@
 e podem receber argumentos e retornar valores. Em tempo de execu??o, as fun??es
 criam um novo escopo sobreposto ao escopo principal. Isso permite recursos
 como recurs?o e possibilita que vari?veis locais (no escopo da fun??o) tenham o
-mesmo nome que vari?veis globais, onde essas ?ltimas ficam ``escondidas'', isso
+mesmo nome que vari?veis globais, onde essas ?ltimas ficam ''escondidas'', isso
 ?, incapazes de serem acessadas enquanto o escopo durar. Ressalta-se que n?o h?
 suporte para fun??es aninhadas, isso ?, fun??es declaradas dentro de fun??es. 
 
-O retorno de dados ? feito por meio da instru??o ``retorne'' e o valor de
+O retorno de dados ? feito por meio da instru??o ''retorne'' e o valor de
 retorno (se houver) deve ser compat?vel com o tipo da fun??o. Esse tipo n?o
 pode ser um tipo agregado como matrizes e vetores.
 
 Tanto a passagem de argumentos quanto o retorno ? feito \textit{por valor},
-isso ?, a copia do valor ? feita, ao invez de a copia de endere?o ou passagem
+isso ?, a c?pia do valor ? feita, ao inv?s de a c?pia de endere?o ou passagem
 \textit{por refer?ncia}.
 
 As vari?veis locais de uma fun??o s?o formadas por seus par?metros e pelas
 vari?veis declaradas em seu escopo. A declara??o de vari?veis locais ? feita
-entre o cabe?alho da fun??o e a palavra-chave ``in?cio'', portanto, n?o ?
+entre o cabe?alho da fun??o e a palavra-chave ''in?cio'', portanto, n?o ?
 uniforme em rela??o a declara??o global, onde se usa as palavras-chave
-``vari?veis'' e ``fim-vari?veis''. 
+''vari?veis'' e ''fim-vari?veis''. 
 
 A declara??o dos par?metros da fun??o tamb?m n?o segue estritamente o formato
 de declara??o de vari?veis. O programa \ref{exemplo_funcao} ilustra a
@@ -1253,11 +1253,11 @@
 sa?da. Ambas as fun??es tem comportamentos excepcionais quando comparadas
 com as fun??es de usu?rio. Essas fun??es s?o discutidas na sess?o a seguir.
 
-  \subsection{A fun??o ``imprima''}
+  \subsection{A fun??o ''imprima''}
 
 A fun??o imprima tem como objetivo imprimir texto no dispositivo de sa?da.
 Ela recebe um n?mero vari?vel de argumentos (pelo menos um), onde cada
-argumento deve ser um valor primitivo, e os imprime em sequencia. Ao final, ?
+argumento deve ser um valor primitivo, e os imprime em sequ?ncia. Ao final, ?
 impresso um caractere de nova linha (LF) e a fun??o retorna.
 
 Essa fun??o se comporta de forma excepcional visto que n?o ?
@@ -1265,38 +1265,38 @@
 argumentos.
 
 
-  \subsection{A fun??o ``leia''}
+  \subsection{A fun??o ''leia''}
 
-A fun??o ``leia'' espera por uma entrada do teclado seguida do caractere LF (em
-geral, associado a tecla ``Enter'') e retorna o valor lido. Esse valor ?
+A fun??o ''leia'' espera por uma entrada do teclado seguida do caractere LF (em
+geral, associado a tecla ''Enter'') e retorna o valor lido. Esse valor ?
 convertido implicitamente para o tipo do \textit{lvalue}. A tabela
 \ref{tb_leia_casts} apresenta convers?es impl?citas processadas pela
-fun??o ``leia'' para o enunciado de exemplo ``x := leia()''.
+fun??o ''leia'' para o enunciado de exemplo ''x := leia()''.
 
-Nota: n?meros reais s?o arredondados, se nescess?rio, e exibidos no formato
-.xx (com duas casas decimais). Portanto, o n?mero ``250.0'' ou ``250'' seria
-impresso como ``250.00'' e ``1.449'' seria impresso como ``1.45''. Se o
+Nota: n?meros reais s?o arredondados, se necess?rio, e exibidos no formato
+.xx (com duas casas decimais). Portanto, o n?mero ''250.0'' ou ''250'' seria
+impresso como ''250.00'' e ''1.449'' seria impresso como ''1.45''. Se o
 par?metro for uma vari?vel, seu valor n?o ser? modificado.
 
 \begin{table}[ht]
 \begin{center}
   \begin{tabular}{|l|l|l|}
     \hline
-    \multicolumn{3}{|c|}{Convers?es da fun??o ``leia''} \\
+    \multicolumn{3}{|c|}{Convers?es da fun??o ''leia''} \\
     \hline
-      Tipo do LValue ``x'' & Texto lido & Valor final de ``x'' \\
+      Tipo do LValue ''x'' & Texto lido & Valor final de ''x'' \\
     \hline
       inteiro & 123 & 123 \\
       inteiro & 123 456 & 123 \\
       inteiro & abc & 0 \\
       inteiro & 123s & 123 \\
       l?gico  & falso & falso \\
-      l?gico & ``0'' & falso \\
+      l?gico & ''0'' & falso \\
       l?gico & falso 12wtc & verdadeiro \\
       l?gico & 0 umdois3 & verdadeiro\\
     \hline
   \end{tabular}
-  \caption{Convers?es impl?citas da fun??o ``leia'' \label{tb_leia_casts}}
+  \caption{Convers?es impl?citas da fun??o ''leia'' \label{tb_leia_casts}}
 \end{center}
 \end{table}
 
@@ -1304,8 +1304,8 @@
 Essa fun??o se comporta de forma excepcional visto que seu tipo de retorno n?o
 ? absoluto (\textit{overloaded}, depende do tipo de \textit{lvalue}) e, no
 momento, ? restrita express?es isentas de operadores. Isso ?, n?o ? permitido
-aplic?-la como um termo em uma express?o com multiplos operandos (ex. ``x :=  y
-+ leia()``), embora seja poss?vel utiliz?-la em subscritos de vetores e
+aplic?-la como um termo em uma express?o com m?ltiplos operandos (ex. ''x :=  y
++ leia()''), embora seja poss?vel utiliz?-la em subscritos de vetores e
 matrizes, assim como em express?es de estruturas de controle. 
 
 Em princ?pio, pode-se levar em conta duas formas de implementar uma fun??o de
@@ -1321,7 +1321,7 @@
 
 \capitulo{O programa GPT}
 
-\section{Intrudu??o}
+\section{Introdu??o}
   
 GPT ? a ferramenta principal da linguagem G-Portugol. Entre suas fun??es
 principais est?o:
@@ -1330,7 +1330,7 @@
   \item
   Compilar algoritmos;
  \item 
-  Traduzir algortimos para outras linguagens;
+  Traduzir algoritmos para outras linguagens;
   \item
   Executar algoritmos.
 \end{itemize}
@@ -1353,7 +1353,7 @@
 \section{Op??es gerais}
 \label{sec:opcoes_gerais}
 
-Ao executar o programa ``gpt'' com o argumento ``-h'', ? mostrado:
+Ao executar o programa ''gpt'' com o argumento ''-h'', ? mostrado:
 
 \begin{verbatim}
 Modo de uso: gpt [op??es] arquivos
@@ -1375,10 +1375,10 @@
 
 \begin{itemize}
  \item 
-  v: Exibe a vers?o do programa ``gpt'', assim como informa??es de copyright;
+  v: Exibe a vers?o do programa ''gpt'', assim como informa??es de copyright;
 
   \item
-  h: exibe todas as op??es suportadas pelo programa ``gpt'';
+  h: exibe todas as op??es suportadas pelo programa ''gpt'';
 
   \item
   o <arquivo>: Ao compilar um algoritmo, salva o execut?vel com o nome de
@@ -1395,23 +1395,23 @@
 
   \item 
   i: Executa o algoritmo diretamente, sem compilar ou criar arquivos. Op??o
-conhecida como ``interpreta??o'' ou ``scripting''.
+conhecida como ''interpreta??o'' ou ''scripting''.
 
   \item
   d: Exibe mais informa??es no relat?rio de erros, como dicas de como proceder
-para solucionar errors de sint?xe.
+para solucionar errors de sintaxe.
 \end{itemize}
 
-A ?ltima op??o (``arquivos'') ? uma lista de arquivos contendo o c?digo fonte
+A ?ltima op??o (''arquivos'') ? uma lista de arquivos contendo o c?digo fonte
 em G-Portugol, embora seja mais comum utilizar um arquivo apenas para cada
 algoritmo.
 
 \section{Tratamento de erros}
   
 Em geral, as ferramentas de diversas linguagens de programa??o oferecem o
-m?nimo de informa??es a cerca de erros de compila??o, as vezes, tendo uma
-forma ``criptica'' dificultando seu entendimento e posterior corre??o.
-Comum, tamb?m a possibilide de que determinados erros sejam reportados em
+m?nimo de informa??es a cerca de erros de compila??o, ?s vezes, tendo uma
+forma ''criptica'' dificultando seu entendimento e posterior corre??o.
+Comum, tamb?m a possibilidade de que determinados erros sejam reportados em
 localiza??es distantes de onde o erro efetivamente se encontra no c?digo
 fonte. Ademais, ? importante notar que nessas linguagens, os erros s?o
 reportados em ingl?s. 
@@ -1433,12 +1433,12 @@
 com x86 e em dois formatos: ELF (\textit{Executable and linking format}) e PE
 (\textit{Portable Executable}). Sistemas Unix, em geral, suportam o formato
 ELF, e o formato PE ? conhecido nos sistemas Microsoft Windows. Ap?s o processo
-de an?lise, o compilador gera c?digo em assembly para, ent?o, usar o NASM
+de an?lise, o compilador gera c?digo em Assembly para, ent?o, usar o NASM
 (Netwide Assembler) como \textit{backend} para montar e criar um execut?vel
 v?lido. Consequentemente, n?o existe etapa de linkagem. A fase de otimiza??o de
 c?digo tamb?m n?o foi implementada.
 
-Para usar esse recurso, ? nescess?rio que o NASM esteja instalado no sistema.
+Para usar esse recurso, ? necess?rio que o NASM esteja instalado no sistema.
 Ele pode ser encontrado em http://www.sf.net/projects/nasm.
 
 \subsection{Tradu??o para a linguagem C}
@@ -1457,42 +1457,42 @@
 compilador pode emitir avisos e erros, visto que \textit{printf} ? uma fun??o da
 biblioteca padr?o, usada no c?digo C resultante. Da mesma forma,
 identificadores com \textit{underlines} antes ou depois em seus nomes
-(como ``\_\_leia\_texto'') devem ser evitados,
+(como ''\_\_leia\_texto'') devem ser evitados,
 pois muitos identificadores internos utilizam essas conven??es de nomea??o, e
 seu uso pode acarretar em conflitos durante a tradu??o.
 
 \subsection{Interpreta??o de c?digo}
 
 O programa GPT permite que o algoritmo seja executado sem gerar c?digo bin?rio.
-Esse modo ? conhecido como ``interpreta??o'' e linguagens como Perl, PHP e Ruby
+Esse modo ? conhecido como ''interpreta??o'' e linguagens como Perl, PHP e Ruby
 utilizam esta t?cnica.
 
 Esse modo permite depurar algoritmos passo a passo (por meio de um
 \textit{client debugger} como o GPTEditor) e inspecionar vari?veis e a pilha de
 fun??es enquanto o algoritmo est? em execu??o.
 
-A unica diferen?a na execu??o de algoritmos em modo interpretado em rela??o a
+A ?nica diferen?a na execu??o de algoritmos em modo interpretado em rela??o a
 outros modos ? que as matrizes/vetores tem seus subscritos checados
-(``\textit{bound checking}''). Isso ?, erros de execu??o s?o emitidos se um
+(''\textit{bound checking}''). Isso ?, erros de execu??o s?o emitidos se um
 ?ndice n?o existir em uma matriz/vetor.
 
 \subsubsection{Depura??o interativa}
 
-A depura??o interativa ? feita em modo ``interpreta??o'', portanto n?o gera
+A depura??o interativa ? feita em modo ''interpreta??o'', portanto n?o gera
 c?digo bin?rio, executando o algoritmo diretamente. Para depurar
-interativamente um algoritmo ? nescess?rio um programa extra: o \textit{client
+interativamente um algoritmo ? necess?rio um programa extra: o \textit{client
 debugger}. Atualmente, o programa GPTEditor suporta a depura??o interativa.
 
 Entre os recursos dispon?veis, pode-se citar a execu??o passo a passo em 3
-modos (comumente conhecidas como ``step into'', ``step over'' e ``step out''),
+modos (comumente conhecidas como ''step into'', ''step over'' e ''step out''),
 inspe??o de vari?veis locais/globais e pontos de
-parada (``\textit{breakpoints}'').
+parada (''\textit{breakpoints}'').
 
 A depura??o ocorre tendo o programa GPT se comunicando via socket com o cliente
 (ex: GPTEditor), iniciando transmiss?o de dados entre esses dois pontos. As
 informa??es enviadas pelo GPT (vari?veis, breakpoints, etc) usam o formato
 baseado em XML, enquanto o cliente envia comandos simples (o que evita que o
-programa GPT nescessite de um XML parser).
+programa GPT necessite de um XML parser).
 
 Por exemplo, a pilha de fun??es pode ser representada da seguinte forma:
 
@@ -1507,7 +1507,7 @@
 \subsection{Processando algoritmos divididos em multiplos arquivos}
 
 A partir da vers?o 1.0, o GPT suporta processar algoritmos divididos em
-multiplos arquivos. Esse recurso ? poss?vel utilizando duas formas: 
+m?ltiplos arquivos. Esse recurso ? poss?vel utilizando duas formas: 
 
 
 \begin{itemize}
@@ -1523,7 +1523,7 @@
 A primeira forma ? explicada na sess?o \ref{sec:opcoes_gerais}. A segunda forma
 pretende facilitar a utiliza??o de fun??es que devem estar dispon?veis por
 padr?o a cada execu??o/compila??o dos algoritmos. Pode-se definir a vari?vel de
-ambiente GPT\_INCLUDE contendo v?rios caminhos de arquivos separados por ``:''.
+ambiente GPT\_INCLUDE contendo v?rios caminhos de arquivos separados por '':''.
 Em sistemas Unix, por exemplo, pode-se criar a essa vari?vel da seguinte forma
 (utilizando Bash):
 
@@ -1531,7 +1531,7 @@
 $ export GPT_INCLUDE="/usr/local/lib/gpt/base.gpt:/usr/local/lib/gpt/util.gpt"
 \end{verbatim}
 
-Onde ``base.gpt'' e ``util.gpt'' s?o arquivos contendo fun??es escritas em
+Onde ''base.gpt'' e ''util.gpt'' s?o arquivos contendo fun??es escritas em
 G-Portugol.
 
 Os arquivos passados pela linha de comando e/ou que se encontram na vari?vel



From gpt-commit-noreply at mail.berlios.de  Thu Feb 19 22:01:44 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 19 Feb 2009 22:01:44 +0100
Subject: [gpt-commit] r520 - in trunk/gpt/src: . modules/interpreter
	modules/x86
Message-ID: <200902192101.n1JL1iC5025546@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-19 22:01:44 +0100 (Thu, 19 Feb 2009)
New Revision: 520

Modified:
   trunk/gpt/src/GPT.cpp
   trunk/gpt/src/modules/interpreter/InterpreterEval.cpp
   trunk/gpt/src/modules/x86/asm_lib.h
Log:
FIX:
-data do copyright
-Bug na impressao de valores logicos

Modified: trunk/gpt/src/GPT.cpp
===================================================================
--- trunk/gpt/src/GPT.cpp	2009-02-16 01:45:00 UTC (rev 519)
+++ trunk/gpt/src/GPT.cpp	2009-02-19 21:01:44 UTC (rev 520)
@@ -111,7 +111,7 @@
   s << "GPT - Compilador G-Portugol\n"
           "Vers?o  : " << VERSION << "\n"
           "Website : http://gpt.berlios.de\n"
-          "Copyright (C) 2003-2006 Thiago Silva <tsilva at sourcecraft.info>\n\n";
+          "Copyright (C) 2003-2009 Thiago Silva <tsilva at sourcecraft.info>\n\n";
   GPTDisplay::self()->showMessage(s);
 }
 

Modified: trunk/gpt/src/modules/interpreter/InterpreterEval.cpp
===================================================================
--- trunk/gpt/src/modules/interpreter/InterpreterEval.cpp	2009-02-16 01:45:00 UTC (rev 519)
+++ trunk/gpt/src/modules/interpreter/InterpreterEval.cpp	2009-02-19 21:01:44 UTC (rev 520)
@@ -845,9 +845,9 @@
         break;
       case TIPO_LOGICO:
         if(atoi((*it).value.c_str())) {
-          s << "verdadeiro";
+          cout << "verdadeiro";
         } else {
-          s << "falso";
+          cout << "falso";
         }
         break;
       case TIPO_LITERAL:

Modified: trunk/gpt/src/modules/x86/asm_lib.h
===================================================================
--- trunk/gpt/src/modules/x86/asm_lib.h	2009-02-16 01:45:00 UTC (rev 519)
+++ trunk/gpt/src/modules/x86/asm_lib.h	2009-02-19 21:01:44 UTC (rev 520)
@@ -36,6 +36,9 @@
 "    cmp ebx, 's'\n"
 "    je .imp_literal\n"
 "    \n"
+"    cmp ebx, 'l'\n"
+"    je .imp_logico\n"
+"    \n"
 "    jmp .footer\n"
 "\n"
 "      .imp_inteiro:\n"



From gpt-commit-noreply at mail.berlios.de  Sat Feb 21 18:50:35 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 21 Feb 2009 18:50:35 +0100
Subject: [gpt-commit] r521 - trunk/gpt/src/modules/interpreter
Message-ID: <200902211750.n1LHoZGJ026184@sheep.berlios.de>

Author: adorilson
Date: 2009-02-21 18:49:59 +0100 (Sat, 21 Feb 2009)
New Revision: 521

Modified:
   trunk/gpt/src/modules/interpreter/InterpreterEval.cpp
Log:
- Correcao do bug #83 (mantis) para o interpretador (impressao de tipo literal)


Modified: trunk/gpt/src/modules/interpreter/InterpreterEval.cpp
===================================================================
--- trunk/gpt/src/modules/interpreter/InterpreterEval.cpp	2009-02-19 21:01:44 UTC (rev 520)
+++ trunk/gpt/src/modules/interpreter/InterpreterEval.cpp	2009-02-21 17:49:59 UTC (rev 521)
@@ -851,7 +851,11 @@
         }
         break;
       case TIPO_LITERAL:
-        cout << (*it).value;
+      	if(!(*it).value.empty()) {	
+          cout << (*it).value.c_str();
+        } else {
+          cout << "(nulo)";
+        }
         break;
       default:
         cout << (*it).value;



From gpt-commit-noreply at mail.berlios.de  Sat Feb 21 20:01:37 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 21 Feb 2009 20:01:37 +0100
Subject: [gpt-commit] r522 - trunk/gpt
Message-ID: <200902211901.n1LJ1bLU000704@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-21 20:01:37 +0100 (Sat, 21 Feb 2009)
New Revision: 522

Modified:
   trunk/gpt/gpt.kdevelop
Log:
nomsg

Modified: trunk/gpt/gpt.kdevelop
===================================================================
--- trunk/gpt/gpt.kdevelop	2009-02-21 17:49:59 UTC (rev 521)
+++ trunk/gpt/gpt.kdevelop	2009-02-21 19:01:37 UTC (rev 522)
@@ -1,5 +1,4 @@
 <?xml version = '1.0'?>
-
 <kdevelop>
   <general>
     <author>Thiago Silva</author>
@@ -16,6 +15,8 @@
     <projectdirectory>.</projectdirectory>
     <absoluteprojectpath>false</absoluteprojectpath>
     <description></description>
+    <projectname>gpt</projectname>
+    <defaultencoding></defaultencoding>
   </general>
   <kdevautoproject>
     <general>
@@ -23,16 +24,21 @@
       <useconfiguration>debug</useconfiguration>
     </general>
     <run>
-      <mainprogram>src/gpt</mainprogram>
+      <mainprogram>/home/tsilva/src/gpt/gpt/debug/src/gpt</mainprogram>
       <terminal>false</terminal>
       <directoryradio>executable</directoryradio>
       <customdirectory>/</customdirectory>
-      <programargs/>
+      <programargs>-i ../exemplos/olamundo.gpt</programargs>
       <autocompile>true</autocompile>
       <envvars/>
       <runarguments>
         <gpt/>
       </runarguments>
+      <globaldebugarguments>-i ../exemplos/olamundo.gpt</globaldebugarguments>
+      <globalcwd>/home/tsilva/src/gpt/gpt/debug</globalcwd>
+      <useglobalprogram>true</useglobalprogram>
+      <autoinstall>false</autoinstall>
+      <autokdesu>false</autokdesu>
     </run>
     <configurations>
       <optimized>
@@ -61,15 +67,13 @@
       </debug>
     </configurations>
     <make>
-      <envvars>
-        <envvar value="1" name="WANT_AUTOCONF_2_5" />
-        <envvar value="1" name="WANT_AUTOMAKE_1_6" />
-      </envvars>
+      <envvars/>
       <abortonerror>true</abortonerror>
-      <numberofjobs>1</numberofjobs>
+      <numberofjobs>3</numberofjobs>
       <dontact>false</dontact>
-      <makebin/>
+      <makebin></makebin>
       <prio>0</prio>
+      <runmultiplejobs>true</runmultiplejobs>
     </make>
   </kdevautoproject>
   <kdevdoctreeview>
@@ -170,11 +174,31 @@
       <codeCompletionDelay>250</codeCompletionDelay>
       <argumentsHintDelay>400</argumentsHintDelay>
       <headerCompletionDelay>250</headerCompletionDelay>
+      <showOnlyAccessibleItems>false</showOnlyAccessibleItems>
+      <completionBoxItemOrder>0</completionBoxItemOrder>
+      <howEvaluationContextMenu>true</howEvaluationContextMenu>
+      <showCommentWithArgumentHint>true</showCommentWithArgumentHint>
+      <statusBarTypeEvaluation>false</statusBarTypeEvaluation>
+      <namespaceAliases>std=_GLIBCXX_STD;__gnu_cxx=std</namespaceAliases>
+      <processPrimaryTypes>true</processPrimaryTypes>
+      <processFunctionArguments>false</processFunctionArguments>
+      <preProcessAllHeaders>false</preProcessAllHeaders>
+      <parseMissingHeadersExperimental>false</parseMissingHeadersExperimental>
+      <resolveIncludePathsUsingMakeExperimental>false</resolveIncludePathsUsingMakeExperimental>
+      <alwaysParseInBackground>true</alwaysParseInBackground>
+      <usePermanentCaching>true</usePermanentCaching>
+      <alwaysIncludeNamespaces>false</alwaysIncludeNamespaces>
+      <includePaths>.;</includePaths>
     </codecompletion>
     <qt>
       <used>false</used>
       <version>3</version>
       <root>/usr/lib/qt</root>
+      <includestyle>3</includestyle>
+      <designerintegration>EmbeddedKDevDesigner</designerintegration>
+      <qmake></qmake>
+      <designer></designer>
+      <designerpluginpaths/>
     </qt>
     <creategettersetter>
       <prefixGet></prefixGet>
@@ -184,6 +208,11 @@
       <inlineGet>true</inlineGet>
       <inlineSet>true</inlineSet>
     </creategettersetter>
+    <splitheadersource>
+      <enabled>false</enabled>
+      <synchronize>true</synchronize>
+      <orientation>Vertical</orientation>
+    </splitheadersource>
   </kdevcppsupport>
   <cppsupportpart>
     <filetemplates>
@@ -202,6 +231,7 @@
       <breakonloadinglibs>true</breakonloadinglibs>
       <separatetty>false</separatetty>
       <floatingtoolbar>false</floatingtoolbar>
+      <raiseGDBOnStart>false</raiseGDBOnStart>
     </general>
     <display>
       <staticmembers>false</staticmembers>



From gpt-commit-noreply at mail.berlios.de  Sat Feb 21 22:26:15 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 21 Feb 2009 22:26:15 +0100
Subject: [gpt-commit] r523 - trunk/gpt/src/modules/x86
Message-ID: <200902212126.n1LLQFST020721@sheep.berlios.de>

Author: adorilson
Date: 2009-02-21 22:26:05 +0100 (Sat, 21 Feb 2009)
New Revision: 523

Modified:
   trunk/gpt/src/modules/x86/X86.cpp
   trunk/gpt/src/modules/x86/asm_lib.h
Log:
- Correcao do bug #83 (ver mantis) para a versao compilada (impressao de tipo literal)


Modified: trunk/gpt/src/modules/x86/X86.cpp
===================================================================
--- trunk/gpt/src/modules/x86/X86.cpp	2009-02-21 19:01:37 UTC (rev 522)
+++ trunk/gpt/src/modules/x86/X86.cpp	2009-02-21 21:26:05 UTC (rev 523)
@@ -186,6 +186,7 @@
             "    aux2            dd 0\n"
             "    str_true        db 'verdadeiro',0\n"
             "    str_false       db 'falso',0\n"
+            "    str_null        db '(nulo)',0\n"
             "    str_no_mem_left db 'N?o foi poss?vel alocar mem?ria.',0\n\n";
 
 

Modified: trunk/gpt/src/modules/x86/asm_lib.h
===================================================================
--- trunk/gpt/src/modules/x86/asm_lib.h	2009-02-21 19:01:37 UTC (rev 522)
+++ trunk/gpt/src/modules/x86/asm_lib.h	2009-02-21 21:26:05 UTC (rev 523)
@@ -84,13 +84,18 @@
 "    begin 0\n"
 "\n"
 "    mov eax, [string]\n"
-"    cmp eax, 0\n"
-"    jz .end\n"
+"    cmp eax, ''\n"
+"    jz .imprima_nulo\n"
 "\n"
 "    addarg dword [string]\n"
 "    call print\n"
 "    clargs 1\n"
+"    jmp .end\n"
 "\n"
+"    .imprima_nulo"
+"      addarg dword str_null\n"
+"      call print\n"
+"      clargs 1\n"
 "\n"
 "    .end:\n"
 "      return\n"



From gpt-commit-noreply at mail.berlios.de  Sun Feb 22 01:36:17 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sun, 22 Feb 2009 01:36:17 +0100
Subject: [gpt-commit] r524 - trunk/gpt/src/modules/parser
Message-ID: <200902220036.n1M0aHYw015740@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-22 01:36:16 +0100 (Sun, 22 Feb 2009)
New Revision: 524

Modified:
   trunk/gpt/src/modules/parser/lexer.g
Log:
-correcao de typo em comentario

Modified: trunk/gpt/src/modules/parser/lexer.g
===================================================================
--- trunk/gpt/src/modules/parser/lexer.g	2009-02-21 21:26:05 UTC (rev 523)
+++ trunk/gpt/src/modules/parser/lexer.g	2009-02-22 00:36:16 UTC (rev 524)
@@ -500,7 +500,7 @@
   matched token. if there is, we check for the tokens on tokens{} secion.
   if is a match, we don't do anything, and let the testLiterals do its work.
   Else, it means we have something like "a-b". So we need to rewind to
-  "a", right before the match of '-', synchorinize the current matched text
+  "a", right before the match of '-', synchronize the current matched text
   (wich now is "a-b") to "a", and let it roll again (wich will dispatch
   a token T_IDENTIFIER with text "a", and start again from '-' point).
 */
@@ -584,4 +584,4 @@
         GPTDisplay::self()->add(s.str(), getLine());
       }
     }
-  ;
\ No newline at end of file
+  ;



From gpt-commit-noreply at mail.berlios.de  Sun Feb 22 01:36:47 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sun, 22 Feb 2009 01:36:47 +0100
Subject: [gpt-commit] r525 - trunk/gpt/src/modules/c_translator
Message-ID: <200902220036.n1M0aljC018648@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-22 01:36:46 +0100 (Sun, 22 Feb 2009)
New Revision: 525

Modified:
   trunk/gpt/src/modules/c_translator/pt2c.g
Log:
FIX:
-str_comp dando segfault quando argumentos sao nulos
-matriz de literais nao estava sendo inicializada corretamente

Modified: trunk/gpt/src/modules/c_translator/pt2c.g
===================================================================
--- trunk/gpt/src/modules/c_translator/pt2c.g	2009-02-22 00:36:16 UTC (rev 524)
+++ trunk/gpt/src/modules/c_translator/pt2c.g	2009-02-22 00:36:46 UTC (rev 525)
@@ -159,6 +159,7 @@
          "   int *d;\n"
          "   double* f;\n"
          "   char* c;\n"
+         "   char** s;\n"
          "   boolean* b;\n"          
          "   switch(type) {\n"
          "     case 'i':\n"
@@ -173,6 +174,10 @@
          "       c = (char*) matrix;\n"
          "       for(i = 0; i < size; i++) c[i] = 0;\n"
          "       break;\n"
+         "     case 's':\n"
+         "       s = (char**) matrix;\n"
+         "       for(i = 0; i < size; i++) s[i] = 0;\n"
+         "       break;\n"
          "     case 'b':\n"
          "       b = (boolean*) matrix;\n"
          "       for(i = 0; i < size; i++) b[i] = 0;\n"
@@ -267,6 +272,12 @@
          "   return TRUE;\n"
          "}\n";
     s << "boolean str_comp(char* left, char* right) {\n"
+         "   if (!left && !right) {\n"
+         "      return TRUE;\n"
+         "   }\n"
+         "   if (!left || !right) {\n"
+         "      return FALSE;\n"
+         "   }\n"
          "   if(str_strlen(left) != str_strlen(right)) {\n"
          "     return FALSE;\n"
          "   }\n"
@@ -507,8 +518,9 @@
                   case TIPO_REAL:
                     init << "'f', ";break;
                   case TIPO_CARACTERE:
+                    init << "'c', ";break;
                   case TIPO_LITERAL:
-                    init << "'c', ";break;      
+                    init << "'s', ";break;      
                   case TIPO_LOGICO:
                     init << "'b', ";break;
                 }
@@ -931,7 +943,7 @@
                   case TIPO_CARACTERE:
                     cpy << "'c', ";break;
                   case TIPO_LITERAL:
-                    cpy << "'s', ";break;      
+                    cpy << "'s', ";break;
                   case TIPO_LOGICO:
                     cpy << "'b', ";break;
                 }



From gpt-commit-noreply at mail.berlios.de  Sun Feb 22 01:37:16 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sun, 22 Feb 2009 01:37:16 +0100
Subject: [gpt-commit] r526 - trunk/gpt/src/modules/x86
Message-ID: <200902220037.n1M0bGMo022173@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-22 01:37:16 +0100 (Sun, 22 Feb 2009)
New Revision: 526

Modified:
   trunk/gpt/src/modules/x86/x86.g
Log:
FIX:
-label de enquanto faltando o ':' ao final

Modified: trunk/gpt/src/modules/x86/x86.g
===================================================================
--- trunk/gpt/src/modules/x86/x86.g	2009-02-22 00:36:46 UTC (rev 525)
+++ trunk/gpt/src/modules/x86/x86.g	2009-02-22 00:37:16 UTC (rev 526)
@@ -415,7 +415,7 @@
   string lbfim = x86.createLabel(true, "fim_enquanto");;
 
   s << lbenq << ":";
-  x86.writeTEXT(lbenq);
+  x86.writeTEXT(s.str());
   s.str("");
 
   x86.writeTEXT("; while: expressao");



From gpt-commit-noreply at mail.berlios.de  Sun Feb 22 01:53:05 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sun, 22 Feb 2009 01:53:05 +0100
Subject: [gpt-commit] r527 - trunk/gpt/test
Message-ID: <200902220053.n1M0r5Bi027699@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-22 01:53:04 +0100 (Sun, 22 Feb 2009)
New Revision: 527

Modified:
   trunk/gpt/test/tester.gpt
Log:
codificacao parece que tava zoada

Modified: trunk/gpt/test/tester.gpt
===================================================================
--- trunk/gpt/test/tester.gpt	2009-02-22 00:37:16 UTC (rev 526)
+++ trunk/gpt/test/tester.gpt	2009-02-22 00:53:04 UTC (rev 527)
@@ -3,16 +3,16 @@
 
 algoritmo tester;
 
-vari?veis
+vari??veis
   i : inteiro;
   r : real;
-  l : l?gico;
+  l : l??gico;
   c : caractere;
   str : literal;  
   mat: matriz[2] de inteiros;
-fim-vari?veis
+fim-vari??veis
 
-in?cio
+in??cio
   testar_inicializacao();
   testar_expr_aritm();
   testar_expr_log();
@@ -32,287 +32,287 @@
 
 fim
 
-fun??o testar_inicializacao()
+fun????o testar_inicializacao()
   local : inteiro;
-in?cio
-  se i <> 0 ent?o
+in??cio
+  se i <> 0 ent??o
     imprima("testar_inicializacao: i <> 0");
   fim-se
 
-  se r <> 0 ent?o
+  se r <> 0 ent??o
     imprima("testar_inicializacao: r <> 0");
   fim-se
 
-  se r <> 0.0 ent?o
+  se r <> 0.0 ent??o
     imprima("testar_inicializacao: r <> 0.0");
   fim-se
 
-  se l <> 0 ent?o 
+  se l <> 0 ent??o 
     imprima("testar_inicializacao: l <> 0");
   fim-se
 
-  se l <> falso ent?o
+  se l <> falso ent??o
     imprima("testar_inicializacao: l <> falso");
   fim-se
 
-  se str <> "" ent?o
+  se str <> "" ent??o
     imprima("testar_inicializacao: str <> \"\"");
   fim-se
 
-  se local <> 0 ent?o
+  se local <> 0 ent??o
     imprima("testar_inicializacao: local <> 0");
   fim-se
 
-  para local de 0 at? 1 fa?a  
-    se mat[local] <> 0 ent?o
+  para local de 0 at?? 1 fa??a  
+    se mat[local] <> 0 ent??o
       imprima("testar_inicializacao: mat[",local,"] <> 0");
     fim-se
   fim-para
 
-  se local <> 1 ent?o
+  se local <> 1 ent??o
     imprima("testar_inicializacao: local <> 2");
   fim-se  
 fim
 
-fun??o testar_expr_aritm()
-in?cio
+fun????o testar_expr_aritm()
+in??cio
 
-  se verdadeiro ent?o
+  se verdadeiro ent??o
     //
-  sen?o
+  sen??o
     imprima("testar_expr_aritm: se verdadeiro");
   fim-se
 
-  se falso ent?o
+  se falso ent??o
     imprima("testar_expr_aritm: se falso");
   fim-se
 
-  se n?o verdadeiro ent?o
-    imprima("testar_expr_aritm: se n?o verdadeiro");
+  se n??o verdadeiro ent??o
+    imprima("testar_expr_aritm: se n??o verdadeiro");
   fim-se
     
-  se 2 + 2 ent?o
+  se 2 + 2 ent??o
     //ok
-  sen?o  
+  sen??o  
     imprima("testar_expr_aritm: 2 + 2");
   fim-se
 
-  se 2 - 2 ent?o
+  se 2 - 2 ent??o
     imprima("testar_expr_aritm: 2 - 2");
   fim-se
 
-  se 2 + 2 <> 4 ent?o
+  se 2 + 2 <> 4 ent??o
     imprima("testar_expr_aritm: 2 + 2 <> 4");
   fim-se
 
-  se n?o (2 - 2) ent?o
+  se n??o (2 - 2) ent??o
     //
-  sen?o
-    imprima("testar_expr_aritm: se n?o (2-2)");  
+  sen??o
+    imprima("testar_expr_aritm: se n??o (2-2)");  
   fim-se
 
-  se 10 + 2 * 3 <> 16 ent?o
+  se 10 + 2 * 3 <> 16 ent??o
     imprima("testar_expr_aritm: 10 + 2 * 3 <> 16");
   fim-se
   
-  se 10 + 2 * 3 - 12 / 3 <> 12 ent?o
+  se 10 + 2 * 3 - 12 / 3 <> 12 ent??o
     imprima("testar_expr_aritm: 10 + 2 * 3 - 12 / 3 <> 12");
   fim-se
 
-  se (10 + 2) * (12 - 10) / 3 <> 8 ent?o
+  se (10 + 2) * (12 - 10) / 3 <> 8 ent??o
     imprima("testar_expr_aritm: (10 + 2) * (12 - 10) / 3 <> 8");
   fim-se
   
-  se 0b101 <> 5 ent?o
+  se 0b101 <> 5 ent??o
     imprima("testar_expr_aritm: 0b101 <> 5");
   fim-se
 
-  se 0xA <> 10 ent?o
+  se 0xA <> 10 ent??o
     imprima("testar_expr_aritm: 0xA <> 10");
   fim-se
 
-  se 0c10 <> 8 ent?o
+  se 0c10 <> 8 ent??o
     imprima("testar_expr_aritm: 0c10 <> 8");
   fim-se
 
-  se 10 * -1 <> -10 ent?o
+  se 10 * -1 <> -10 ent??o
     imprima("testar_expr_aritm: 10 * -1 <> -10");
   fim-se
 
-  se 10 - 5.5 <> 4.5 ent?o
+  se 10 - 5.5 <> 4.5 ent??o
     imprima("testar_expr_aritm: 10 - 5.5 <> 4.5");
   fim-se
 
-  se 5.5 - 1 <> 4.5 ent?o
+  se 5.5 - 1 <> 4.5 ent??o
     imprima("testar_expr_aritm: 5.5 - 1 <> 4.5");
   fim-se
 
-  se 5.5 * 2 <> 11 ent?o
+  se 5.5 * 2 <> 11 ent??o
     imprima("testar_expr_aritm: 5.5 * 2 <> 11");
   fim-se
 
-  se 2 * 5.5  <> 11 ent?o
+  se 2 * 5.5  <> 11 ent??o
     imprima("testar_expr_aritm: 2 * 5.5  <> 11");
   fim-se
 
-  se 1 + 2 * 5.5  <> 12 ent?o
+  se 1 + 2 * 5.5  <> 12 ent??o
     imprima("testar_expr_aritm: 1 + 2 * 5.5  <> 12");
   fim-se
 
-  se 1 + 5.5 * 2 <> 12 ent?o
+  se 1 + 5.5 * 2 <> 12 ent??o
     imprima("testar_expr_aritm: 1 + 5.5 * 2 <> 12");
   fim-se
 
-  se 5 / 2 <> 2 ent?o
+  se 5 / 2 <> 2 ent??o
     imprima("testar_expr_aritm: 5 / 2 <> 2");
   fim-se
   
-  se 5.0 / 2 <> 2.5 ent?o
+  se 5.0 / 2 <> 2.5 ent??o
     imprima("testar_expr_aritm: 5.0 / 2 <> 2.5");
   fim-se
 
-  se 1 + 5.0 / 2 <> 3.5 ent?o
+  se 1 + 5.0 / 2 <> 3.5 ent??o
     imprima("testar_expr_aritm: 1 + 5.0 / 2 <> 3.5");
   fim-se
 
-  se 1 > 2 ent?o
+  se 1 > 2 ent??o
     imprima("testar_expr_aritm: 1 > 2");
   fim-se
 
-  se 1 >= 2 ent?o
+  se 1 >= 2 ent??o
     imprima("testar_expr_aritm: 1 >= 2");
   fim-se
 
-  se 1 >= 1 ent?o
-  sen?o
+  se 1 >= 1 ent??o
+  sen??o
     imprima("testar_expr_aritm: 1 >= 1");
   fim-se
 
-  se 2 < 1 ent?o
+  se 2 < 1 ent??o
     imprima("testar_expr_aritm: 2 < 1");
   fim-se
 
-  se 2 <= 1 ent?o
+  se 2 <= 1 ent??o
     imprima("testar_expr_aritm: 2 <= 1");
   fim-se
 
-  se 2 <= 2 ent?o
-  sen?o
+  se 2 <= 2 ent??o
+  sen??o
     imprima("testar_expr_aritm: 2 <= 1");
   fim-se
 
 fim
 
-fun??o testar_expr_log()
-in?cio
-  se verdadeiro e verdadeiro ent?o
-  sen?o
+fun????o testar_expr_log()
+in??cio
+  se verdadeiro e verdadeiro ent??o
+  sen??o
     imprima("testar_expr_log: verdadeiro e verdadeiro");
   fim-se
 
-  se verdadeiro e falso ent?o
+  se verdadeiro e falso ent??o
     imprima("testar_expr_log: verdadeiro e falso");
   fim-se
 
-  se falso e verdadeiro ent?o
+  se falso e verdadeiro ent??o
     imprima("testar_expr_log: falso e verdadeiro");
   fim-se
 
-  se falso e falso ent?o
+  se falso e falso ent??o
     imprima("testar_expr_log: falso e falso");
   fim-se
 
-  se verdadeiro ou verdadeiro ent?o
-  sen?o
+  se verdadeiro ou verdadeiro ent??o
+  sen??o
     imprima("testar_expr_log: verdadeiro ou verdadeiro");
   fim-se
 
-  se verdadeiro ou falso ent?o
-  sen?o
+  se verdadeiro ou falso ent??o
+  sen??o
     imprima("testar_expr_log: verdadeiro ou falso");
   fim-se
 
-  se falso ou verdadeiro ent?o
-  sen?o
+  se falso ou verdadeiro ent??o
+  sen??o
     imprima("testar_expr_log: falso ou verdadeiro");
   fim-se
 
-  se falso ou falso ent?o
+  se falso ou falso ent??o
     imprima("testar_expr_log: falso ou falso");
   fim-se
 
 
   //not
-  se n?o (verdadeiro e verdadeiro) ent?o
-    imprima("testar_expr_log: n?o verdadeiro e verdadeiro");
+  se n??o (verdadeiro e verdadeiro) ent??o
+    imprima("testar_expr_log: n??o verdadeiro e verdadeiro");
   fim-se
 
-  se n?o (verdadeiro e falso) ent?o
-  sen?o
-    imprima("testar_expr_log: n?o verdadeiro e falso");
+  se n??o (verdadeiro e falso) ent??o
+  sen??o
+    imprima("testar_expr_log: n??o verdadeiro e falso");
   fim-se
 
-  se n?o (falso e verdadeiro) ent?o
-  sen?o
-    imprima("testar_expr_log: n?o falso e verdadeiro");
+  se n??o (falso e verdadeiro) ent??o
+  sen??o
+    imprima("testar_expr_log: n??o falso e verdadeiro");
   fim-se
 
-  se n?o (falso e falso) ent?o
-  sen?o
-    imprima("testar_expr_log: n?o falso e falso");
+  se n??o (falso e falso) ent??o
+  sen??o
+    imprima("testar_expr_log: n??o falso e falso");
   fim-se
 
-  se n?o (verdadeiro ou verdadeiro) ent?o
-    imprima("testar_expr_log: n?o verdadeiro ou verdadeiro");
+  se n??o (verdadeiro ou verdadeiro) ent??o
+    imprima("testar_expr_log: n??o verdadeiro ou verdadeiro");
   fim-se
 
-  se n?o (verdadeiro ou falso) ent?o
-    imprima("testar_expr_log: n?o verdadeiro ou falso");
+  se n??o (verdadeiro ou falso) ent??o
+    imprima("testar_expr_log: n??o verdadeiro ou falso");
   fim-se
 
-  se n?o (falso ou verdadeiro) ent?o
-    imprima("testar_expr_log: n?o falso ou verdadeiro");
+  se n??o (falso ou verdadeiro) ent??o
+    imprima("testar_expr_log: n??o falso ou verdadeiro");
   fim-se
 
-  se n?o (falso ou falso) ent?o
-  sen?o
-    imprima("testar_expr_log: n?o falso ou falso");
+  se n??o (falso ou falso) ent??o
+  sen??o
+    imprima("testar_expr_log: n??o falso ou falso");
   fim-se
 
   //operadores binarios &, |, ^
 
-  se (5 & 0b100) <> 4 ent?o
+  se (5 & 0b100) <> 4 ent??o
     imprima("testar_expr_log: 5 & 0b100 <> 4");
   fim-se
 
   //<> maior precedencia que |
-  se 0b101 | 2 <> 7 ent?o
-  sen?o
+  se 0b101 | 2 <> 7 ent??o
+  sen??o
     imprima("testar_expr_log: 0b101 | 2 <> 7");
   fim-se
 
-  se (0b101 | 2) <> 7 ent?o
+  se (0b101 | 2) <> 7 ent??o
     imprima("testar_expr_log: 0b101 | 2 <> 7");
   fim-se
 
-  se (0b1011 ^ 0b0101) <> 14 ent?o
+  se (0b1011 ^ 0b0101) <> 14 ent??o
     imprima("testar_expr_log: (0b1011 ^ 0b0101) <> 14");
   fim-se
 
-  se ~4 <> -5 ent?o
+  se ~4 <> -5 ent??o
     imprima("testar_expr_log: ~4 <> -5");
   fim-se
 fim
 
 
-fun??o testar_matriz_carac()
+fun????o testar_matriz_carac()
   gg: matriz[2][3] de caracteres;
   i,j: inteiro;
-in?cio  
+in??cio  
 
-  para i de 0 at? 1 fa?a
-    para j de 0 at? 2 fa?a      
-      se gg[i][j] <> '' ou  gg[i][j] <> 0 ent?o
+  para i de 0 at?? 1 fa??a
+    para j de 0 at?? 2 fa??a      
+      se gg[i][j] <> '' ou  gg[i][j] <> 0 ent??o
         imprima("testar_matriz_carac: gg[i][j] <> \"\"");
       fim-se
       c := c + 1;
@@ -329,12 +329,12 @@
   matriz_carac_func(gg);
 fim
 
-fun??o matriz_carac_func(qq: matriz[2][3] de caracteres)
+fun????o matriz_carac_func(qq: matriz[2][3] de caracteres)
   cp : matriz[6] de caracteres;
   i : inteiro;
   j : inteiro;
   c : inteiro;
-in?cio  
+in??cio  
   cp[0] := 'a';
   cp[1] := 'b';
   cp[2] := 'c';
@@ -342,9 +342,9 @@
   cp[4] := 'e';
   cp[5] := 'f';
 
-  para i de 0 at? 1 fa?a
-    para j de 0 at? 2 fa?a      
-      se qq[i][j] <> cp[c] ent?o        
+  para i de 0 at?? 1 fa??a
+    para j de 0 at?? 2 fa??a      
+      se qq[i][j] <> cp[c] ent??o        
         imprima("matriz_carac_func: qq[i][j] <> cp[c]");
       fim-se
       c := c + 1;
@@ -353,15 +353,15 @@
 
 fim
 
-fun??o testar_matriz_literais()
+fun????o testar_matriz_literais()
   gg : matriz[2][3] de literais;
   i,j: inteiro;
-in?cio
+in??cio
 
-  para i de 0 at? 1 fa?a
-    para j de 0 at? 2 fa?a
-      se gg[i][j] <> "" ent?o
-        imprima("testar_matriz_literais: gg[i][j] <> \"\"");
+  para i de 0 at?? 1 fa??a
+    para j de 0 at?? 2 fa??a
+      se gg[i][j] <> "" ent??o
+        imprima("testar_matriz_literais: gg[",i,"][",j,"] <> \"\"");
       fim-se
       c := c + 1;
     fim-para
@@ -377,12 +377,12 @@
   matriz_lit_func(gg);
 fim
 
-fun??o matriz_lit_func(qq: matriz[2][3] de literais)
+fun????o matriz_lit_func(qq: matriz[2][3] de literais)
   cp : matriz[6] de literais;
   i : inteiro;
   j : inteiro;
   c : inteiro;
-in?cio
+in??cio
   cp[0] := "oi1";
   cp[1] := "oi2";
   cp[2] := "oi3";
@@ -390,9 +390,9 @@
   cp[4] := "oi5";
   cp[5] := "oi6";
 
-  para i de 0 at? 1 fa?a
-    para j de 0 at? 2 fa?a
-      se qq[i][j] <> cp[c] ent?o
+  para i de 0 at?? 1 fa??a
+    para j de 0 at?? 2 fa??a
+      se qq[i][j] <> cp[c] ent??o
         imprima("testar_matriz_literais: qq[i][j] <> cp[c]");
       fim-se
       c := c + 1;
@@ -401,80 +401,80 @@
 
 fim
 
-fun??o testar_enquanto()
+fun????o testar_enquanto()
   local : inteiro;
   z : inteiro;
-in?cio
+in??cio
 
-  enquanto n?o local fa?a
+  enquanto n??o local fa??a
     
-    se z = 0 ent?o
+    se z = 0 ent??o
       z := 1;    
     fim-se
   
-    se z = 1 ent?o
+    se z = 1 ent??o
       local := 1;
     fim-se
   fim-enquanto
 
-  se local <> 1 ou z <> 1 ent?o
+  se local <> 1 ou z <> 1 ent??o
     imprima("testar_enquanto: local <> 1 e z <> 1");
   fim-se
 fim
 
-fun??o testar_para()
+fun????o testar_para()
   str : inteiro; //shadow global str
   g : inteiro;
-in?cio
+in??cio
 
-  para str de 0 at? 4 fa?a
+  para str de 0 at?? 4 fa??a
     g := g + str;
   fim-para
 
-  se g <> 10 ou str <> 4 ent?o
+  se g <> 10 ou str <> 4 ent??o
     imprima("testar_para: g <> 10 ou str <> 4");
   fim-se
 
   g := 0;
-  para str de 0 at? 10 passo 2 fa?a
+  para str de 0 at?? 10 passo 2 fa??a
     g := g + str;
   fim-para
 
-  se g <> 30 ou str <> 10 ent?o
+  se g <> 30 ou str <> 10 ent??o
     imprima("testar_para: g <> 30 ou str <> 10");
   fim-se
   
   g := 30;
-  para str de 10 at? 0 passo -2 fa?a
+  para str de 10 at?? 0 passo -2 fa??a
     g := g - str;
   fim-para  
 
-  se g <> 0 ou str <> 0 ent?o
+  se g <> 0 ou str <> 0 ent??o
     imprima("testar_para: g <> 0 ou str <> 0");
   fim-se
 fim
 
 
 
-fun??o testar_funcoes()
+fun????o testar_funcoes()
   lit : literal;
   mm  : matriz[2] de inteiros;
   i : inteiro;
   r : real;
-in?cio
+in??cio
   mm[0] := -7;
   mm[1] := -8;
 
   lit := f(13, 5.5, mm, 'a');
-  se lit <> "ok" ent?o
+  se lit <> "ok" ent??o
     imprima("testar_funcoes: lit <> \"oi\"");
   fim-se
 
-  se mm[0] = 99 ent?o
+  se mm[0] = 99 ent??o
     imprima("testar_funcoes: mm[0] = 99");
   fim-se
 
-  se mm[0] <> -7 ent?o
+  se mm[0] <> -7 ent??o
     imprima("testar_funcoes: mm[0] <> -7");
   fim-se
 
@@ -482,24 +482,24 @@
   mm[1] := 0;
   lit := f(1,0, mm, 0);
 
-  se lit <> "ret" ent?o
+  se lit <> "ret" ent??o
     imprima("testar_funcoes: lit <> \"ret\"");
   fim-se
 
   r := f2(2.6);
 
   i := r + 0.5;
-  se i <> 6 ent?o
+  se i <> 6 ent??o
     imprima("testar_funcoes: i <> 6");
   fim-se
 
   i := f2(2.6);
-  se i <> 5 ent?o
+  se i <> 5 ent??o
     imprima("testar_funcoes: i <> 5");
   fim-se
 
   r := f3();
-  se r <> 99 ent?o
+  se r <> 99 ent??o
     imprima("testar_funcoes: r <> 99");
   fim-se
 
@@ -507,16 +507,16 @@
   f4(2);
 fim
 
-fun??o f(x:inteiro, r:real, m: matriz[2] de inteiros, c: caractere) : literal
+fun????o f(x:inteiro, r:real, m: matriz[2] de inteiros, c: caractere) : literal
   count : inteiro;
-in?cio
+in??cio
   count := x + r + m[0] + m[1] + c + 0.5;
   
-  se count = 1 ent?o
+  se count = 1 ent??o
     retorne "ret";
   fim-se
     
-  se count <> 101 ent?o
+  se count <> 101 ent??o
     imprima("f: count <> 101");
   fim-se
 
@@ -525,23 +525,23 @@
   retorne "ok";
 fim
 
-fun??o f2(x: inteiro) : real
-in?cio
-  se x <> 2 ent?o
+fun????o f2(x: inteiro) : real
+in??cio
+  se x <> 2 ent??o
     imprima("f2: x <> 2");
   fim-se
 
   retorne 5.6;
 fim
 
-fun??o f3() : inteiro
-in?cio
+fun????o f3() : inteiro
+in??cio
   retorne 99;
 fim
 
-fun??o f4(r:real)
-in?cio
-  se r <> 2 ent?o
+fun????o f4(r:real)
+in??cio
+  se r <> 2 ent??o
     imprima("f4: r <> 2");
   fim-se
 fim



From gpt-commit-noreply at mail.berlios.de  Sun Feb 22 02:43:37 2009
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sun, 22 Feb 2009 02:43:37 +0100
Subject: [gpt-commit] r528 - trunk/gpt/src/modules/x86
Message-ID: <200902220143.n1M1hb3p002555@sheep.berlios.de>

Author: thiago_silva
Date: 2009-02-22 02:43:36 +0100 (Sun, 22 Feb 2009)
New Revision: 528

Modified:
   trunk/gpt/src/modules/x86/X86.cpp
Log:
-substituindo um hack por outro em toReal

Modified: trunk/gpt/src/modules/x86/X86.cpp
===================================================================
--- trunk/gpt/src/modules/x86/X86.cpp	2009-02-22 00:53:04 UTC (rev 527)
+++ trunk/gpt/src/modules/x86/X86.cpp	2009-02-22 01:43:36 UTC (rev 528)
@@ -1024,14 +1024,20 @@
   }
 }
 
+//extrai os bytes que representam um n?mero em ponto flutuante
+//e devolve o inteiro como string
 string X86::toReal(const string& str) {
+  float fvalue = (float) atof(str.c_str());
+  unsigned char *cp = (unsigned char*) &fvalue;
+
+  int i = cp[0]
+    + (cp[1] << 8) 
+    + (cp[2] << 16) 
+    + (cp[3] << 24);
+
   stringstream s;
-  //get the content of a float variable to integer.
-  float fvalue; //sizeof(float) should be 4
-  long  *fvaluep; //sizeof(long) should be 4
-  fvalue = atof(str.c_str());
-  fvaluep = (long*) &fvalue;
-  s << *fvaluep;
+  s << i;
+
   return s.str();
 }
 



