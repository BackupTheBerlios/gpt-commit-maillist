<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-commit] r339 - in trunk/gpt2/src/gptc: . testes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-commit/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r339%20-%20in%20trunk/gpt2/src/gptc%3A%20.%20testes&In-Reply-To=%3C200711080743.lA87hAYd013908%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000012.html">
   <LINK REL="Next"  HREF="000014.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-commit] r339 - in trunk/gpt2/src/gptc: . testes</H1>
    <B>gpt-commit-noreply at mail.berlios.de</B> 
    <A HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r339%20-%20in%20trunk/gpt2/src/gptc%3A%20.%20testes&In-Reply-To=%3C200711080743.lA87hAYd013908%40sheep.berlios.de%3E"
       TITLE="[gpt-commit] r339 - in trunk/gpt2/src/gptc: . testes">gpt-commit-noreply at mail.berlios.de
       </A><BR>
    <I>Thu Nov  8 08:43:10 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000012.html">[gpt-commit] r338 - in trunk/gpt2: . doc src tests
</A></li>
        <LI>Next message: <A HREF="000014.html">[gpt-commit] r340 - trunk/gpt2/src/gptc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: thiago_silva
Date: 2007-11-08 08:43:09 +0100 (Thu, 08 Nov 2007)
New Revision: 339

Added:
   trunk/gpt2/src/gptc/Makefile
   trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp
   trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp
   trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp
   trunk/gpt2/src/gptc/UnicodeCharScanner.hpp
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
   trunk/gpt2/src/gptc/teste.cpp
   trunk/gpt2/src/gptc/testes/
   trunk/gpt2/src/gptc/testes/lex_teste.gpt
   trunk/gpt2/src/gptc/testes/tree_teste.gpt
Log:
-lexer/parser infanto-juvenil
  * refatoracao do lexer em relacao a v1.0
  * parser limpo (sem codigo de tratamento de erros)
  * finalizada a estrutura inicial da AST
  * Faltando da gramatica: enunciado::expressao e en_asm

Added: trunk/gpt2/src/gptc/Makefile
===================================================================
--- trunk/gpt2/src/gptc/Makefile	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/Makefile	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,36 @@
+objects = PortugolLexer.o PortugolParser.o \
+			    MismatchedUnicodeCharException.o teste.o
+
+teste: $(objects)
+	g++ -o teste $(objects) /usr/local/lib/libantlr.a
+
+PortugolLexer.o: PortugolLexer.hpp PortugolLexer.cpp
+	g++ -c PortugolLexer.cpp
+
+PortugolParser.o: PortugolParser.hpp PortugolParser.cpp
+	g++ -c PortugolParser.cpp
+
+MismatchedUnicodeCharException.o:
+	g++ -c MismatchedUnicodeCharException.cpp
+
+teste.o: teste.cpp table.hpp
+	g++ -c teste.cpp
+
+PortugolLexer.hpp PortugolLexer.cpp: lexer.g
+	antlr lexer.g
+
+PortugolParser.hpp PortugolParser.cpp: parser.g
+	antlr parser.g
+
+table.hpp:
+	grep = PortugolTokenTypes.txt &gt; table.hpp
+	sed -i -e 's/([^=]*)//' table.hpp
+	sed -i -e 's/&quot;[^&quot;]*&quot;//' table.hpp
+	sed -i -e 's/==/=/' table.hpp
+	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]=&quot;\1&quot;;/' table.hpp
+
+
+clean:
+	rm -f *.o PortugolLexer.cpp PortugolLexer.hpp PortugolTokenTypes.hpp \
+	PortugolTokenTypes.txt PortugolParser.cpp PortugolParser.hpp teste \
+	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp

Added: trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,110 @@
+
+#include &lt;iostream&gt;
+
+#include &lt;antlr/config.hpp&gt;
+#include &lt;antlr/RecognitionException.hpp&gt;
+#include &lt;antlr/BitSet.hpp&gt;
+#include &lt;antlr/String.hpp&gt;
+#include &quot;MismatchedUnicodeCharException.hpp&quot;
+#include &quot;UnicodeCharScanner.hpp&quot;
+
+
+MismatchedUnicodeCharException::MismatchedUnicodeCharException()
+: RecognitionException(&quot;Mismatched char&quot;)
+{
+}
+
+// Expected range / not range
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	char_type lower,
+	char_type up,
+	bool matchNot,
+	UnicodeCharScanner* cs
+)
+: RecognitionException(&quot;Mismatched char&quot;,
+							  cs-&gt;getFilename(),
+							  cs-&gt;getLine(), cs-&gt;getColumn())
+, mismatchType(matchNot ? NOT_RANGE : RANGE)
+, foundChar(c)
+, expecting(lower)
+, upper(up)
+, scanner(cs)
+{
+}
+
+// Expected char / not char
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	char_type expect,
+	bool matchNot,
+	UnicodeCharScanner* cs
+) : RecognitionException(&quot;Mismatched char&quot;,
+                      cs-&gt;getFilename(),
+							 cs-&gt;getLine(), cs-&gt;getColumn())
+, mismatchType(matchNot ? NOT_CHAR : CHAR)
+, foundChar(c)
+, expecting(expect)
+, scanner(cs)
+{
+}
+
+// Expected BitSet / not BitSet
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	antlr::BitSet s,
+	bool matchNot,
+	UnicodeCharScanner* cs
+) : RecognitionException(&quot;Mismatched char&quot;,
+                      cs-&gt;getFilename(),
+							 cs-&gt;getLine(), cs-&gt;getColumn())
+, mismatchType(matchNot ? NOT_SET : SET)
+, foundChar(c)
+, set(s)
+, scanner(cs)
+{
+}
+
+MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
+
+/**
+ * Returns a clean error message (no line number/column information)
+ */
+std::string MismatchedUnicodeCharException::getMessage() const
+{
+	ANTLR_USE_NAMESPACE(std)string s;
+
+	switch (mismatchType) {
+	case CHAR :
+		s += &quot;expecting '&quot; + antlr::charName(expecting) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
+		break;
+	case NOT_CHAR :
+		s += &quot;expecting anything but '&quot; + antlr::charName(expecting) + &quot;'; got it anyway&quot;;
+		break;
+	case RANGE :
+		s += &quot;expecting token in range: '&quot; + antlr::charName(expecting) + &quot;'..'&quot; + antlr::charName(upper) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
+		break;
+	case NOT_RANGE :
+		s += &quot;expecting token NOT in range: &quot; + antlr::charName(expecting) + &quot;'..'&quot; + antlr::charName(upper) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
+		break;
+	case SET :
+	case NOT_SET :
+		{
+			s += ANTLR_USE_NAMESPACE(std)string(&quot;expecting &quot;) + (mismatchType == NOT_SET ? &quot;NOT &quot; : &quot;&quot;) + &quot;one of (&quot;;
+			ANTLR_USE_NAMESPACE(std)vector&lt;unsigned int&gt; elems = set.toArray();
+			for ( unsigned int i = 0; i &lt; elems.size(); i++ )
+			{
+				s += &quot; '&quot;;
+				s += antlr::charName(elems[i]);
+				s += &quot;'&quot;;
+			}
+			s += &quot;), found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
+		}
+		break;
+	default :
+		s += RecognitionException::getMessage();
+		break;
+	}
+
+	return s;
+}

Added: trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,82 @@
+#ifndef INC_MismatchedUnicodeCharException_hpp__
+#define INC_MismatchedUnicodeCharException_hpp__
+
+/* ANTLR Translator Generator
+ * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
+ * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
+ *
+ * $Id:$
+ */
+
+#include &lt;antlr/config.hpp&gt;
+#include &lt;antlr/RecognitionException.hpp&gt;
+#include &lt;antlr/BitSet.hpp&gt;
+#include &lt;antlr/String.hpp&gt;
+
+class UnicodeCharScanner;
+
+class MismatchedUnicodeCharException : public antlr::RecognitionException {
+public:
+	typedef unsigned int char_type;
+	typedef enum {
+		CHAR = 1,
+		NOT_CHAR = 2,
+		RANGE = 3,
+		NOT_RANGE = 4,
+		SET = 5,
+		NOT_SET = 6
+	} MATCH_TYPE;
+
+	MismatchedUnicodeCharException();
+
+	// Expected range / not range
+	MismatchedUnicodeCharException(
+		char_type c,
+		char_type lower,
+		char_type up,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	// Expected char / not char
+	MismatchedUnicodeCharException(
+		char_type c,
+		char_type expect,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	// Expected BitSet / not BitSet
+	MismatchedUnicodeCharException(
+		char_type c,
+		antlr::BitSet s,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	~MismatchedUnicodeCharException() throw();
+
+	/**
+	 * Returns a clean error message (no line number/column information)
+	 */
+	std::string getMessage() const;
+private:
+	// One of the above
+	MATCH_TYPE mismatchType;
+
+	// what was found on the input stream
+	char_type foundChar;
+
+	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
+	char_type expecting;
+
+	// For RANGE/NOT_RANGE (expecting is lower bound of range)
+	char_type upper;
+
+	// For SET/NOT_SET
+	antlr::BitSet set;
+	// who knows...they may want to ask scanner questions
+	UnicodeCharScanner* scanner;
+};
+
+#endif

Added: trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,83 @@
+#ifndef INC_UnicodeCharBuffer_hpp__
+#define INC_UnicodeCharBuffer_hpp__
+
+#include &lt;istream&gt;
+#include &lt;cassert&gt;
+#include &lt;antlr/config.hpp&gt;
+#include &lt;antlr/InputBuffer.hpp&gt;
+#include &lt;antlr/CharStreamIOException.hpp&gt;
+
+class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
+public:
+	typedef unsigned int char_type;	// should be 32 bits!
+
+	/// Create a character buffer
+	UnicodeCharBuffer(std::istream&amp; inp)
+	: input(inp)
+	{
+		//	input.exceptions(std::ios_base::badbit|
+		//						  std::ios_base::failbit);
+	}
+	/// Get the next character from the stream
+	int getChar()
+	{
+		char_type ch = 0;
+		int inchar = input.get();
+		if( inchar == EOF )
+			return -1;
+
+// This is how UTF8 is encoded
+// +---------------------------+----------+----------+----------+----------+
+// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
+// +---------------------------+----------+----------+----------+----------+
+// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
+// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
+// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
+// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
+// +---------------------------+----------+----------+----------+----------+
+
+		if( (inchar &amp; 0x80) == 0 )
+			return inchar;
+
+		unsigned int need = 0;
+		if( (inchar &amp; 0xF8) == 0xF8 )
+		{
+			ch = inchar &amp; 7;
+			need = 3;
+		}
+		else if( (inchar &amp; 0xE0) == 0xE0 )
+		{
+			ch = inchar &amp; 0xF;
+			need = 2;
+		}
+		else if( (inchar &amp; 0xC0) == 0xC0 )
+		{
+			ch = inchar &amp; 0x1F;
+			need = 1;
+		}
+		else
+		{
+			assert(&quot;Invalid UTF8&quot;);
+		}
+		while( need )
+		{
+			inchar = input.get();
+			if( inchar == EOF )
+				assert(&quot;Invalid UTF8&quot;);
+//				throw antlr::CharStreamIOException(std::logic_error());
+			ch &lt;&lt;= 6;
+			ch += inchar &amp; 0x3F;
+			need--;
+		}
+		return ch;
+	}
+private:
+	// character source
+	std::istream&amp; input;
+
+	// NOTE: Unimplemented
+	UnicodeCharBuffer(const UnicodeCharBuffer&amp; other);
+	UnicodeCharBuffer&amp; operator=(const UnicodeCharBuffer&amp; other);
+};
+
+#endif //INC_UnicodeCharBuffer_hpp__

Added: trunk/gpt2/src/gptc/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/src/gptc/UnicodeCharScanner.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/UnicodeCharScanner.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,561 @@
+#ifndef INC_UnicodeCharScanner_hpp__
+#define INC_UnicodeCharScanner_hpp__
+
+#include &lt;map&gt;
+#include &lt;cctype&gt;
+
+#include &lt;antlr/config.hpp&gt;
+#include &lt;antlr/CommonToken.hpp&gt;
+#include &lt;antlr/TokenStream.hpp&gt;
+#include &lt;antlr/RecognitionException.hpp&gt;
+#include &lt;antlr/SemanticException.hpp&gt;
+#include &lt;antlr/InputBuffer.hpp&gt;
+#include &lt;antlr/BitSet.hpp&gt;
+#include &lt;antlr/LexerSharedInputState.hpp&gt;
+
+#include &quot;MismatchedUnicodeCharException.hpp&quot;
+
+/** Superclass of generated lexers
+ */
+class UnicodeCharScanner : public antlr::TokenStream {
+protected:
+	typedef antlr::RefToken (*factory_type)();
+public:
+	typedef int char_type;
+	typedef std::map&lt;std::string,int&gt; string_map;
+
+	UnicodeCharScanner( antlr::InputBuffer&amp; cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( const antlr::LexerSharedInputState&amp; state, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(state)
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
+	}
+
+	virtual ~UnicodeCharScanner()
+	{
+	}
+
+	virtual char_type LA(char_type i)
+	{
+		char_type c = inputState-&gt;getInput().LA(i);
+		return c;
+	}
+
+	virtual void append(char_type c)
+	{
+		if (saveConsumedInput)
+		{
+			size_t len = text.length();
+
+			if( (len % 256) == 0 )
+				text.reserve(len+256);
+
+// This is how UTF8 is encoded
+// +---------------------------+----------+----------+----------+----------+
+// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
+// +---------------------------+----------+----------+----------+----------+
+// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
+// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
+// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
+// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
+// +---------------------------+----------+----------+----------+----------+
+
+			if (c &lt; 0x80)
+			{
+				text += c;
+				return;
+			}
+			else if (c &lt; 0x800)
+			{
+				text += ( (c &gt;&gt; 6) | 0xC0 );
+				text += ( c &amp; 0x3F | 0x80 );
+			}
+			else if (c &lt; 0x10000)
+			{
+				text += ( (c &gt;&gt; 12) | 0xE0 );
+				text += ( ((c &gt;&gt; 6) &amp; 0x3F) | 0x80 );
+				text += ( (c &amp; 0x3F) | 0x80 );
+			}
+			else if (c &lt; 0x200000)
+			{
+				text += ( (c &gt;&gt; 18) | 0xF0 );				// first 3 bits
+				text += ( (((c &gt;&gt; 16) &amp; 0x3) &lt;&lt; 4) |
+								 ((c &gt;&gt; 12) &amp; 0xF) | 0x80 );
+				text += ( ((c &gt;&gt; 6) &amp; 0x3F) | 0x80 );
+				text += ( (c &amp; 0x3F) | 0x80 );
+			}
+			else
+				assert(0);
+		}
+	}
+
+	virtual void append(const std::string&amp; s)
+	{
+		assert(0);
+		if (saveConsumedInput)
+			text+=s;
+	}
+
+	virtual void commit()
+	{
+		inputState-&gt;getInput().commit();
+	}
+
+	virtual void consume()
+	{
+		if (inputState-&gt;guessing == 0)
+		{
+			char_type c = LA(1);
+			append(c);
+			inputState-&gt;column++;
+		}
+		inputState-&gt;getInput().consume();
+	}
+
+	/** Consume chars until one matches the given char */
+	virtual void consumeUntil(char_type c)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast&lt;char_type&gt;(EOF_CHAR) == la_1 || la_1 == c )
+				break;
+			consume();
+		}
+	}
+
+	/** Consume chars until one matches the given set */
+	virtual void consumeUntil(const antlr::BitSet&amp; set)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast&lt;char_type&gt;(EOF_CHAR) == la_1 || set.member(la_1) )
+				break;
+			consume();
+		}
+	}
+
+	/// Mark the current position and return a id for it
+	virtual unsigned int mark()
+	{
+		return inputState-&gt;getInput().mark();
+	}
+
+	/// Rewind the scanner to a previously marked position
+	virtual void rewind(unsigned int pos)
+	{
+		inputState-&gt;getInput().rewind(pos);
+	}
+
+	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
+	virtual void match(char_type c)
+	{
+		char_type la_1 = LA(1);
+		if ( la_1 != c )
+			throw MismatchedUnicodeCharException(la_1, c, false, this);
+		consume();
+	}
+
+	/** See if input contains element from bitset b
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void match(const antlr::BitSet&amp; b)
+	{
+		char_type la_1 = LA(1);
+
+		if ( !b.member(la_1) )
+			throw MismatchedUnicodeCharException( la_1, b, false, this );
+		consume();
+	}
+
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match( const char* s )
+	{
+		while( *s != '\0' )
+		{
+			// the &amp; 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (*s++ &amp; 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match(const std::string&amp; s)
+	{
+		size_t len = s.length();
+
+		for (size_t i = 0; i &lt; len; i++)
+		{
+			// the &amp; 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (s[i] &amp; 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input does not contain character 'c'
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchNot(char_type c)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 == c )
+			throw MismatchedUnicodeCharException(la_1, c, true, this);
+
+		consume();
+	}
+	/** See if input contains character in range c1-c2
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchRange(char_type c1, char_type c2)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 &lt; c1 || la_1 &gt; c2 )
+			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
+
+		consume();
+	}
+
+	/// Get the line the scanner currently is in (starts at 1)
+	virtual int getLine() const
+	{
+		return inputState-&gt;line;
+	}
+
+	/// set the line number
+	virtual void setLine(int l)
+	{
+		inputState-&gt;line = l;
+	}
+
+	/// Get the column the scanner currently is in (starts at 1)
+	virtual int getColumn() const
+	{
+		return inputState-&gt;column;
+	}
+	/// set the column number
+	virtual void setColumn(int c)
+	{
+		inputState-&gt;column = c;
+	}
+
+	/// get the filename for the file currently used
+	virtual const std::string&amp; getFilename() const
+	{
+		return inputState-&gt;filename;
+	}
+	/// Set the filename the scanner is using (used in error messages)
+	virtual void setFilename(const std::string&amp; f)
+	{
+		inputState-&gt;filename = f;
+	}
+
+	virtual bool getCommitToPath() const
+	{
+		return commitToPath;
+	}
+
+	virtual void setCommitToPath(bool commit)
+	{
+		commitToPath = commit;
+	}
+
+	/** return a copy of the current text buffer */
+	virtual const std::string&amp; getText() const
+	{
+		return text;
+	}
+
+	virtual void setText(const std::string&amp; s)
+	{
+		text = s;
+	}
+
+	virtual void resetText()
+	{
+		text = &quot;&quot;;
+		inputState-&gt;tokenStartColumn = inputState-&gt;column;
+		inputState-&gt;tokenStartLine = inputState-&gt;line;
+	}
+
+	virtual antlr::RefToken getTokenObject() const
+	{
+		return _returnToken;
+	}
+
+	///{ These need different handling in unicode case
+
+	virtual bool getCaseSensitiveLiterals() const=0;
+
+	virtual bool getCaseSensitive() const
+	{
+		return caseSensitive;
+	}
+
+	virtual void setCaseSensitive(bool t)
+	{
+		caseSensitive = t;
+	}
+
+	/** Override this method to get more specific case handling
+	 * @note some platforms probably require setting the right locale for
+	 * correct functioning.
+	 */
+	virtual char_type toLower(char_type c) const
+	{
+		return std::tolower(c);
+	}
+
+	/** Used to keep track of line breaks, needs to be called from
+	 * within generated lexers when a \n \r is encountered.
+	 */
+	virtual void newline()
+	{
+		++inputState-&gt;line;
+		inputState-&gt;column = 1;
+	}
+
+	/** Advance the current column number by an appropriate amount according
+	 * to the tabsize. This method needs to be explicitly called from the
+	 * lexer rules encountering tabs.
+	 */
+	virtual void tab()
+	{
+		int c = getColumn();
+		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
+		setColumn( nc );
+	}
+	/// set the tabsize. Returns the old tabsize
+	int setTabsize( int size )
+	{
+		int oldsize = tabsize;
+		tabsize = size;
+		return oldsize;
+	}
+	/// Return the tabsize used by the scanner
+	int getTabSize() const
+	{
+		return tabsize;
+	}
+	///}
+
+	/** Report exception errors caught in nextToken() */
+	virtual void reportError(const antlr::RecognitionException&amp; ex)
+	{
+		std::cerr &lt;&lt; ex.toString().c_str() &lt;&lt; std::endl;
+	}
+
+	/** Parser error-reporting function can be overridden in subclass */
+	virtual void reportError(const std::string&amp; s)
+	{
+		if (getFilename() == &quot;&quot;)
+			std::cerr &lt;&lt; &quot;error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
+		else
+			std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
+	}
+
+	/** Parser warning-reporting function can be overridden in subclass */
+	virtual void reportWarning(const std::string&amp; s)
+	{
+		if (getFilename() == &quot;&quot;)
+			std::cerr &lt;&lt; &quot;warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
+		else
+			std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
+	}
+
+	virtual antlr::InputBuffer&amp; getInputBuffer()
+	{
+		return inputState-&gt;getInput();
+	}
+
+	virtual antlr::LexerSharedInputState getInputState()
+	{
+		return inputState;
+	}
+
+	/** set the input state for the lexer.
+	 * @note state is a reference counted object, hence no reference */
+	virtual void setInputState(antlr::LexerSharedInputState state)
+	{
+		inputState = state;
+	}
+
+	/// Set the factory for created tokens
+	virtual void setTokenObjectFactory(factory_type factory)
+	{
+		tokenFactory = factory;
+	}
+
+	/** Test the token text against the literals table
+	 * Override this method to perform a different literals test
+	 */
+	virtual int testLiteralsTable(int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** Test the text passed in against the literals table
+	 * Override this method to perform a different literals test
+	 * This is used primarily when you want to test a portion of
+	 * a token
+	 */
+	virtual int testLiteralsTable(const std::string&amp; text, int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** This method is called by YourLexer::nextToken() when the lexer has
+	 *  hit EOF condition.  EOF is NOT a character.
+	 *  This method is not called if EOF is reached during
+	 *  syntactic predicate evaluation or during evaluation
+	 *  of normal lexical rules, which presumably would be
+	 *  an IOException.  This traps the &quot;normal&quot; EOF condition.
+	 *
+	 *  uponEOF() is called after the complete evaluation of
+	 *  the previous token and only if your parser asks
+	 *  for another token beyond that last non-EOF token.
+	 *
+	 *  You might want to throw token or char stream exceptions
+	 *  like: &quot;Heh, premature eof&quot; or a retry stream exception
+	 *  (&quot;I found the end of this file, go back to referencing file&quot;).
+	 */
+	virtual void uponEOF()
+	{
+	}
+
+	/// Methods used to change tracing behavior
+	void traceIndent()
+	{
+		for( int i = 0; i &lt; traceDepth; i++ )
+			std::cout &lt;&lt; &quot; &quot;;
+	}
+
+	void traceIn(const char* rname)
+	{
+		traceDepth++;
+		traceIndent();
+		std::cout &lt;&lt; &quot;&gt; lexer &quot; &lt;&lt; rname
+			&lt;&lt; &quot;; c==&quot; &lt;&lt; LA(1) &lt;&lt; std::endl;
+	}
+
+	void traceOut(const char* rname)
+	{
+		traceIndent();
+		std::cout &lt;&lt; &quot;&lt; lexer &quot; &lt;&lt; rname
+			&lt;&lt; &quot;; c==&quot; &lt;&lt; LA(1) &lt;&lt; std::endl;
+		traceDepth--;
+	}
+
+#ifndef NO_STATIC_CONSTS
+	static const int EOF_CHAR = EOF;
+#else
+	enum {
+		EOF_CHAR = EOF
+	};
+#endif
+protected:
+	std::string text; ///&lt; Text of current token
+ 	/// flag indicating wether consume saves characters
+	bool saveConsumedInput;
+	factory_type tokenFactory;				///&lt; Factory for tokens
+	bool caseSensitive; 						///&lt; Is this lexer case sensitive
+	string_map literals;						 // set by subclass
+
+	antlr::RefToken _returnToken;		///&lt; used to return tokens w/o using return val
+
+	/// Input state, gives access to input stream, shared among different lexers
+	antlr::LexerSharedInputState inputState;
+
+	/** Used during filter mode to indicate that path is desired.
+	 * A subsequent scan error will report an error as usual
+	 * if acceptPath=true;
+	 */
+	bool commitToPath;
+
+	unsigned int tabsize; 	///&lt; tab size the scanner uses.
+
+	/// Create a new RefToken of type t
+	virtual antlr::RefToken makeToken(int t)
+	{
+		antlr::RefToken tok = tokenFactory();
+		// actually at this point you want to convert the stored lexeme text
+		// into the format you want to have it in in the backend...
+		tok-&gt;setType(t);
+		tok-&gt;setColumn(inputState-&gt;tokenStartColumn);
+		tok-&gt;setLine(inputState-&gt;tokenStartLine);
+		return tok;
+	}
+
+	/** Tracer class, used when -traceLexer is passed to antlr
+	 */
+	class Tracer {
+	private:
+		UnicodeCharScanner* parser;
+		const char* text;
+
+		Tracer(const Tracer&amp; other); 					// undefined
+		Tracer&amp; operator=(const Tracer&amp; other); 	// undefined
+	public:
+		Tracer( UnicodeCharScanner* p, const char* t )
+		: parser(p), text(t)
+		{
+			parser-&gt;traceIn(text);
+		}
+		~Tracer()
+		{
+			parser-&gt;traceOut(text);
+		}
+	};
+
+	int traceDepth;
+private:
+	UnicodeCharScanner( const UnicodeCharScanner&amp; other ); 		  		// undefined
+	UnicodeCharScanner&amp; operator=( const UnicodeCharScanner&amp; other );	// undefined
+};
+
+#endif //INC_UnicodeCharScanner_hpp__

Added: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,583 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+header {
+  #include &lt;string&gt;
+  #include &lt;sstream&gt;
+  #include &lt;iostream&gt;
+  #include &lt;ctype.h&gt;
+  #include &quot;UnicodeCharBuffer.hpp&quot;
+  #include &quot;UnicodeCharScanner.hpp&quot;
+}
+
+options {
+  language=&quot;Cpp&quot;;
+}
+
+class PortugolLexer extends Lexer(&quot;UnicodeCharScanner&quot;);
+
+options {
+  k=2;
+  genHashLines   = false;
+  exportVocab    = Portugol;
+  filter         = T_INVALIDO;
+  testLiterals   = false;
+}
+
+tokens {
+  T_KW_ALGORITMO=&quot;algoritmo&quot;;
+  T_KW_USE=&quot;use&quot;;
+  T_KW_VARIAVEL=&quot;vari&#225;vel&quot;;
+  T_KW_VARIAVEIS=&quot;vari&#225;veis&quot;;
+  T_KW_FIM_VARIAVEIS=&quot;fim-vari&#225;veis&quot;;
+  T_KW_INTEIRO=&quot;inteiro&quot;;
+  T_KW_REAL=&quot;real&quot;;
+  T_KW_CARACTERE=&quot;caractere&quot;;
+  T_KW_LITERAL=&quot;literal&quot;;
+  T_KW_LOGICO=&quot;l&#243;gico&quot;;
+  T_KW_CORINGA=&quot;coringa&quot;;
+  T_KW_MATRIZ=&quot;matriz&quot;;
+  T_KW_DO=&quot;do&quot;;
+  T_KW_TIPO=&quot;tipo&quot;;
+  T_KW_CONSTANTE=&quot;constante&quot;;
+  T_KW_CONSTANTES=&quot;constantes&quot;;
+  T_KW_FIM_CONSTANTES=&quot;fim-constantes&quot;;
+  T_KW_ESTRUTURA=&quot;estrutura&quot;;
+  T_KW_FIM_ESTRUTURA=&quot;fim-estrutura&quot;;
+  T_KW_FUNCAO=&quot;fun&#231;&#227;o&quot;;
+  T_KW_PROCEDIMENTO=&quot;procedimento&quot;;
+  T_KW_REF=&quot;ref&quot;;
+  T_KW_INICIO=&quot;in&#237;cio&quot;;
+  T_KW_FIM=&quot;fim&quot;;
+  T_KW_SAIR=&quot;sair&quot;;
+  T_KW_RETORNE=&quot;retorne&quot;;
+  T_KW_SE=&quot;se&quot;;
+  T_KW_ENTAO=&quot;ent&#227;o&quot;;
+  T_KW_SENAO=&quot;sen&#227;o&quot;;
+  T_KW_FIM_SE=&quot;fim-se&quot;;
+  T_KW_ENQUANTO=&quot;enquanto&quot;;
+  T_KW_FACA=&quot;fa&#231;a&quot;;
+  T_KW_FIM_ENQUANTO=&quot;fim-enquanto&quot;;
+  T_KW_PARA=&quot;para&quot;;
+  T_KW_DE=&quot;de&quot;;
+  T_KW_ATE=&quot;at&#233;&quot;;
+  T_KW_FIM_PARA=&quot;fim-para&quot;;
+  T_KW_PASSO=&quot;passo&quot;;
+  T_KW_REPITA=&quot;repita&quot;;
+  T_KW_CASO=&quot;caso&quot;;
+  T_KW_SEJA=&quot;seja&quot;;
+  T_KW_FIM_SENAO=&quot;fim-sen&#227;o&quot;;
+  T_KW_FIM_CASO=&quot;fim-caso&quot;;
+  T_KW_FIM_FACA=&quot;fim-fa&#231;a&quot;;
+  T_KW_OU=&quot;ou&quot;;
+  T_KW_E=&quot;e&quot;;
+  T_KW_NAO=&quot;n&#227;o&quot;;
+  T_KW_VERDADEIRO=&quot;verdadeiro&quot;;
+  T_KW_FALSO=&quot;falso&quot;;
+  T_KW_ASM=&quot;asm&quot;;
+  T_KW_FIMASM=&quot;fim-asm&quot;;
+
+  T_REAL_LITERAL=&quot;n&#250;mero real&quot;; //a regra T_INTEIRO_LITERAL lida com reais
+
+
+  //imagin&#225;rios para a AST
+
+  TI_VALOR;
+  TI_VMATRIZ;    //valor da matriz    (literal [])
+  TI_VESTRUTURA; //valor da estrutura (literal {})
+
+  TI_MATRIZ;
+  TI_DIMENSOES;
+  TI_NULL;
+
+  TI_UN_POSITIVO;
+  TI_UN_NEGATIVO;
+  TI_UN_NEGACAO;
+  TI_UN_NEGACAOB;
+  TI_PARENTESIS;
+
+  TI_CALL;
+}
+
+
+{
+public:
+  PortugolLexer(std::istream&amp; in, bool case_s)
+   : UnicodeCharScanner(new UnicodeCharBuffer(in), case_s)
+    {
+      initLiterals();
+    }
+
+private:
+
+  std::string toBase10(const std::string&amp; oct, int from) {
+    std::stringstream stream;
+    unsigned long long base10;
+    base10 = strtoull(oct.c_str(), NULL, from);
+    stream &lt;&lt; base10;
+    return stream.str();
+  }
+
+  bool isOctal(const std::string&amp; num) {
+    std::stringstream s;
+    if ((num.find(&quot;8&quot;,0)  != std::string::npos) ||
+        (num.find(&quot;9&quot;,0)  != std::string::npos)) {
+      return false;
+    } else {
+      for (unsigned int i = 2; i &lt; num.length(); ++i) {
+        if (!isdigit(num[i])) {
+          return false;
+        }
+      }
+    }
+    return true;
+  }
+
+  bool isHex(const std::string&amp; num) {
+    for (unsigned int i = 2; i &lt; num.length(); ++i) {
+      if (!isxdigit(num[i])) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  bool isBin(const std::string&amp; num) {
+    for(unsigned int i = 2; i &lt; num.length(); ++i) {
+      if ((num[i] != '0') &amp;&amp; (num[i] != '1')) {
+        return false;
+      }
+    }
+    return true;
+  }
+}
+
+
+//####################################
+//##             Regras             ##
+//####################################
+
+
+
+T_ESPACO :
+  (   ' '
+    | '\t'
+    | '\n' { newline(); }
+    | '\r'
+  )
+  { $setType(antlr::Token::SKIP); }
+  ;
+
+COMENTARIO_CPP
+  : &quot;//&quot; (~('\n'))* ('\n')?
+    {
+      newline();
+      $setType(antlr::Token::SKIP);
+    }
+  ;
+
+COMENTARIO_C
+{int line = getLine();}
+  : &quot;/*&quot;
+    (
+      options { generateAmbigWarnings=false; } :
+        '\n'                     {newline();}
+      | ('\r' '\n')=&gt; '\r' '\n'  {newline();}
+      | '\r'                     {newline();}
+      |~('*'|'\n'|'\r')
+      | ('*' ~'/' )=&gt; '*'
+    )*
+    &quot;*/&quot;
+    {$setType(antlr::Token::SKIP);}
+  ;
+exception
+catch[antlr::RecognitionException] {
+  std::stringstream s;
+  //aviso! n&#227;o &#233; erro!
+  s &lt;&lt; &quot;coment&#225;rio iniciado na linha &quot; &lt;&lt; line &lt;&lt; &quot; n&#227;o termina com \&quot;*/\&quot;.&quot;;
+  std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
+  $setType(antlr::Token::SKIP);
+}
+
+T_PONTO_VIRGULA
+options {
+  paraphrase = &quot;';'&quot;;
+}
+  : ';'
+  ;
+
+T_VIRGULA
+options {
+  paraphrase = &quot;','&quot;;
+}
+  : ','
+  ;
+
+T_2_PONTOS
+options {
+  paraphrase = &quot;':'&quot;;
+}
+
+  : ':'
+  ;
+
+T_ABRE_CHAVE
+options {
+  paraphrase = &quot;'['&quot;;
+}
+  : '['
+  ;
+
+T_FECHA_CHAVE
+options {
+  paraphrase = &quot;']'&quot;;
+}
+  : ']'
+  ;
+
+T_ABRE_COLCHETE
+options {
+  paraphrase = &quot;'{'&quot;;
+}
+  : '{'
+  ;
+
+T_FECHA_COLCHETE
+options {
+  paraphrase = &quot;'}'&quot;;
+}
+  : '}'
+  ;
+
+T_ABRE_PAREN
+options {
+  paraphrase = &quot;'('&quot;;
+}
+  : '('
+  ;
+T_FECHA_PAREN
+options {
+  paraphrase = &quot;')'&quot;;
+}
+  : ')'
+  ;
+
+T_ATRIBUICAO
+options {
+  paraphrase = &quot;':='&quot;;
+}
+  : &quot;:=&quot;
+  ;
+
+T_BIT_OU
+options {
+  paraphrase = &quot;operador '|'&quot;;
+}
+  : '|'
+  ;
+
+T_BIT_OUX
+options {
+  paraphrase = &quot;operador '^'&quot;;
+}
+  : '^'
+  ;
+
+T_BIT_E
+options {
+  paraphrase = &quot;operador '&amp;'&quot;;
+}
+  : '&amp;'
+  ;
+
+T_BIT_NAO
+options {
+  paraphrase = &quot;operador '~'&quot;;
+}
+  : '~'
+  ;
+
+
+T_IGUAL
+options {
+  paraphrase = &quot;operador '='&quot;;
+}
+  : '='
+  ;
+
+T_DIFERENTE
+options {
+  paraphrase = &quot;operador '&lt;&gt;'&quot;;
+}
+  : &quot;&lt;&gt;&quot;
+  ;
+
+T_MAIOR
+options {
+  paraphrase = &quot;operador '&gt;'&quot;;
+}
+  : '&gt;'
+  ;
+
+T_MAIOR_EQ
+options {
+  paraphrase = &quot;operador '&gt;='&quot;;
+}
+  : &quot;&gt;=&quot;
+  ;
+
+T_MENOR
+options {
+  paraphrase = &quot;operador '&lt;'&quot;;
+}
+  : '&lt;'
+  ;
+T_MENOR_EQ
+options {
+  paraphrase = &quot;operador '&lt;='&quot;;
+}
+  : &quot;&lt;=&quot;
+  ;
+
+T_MAIS
+options {
+  paraphrase = &quot;operador '+'&quot;;
+}
+  : '+'
+  ;
+
+T_MENOS
+options {
+  paraphrase = &quot;operador '-'&quot;;
+}
+  : '-'
+  ;
+
+T_DIV
+options {
+  paraphrase = &quot;operador '/'&quot;;
+}
+  : '/'
+  ;
+
+T_MULTIP
+options {
+  paraphrase = &quot;operador '*'&quot;;
+}
+  : '*'
+  ;
+
+T_MOD
+options {
+  paraphrase = &quot;operador '%'&quot;;
+}
+  : '%'
+  ;
+
+/* Literais */
+
+
+T_INTEIRO_LITERAL
+options {
+  paraphrase = &quot;n&#250;mero inteiro&quot;;
+}
+  : ('0' ('c'|'C') )=&gt; T_OCTAL_LIT
+  | ('0' ('x'|'X') )=&gt; T_HEX_LIT
+  | ('0' ('b'|'B') )=&gt; T_BIN_LIT
+  | (T_DIGITO)+
+    (
+      '.' (T_DIGITO)+
+      {$setType(T_REAL_LITERAL);}
+    )?
+  ;
+
+T_TEXTO_LITERAL
+options {
+  paraphrase = &quot;literal&quot;;
+}
+  : '&quot;'! ( ~( '&quot;' | '\\' | '\n' | '\r') | T_ESCAPE )* '&quot;'!
+  ;
+
+
+T_CARACTERE_LITERAL
+options {
+  paraphrase = &quot;caractere&quot;;
+}
+  : '\''! ( ~( '\'' | '\\' ) | T_ESCAPE )? '\''!
+  ;
+
+
+
+/*
+  Ok, um pouco de malabarismo...
+
+  Eis o problema:
+
+  N&#243;s precisamos que uma string como &quot;fim-vari&#225;veis&quot; seja
+  identificada pelo scanner. Para isso, as keywords em tokens{} devem
+  ser cobertos pelas regras T_*. No caso, T_IDENTIFICADOR
+  costuma ser a regra que identifica keywords.
+
+  Por&#233;m, &quot;fim-vari&#225;veis&quot; n&#227;o &#233; um identificador v&#225;lido
+  (ambig. com &quot;fim - vari&#225;veis&quot;).
+
+  Ent&#227;o, T_IDENTIFICADOR aqui representa a regra mais geral poss&#237;vel,
+  para cobrir as keywords em tokens{}. Mas, para o caso problem&#225;tico
+  de T_IDENTIFICADOres com &quot;-&quot;, verificamos se o lexema atual
+  &#233; uma keyword ou um identificador seguido de T_MENOS, utilizando
+  &quot;testLiteralsTable&quot; manualmente.
+
+  Se testLiteralsTable indicar que o lexema atual com hifen for uma keyword,
+  &#233; a pr&#243;pria, obviamente.
+
+  Se n&#227;o, trata-se de um ID seguido de T_MENOS. Ent&#227;o, fazemos o rollback
+  at&#233; o ponto do hifen.
+*/
+
+T_IDENTIFICADOR
+options {
+  testLiterals = true;
+}
+  { int m = -1,len; }
+
+  : T_ID_AUX
+      {
+        len = $getText.length();
+        if (LA(1) == '-') {
+          m = mark();
+        }
+      }
+
+    ('-' (T_LETRA_OU_DIGITO)*)?
+  {
+    if ((m != -1) &amp;&amp; (testLiteralsTable(_ttype) == T_IDENTIFICADOR)) {
+      rewind(m);
+      std::string s = $getText;
+      $setText(s.substr(0,len));
+    }
+  }
+  ;
+
+
+
+//####################################
+//##            Protecteds          ##
+//####################################
+
+
+protected
+T_ESCAPE
+  : '\\' .  /* ex. \a */
+  ;
+
+protected
+T_DIGITO
+  : '0'..'9'
+  ;
+
+protected
+T_LETRA
+  : 'a'..'z'|'A'..'Z' | '\u00C0' .. '\u00FF' /* latim-1 */
+  ;
+
+
+protected
+T_LETRA_OU_DIGITO
+  : T_LETRA | T_DIGITO | '_'
+  ;
+
+
+//mais detalhes em T_IDENTIFICADOR
+protected
+T_ID_AUX
+  : (T_LETRA | '_') (T_LETRA_OU_DIGITO)*
+  ;
+
+protected
+T_OCTAL_LIT
+  : '0' ('c'|'C') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isOctal(str)) {
+      $setText(toBase10(str.substr(2), 8));
+    } else {
+      std::stringstream s;
+      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero octal v&#225;lido&quot;;
+      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
+    }
+  }
+  ;
+
+protected
+T_HEX_LIT
+  : '0' ('x'|'X') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isHex(str)) {
+      $setText(toBase10(str, 16));
+    } else {
+      std::stringstream s;
+      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero hexadecimal v&#225;lido&quot;;
+      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
+    }
+  }
+  ;
+
+protected
+T_BIN_LIT
+  : '0' ('b'|'B') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isBin(str)) {
+      $setText(toBase10(str.substr(2), 2));
+    } else {
+      std::stringstream s;
+      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero bin&#225;rio v&#225;lido&quot;;
+      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
+    }
+  }
+  ;
+
+protected
+T_INVALIDO
+  : .
+    {
+      //caracteres de espa&#231;o inexistentes na tabela ascii
+      //([160] == [-96] == ' ' == [32] == 160-128)
+      if ($getText.c_str()[0] == (int)0xffffffa0) {
+        $setType(antlr::Token::SKIP);
+      } else {
+        std::stringstream s;
+        if (($getText != &quot;\&quot;&quot;) &amp;&amp; ($getText != &quot;'&quot;)) {
+          s &lt;&lt; &quot;Caractere inv&#225;lido: \&quot;&quot; &lt;&lt; $getText &lt;&lt; &quot;\&quot;.\n&quot;;
+          s &lt;&lt; &quot;Verifique se a codifica&#231;&#227;o do texto est&#225; em UTF-8&quot;;
+        } else {
+          s &lt;&lt; &quot;Faltando fechar aspas&quot;;
+        }
+        std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
+      }
+    }
+  ;

Added: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,477 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+options {
+  language=&quot;Cpp&quot;;
+}
+
+class PortugolParser extends Parser;
+options {
+  importVocab  = Portugol;
+  genHashLines = false;
+  buildAST     = true;
+}
+
+{
+private:
+  void createRootNode(antlr::ASTPair&amp; ast, antlr::RefToken token) {
+    astFactory-&gt;makeASTRoot(ast, astFactory-&gt;create(token));
+  }
+
+  void createRootNode(antlr::ASTPair&amp; ast, int token) {
+    astFactory-&gt;makeASTRoot(ast, astFactory-&gt;create(token));
+  }
+
+  void addChildNode(antlr::ASTPair&amp; ast, antlr::RefToken token) {
+    astFactory-&gt;addASTChild(ast, astFactory-&gt;create(token));
+  }
+
+  void addChildNode(antlr::ASTPair&amp; ast, antlr::RefAST child) {
+    astFactory-&gt;addASTChild(ast, child);
+  }
+
+  antlr::RefAST createNode(int type, const std::string&amp; txt) {
+    return astFactory-&gt;create(type, txt);
+  }
+}
+
+
+
+//####################################
+//##             In&#237;cio             ##
+//####################################
+
+programa
+  : (declaracao_algoritmo)?
+
+    (importacao)*
+
+    (   declaracao_variaveis
+      | declaracao_constantes
+      | bloco_declaracao_estrutura
+    )*
+
+    corpo
+
+    EOF
+  ;
+
+declaracao_algoritmo!
+  : T_KW_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
+  ;
+
+importacao
+  : T_KW_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
+  ;
+
+corpo
+  :  (declaracao_subrotina)*
+      bloco_codigo
+     (declaracao_subrotina)*
+  ;
+
+
+
+//####################################
+//##    Declara&#231;&#227;o de Vari&#225;veis     ##
+//####################################
+
+declaracao_variaveis
+  : bloco_declaracao_variaveis
+  | T_KW_VARIAVEL! declaracao_variavel_uniq
+  ;
+
+bloco_declaracao_variaveis
+  : T_KW_VARIAVEIS^ (declaracao_variavel)+ T_KW_FIM_VARIAVEIS!
+  ;
+
+declaracao_variavel!
+  : ids:lista_identificadores   T_2_PONTOS
+    t:tipo (l:lista_inicializacao)? T_PONTO_VIRGULA
+
+            {
+              if (l_AST == antlr::nullAST) {
+                #declaracao_variavel =
+                    #([T_KW_VARIAVEL,&quot;&amp;var&quot;], t,ids);
+              } else {
+                #declaracao_variavel =
+                    #([T_KW_VARIAVEL,&quot;&amp;var&quot;], t,ids,([TI_VALOR,&quot;&amp;valor&quot;],l));
+              }
+            }
+  ;
+
+lista_identificadores
+  : T_IDENTIFICADOR (T_VIRGULA! T_IDENTIFICADOR)*
+  ;
+
+declaracao_variavel_uniq!
+  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    (l:lista_inicializacao)? T_PONTO_VIRGULA
+
+            {
+              if (l_AST == antlr::nullAST) {
+                #declaracao_variavel_uniq=
+                    #([T_KW_VARIAVEL,&quot;&amp;var&quot;], t,id);
+              } else {
+                #declaracao_variavel_uniq =
+                    #([T_KW_VARIAVEL,&quot;&amp;var&quot;], t,id,([TI_VALOR,&quot;&amp;valor&quot;],l));
+              }
+            }
+  ;
+
+tipo
+  : tipo_primitivo
+  | tipo_matriz
+  | T_IDENTIFICADOR
+  ;
+
+lista_inicializacao
+  : T_ATRIBUICAO! (expressao | inicializacao_composta)
+  ;
+
+inicializacao_composta!
+  : T_ABRE_CHAVE!
+      idx:inicializacao_indices
+    T_FECHA_CHAVE!
+
+                 {#inicializacao_composta = #([TI_VMATRIZ, &quot;&amp;vmatriz&quot;],idx);}
+
+  | T_ABRE_COLCHETE!
+      mem:inicializacao_membros
+    T_FECHA_COLCHETE!
+
+                 {#inicializacao_composta = #([TI_VESTRUTURA, &quot;&amp;vestr&quot;],mem);}
+  ;
+
+inicializacao_indices
+  : (expressao | inicializacao_composta) (T_VIRGULA! inicializacao_indices)?
+  ;
+
+inicializacao_membros
+  : T_IDENTIFICADOR T_ATRIBUICAO! (expressao | inicializacao_composta)
+    (T_VIRGULA! inicializacao_membros)?
+  ;
+
+tipo_primitivo
+  : T_KW_INTEIRO
+  | T_KW_REAL
+  | T_KW_CARACTERE
+  | T_KW_LITERAL
+  | T_KW_LOGICO
+  | T_KW_CORINGA
+  ;
+
+tipo_matriz!
+  : T_KW_MATRIZ dim:matriz_dimensoes
+    T_KW_DO T_KW_TIPO t:matriz_tipo
+
+    {#tipo_matriz = #([TI_MATRIZ, &quot;&amp;matriz&quot;], t,dim);}
+  ;
+
+matriz_dimensoes
+  : ( T_ABRE_CHAVE!
+      ( T_INTEIRO_LITERAL
+        | /*vazio*/  {addChildNode(currentAST, createNode(TI_NULL,&quot;&amp;null&quot;));}
+      )
+      T_FECHA_CHAVE!
+    )+
+  ;
+
+matriz_tipo
+  : tipo_primitivo | T_IDENTIFICADOR
+  ;
+
+
+
+//####################################
+//##    Declara&#231;&#227;o de Constantes    ##
+//####################################
+
+
+declaracao_constantes
+  : bloco_declaracao_constantes
+  | T_KW_CONSTANTE! declaracao_constante
+  ;
+
+bloco_declaracao_constantes
+  : T_KW_CONSTANTES^ (declaracao_constante)+ T_KW_FIM_CONSTANTES!
+  ;
+
+declaracao_constante!
+  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    l:lista_inicializacao T_PONTO_VIRGULA
+
+               {#declaracao_constante = #([T_KW_CONSTANTE,&quot;&amp;const&quot;], t,id,l);}
+  ;
+
+
+
+
+//####################################
+//##    Declara&#231;&#227;o de Estruturas    ##
+//####################################
+
+
+bloco_declaracao_estrutura
+  : T_KW_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_KW_FIM_ESTRUTURA!
+  ;
+
+
+
+
+//####################################
+//##    Declara&#231;&#227;o de Subrotinas    ##
+//####################################
+
+declaracao_subrotina
+  : declaracao_funcao
+  | declaracao_procedimento
+  ;
+
+declaracao_funcao
+  : T_KW_FUNCAO^ T_IDENTIFICADOR
+      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo
+    (declaracao_constantes | declaracao_variaveis)*
+    bloco_codigo
+  ;
+
+declaracao_procedimento
+  : T_KW_PROCEDIMENTO^ T_IDENTIFICADOR
+      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
+    (declaracao_constantes | declaracao_variaveis)*
+    bloco_codigo
+  ;
+
+lista_parametros
+  : parametro (T_VIRGULA! parametro)*
+  ;
+
+parametro!
+  : ((c:T_KW_CONSTANTE)? r:T_KW_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    {#parametro = #([T_KW_VARIAVEL,&quot;&amp;param&quot;],t,id,c,r);}
+  ;
+
+
+
+//####################################
+//##         Bloco de c&#243;digo        ##
+//####################################
+
+bloco_codigo
+  : T_KW_INICIO^ lista_enunciados T_KW_FIM!
+  ;
+
+lista_enunciados
+  : (enunciado)*
+  ;
+
+enunciado
+  : (lvalue T_ATRIBUICAO)=&gt; en_atribuicao
+  | en_retorne
+  | en_se
+  | en_enquanto
+  | en_repita
+  | en_para
+  | en_caso
+
+  | en_asm
+
+  | T_KW_SAIR^ T_PONTO_VIRGULA!
+  | T_PONTO_VIRGULA!
+
+//  TODO: retirar da gramatica ou resolver a ambiguidade
+//        se esta producao vingar, retirar enunciado::chamada_subrotina
+//   | expressao  T_PONTO_VIRGULA!
+
+  | chamada_subrotina T_PONTO_VIRGULA!
+  ;
+
+en_atribuicao
+  : lvalue T_ATRIBUICAO^ expressao T_PONTO_VIRGULA!
+  ;
+
+
+en_retorne
+  : T_KW_RETORNE^ (expressao)? T_PONTO_VIRGULA!
+  ;
+
+lvalue
+  : T_IDENTIFICADOR^ matriz_indices
+  ;
+
+matriz_indices
+  : ( T_ABRE_CHAVE!
+      expressao
+      T_FECHA_CHAVE!
+    )*
+  ;
+
+en_se
+  : T_KW_SE^ expressao T_KW_ENTAO!
+      lista_enunciados (T_KW_SENAO! lista_enunciados)? T_KW_FIM_SE!
+  ;
+
+en_enquanto
+  : T_KW_ENQUANTO^ expressao T_KW_FACA! lista_enunciados T_KW_FIM_ENQUANTO!
+  ;
+
+en_para
+  : T_KW_PARA^ lvalue T_KW_DE! expressao
+    T_KW_ATE! expressao (passo)? T_KW_FACA!
+      lista_enunciados T_KW_FIM_PARA!
+  ;
+
+passo
+  : T_KW_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
+  ;
+
+en_repita
+  : T_KW_REPITA^ lista_enunciados T_KW_ATE expressao
+  ;
+
+en_caso
+  : T_KW_CASO^ expressao
+      T_KW_SEJA! (teste_caso)+
+      (caso_senao)? T_KW_FIM_CASO!
+  ;
+
+teste_caso!
+  : l:literal T_KW_FACA! en:lista_enunciados T_KW_FIM_FACA!
+
+                                {#teste_caso = #(l, en);}
+  ;
+
+caso_senao
+  : T_KW_SENAO^ lista_enunciados T_KW_FIM_SENAO!
+  ;
+
+
+//TODO: codigo ilustrativo.
+en_asm!
+  : T_KW_ASM (~(T_KW_FIMASM))* T_KW_FIMASM
+  ;
+
+
+//####################################
+//##            Express&#245;es          ##
+//####################################
+
+expressao
+  : expr_e (T_KW_OU^ expr_e)*
+  ;
+
+expr_e
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_ou (T_KW_E^ expr_bit_ou)*
+  ;
+
+expr_bit_ou
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
+  ;
+
+expr_bit_oux
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
+  ;
+
+expr_bit_e
+options {
+  defaultErrorHandler=false;
+}
+  : expr_igual (T_BIT_E^ expr_igual)*
+  ;
+
+expr_igual
+options {
+  defaultErrorHandler=false;
+}
+  : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
+  ;
+
+expr_relacional
+options {
+  defaultErrorHandler=false;
+}
+  : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
+  ;
+
+expr_ad
+options {
+  defaultErrorHandler=false;
+}
+  : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
+  ;
+
+expr_multip
+options {
+  defaultErrorHandler=false;
+}
+  : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
+  ;
+
+expr_unario
+options {
+  defaultErrorHandler=false;
+}
+  : op_unario expr_elemento
+  ;
+
+op_unario!
+  : ( T_MENOS   {#op_unario = #[TI_UN_NEGATIVO,&quot;&amp;negat&quot;];}
+    | T_MAIS    {#op_unario = #[TI_UN_POSITIVO,&quot;&amp;pos&quot;];}
+    | T_KW_NAO  {#op_unario = #[TI_UN_NEGACAO ,&quot;nega&#231;&quot;];}
+    | T_BIT_NAO {#op_unario = #[TI_UN_NEGACAOB,&quot;&amp;negb&quot;];}
+    )?
+  ;
+
+expr_elemento
+  :  (T_IDENTIFICADOR T_ABRE_PAREN)=&gt; chamada_subrotina
+  |  lvalue
+  |  literal
+  |! T_ABRE_PAREN e:expressao T_FECHA_PAREN
+     {#expr_elemento = #([TI_PARENTESIS,&quot;&amp;paren&quot;], e);}
+  ;
+
+
+chamada_subrotina!
+  : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
+
+    {#chamada_subrotina = #([TI_CALL,&quot;&amp;call&quot;], id, args);}
+  ;
+
+lista_argumentos
+  : expressao (T_VIRGULA! expressao)*
+  ;
+
+literal
+  : T_TEXTO_LITERAL
+  | T_INTEIRO_LITERAL
+  | T_REAL_LITERAL
+  | T_CARACTERE_LITERAL
+  | T_KW_VERDADEIRO
+  | T_KW_FALSO
+  ;

Added: trunk/gpt2/src/gptc/teste.cpp
===================================================================
--- trunk/gpt2/src/gptc/teste.cpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/teste.cpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,64 @@
+#include &lt;stdio.h&gt;
+#include &quot;PortugolLexer.hpp&quot;
+#include &quot;PortugolParser.hpp&quot;
+#include &quot;PortugolTokenTypes.hpp&quot;
+#include &lt;antlr/TokenBuffer.hpp&gt;
+#include &lt;antlr/CommonAST.hpp&gt;
+
+#include &lt;fstream&gt;
+
+void dump_tokens(char* fname) {
+  char *table[200];
+  #include &quot;table.hpp&quot;
+  std::ifstream fi(fname);
+  PortugolLexer lexer(fi, true);
+  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
+
+  while (true) {
+    std::cout &lt;&lt; lexer.getLine() &lt;&lt; &quot;: [&quot; &lt;&lt; buffer-&gt;LA(1) &lt;&lt; &quot;] &quot;
+              &lt;&lt; table[buffer-&gt;LA(1)] &lt;&lt; &quot; (&quot; &lt;&lt; lexer.getText() &lt;&lt; &quot;)&quot;;
+    buffer-&gt;consume();
+    getchar();
+
+    if (buffer-&gt;LA(1) == PortugolTokenTypes::EOF_) {
+      break;
+    }
+  }
+}
+
+void dump_tree(char* fname) {
+
+  std::ifstream fi(fname);
+  PortugolLexer lexer(fi, true);
+  PortugolParser parser(lexer);
+
+  antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,&amp;antlr::CommonAST::factory);
+  parser.initializeASTFactory(ast_factory);
+  parser.setASTFactory(&amp;ast_factory);
+
+  parser.programa();
+
+  antlr::RefCommonAST ast = antlr::RefCommonAST(parser.getAST());
+
+  if (ast) {
+    std::cerr &lt;&lt; ast-&gt;toStringList() &lt;&lt; std::endl &lt;&lt; std::endl;
+  } else {
+    std::cerr &lt;&lt; &quot;: no parse tree&quot; &lt;&lt; std::endl;
+  }
+}
+
+int main(int argc, char** argv) {
+
+  if (argc &lt; 3) {
+    std::cerr &lt;&lt; &quot;./test [lp] &lt;file.gpt&gt;&quot; &lt;&lt; std::endl;
+    return 0;
+  }
+
+  if (*argv[1] == 't') {
+    dump_tree(argv[2]);
+  } else {
+    dump_tokens(argv[2]);
+  }
+
+  return 0;
+}

Added: trunk/gpt2/src/gptc/testes/lex_teste.gpt
===================================================================
--- trunk/gpt2/src/gptc/testes/lex_teste.gpt	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/testes/lex_teste.gpt	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,110 @@
+algoritmo
+use
+vari&#225;vel
+vari&#225;veis
+fim-vari&#225;veis
+inteiro
+real
+caractere
+literal
+l&#243;gico
+coringa
+matriz
+do
+tipo
+constante
+constantes
+fim-constantes
+estrutura
+fim-estrutura
+fun&#231;&#227;o
+procedimento
+ref
+in&#237;cio
+fim
+sair
+retorne
+se
+ent&#227;o
+sen&#227;o
+fim-se
+enquanto
+fa&#231;a
+fim-enquanto
+para
+de
+at&#233;
+fim-para
+passo
+repita
+caso
+seja
+fim-sen&#227;o
+fim-caso
+fim-fa&#231;a
+ou
+e
+n&#227;o
+verdadeiro
+falso
+asm
+fim-asm
+
+//comentario CPP
+
+/* comment
+  ario C */
+
+;
+,
+:
+[
+]
+{
+}
+(
+)
+:=
+|
+^
+&amp;
+=
+&lt;&gt;
+&gt;
+&gt;=
+&lt;
+&lt;=
++
+-
+/
+*
+%
+~
+
+123
+-2
+1.023
+
+0c123
+0C123
+0c987
+0X1AB
+0x1ab
+0xTT
+0b10101
+0B10101
+0b2
+
+&quot;oi
+&quot;ol&#225; \nbla&quot;
+&quot;&quot;
+
+'o'
+''
+'&#225;'
+'\b'
+'\\'
+
+teste
+_oum
+p&#233;

Added: trunk/gpt2/src/gptc/testes/tree_teste.gpt
===================================================================
--- trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,106 @@
+// algoritmo teste;
+
+// use &quot;bib1&quot;;
+// use &quot;bib2&quot;;
+// use &quot;bib3&quot;;
+// use &quot;bib4&quot;;
+
+// vari&#225;veis
+//   p : T;
+//   a,b : real;
+//   c : inteiro := 10;
+//   j : matriz[] do tipo inteiro := [1,2,3];
+//   es,e2 : T := {nome:=&quot;foo&quot;,id:=6};
+//   e4    : matriz[] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3}];
+// fim-vari&#225;veis
+
+
+// vari&#225;vel q : T;
+// vari&#225;vel j : K := &quot;oi&quot;;
+// vari&#225;vel m : matriz[] do tipo I := [9,8,7];
+// vari&#225;vel z : T := {i:=10, j:=20};
+// vari&#225;vel e4    : matriz[10][20] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3}];
+
+// constantes
+//   z  : inteiro := 3;
+//   j  : matriz[] do tipo inteiro := [1,2,3];
+//   es : T := {nome:=&quot;foo&quot;,id:=6};
+//   e4 : matriz[] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3},{k:=[9,8,7]}];
+// fim-constantes
+//
+// constante x : inteiro := {z := [1,2,3]};
+
+// estrutura T
+//   z   : inteiro := 1;
+//   j,z : kkk;
+// fim-estrutura
+
+in&#237;cio
+//   x := 10;
+//   z[1] := 9;
+//   z[0][0] := n&#227;o(~1 + -2 * +3);
+
+//   se x &gt; 2 ent&#227;o
+//     x := 2;
+//   fim-se
+//
+//   se z = &quot;oi&quot; ent&#227;o
+//     z := 1;
+//   sen&#227;o
+//     z := 2;
+//   fim-se
+
+// enquanto x &gt; 2 fa&#231;a
+//   x := 2;
+// fim-enquanto
+
+// repita
+//   x := 2;
+//   k := 3;
+// at&#233; x &gt; 3
+
+// para x de 1+2 at&#233; 10+100 fa&#231;a
+//   x := 3;
+// fim-para
+
+// para x[y] de 0 at&#233; 100 passo -1 fa&#231;a
+//   x := 3;
+// fim-para
+
+// caso x seja
+//   &quot;oi&quot; fa&#231;a
+//     x := 1;
+//     z := 2;
+//   fim-fa&#231;a
+//
+//   10 fa&#231;a
+//     x:=3;
+//     sair;
+//   fim-fa&#231;a
+//
+//   sen&#227;o
+//     x:= 10;
+//   fim-sen&#227;o
+// fim-caso
+//
+//   retorne 10+10;
+
+  f(10, 1+2, g());
+
+//   &quot;se&quot; x &gt; 10
+/*  asm
+    ola  as &quot;sss&quot; 1 se ent&#227;o
+    adasd &quot;fim-asm&quot;
+  fim-asm*/
+fim
+
+
+// fun&#231;&#227;o f(a:I,k:matriz[1][2] do tipo I) : T
+// in&#237;cio
+//   x := 2;
+// fim
+
+// procedimento p(a:I,k:matriz[1][2] do tipo I)
+// in&#237;cio
+//   z := 2;
+// fim


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000012.html">[gpt-commit] r338 - in trunk/gpt2: . doc src tests
</A></li>
	<LI>Next message: <A HREF="000014.html">[gpt-commit] r340 - trunk/gpt2/src/gptc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13">[ date ]</a>
              <a href="thread.html#13">[ thread ]</a>
              <a href="subject.html#13">[ subject ]</a>
              <a href="author.html#13">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-commit">More information about the gpt-commit
mailing list</a><br>
</body></html>
