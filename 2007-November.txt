From gpt-commit-noreply at mail.berlios.de  Thu Nov  1 14:24:26 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 1 Nov 2007 14:24:26 +0100
Subject: [gpt-commit] r333 - in trunk/gpt2: src/modules/parser test/wikki
Message-ID: <200711011324.lA1DOQWS007889@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-01 14:24:25 +0100 (Thu, 01 Nov 2007)
New Revision: 333

Added:
   trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
   trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
   trunk/gpt2/src/modules/parser/CTemporaryVar.cpp
   trunk/gpt2/src/modules/parser/CTemporaryVar.hpp
Removed:
   trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
   trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.hpp
Modified:
   trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp
   trunk/gpt2/src/modules/parser/Makefile.am
   trunk/gpt2/src/modules/parser/Tools.cpp
   trunk/gpt2/src/modules/parser/Tools.hpp
   trunk/gpt2/src/modules/parser/lexer.g
   trunk/gpt2/src/modules/parser/parser.g
   trunk/gpt2/test/wikki/estruturas_condicionais_4.gpt
   trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt
Log:
REGULAR:
- Adequacao do exemplo de uso da sentenca "caso" conforme a gramatica
- Criacao de exemplos mais simples com expressoes matematicas para testar o GptC
- Ajustes no Parser:
  - Correcao na gramatica da regra "declaracao_variaveis"
  - Traducao (parcial) da definicao de variaveis para GptAssembly
  - Traducao (parcial) de expressoes para GptAssembly (codigo herdado da V1)
  - Traducao (parcial) de atribuicoes para GptAssembly
  - Traducao (parcial) da sentenca "se" para GptAssembly
  - Traducao (parcial) da sentenca "enquanto" para GptAssembly
  - Traducao (parcial) da sentenca "para" para GptAssembly
  - Traducao (parcial) da sentenca "caso" para GptAssembly
  - Implementacao dos metodos para emissao de alguns mnemonicos
  - Acrescentado a definicao do token "fim-caso"


Deleted: trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,46 +0,0 @@
-#include <Tools.hpp>
-#include "CTemporarySymbol.hpp"
-
-CTemporarySymbol::CTemporarySymbol( )
-{
-}
-
-CTemporarySymbol::CTemporarySymbol( const string &baseName, const int &initialValue)
-	: _baseName(baseName), _count(initialValue)
-{
-}
-
-CTemporarySymbol::~CTemporarySymbol( )
-{
-}
-
-void CTemporarySymbol::setBaseName( string baseName )
-{
-	_baseName = baseName;
-}
-
-void CTemporarySymbol::setInitialValue( int initialValue )
-{
-	_count = initialValue;
-}
-
-string CTemporarySymbol::getNewSymbol( )
-{
-	return( _baseName + itoa( _count++ ) );
-}
-
-void CTemporarySymbol::removeLastSymbol( )
-{
-	_count--;
-}
-
-unsigned int CTemporarySymbol::getMaxSymbolsUsed( )
-{
-	return( _count );
-}
-
-string CTemporarySymbol::getLastSymbol( )
-{
-	return( _baseName + itoa( _count - 1 ) );
-}
-

Added: trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -0,0 +1,48 @@
+#include <Tools.hpp>
+
+#include "CTemporarySymbol.hpp"
+
+CTemporarySymbol::CTemporarySymbol( )
+	: _baseName("_ts"), _count(1)
+{
+}
+
+CTemporarySymbol::CTemporarySymbol( const string &baseName, const int &initialValue)
+	: _baseName(baseName), _count(initialValue)
+{
+}
+
+CTemporarySymbol::~CTemporarySymbol( )
+{
+}
+
+void CTemporarySymbol::setBaseName( string baseName )
+{
+	_baseName = baseName;
+}
+
+void CTemporarySymbol::setInitialValue( int initialValue )
+{
+	_count = initialValue;
+}
+
+string CTemporarySymbol::getNew( )
+{
+	return( _baseName + itoa( _count++ ) );
+}
+
+void CTemporarySymbol::removeLast( )
+{
+	_count--;
+}
+
+unsigned int CTemporarySymbol::getMaxUsed( )
+{
+	return( _count );
+}
+
+string CTemporarySymbol::getLast( )
+{
+	return( _baseName + itoa( _count - 1 ) );
+}
+

Deleted: trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,25 +0,0 @@
-#ifndef GPT_CTEMPORARY_SYMBOL_H
-#define GPT_CTEMPORARY_SYMBOL_H
-
-#include <string>
-
-using namespace std;
-
-class CTemporarySymbol
-{
-public:
-	CTemporarySymbol( );
-	CTemporarySymbol( const string &baseName, const int &initialValue = 0 );
-	~CTemporarySymbol( );
-	void setBaseName( string baseName );
-	void setInitialValue( int initialValue );
-	string getNewSymbol( );
-	void removeLastSymbol( );
-	unsigned int getMaxSymbolsUsed( );
-	string getLastSymbol( );
-private:
-	string _baseName;
-	int _count;
-};
-
-#endif

Added: trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -0,0 +1,25 @@
+#ifndef GPT_CTEMPORARY_SYMBOL_H
+#define GPT_CTEMPORARY_SYMBOL_H
+
+#include <string>
+
+using namespace std;
+
+class CTemporarySymbol
+{
+public:
+	CTemporarySymbol( );
+	CTemporarySymbol( const string &baseName, const int &initialValue = 0 );
+	~CTemporarySymbol( );
+	void setBaseName( string baseName );
+	void setInitialValue( int initialValue );
+	string getNew( );
+	void removeLast( );
+	unsigned int getMaxUsed( );
+	string getLast( );
+private:
+	string _baseName;
+	int _count;
+};
+
+#endif

Copied: trunk/gpt2/src/modules/parser/CTemporaryVar.cpp (from rev 330, trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp)

Copied: trunk/gpt2/src/modules/parser/CTemporaryVar.hpp (from rev 331, trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp)

Modified: trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,6 +1,8 @@
 #include "GASMFE_CAsmProgram.hpp"
 
+#include "Tools.hpp"
 
+
 CAsmProgram::CAsmProgram( COptions *options )
 	: _options( options ), _context( NULL )
 {
@@ -62,3 +64,9 @@
 	return _context;
 }
 
+
+void CAsmProgram::emitVarDefinition( const string &name, const int &type )
+{
+	_file->writeln( "var " + name + " " + typeInAsm( type ) );
+}
+

Modified: trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -19,6 +19,7 @@
 	CContext *addContext( );
 	CContext *remContext( );
 	CContext *getContext( );
+	void emitVarDefinition( const string &name, const int &type );
 private:
 	COptions *_options;
 	CContext *_context;

Deleted: trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,17 +0,0 @@
-#include "GASMFE_CMakeLabels.hpp"
-
-CMakeLabels::CMakeLabels( const int &initialValue ) : CTemporarySymbol( "__lbl_", initialValue )
-{
-}
-
-
-CMakeLabels::~CMakeLabels( )
-{
-}
-
-
-string CMakeLabels::newLabel( )
-{
-	return getNewSymbol( );
-}
-

Deleted: trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CMakeLabels.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,18 +0,0 @@
-#ifndef GASMFE_CMAKE_LABELS_H
-#define GASMFE_CMAKE_LABELS_H
-
-#include <string>
-using namespace std;
-
-#include "CTemporarySymbol.hpp"
-
-class CMakeLabels : private CTemporarySymbol
-{
-public:
-	CMakeLabels( const int &initialValue = 1 );
-	~CMakeLabels( );
-	string newLabel( );
-};
-
-#endif
-

Deleted: trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,19 +0,0 @@
-#include "GASMFE_CMakeTempVars.hpp"
-
-
-CMakeTempVars::CMakeTempVars( const int &initialValue )
-	: CTemporarySymbol( "__tempvar_", initialValue )
-{
-}
-
-
-CMakeTempVars::~CMakeTempVars( )
-{
-}
-
-
-string CMakeTempVars::newVar( )
-{
-	return getNewSymbol( );
-}
-

Deleted: trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CMakeTempVars.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,18 +0,0 @@
-#ifndef GASMFE_CMAKE_TEMP_VARS_H
-#define GASMFE_CMAKE_TEMP_VARS_H
-
-#include <string>
-using namespace std;
-
-#include "CTemporarySymbol.hpp"
-
-class CMakeTempVars : private CTemporarySymbol
-{
-public:
-	CMakeTempVars( const int &initialValue = 1 );
-	~CMakeTempVars( );
-	string newVar( );
-};
-
-#endif
-

Modified: trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -101,12 +101,68 @@
 //	writeln( "add" );
 //}
 
+
+void CSubroutine::emitISUMMn( const string &var, const string &op1, const string &op2 )
+{
+	writeln( "isum " + var + ", " + op1 + ", " + op2 );
+}
+
+
+void CSubroutine::emitIMULMn( const string &var, const string &op1, const string &op2 )
+{
+	writeln( "imul " + var + ", " + op1 + ", " + op2 );
+}
+
+
+void CSubroutine::emitIGEMn( const string &var, const string &op1, const string &op2 )
+{
+	writeln( "ige " + var + ", " + op1 + ", " + op2 );
+}
+
+
+void CSubroutine::emitIFNOTMn( const string &var, const string &label )
+{
+	writeln( "ifnot " + var + ", " + label );
+}
+
+void CSubroutine::emitJMPMn( const string &label )
+{
+	writeln( "jmp " + label );
+}
+
+
+void CSubroutine::emitMn( const string &mn, const string &op1, const string &op2, const string &op3)
+{
+	write( mn );
+	if (op1.empty()) {
+		writeln( );
+		return;
+	}
+
+	write( " " + op1 );
+	if (op2.empty()) {
+		writeln( );
+		return;
+	}
+
+	write( ", " + op2 );
+	if (op3.empty()) {
+		writeln( );
+		return;
+	}
+
+	writeln( ", " + op3 );
+}
+
+
 void CSubroutine::emitLabel( const string &label )
 {
 	writeln( label + string(":") );
 }
 
 
+
+
 void CSubroutine::write( string value )
 {
 /*	if ( _sourceInfo && *_options->sourceLine > _lastSourceLine ) {

Modified: trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -27,10 +27,17 @@
         void emitISETMn( const string &var, const string &value );
         void emitPUSHMn( const antlr::RefToken &_token, const bool &_pushType = false );
 	void emitPUSHMn( const int& value );
+	void emitISUMMn( const string &var, const string &op1, const string &op2 );
+	void emitIMULMn( const string &var, const string &op1, const string &op2 );
+	void emitIGEMn( const string &var, const string &op1, const string &op2 );
+	void emitIFNOTMn( const string &var, const string &label );
+	void emitJMPMn( const string &label );
+	void emitMn( const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
+
 	void emitLabel( const string &label );
 
 	void write( string value );
-	void writeln( string value );
+	void writeln( string value = "" );
 
 	const string& getName( ) const
 	{

Modified: trunk/gpt2/src/modules/parser/Makefile.am
===================================================================
--- trunk/gpt2/src/modules/parser/Makefile.am	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/Makefile.am	2007-11-01 13:24:25 UTC (rev 333)
@@ -8,9 +8,9 @@
 
 nodist_libparser_la_SOURCES = $(BUILT_SOURCES)
 libparser_la_SOURCES = BasePortugolParser.cpp MismatchedUnicodeCharException.cpp GASMFE_CSubroutine.cpp \
-                       GASMFE_CArguments.cpp  GASMFE_CMakeTempVars.cpp CTemporarySymbol.cpp   \
+                       GASMFE_CArguments.cpp  CTemporarySymbol.cpp   \
                        GASMFE_CContext.cpp Tools.cpp CTextFile.cpp GASMFE_CGptAssemblyFile.cpp          \
-                       GASMFE_CAsmProgram.cpp GASMFE_CMakeLabels.cpp
+                       GASMFE_CAsmProgram.cpp
 
 
 if INSTALL_DEVEL

Modified: trunk/gpt2/src/modules/parser/Tools.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/Tools.cpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/Tools.cpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -252,3 +252,22 @@
    return "ERRO !!!";
 }
 
+const string typeInAsm( const int &type )
+{
+   if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
+      return "int";
+   } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
+      return "string";
+   } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
+      return "int";
+   } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
+      return "int";
+   } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
+      return "pointer ???";
+   } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
+      return "matrix";
+   }
+
+   return "ERRO !!!";
+}
+

Modified: trunk/gpt2/src/modules/parser/Tools.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/Tools.hpp	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/Tools.hpp	2007-11-01 13:24:25 UTC (rev 333)
@@ -33,5 +33,6 @@
 bool streamtoken(istringstream&, string&, string&);
 // string& getStringWithTab(string, string);
 const string typeToText(const int &type);
+const string typeInAsm( const int &type );
 
 #endif

Modified: trunk/gpt2/src/modules/parser/lexer.g
===================================================================
--- trunk/gpt2/src/modules/parser/lexer.g	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/lexer.g	2007-11-01 13:24:25 UTC (rev 333)
@@ -96,6 +96,7 @@
   T_KW_SEJA="seja";
   T_KW_FIM_SENAO="fim-sen?o";
   T_KW_FIM_FACA="fim-fa?a";
+  T_KW_FIM_CASO="fim-caso";
   T_KW_VARIAVEL="vari?vel";
   T_KW_USE="use";
   T_KW_CORINGA="coringa";

Modified: trunk/gpt2/src/modules/parser/parser.g
===================================================================
--- trunk/gpt2/src/modules/parser/parser.g	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/src/modules/parser/parser.g	2007-11-01 13:24:25 UTC (rev 333)
@@ -24,6 +24,7 @@
   #include "GPTDisplay.hpp"
   #include "GASMFE_CAsmProgram.hpp"
   #include "GASMFE_COptions.hpp"
+  #include "CTemporarySymbol.hpp"
 }
 
 options {
@@ -42,21 +43,20 @@
 }
 
 {  
-//  public:
-//    RefPortugolAST getPortugolAST()
-//    {
-//      return returnAST;
-//    }
    public:
       COptions options;
       CAsmProgram  *asmPrg;
       CSubroutine *subroutine;
       CArguments args;
+      CTemporarySymbol tempVar;
+      CTemporarySymbol tempLabel;
       void initParser( )
       {
          options.sourcefile = "xxx.gpt";
          options.destfile   = "xxx.gasm";
          asmPrg = new CAsmProgram( &options );
+         tempVar.setBaseName( "__temp_" );
+         tempLabel.setBaseName( "__label_" );
       }
       void finishParser( )
       {
@@ -66,26 +66,17 @@
 }
 
 
+//#########################
+//## In?cio da gram?tica ##
+//#########################
 
+//##############
+//## Programa ##
+//##############
 
-/******************************** GRAMATICA *************************************************/
-
-/*algoritmo
-  : declaracao_algoritmo (var_decl_block)? stm_block (func_decls)* EOF
-  ;
-
-  exception //nem "variaveis" nem "inicio"
-  catch[antlr::NoViableAltException e] {
-    reportParserError(e.getLine(), 
-      "\"vari?veis\" ou \"in?cio\" ap?s declara??o de algoritmo", getTokenDescription(e.token));
-  }
-
-  catch[antlr::MismatchedTokenException e] { //EOF
-    reportParserError(e.getLine(), expecting_eof_or_function, getTokenDescription(e.token));
-  }
-*/
-
-programa 
+//--------
+  programa
+//-------- 
   : { initParser( ); } (declaracao_algoritmo)? (importacao)*
     (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis)* corpo EOF
     { finishParser( ); }
@@ -106,10 +97,15 @@
   ;
 
 
-/****************************************************************************/
-declaracao_variaveis
+//#############################
+//## Declara??o de vari?veis ##
+//#############################
+
+//--------------------
+  declaracao_variaveis
+//--------------------
   : bloco_declaracao_variaveis
-  | "vari?vel" declaracao_variavel T_SEMICOL
+  | "vari?vel" declaracao_variavel
   ;
 
 bloco_declaracao_variaveis
@@ -117,7 +113,16 @@
   ;
 
 declaracao_variavel
-  : T_IDENTIFICADOR (T_COMMA T_IDENTIFICADOR)* T_COLON tipo (lista_inicializacao)? T_SEMICOL
+{
+  RefToken tk_type;
+}
+  : tk_id:T_IDENTIFICADOR 
+    (T_COMMA T_IDENTIFICADOR)* 
+    T_COLON tipo {tk_type = lastToken; }
+    (lista_inicializacao)? T_SEMICOL
+    { // TODO: nao esta correto porque so gera uma variavel...
+       asmPrg->emitVarDefinition( tk_id->getText( ), tk_type->getType( ) );
+    }
   ;
 
 declaracao_variavel_sing
@@ -131,7 +136,7 @@
   ;
 
 lista_inicializacao
-  : T_ATTR (expressao | inicializacao_composta)
+  : T_ATTR (expr | inicializacao_composta)
   ;
 
 inicializacao_composta
@@ -140,11 +145,11 @@
   ;
 
 inicializacao_indices
-  : (expressao | inicializacao_composta)
+  : (expr | inicializacao_composta)
   ;
 
 inicializacao_membros
-  : T_IDENTIFICADOR T_ATTR (expressao | inicializacao_composta)
+  : T_IDENTIFICADOR T_ATTR (expr | inicializacao_composta)
   ;
 
 tipo_primitivo
@@ -217,46 +222,105 @@
   ;
 
 enunciado
-  : en_atribuicao
+  : (lvalue T_ATTR)=> en_atribuicao
   | en_retorne
   | en_se
   | en_enquanto
-  | en_repita
+//  | en_repita
   | en_para
   | en_caso
   | en_asm
-  | expressao
+  | expr
   | "sair" T_SEMICOL
   | T_SEMICOL
   ;
 
 en_atribuicao
 {
-   RefToken tklvalue;
-   RefToken tkexpret;
+   string tklvalue;
+   string tkexpret;
 }
-  : tklvalue=lvalue T_ATTR tkexpret=expressao T_SEMICOL
-    { subroutine->emitISETMn( tklvalue->getText( ), tkexpret->getText( ) ); }
+  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
+//  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
+//  : (lvalue T_ATTR)=> stm_attr {tkexpret=lastToken;} T_SEMICOL
+    { subroutine->emitISETMn( tklvalue, tkexpret ); }
   ;
 
+stm_attr
+  : lvalue T_ATTR expr
+  ;
+
 en_retorne
-  : "retorne" (expressao)? T_SEMICOL
+  : "retorne" (expr)? T_SEMICOL
   ;
 
-lvalue returns [RefToken tk_id]
-  : T_IDENTIFICADOR {tk_id=lastToken;} //(T_ABREC expressao T_FECHAC)*
+lvalue returns [string tk_id]
+  : T_IDENTIFICADOR {tk_id=lastToken->getText( );} //(T_ABREC expr T_FECHAC)*
   ;
 
 en_se
-  : "se" expressao "ent?o" lista_enunciados ("sen?o" lista_enunciados)? "fim-se"
+{
+  string expRet;
+  string elseLabel;
+  string nextLabel;
+}
+  : "se" expRet=expr "ent?o" { elseLabel = tempLabel.getNew( ); subroutine->emitIFNOTMn( expRet, elseLabel ); }
+    lista_enunciados
+    { nextLabel = tempLabel.getNew( ); subroutine->emitJMPMn( nextLabel ); }
+    ("sen?o" { subroutine->emitLabel( elseLabel ); } lista_enunciados)? "fim-se"
+    { subroutine->emitLabel( nextLabel ); }
   ;
 
 en_enquanto
-  : "enquanto" expressao "fa?a" lista_enunciados "fim-enquanto"
+{
+  string testLabel;
+  string expRet;
+  string nextCommandLabel;
+}
+  : "enquanto"
+    {
+       testLabel = tempLabel.getNew( );
+       nextCommandLabel = tempLabel.getNew( );
+       subroutine->emitLabel( testLabel );
+    }
+    expRet=expr "fa?a"
+    {
+       subroutine->emitIFNOTMn( expRet, nextCommandLabel );
+    }
+    lista_enunciados
+    "fim-enquanto"
+    {
+       subroutine->emitJMPMn( testLabel );
+       subroutine->emitLabel( nextCommandLabel );
+    }
   ;
 
 en_para
-  : "para" lvalue "de" expressao "at?" expressao (passo)? "fa?a" lista_enunciados "fim-para"
+{
+  string lvalueRet;
+  string exp1;
+  string exp2;
+  string testLabel;
+  string nextCommandLabel;
+  string testVar;
+}
+  : "para" lvalueRet=lvalue "de" exp1=expr "at?" exp2=expr (passo)? "fa?a"
+    {
+       subroutine->emitISETMn( lvalueRet, exp1 );
+       testLabel = tempLabel.getNew( );
+       nextCommandLabel = tempLabel.getNew( );
+       testVar   = tempVar.getNew( );
+       subroutine->emitLabel( testLabel );
+       subroutine->emitMn( "ile", testVar, lvalueRet, exp2 );
+       subroutine->emitIFNOTMn( testVar, nextCommandLabel );
+    }
+    lista_enunciados
+    "fim-para"
+    {
+       subroutine->emitMn( "iinc", lvalueRet, "1" );
+       subroutine->emitJMPMn( testLabel );
+       subroutine->emitLabel( nextCommandLabel );
+    }
   ;
 
 passo
@@ -264,20 +328,48 @@
   ;
 
 //en_repita
-//  : "repita" lista_enunciados "enquanto" expressao
-//  | "repita" lista_enunciados "at?" expressao
+//  : "repita" lista_enunciados "enquanto" expr
+//  | "repita" lista_enunciados "at?" expr
 //  ;
 
-en_repita
-  : "repita" lista_enunciados "at?" expressao
-  ;
+//en_repita
+//  : "repita" lista_enunciados "at?" expr
+//  ;
 
 en_caso 
-  : "caso" expressao "seja" (teste_caso)+ ("sen?o" lista_enunciados "fim-sen?o")? "fim-caso" 
+{
+  string expret;
+  string varTest;
+  string nextCommandLabel;
+  string nextTestLabel;
+}
+  : "caso" expret=expr "seja" 
+    {
+       varTest = tempVar.getNew( );
+       subroutine->emitISETMn( varTest, expret );
+       nextCommandLabel = tempLabel.getNew( );
+    }
+    (
+       nextTestLabel=teste_caso[varTest]
+       {subroutine->emitJMPMn( nextCommandLabel ); subroutine->emitLabel( nextTestLabel );}
+    )+ ("sen?o" lista_enunciados "fim-sen?o")? "fim-caso" 
+    {
+       subroutine->emitLabel( nextCommandLabel );
+    }
   ; 
   
-teste_caso
-  : literal "fa?a" lista_enunciados "fim-fa?a"
+teste_caso [string varTest] returns [string nextTestLabel]
+{
+  string lit;
+}
+  : lit=literal "fa?a" 
+    {
+       subroutine->emitMn( "ieq", tempVar.getNew( ), varTest, lit );
+       nextTestLabel = tempLabel.getNew( );
+       subroutine->emitIFNOTMn( tempVar.getLast( ), nextTestLabel );
+    }
+    lista_enunciados
+    "fim-fa?a"
   ;
 
 en_asm
@@ -286,79 +378,123 @@
 
 
 /****************************************************************************/
-expressao returns [RefToken tk_ret]
-  : termo {tk_ret=lastToken;} //T_BIT_E termo
+chamada_subrotina
+  : tk_id:T_IDENTIFICADOR T_ABREP
+    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos { args.emitMnsInSubroutineCall( ); })? T_FECHAP
+    { subroutine->emitPCALLMn( tk_id->getText( ) ); }
+  ; 
+
+lista_argumentos
+{
+   RefToken exp;
+}
+  : expr { args.push_back( lastToken ); }
+    (T_COMMA expr { args.push_back( lastToken ); } )*
   ;
 
-/*
-expressao
-  : termo "|" termo
-  | termo "^" termo
-  | termo "&" termo
-  | termo ">>" termo 
-  | termo "<<" termo
-  | termo ("ou" | "||") termo
-  | termo ("e" | "&&") termo
-  | termo ("=" | "<>") termo
-  | termo (">" | ">="|"<"|"<=") termo
-  | termo ("+" | "-") termo
-  | termo ("/" | "*" | "%") termo
-  | ("+" | "-" | "~" | "n?o")? termo
-  | "(" termo ")"
-  | chamada_subrotina
+literal returns [string ret]
+  : ( T_STRING_LIT | T_INT_LIT | T_REAL_LITERAL | T_CARAC_LITERAL | "verdadeiro" | "falso" ) {ret=lastToken->getText( );}
   ;
-*/
 
-/*expressao
-  : expressao "|" expressao
-  | expressao "^" expressao
-  | expressao "&" expressao
-  | expressao ">>" expressao 
-  | expressao "<<" expressao
-  | expressao ("ou" | "||") expressao
-  | expressao ("e" | "&&") expressao
-  | expressao ("=" | "<>") expressao
-  | expressao (">" | ">="|"<"|"<=") expressao
-  | expressao ("+" | "-") expressao
-  | expressao ("/" | "*" | "%") expressao
-  | ("+" | "-" | "~" | "n?o")? termo
+
+/* ----------------------------- Expressoes ---------------------------------- */
+
+expr returns [string ret]
+  : ret=expr_e (T_KW_OU expr_e)*
   ;
-*/
+  
+expr_e  returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+{
+  string op2;
+}
+  : ret=expr_bit_ou (T_KW_E op2=expr_bit_ou {subroutine->emitMn( "and", tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
+  ;
 
+expr_bit_ou returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+  : ret=expr_bit_xou (T_BIT_OU expr_bit_xou)*
+  ;
 
-termo returns [RefToken tk_ret]
-  : tk_ret=lvalue
-  | literal { tk_ret = lastToken; }
-  | chamada_subrotina
+expr_bit_xou  returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+  : ret=expr_bit_e (T_BIT_XOU expr_bit_e)*
   ;
 
-//termo
-//  : chamada_subrotina
-//  | lvalue
-//  | literal
-////  | "(" expressao ")"
-//  ;
+expr_bit_e returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+  : ret=expr_igual (T_BIT_E expr_igual)*
+  ;
+  
+expr_igual returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+  : ret=expr_relacional (T_IGUAL expr_relacional|T_DIFERENTE expr_relacional)*
+  ;
+        
+expr_relacional returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+{
+  string op2;
+}
+  : ret=expr_ad ((T_MAIOR| T_MAIOR_EQ| T_MENOR| T_MENOR_EQ)
+    op2=expr_ad {subroutine->emitIGEMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
+  ;
 
-chamada_subrotina
-  : tk_id:T_IDENTIFICADOR T_ABREP
-    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos { args.emitMnsInSubroutineCall( ); })? T_FECHAP
-    { subroutine->emitPCALLMn( tk_id->getText( ) ); }
-  ; 
+expr_ad returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+{
+   string op2;
+}
+  : ret=expr_multip (T_MAIS op2=expr_multip {subroutine->emitISUMMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); }
+                    | T_MENOS expr_multip)*
+  ;
 
-lista_argumentos
+expr_multip returns [string op1]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
 {
-   RefToken exp;
+  string op2;
+  RefToken op;
 }
-  : exp=expressao { args.push_back( exp ); }
-    (T_COMMA exp=expressao { args.push_back( exp ); } )*
+  : op1=expr_unario
+    (( T_DIV | T_MULTIP | T_MOD ) {op=lastToken;} op2=expr_unario {subroutine->emitIMULMn( tempVar.getNew( ), op1, op2 ); op1=tempVar.getLast( ); } )*
   ;
 
-literal
-  : T_STRING_LIT
-  | T_INT_LIT
-  | T_REAL_LITERAL
-  | T_CARAC_LITERAL
-  | "verdadeiro"
-  | "falso"
+expr_unario returns [string ret]
+options {
+  defaultErrorHandler=false; //noviable should be caught on expr
+}
+  : op_unario ret=expr_elemento
   ;
 
+op_unario
+  : (
+        e:T_MENOS
+      | a:T_MAIS
+      | n:T_KW_NOT
+      | b:T_BIT_NOT
+    )?
+  ; 
+
+expr_elemento returns [string ret]
+  : (T_IDENTIFICADOR T_ABREP)=> chamada_subrotina // ret= ???
+  | ret=lvalue
+  | ret=literal
+  | t:T_ABREP ret=expr T_FECHAP 
+  ;
+

Modified: trunk/gpt2/test/wikki/estruturas_condicionais_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/estruturas_condicionais_4.gpt	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/test/wikki/estruturas_condicionais_4.gpt	2007-11-01 13:24:25 UTC (rev 333)
@@ -4,15 +4,15 @@
 
 in?cio
     x := leia( );
-    caso x fa?a
-    op??o 1:
+    caso x seja
+    1 fa?a
         imprima( "x = um" );
-    fim-op??o
-    op??o 2:
+    fim-fa?a
+    2 fa?a
         imprima( "x = dois" );
-    fim-op??o
-    sen?o:
+    fim-fa?a
+    sen?o
         imprima( "x diferente de um e dois" );
-    fim-op??o
+    fim-sen?o
     fim-caso
 fim

Modified: trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt	2007-10-31 13:25:47 UTC (rev 332)
+++ trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt	2007-11-01 13:24:25 UTC (rev 333)
@@ -1,5 +1,12 @@
 algoritmo exemplo;
 
+vari?vel t1: inteiro;
+
 in?cio
-    imprima( "2+5*3=", 2+5*3 );
+    t1 := 1+2;
+    t1 := 5*3;
+    t2 := 2+t1;
+    imprima( "2+5*3=", t2 );
+    t1 := 2+5*3;
+    imprima( "2+5*3=", t1 );
 fim



From gpt-commit-noreply at mail.berlios.de  Thu Nov  1 14:42:58 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 1 Nov 2007 14:42:58 +0100
Subject: [gpt-commit] r334 - trunk/gpt2/src/modules/parser
Message-ID: <200711011342.lA1Dgwp0010563@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-01 14:42:58 +0100 (Thu, 01 Nov 2007)
New Revision: 334

Removed:
   trunk/gpt2/src/modules/parser/CTemporaryVar.cpp
   trunk/gpt2/src/modules/parser/CTemporaryVar.hpp
Log:
DEVNULL:
- Removendo arquivos nao utilizados


Deleted: trunk/gpt2/src/modules/parser/CTemporaryVar.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporaryVar.cpp	2007-11-01 13:24:25 UTC (rev 333)
+++ trunk/gpt2/src/modules/parser/CTemporaryVar.cpp	2007-11-01 13:42:58 UTC (rev 334)
@@ -1,46 +0,0 @@
-#include <Tools.hpp>
-#include "CTemporarySymbol.hpp"
-
-CTemporarySymbol::CTemporarySymbol( )
-{
-}
-
-CTemporarySymbol::CTemporarySymbol( const string &baseName, const int &initialValue)
-	: _baseName(baseName), _count(initialValue)
-{
-}
-
-CTemporarySymbol::~CTemporarySymbol( )
-{
-}
-
-void CTemporarySymbol::setBaseName( string baseName )
-{
-	_baseName = baseName;
-}
-
-void CTemporarySymbol::setInitialValue( int initialValue )
-{
-	_count = initialValue;
-}
-
-string CTemporarySymbol::getNewSymbol( )
-{
-	return( _baseName + itoa( _count++ ) );
-}
-
-void CTemporarySymbol::removeLastSymbol( )
-{
-	_count--;
-}
-
-unsigned int CTemporarySymbol::getMaxSymbolsUsed( )
-{
-	return( _count );
-}
-
-string CTemporarySymbol::getLastSymbol( )
-{
-	return( _baseName + itoa( _count - 1 ) );
-}
-

Deleted: trunk/gpt2/src/modules/parser/CTemporaryVar.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporaryVar.hpp	2007-11-01 13:24:25 UTC (rev 333)
+++ trunk/gpt2/src/modules/parser/CTemporaryVar.hpp	2007-11-01 13:42:58 UTC (rev 334)
@@ -1,25 +0,0 @@
-#ifndef GPT_CTEMPORARY_SYMBOL_H
-#define GPT_CTEMPORARY_SYMBOL_H
-
-#include <string>
-
-using namespace std;
-
-class CTemporarySymbol
-{
-public:
-	CTemporarySymbol( );
-	CTemporarySymbol( const string &baseName, const int &initialValue = 0 );
-	~CTemporarySymbol( );
-	void setBaseName( string baseName );
-	void setInitialValue( int initialValue );
-	string getNewSymbol( );
-	void removeLastSymbol( );
-	unsigned int getMaxSymbolsUsed( );
-	string getLastSymbol( );
-private:
-	string _baseName;
-	int _count;
-};
-
-#endif



From gpt-commit-noreply at mail.berlios.de  Mon Nov  5 17:07:52 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 5 Nov 2007 17:07:52 +0100
Subject: [gpt-commit] r335 - in trunk/gpt2: . src src/modules
	src/modules/parser test test/wikki test/wikki/checked
Message-ID: <200711051607.lA5G7qnb030507@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-05 17:07:40 +0100 (Mon, 05 Nov 2007)
New Revision: 335

Added:
   trunk/gpt2/test/check.sh
   trunk/gpt2/test/check_all.sh
   trunk/gpt2/test/comp.sh
   trunk/gpt2/test/comp_all.sh
   trunk/gpt2/test/gpt
   trunk/gpt2/test/prep_tests.sh
   trunk/gpt2/test/show_and_comp.sh
   trunk/gpt2/test/test_ok.sh
   trunk/gpt2/test/test_ok_all.sh
   trunk/gpt2/test/teste_chamada_subrotinas.gpt
   trunk/gpt2/test/wikki/checked/
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gasm
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gpt
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gasm
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gpt
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gasm
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gpt
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gasm
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gpt
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gasm
   trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gpt
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gasm
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gpt
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gasm
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gpt
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gasm
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gpt
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gasm
   trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gpt
   trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gasm
   trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gpt
   trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gasm
   trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gpt
   trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gpt
   trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gpt
   trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gasm
   trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gpt
   trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gpt
   trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gpt
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gpt
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gpt
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gpt
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gasm
   trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gpt
   trunk/gpt2/test/wikki/checked/variaveis_1.gasm
   trunk/gpt2/test/wikki/checked/variaveis_1.gpt
   trunk/gpt2/test/wikki/checked/variaveis_2.gasm
   trunk/gpt2/test/wikki/checked/variaveis_2.gpt
   trunk/gpt2/test/wikki/checked/variaveis_3.gasm
   trunk/gpt2/test/wikki/checked/variaveis_3.gpt
   trunk/gpt2/test/wikki/checked/variaveis_4.gasm
   trunk/gpt2/test/wikki/checked/variaveis_4.gpt
   trunk/gpt2/test/wikki/checked/variaveis_5.gasm
   trunk/gpt2/test/wikki/checked/variaveis_5.gpt
   trunk/gpt2/test/wikki/checked/variaveis_6.gasm
   trunk/gpt2/test/wikki/checked/variaveis_6.gpt
   trunk/gpt2/test/wikki/checked/variaveis_7.gasm
   trunk/gpt2/test/wikki/checked/variaveis_7.gpt
   trunk/gpt2/test/wikki/estruturas_condicionais_5.gpt
   trunk/gpt2/test/wikki/expressoes_matematicas_2.gpt
Modified:
   trunk/gpt2/configure.in
   trunk/gpt2/src/GPT.cpp
   trunk/gpt2/src/GPT.hpp
   trunk/gpt2/src/modules/Symbol.cpp
   trunk/gpt2/src/modules/Symbol.hpp
   trunk/gpt2/src/modules/SymbolTable.cpp
   trunk/gpt2/src/modules/SymbolTable.hpp
   trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
   trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
   trunk/gpt2/src/modules/parser/CTextFile.cpp
   trunk/gpt2/src/modules/parser/CTextFile.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CArguments.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CArguments.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp
   trunk/gpt2/src/modules/parser/GASMFE_COptions.hpp
   trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp
   trunk/gpt2/src/modules/parser/Makefile.am
   trunk/gpt2/src/modules/parser/Tools.cpp
   trunk/gpt2/src/modules/parser/Tools.hpp
   trunk/gpt2/src/modules/parser/lexer.g
   trunk/gpt2/src/modules/parser/parser.g
   trunk/gpt2/test/wikki/constantes_1.gpt
   trunk/gpt2/test/wikki/estruturas_repeticao_4.gpt
   trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt
   trunk/gpt2/test/wikki/inline_codigo_gptassembly.gpt
   trunk/gpt2/test/wikki/matrizes_3.gpt
   trunk/gpt2/test/wikki/variaveis_4.gpt
   trunk/gpt2/test/wikki/variaveis_7.gpt
Log:
- Geracao do prototipo do ambiente para execucao de testes regressivos
- Implementado parcialmente o suporte a qualquer simbolo da linguagem
  na tabela de simbolos
- Implementado metodos para conversao de tipos entre Portugol e GptAssembly
- Correcao de exemplos em Portugol estavam sintaticamente incorretos
- Alteracoes no front-end para geracao de codigo GptAssembly
  - Flexibilizacao nas rotinas de geracao de mnemonicos
  - Refactory nas classes de geracao do texto em GptAssembly
  - Geracao correta da declaracao de variaveis globais, locais e parametros
  - Geracao correta para expressoes (com precedencia)
  - Geracao dos mnemonicos corretos conforme o tipo de dado
  - Geracao correta para declaracao de procedimentos e funcoes
  - Geracao correta para chamada de procedimentos e funcoes
    - Empilha na ordem inversa os argumentos
    - Gera espaco para retorno de funcoes e desempilha o resultado
  - Geracao correta para as seguintes sentencas:
    - se..fim-se
    - se..senao..fim-se
    - enquanto..fim-enquanto
    - para..fim-para (com e sem passo)
    - repita..ate
    - caso..fim-caso
  - Geracao correta para assembly inline


Modified: trunk/gpt2/configure.in
===================================================================
--- trunk/gpt2/configure.in	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/configure.in	2007-11-05 16:07:40 UTC (rev 335)
@@ -39,17 +39,19 @@
   if test $use_debug_code = "full"; then
     CXXFLAGS="-g3 $CXXFLAGS"
   else
-    CXXFLAGS="-g -O2 $CXXFLAGS"
+    CXXFLAGS="-g  $CXXFLAGS"
   fi
 else
-  CXXFLAGS="-O2 $CXXFLAGS"
+  CXXFLAGS="-g $CXXFLAGS"
 fi
 
 if test "$use_debug_define" = "yes"; then
   CXXFLAGS="-DDEBUG $CXXFLAGS"
 fi
 
+CXXFLAGS += "-g"
 
+
 dnl------------------------------
 dnl Check SO
 dnl------------------------------

Modified: trunk/gpt2/src/GPT.cpp
===================================================================
--- trunk/gpt2/src/GPT.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/GPT.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -131,25 +131,13 @@
   }
 
   string ofname = _outputfile;
-//  if(!_useOutputFile) {
-//    if(!genBinary) {
-      ofname += ".asm";
-//    } 
-//    #ifdef WIN32
-//    else 
-//    {      
-//      ofname += ".exe";      
-//    }
-//    #endif
-//  }
+  ofname += ".asm";
 
-//  X86Walker x86(_stable);
   string asmsrc = "teste.gasm";//x86.algoritmo(_astree);
 
   string ftmpname = createTmpFile();
   ofstream fo;
 
-//  if(!genBinary) { //salva assembly code
     fo.open(ofname.c_str(), ios_base::out);
     if(!fo) {
       s << PACKAGE << ": n?o foi poss?vel abrir o arquivo: \"" << ofname << "\"" << endl;
@@ -158,32 +146,8 @@
     }
     fo << asmsrc;
     fo.close();
-//  } else { //compile
-//    fo.open(ftmpname.c_str(), ios_base::out);
-//    if(!fo) {
-//      s << PACKAGE << ": erro ao processar arquivo tempor?rio" << endl;
-//      GPTDisplay::self()->showError(s);
-//      goto bail;
-//    }
-//    fo << asmsrc;
-//    fo.close();
 
-//    stringstream cmd;
-//    cmd << "nasm -fbin -o " << ofname << " " << ftmpname;
 
-//    if(system(cmd.str().c_str()) == -1) {
-//      s << PACKAGE << ": n?o foi poss?vel invocar gcc." << endl;
-//      GPTDisplay::self()->showError(s);
-//      goto bail;
-//    }
-
-//    #ifndef WIN32
-//      cmd.str("");
-//      cmd << "chmod +x " << ofname;
-//      system(cmd.str().c_str());
-//    #endif
-  //}
-
   success = true;
 
   bail:
@@ -193,54 +157,7 @@
     return success;
 }
 
-/*bool GPT::translate2C(const list<string>& ifnames) {
-  bool success = false;
-  stringstream s;
 
-  if(!prologue(ifnames)) {
-    return false;
-  }
-
-  string ofname = _outputfile;
-  if(!_useOutputFile) {
-     ofname += ".c";
-  }
-
-  Portugol2CWalker pt2c(_stable);
-  string c_src = pt2c.algoritmo(_astree);
-
-  ofstream fo;
-  fo.open(ofname.c_str(), ios_base::out);
-  if(!fo) {
-    s << PACKAGE << ": n?o foi poss?vel abrir o arquivo: \"" << ofname << "\"" << endl;
-    GPTDisplay::self()->showError(s);
-    goto bail;
-  }
-  fo << c_src;
-  fo.close();
-
-  success = true;
-
-  bail:
-    return success;
-}
-*/
-
-
-/*
-bool GPT::interpret(const list<string>& ifnames, const string& host, int port) {
-  if(!prologue(ifnames)) {
-    return false;
-  }
-
-  InterpreterWalker interpreter(_stable, host, port);
-  interpreter.algoritmo(_astree);
-
-  return true;
-}
-*/
-
-
 bool GPT::parse(list<pair<string,istream*> >& istream_list) {
   stringstream s;
   
@@ -282,36 +199,32 @@
 
     GPTDisplay::self()->setCurrentFile(firstFile);
     
-//    ASTFactory ast_factory(PortugolAST::TYPE_NAME,&PortugolAST::factory);
-//    parser.initializeASTFactory(ast_factory);
-//    parser.setASTFactory(&ast_factory);
+    // nao esta correto, mas funciona utilizarmos fistFile enquanto tivermos um arquivo apenas
+    string file = firstFile;
+    // retira a extensao
+    size_t pos = file.rfind( "." );
+    file.erase( pos, 4 );
 
-//    parser.algoritmo();
-    parser.programa();
-    if(_outputfile.empty()) {
-      _outputfile = parser.nomeAlgoritmo();
-    }
+    string asmProgram = parser.programa(file);
 
     if(GPTDisplay::self()->hasError()) {
       GPTDisplay::self()->showErrors();
       return false;
     }
 
-//    _astree = parser.getPortugolAST();
 
-//    if(!_astree) {
-//      s << PACKAGE << ": erro interno: no parse tree" << endl;
-//      GPTDisplay::self()->showError(s);
-//      return false;
-//    }
+    ofstream fo;
 
-//    if(_printParseTree) {
-//      std::cerr << _astree->toStringList() << std::endl << std::endl;
-//    }
+    string asmFile = file + ".gasm";
+    fo.open(asmFile.c_str(), ios_base::out);
+    if(!fo) {
+      s << PACKAGE << ": n?o foi poss?vel abrir o arquivo: \"" << asmFile << "\"" << endl;
+      GPTDisplay::self()->showError(s);
+      return false;
+    }
+    fo << asmProgram;
+    fo.close();
 
-//    SemanticWalker semantic(_stable);
-//    semantic.algoritmo(_astree);
-
     if(GPTDisplay::self()->hasError()) {
       GPTDisplay::self()->showErrors();
       return false;

Modified: trunk/gpt2/src/GPT.hpp
===================================================================
--- trunk/gpt2/src/GPT.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/GPT.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -24,7 +24,6 @@
 #include <list>
 #include <string>
 
-//#include "PortugolAST.hpp"
 #include "SymbolTable.hpp"
 
 
@@ -39,16 +38,12 @@
   static GPT* self();
 
   void reportDicas(bool value);
-//  void printParseTree(bool value);
-//   void usePipe(bool value);
   void setOutputFile(string str);
 
   void showHelp();
   void showVersion();
 
   bool compile(const list<string>& ifnames, bool genBinary = true);
-//  bool translate2C(const list<string>& ifnames);
-//  bool interpret(const list<string>& ifnames, const string& host, int port);
   
 private:
   GPT();
@@ -61,12 +56,9 @@
 
   bool prologue(const list<string>& ifname);
 
-//   bool _usePipe;
-//  bool _printParseTree;
   bool _useOutputFile;
   string _outputfile;
 
-//  RefPortugolAST _astree;
   SymbolTable    _stable;
   
 };

Modified: trunk/gpt2/src/modules/Symbol.cpp
===================================================================
--- trunk/gpt2/src/modules/Symbol.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/Symbol.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -20,15 +20,18 @@
 
 #include "Symbol.hpp"
 
+#include "PortugolParserTokenTypes.hpp"
+
 #include <sstream>
 
 SymbolType::SymbolType() 
   : _isPrimitive(true)
   , _primitiveType(TIPO_NULO)
+  , _isVariable(true)
   {}
   
-SymbolType::SymbolType(int type) 
-  : _isPrimitive(true), _primitiveType(type)
+SymbolType::SymbolType(int type, bool isVariable) 
+  : _isPrimitive(true), _primitiveType(type), _isVariable(isVariable)
   {
 }
 
@@ -38,7 +41,7 @@
   _dimensions.clear();
 }
 
-int SymbolType::primitiveType() const {
+int SymbolType::getPrimitiveType() const {
   return _primitiveType;
 }
   
@@ -50,6 +53,11 @@
   return _isPrimitive;
 }
 
+void SymbolType::setIsVariable(bool isVariable)
+{
+  _isVariable = isVariable;
+}
+
 void SymbolType::setDimensions(const list<int>& d) {
   _isPrimitive = false;
   _dimensions = d;
@@ -73,10 +81,36 @@
   return str.str();
 }
 
+
+string SymbolType::toAsmType() const {
+  string str;
+  switch(_primitiveType) {
+//    case TIPO_NULO:      str = "null"; break;
+    case PortugolParserTokenTypes::T_KW_INTEIRO:    str = "int"; break;
+    case PortugolParserTokenTypes::T_KW_REAL:   str = "real"; break;
+    case PortugolParserTokenTypes::T_KW_CARACTERE:  str = "char"; break;
+    case PortugolParserTokenTypes::T_KW_LITERAL: str = "string"; break;
+    case PortugolParserTokenTypes::T_KW_LOGICO: str = "bool"; break;
+    case PortugolParserTokenTypes::T_KW_MATRIZ: str = "matrix"; break;
+//    case TIPO_LOGICO:    str = "bool"; break;    
+//    case TIPO_MATRIZ:    str = "matrix"; break;
+//    case TIPO_ALL:       str = "@all"; break;
+    default:             str = "desconhecido"; break;
+  }
+  return str;
+}
+
+bool SymbolType::getIsVariable( ) const
+{
+   return _isVariable;
+}
+
+
+
 //------------------------------------------------------------------------------------//
 
 Symbol::Symbol() 
-  : cd(-1), scope(), lexeme(), line(-1), type(TIPO_NULO), isFunction(false), isBuiltin(false)
+  : cd(-1), scope(), lexeme(), line(-1), type(TIPO_NULO,false), isFunction(false), isBuiltin(false)
   , param()
 {
 
@@ -84,20 +118,21 @@
 
 Symbol::Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_) 
   : cd(-1), scope(scope_), lexeme(lexeme_), line(line_)
-  , type(TIPO_NULO), isFunction(isfunction_), isBuiltin(false)
+  , type(TIPO_NULO,false), isFunction(isfunction_), isBuiltin(false)
   , param() {}
 
 
-Symbol::Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_) 
+Symbol::Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_, bool isVariable_) 
     : cd(-1), scope(scope_), lexeme(lexeme_), line(line_)
     , type(), isFunction(isfunction_), isBuiltin(false)
     , param() {
 
   type.setPrimitive(true);
   type.setPrimitiveType(type_);
+  type.setIsVariable(isVariable_);
 }
 
-Symbol::Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_,
+Symbol::Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_, bool isVariable_,
   const list<int>& dimensions) 
     : cd(-1), scope(scope_)
     , lexeme(lexeme_)
@@ -113,6 +148,7 @@
   } else {
     type.setPrimitive(true);
   }
+  type.setIsVariable(isVariable_);
 }
 
 bool Symbol::isValid() const {
@@ -133,3 +169,9 @@
   }
   return str;
 }
+
+
+SymbolType Symbol::getType( ) const
+{
+   return type;
+}

Modified: trunk/gpt2/src/modules/Symbol.hpp
===================================================================
--- trunk/gpt2/src/modules/Symbol.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/Symbol.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -37,22 +37,28 @@
 class SymbolType {
 public:
   SymbolType();
-  SymbolType(int type);
+  SymbolType(int type, bool isVariable);
 
   void setPrimitiveType(int type);
-  int primitiveType() const;
+  int getPrimitiveType() const;
   
   void setPrimitive(bool);
   bool isPrimitive() const;
 
+  void setIsVariable(bool);
+
   void setDimensions(const list<int>&);
   list<int>& dimensions();
 
   string toString() const;
+  string toAsmType() const;
+
+  bool getIsVariable( ) const;
 protected:
   bool _isPrimitive;
   int _primitiveType;  
   list<int>    _dimensions; //conjunto/matrizASTRef  
+  bool _isVariable;
 };
 
 class ParameterSig {
@@ -61,7 +67,7 @@
   : variable_params(false)  {}
 
   void add(const string& name, int type) {
-    SymbolType s(type);
+    SymbolType s(type, false);
     params.push_back(pair<string, SymbolType>(name,s));
   }
 
@@ -72,7 +78,7 @@
     params.push_back(pair<string, SymbolType>(name,t));
   }
 
-  int paramType(int idx) {
+  int getParamType(int idx) {
     if(isVariable()) {
       return TIPO_ALL;
     }
@@ -80,7 +86,7 @@
     int c = 0;
     for(list<pair<string,SymbolType> >::iterator it = params.begin(); it != params.end(); it++, c++) {
       if(c == idx) {
-        return (*it).second.primitiveType();
+        return (*it).second.getPrimitiveType();
       }
     }
     return TIPO_NULO; //throw exception?
@@ -100,16 +106,18 @@
   
   Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_);
 
-  Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_);
+  Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_, bool isVariable_);
 
-  Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_,
+  Symbol(const string& scope_, const string& lexeme_, int line_, bool isfunction_, int type_, bool isVariable_,
     const list<int>& dimensions);
 
   bool isValid() const;
      
   static string typeToString(int type);
 
+  SymbolType getType( ) const;
 
+
   //attrs
 
   

Modified: trunk/gpt2/src/modules/SymbolTable.cpp
===================================================================
--- trunk/gpt2/src/modules/SymbolTable.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/SymbolTable.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -37,14 +37,14 @@
 }
 
 void SymbolTable::registrarLeia() {
-  Symbol f(SymbolTable::GlobalScope, "leia", 0, true, TIPO_ALL);
+  Symbol f(SymbolTable::GlobalScope, "leia", 0, true, TIPO_ALL, false);
   f.cd = currentCod++;
   f.isBuiltin = true;
   insertSymbol(f, SymbolTable::GlobalScope);
 }
 
 void SymbolTable::registrarImprima() {
-  Symbol f(SymbolTable::GlobalScope, "imprima", 0, true, TIPO_NULO);
+  Symbol f(SymbolTable::GlobalScope, "imprima", 0, true, TIPO_NULO, false);
   f.cd = currentCod++;
   f.param.setVariable(true);
   f.isBuiltin = true;
@@ -52,7 +52,7 @@
 }
 
 void SymbolTable::declareVar(const string& scope, const string& lexeme, int line, int type) {
-  Symbol s(scope, lexeme, line, false, type);
+  Symbol s(scope, lexeme, line, false, type, true);
   s.cd = currentCod++;
   symbols[scope].push_back(s);
 }
@@ -60,12 +60,19 @@
 void SymbolTable::declareVar(const string& scope, const string& lexeme, int line, int type
       , const list<int>& dimensions) {
 
-  Symbol s(scope, lexeme, line, false, type, dimensions);
+  Symbol s(scope, lexeme, line, false, type, true, dimensions);
   s.cd = currentCod++;
   symbols[scope].push_back(s);  
 }
 
+void SymbolTable::addConstant(const string& scope, const string& lexeme, int line, int type) {
+  // O codigo ta igual ao declareVar...
+  Symbol s(scope, lexeme, line, false, type, false);
+  s.cd = currentCod++;
+  symbols[scope].push_back(s);
+}
 
+
 void SymbolTable::insertSymbol(Symbol& s, const string& scope) {
   s.cd = currentCod++;
   symbols[scope].push_back(s);
@@ -92,7 +99,7 @@
     }
   }
 
-  throw SymbolTableException("no symbol found");
+  throw SymbolTableException("no symbol found[" + scope + ":" + lexeme);
 }
 
 list<Symbol> SymbolTable::getSymbols(const string& scope) {

Modified: trunk/gpt2/src/modules/SymbolTable.hpp
===================================================================
--- trunk/gpt2/src/modules/SymbolTable.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/SymbolTable.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -50,6 +50,8 @@
   void declareVar(const string& scope, const string& lexeme, int line, int type
       , const list<int>& dimensions);
 
+  void addConstant( const string& scope, const string& lexeme, int line, int type);
+
   void insertSymbol(Symbol& s, const string& scope);
 
   Symbol& getSymbol(const string& scope, const string& lexeme, bool searchGlobal = false);

Modified: trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -7,8 +7,8 @@
 {
 }
 
-CTemporarySymbol::CTemporarySymbol( const string &baseName, const int &initialValue)
-	: _baseName(baseName), _count(initialValue)
+CTemporarySymbol::CTemporarySymbol( const string &baseName, const int &nextValue)
+	: _baseName(baseName), _count(nextValue)
 {
 }
 
@@ -21,14 +21,16 @@
 	_baseName = baseName;
 }
 
-void CTemporarySymbol::setInitialValue( int initialValue )
+void CTemporarySymbol::setNextValue( int nextValue )
 {
-	_count = initialValue;
+	_count = nextValue;
 }
 
 string CTemporarySymbol::getNew( )
 {
-	return( _baseName + itoa( _count++ ) );
+	_last = _baseName + itoa( _count++ );
+
+	return _last;
 }
 
 void CTemporarySymbol::removeLast( )
@@ -43,6 +45,6 @@
 
 string CTemporarySymbol::getLast( )
 {
-	return( _baseName + itoa( _count - 1 ) );
+	return( _last );
 }
 

Modified: trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/CTemporarySymbol.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -9,10 +9,10 @@
 {
 public:
 	CTemporarySymbol( );
-	CTemporarySymbol( const string &baseName, const int &initialValue = 0 );
+	CTemporarySymbol( const string &baseName, const int &nextValue = 0 );
 	~CTemporarySymbol( );
 	void setBaseName( string baseName );
-	void setInitialValue( int initialValue );
+	void setNextValue( int initialValue );
 	string getNew( );
 	void removeLast( );
 	unsigned int getMaxUsed( );
@@ -20,6 +20,7 @@
 private:
 	string _baseName;
 	int _count;
+	string _last;
 };
 
 #endif

Modified: trunk/gpt2/src/modules/parser/CTextFile.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTextFile.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/CTextFile.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,32 +1,30 @@
 #include "CTextFile.hpp"
 
 
-CTextFile::CTextFile( const string &filename, const string &chrTab )
+CTextFile::CTextFile( const string &chrTab )
 	: _chrTab( chrTab ), _emitTab( true )
 {
-	_file = new ofstream( filename.c_str( ) );
 }
 
 
 CTextFile::~CTextFile( )
 {
-	delete _file;
 }
 
 
 void CTextFile::writeln( const string &message )
 {
 	if ( _emitTab ) {
-		(*_file) << _tabs;
+		_txt << _tabs;
 	}
-	(*_file) << message << endl;
+	_txt << message << endl;
 	_emitTab = true;
 }
 
 
 void CTextFile::writeln( )
 {
-	(*_file) << endl;
+	_txt << endl;
 	_emitTab = true;
 }
 
@@ -34,9 +32,9 @@
 void CTextFile::write( const string &message )
 {
 	if ( _emitTab ) {
-		(*_file) << _tabs;
+		_txt << _tabs;
 	}
-	(*_file) << message;
+	_txt << message;
 	_emitTab = false;
 }
 
@@ -53,26 +51,21 @@
 }
 
 
-CTextFile& CTextFile::operator << ( const string &message )
+string CTextFile::getText( ) const
 {
-    write(message);
-	
-	return *this;
+	return _txt.str( );
 }
 
 
-/*
-ostream& operator << (ostream& os, const ConstantPool& constantPool) {
-    os << "Constant pool size: " << constantPool.size( ) << endl;
-
-    for ( ConstantPool::const_iterator constant = constantPool.begin( );
-          constant != constantPool.end( ); constant++ ) {
-        // number
-        os << "\t" << strZero(constant - constantPool.begin( ), 3) << ":"
-        << *constant;
-    }
-
-    return ( os );
+bool CTextFile::writeToFile( const string &filename )
+{
+	ofstream *_file;
+	_file = new ofstream( filename.c_str( ) );
+	if (_file) {
+		(*_file) << _txt;
+		delete _file;
+		return true;
+	}
+	return false;
 }
-*/
 

Modified: trunk/gpt2/src/modules/parser/CTextFile.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/CTextFile.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/CTextFile.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -3,24 +3,27 @@
 
 #include <string>
 #include <fstream>
+#include <sstream>
+
 using namespace std;
 
 class CTextFile
 {
 public:
-	CTextFile( const string &filename, const string &chrTab = "\t" );
+	CTextFile( const string &chrTab = "\t" );
 	~CTextFile( );
 	void writeln( const string &message );
 	void writeln( );
 	void write( const string &message );
 	void incTab( );
 	void decTab( );
-	CTextFile& operator << ( const string &message );
+	string getText( ) const;
+	bool writeToFile( const string &filename );
 private:
 	string _chrTab;
 	string _tabs;
-	ofstream *_file;
 	bool _emitTab;
+	stringstream _txt;
 };
 
 #endif

Modified: trunk/gpt2/src/modules/parser/GASMFE_CArguments.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CArguments.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CArguments.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,6 +1,8 @@
 #include "GASMFE_CArguments.hpp"
 
+#include "Tools.hpp"
 
+
 CArguments::CArguments( )
 {
 }
@@ -18,15 +20,13 @@
 
 	bool varArgs = _subroutineName == "imprima";
 
-	// TODO: emite ao contrario
 	// se for "imprima" empilha o nro de argumentos e o tipo de cada um
 	// por enquanto imprima eh um caso especial, mas nas proximas versoes isso seria corrigido...
-	for( argument = begin(); argument != end(); argument++ ) {
-                antlr::RefToken token = *argument;
-		_subroutine->emitPUSHMn( token, varArgs );
+	for( argument = end() - 1; argument >= begin(); argument-- ) {
+		_subroutine->emitPUSHMn( *argument, varArgs );
 
 	}
 	if (varArgs) {
-		_subroutine->emitPUSHMn( size( ) );
+		_subroutine->emitMn( "push", itoa( size( ) ) );
 	}
 }

Modified: trunk/gpt2/src/modules/parser/GASMFE_CArguments.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CArguments.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CArguments.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -4,11 +4,9 @@
 #include <vector>
 using namespace std;
 
-#include "PortugolParserTokenTypes.hpp"
-
 #include "GASMFE_CSubroutine.hpp"
 
-class CArguments : public vector<antlr::RefToken> // usar list :-)
+class CArguments : public vector<string> // usar list :-)
 {
 public:
 	CArguments( );

Modified: trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -3,27 +3,31 @@
 #include "Tools.hpp"
 
 
-CAsmProgram::CAsmProgram( COptions *options )
-	: _options( options ), _context( NULL )
+CAsmProgram::CAsmProgram( COptions *options, SymbolTable *symbolTable )
+	: _options( options ), _symbolTable( symbolTable ), _context( NULL )
 {
-	_file = new CGptAssemblyFile( _options->destfile );
-	_file->makeFileHeader( _options->destfile );
-	_file->writeln( "program " + _options->destfile );
-	_file->writeln( );
 }
 
-CAsmProgram::~CAsmProgram( )
+void CAsmProgram::init( )
 {
-	_file->makeFileFooter( );
+	_asmPrg.writeln( "// Programa " + _options->filename + ".gasm gerado a partir de " + _options->filename + ".gpt" );
+	_asmPrg.writeln( "program " + _options->filename );
+	_asmPrg.writeln( );
+}
 
-	_file->writeln( "end-program" );
+void CAsmProgram::finish( )
+{
+	_asmPrg.writeln( "end-program" );
+}
 
-	delete _file;
+CAsmProgram::~CAsmProgram( )
+{
 }
 
-CSubroutine *CAsmProgram::initSubroutine( const char *name )
+CSubroutine *CAsmProgram::initSubroutine( string name )
 {
-	CSubroutine *action = new CSubroutine( _options, _file, name );
+	CSubroutine *action = new CSubroutine( _options, /*_file,*/ name, _symbolTable );
+	action->init( );
 
 	return action;
 }
@@ -31,11 +35,13 @@
 
 void CAsmProgram::finishSubroutine( CSubroutine *action )
 {
+	action->finish( );
+	_asmPrg.write( action->getCode( ) );
 	delete action;
 }
 
 
-CContext *CAsmProgram::addContext( )
+/*CContext *CAsmProgram::addContext( )
 {
 	CContext* context = new CContext( );
 	_contexts.push( context );
@@ -63,10 +69,16 @@
 {
 	return _context;
 }
+*/
 
-
 void CAsmProgram::emitVarDefinition( const string &name, const int &type )
 {
-	_file->writeln( "var " + name + " " + typeInAsm( type ) );
+	_asmPrg.writeln( "var " + name + " " + typeInAsm( type ) );
 }
 
+
+string CAsmProgram::getAsm( ) const
+{
+	return _asmPrg.getText( );
+}
+

Modified: trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CAsmProgram.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -2,9 +2,10 @@
 #define GASMFE_CASM_PROGRAM_H
 
 #include "GASMFE_CContext.hpp"
-#include "GASMFE_CGptAssemblyFile.hpp"
 #include "GASMFE_COptions.hpp"
 
+#include "SymbolTable.hpp"
+
 #include <string>
 #include <stack>
 using namespace std;
@@ -12,19 +13,23 @@
 class CAsmProgram
 {
 public:
-	CAsmProgram( COptions *options );
+	CAsmProgram( COptions *options, SymbolTable *symbolTable );
 	~CAsmProgram( );
-	CSubroutine *initSubroutine( const char *name );
+	void init( );
+	void finish( );
+	CSubroutine *initSubroutine( string name );
 	void finishSubroutine( CSubroutine *subroutine );
 	CContext *addContext( );
 	CContext *remContext( );
 	CContext *getContext( );
 	void emitVarDefinition( const string &name, const int &type );
+	string getAsm( ) const;
 private:
 	COptions *_options;
 	CContext *_context;
 	stack<CContext*> _contexts;
-	CGptAssemblyFile *_file;
+        SymbolTable *_symbolTable;
+	CTextFile _asmPrg;
 };
 
 #endif

Modified: trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,37 +0,0 @@
-#include "GASMFE_CGptAssemblyFile.hpp"
-
-
-CGptAssemblyFile::CGptAssemblyFile( const string &filename, const string &chrTab )
-	: CTextFile( filename, chrTab )
-{
-}
-
-
-CGptAssemblyFile::~CGptAssemblyFile( )
-{
-}
-
-
-void CGptAssemblyFile::makeFileHeader( const string &filename )
-{
-	writeln( "// Programa XXX.gasm gerado a partir de XXX.gpt" );
-}
-
-
-void CGptAssemblyFile::makeProcedureHeader( const string &name )
-{
-	writeln( string( "// Procedure " ) + name );
-}
-
-
-void CGptAssemblyFile::makeProcedureFooter( )
-{
-	writeln( "// Fim da procedure" );
-	writeln( );
-}
-
-
-void CGptAssemblyFile::makeFileFooter( )
-{
-}
-

Modified: trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,18 +0,0 @@
-#ifndef GASMFE_CGPT_ASSEMBLY_FILE_H
-#define GASMFE_CGPT_ASSEMBLY_FILE_H
-
-#include "CTextFile.hpp"
-
-class CGptAssemblyFile : public CTextFile
-{
-public:
-	CGptAssemblyFile( const string &filename, const string &chrTab = "\t" );
-	~CGptAssemblyFile( );
-	void makeFileHeader( const string &filename );
-	void makeFileFooter( );
-	void makeProcedureHeader( const string &name );
-	void makeProcedureFooter( );
-};
-
-#endif
-

Modified: trunk/gpt2/src/modules/parser/GASMFE_COptions.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_COptions.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_COptions.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -10,8 +10,9 @@
 		sentences = false;
 		sourceLine = NULL;
 	}
-	string sourcefile;
-	string destfile;
+	string filename;
+//	string sourcefile;
+//	string destfile;
 	bool sentences;
 	int *sourceLine;
 };

Modified: trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -5,18 +5,17 @@
 
 #include "Tools.hpp"
 
+#include "PortugolParserTokenTypes.hpp"
 
-CSubroutine::CSubroutine( COptions *options, CGptAssemblyFile *file, const string &name )
-	: _options( options ), _file( file ), _name( name ), _lastSourceLine( 0 )
-{
-	_file->makeProcedureHeader( _name );
-	_file->writeln( "proc " + _name );
-	_file->incTab( );
 
+CSubroutine::CSubroutine( COptions *options, /*CGptAssemblyFile *file,*/ const string &name, SymbolTable *symbolTable )
+	: _options( options ), _name( name ), _symbolTable( symbolTable ), _lastSourceLine( 0 )
+{
 	if ( _options->sentences ) {
 		//_sourceInfo = new SourceInfo( );
 		//_sourceInfo->setFileName( _options->sourcefile );
 	}
+	_body.incTab( );
 }
 
 
@@ -25,169 +24,148 @@
 	//if ( _sourceInfo ) {
 	//	delete _sourceInfo;
 	//}
-
-	_file->decTab( );
-	_file->writeln( "end-proc" );
-
-	_file->makeProcedureFooter( );
 }
 
 
-void CSubroutine::beginParams( )
+void CSubroutine::init( )
 {
-	_file->write( "(" );
+	_header.writeln( string( "// Procedure " ) + _name );
+	_header.writeln( "proc " + _name );
+	_header.incTab( );
+//	_body.incTab( );
 }
 
 
-void CSubroutine::endParams( )
+void CSubroutine::finish( )
 {
-	_file->writeln( ")" );
+	if (_name == "main") {
+		_body.writeln( "exit_0" );
+	}
+//	_body->decTab( );
+	_footer.writeln( "end-proc" );
+
+	_footer.writeln( "// Fim da procedure" );
+	_footer.writeln( );
 }
 
 
-void CSubroutine::addParam( const string &name )
+void CSubroutine::emitPUSHMn( const string &symbol, const bool &pushType )
 {
-	_params.push_back(name);
+   SymbolType symbolType = _symbolTable->getSymbol( getName( ), symbol, true ).getType( );
 
-	if (_params.size() != 1) {
-		_file->write( ", " );
-	}
-	_file->write( name );
+   _body.writeln( string("push ")   + symbol );
+
+   if (pushType) {
+      _body.writeln( string("push_") + symbolType.toAsmType( ) );
+   }
 }
 
 
-void CSubroutine::emitCodeToLoadParamValues( )
+void CSubroutine::emitMn( const string &mn, const string &op1, const string &op2, const string &op3)
 {
-	for( int param = _params.size( )-1; param >= 0; param-- ) {
-		//emitLVMn( _params[param] );
+	_body.write( mn );
+	if (op1.empty()) {
+		_body.writeln( );
+		return;
 	}
-}
 
+	_body.write( " " + op1 );
+	if (op2.empty()) {
+		_body.writeln( );
+		return;
+	}
 
-void CSubroutine::emitPCALLMn( const string &name )
-{
-	writeln( string("pcall ") + name );
-}
+	_body.write( ", " + op2 );
+	if (op3.empty()) {
+		_body.writeln( );
+		return;
+	}
 
-
-void CSubroutine::emitISETMn( const string &var, const string &value )
-{
-	writeln( string("iset ") + var + string(", ") + value );
+	_body.writeln( ", " + op3 );
 }
 
-
-void CSubroutine::emitPUSHMn( const antlr::RefToken &_token, const bool &_pushType )
+void CSubroutine::emitMnWithPrefix( const string &mn, const string &var, const string &op1, const string &op2 )
 {
-//	writeln( string("push ") + literal );
-   if (_token->getType( ) == PortugolParserTokenTypes::T_STRING_LIT) {
-      writeln( string("push \"") + _token->getText( ) + "\"" );
-   } else {
-      writeln( string("push ") + _token->getText( ) );
-   }
-   if (_pushType) {
-      writeln( string("push_") + typeToText( _token->getType( ) ) );
-   }
+	emitMn( getMnWithPrefix( mn, var ), var, op1, op2 ); 
 }
 
 
-void CSubroutine::emitPUSHMn( const int& value )
+void CSubroutine::emitLabel( const string &label )
 {
-   writeln( string("push ") + itoa( value ) );
+	_body.writeln( label + string(":") );
 }
 
 
-//void CSubroutine::emitADDMn( )
-//{
-//	writeln( "add" );
-//}
-
-
-void CSubroutine::emitISUMMn( const string &var, const string &op1, const string &op2 )
+void CSubroutine::emitAsmCode( const string &code )
 {
-	writeln( "isum " + var + ", " + op1 + ", " + op2 );
+	_body.writeln( );
+	_body.writeln( "// asm-begin" );
+	_body.writeln( code );
+	_body.writeln( "// asm-end" );
+	_body.writeln( );
 }
 
 
-void CSubroutine::emitIMULMn( const string &var, const string &op1, const string &op2 )
+/*
+void CSubroutine::write( string value )
 {
-	writeln( "imul " + var + ", " + op1 + ", " + op2 );
-}
+//	if ( _sourceInfo && *_options->sourceLine > _lastSourceLine ) {
+//		string line = _sourceInfo->getLine( *_options->sourceLine );
+//		line = alltrim( wo_ctrl_chrs( line, ' ' ) );
+//		_file->write(
+//				string( "// LINE " ) + string( itoa( *_options->sourceLine ) ) + string( " --> " ) + line
+//				);
+//		_lastSourceLine = *_options->sourceLine;
+//	}
 
-
-void CSubroutine::emitIGEMn( const string &var, const string &op1, const string &op2 )
-{
-	writeln( "ige " + var + ", " + op1 + ", " + op2 );
+	_body.write( value );
 }
 
-
-void CSubroutine::emitIFNOTMn( const string &var, const string &label )
+void CSubroutine::writeln( string value )
 {
-	writeln( "ifnot " + var + ", " + label );
+//	if ( _sourceInfo && *_options->sourceLine > _lastSourceLine ) {
+//		string line = _sourceInfo->getLine( *_options->sourceLine );
+//		line = alltrim( wo_ctrl_chrs( line, ' ' ) );
+//		_file->writeln(
+//				string( "// LINE " ) + string( itoa( *_options->sourceLine ) ) + string( " --> " ) + line
+//				);
+//		_lastSourceLine = *_options->sourceLine;
+//	}
+
+	_body.writeln( value );
 }
+*/
 
-void CSubroutine::emitJMPMn( const string &label )
+void CSubroutine::emitVarDefinition( const string &name, const int &type )
 {
-	writeln( "jmp " + label );
+	_header.writeln( "var " + name + " " + typeInAsm( type ) );
 }
 
 
-void CSubroutine::emitMn( const string &mn, const string &op1, const string &op2, const string &op3)
+void CSubroutine::emitParDefinition( const string &name, const int &type )
 {
-	write( mn );
-	if (op1.empty()) {
-		writeln( );
-		return;
-	}
-
-	write( " " + op1 );
-	if (op2.empty()) {
-		writeln( );
-		return;
-	}
-
-	write( ", " + op2 );
-	if (op3.empty()) {
-		writeln( );
-		return;
-	}
-
-	writeln( ", " + op3 );
+	_header.writeln( "par " + name + " " + typeInAsm( type ) );
 }
 
 
-void CSubroutine::emitLabel( const string &label )
+string CSubroutine::getCode( ) const
 {
-	writeln( label + string(":") );
+	return _header.getText() + _body.getText() + _footer.getText();
 }
 
 
-
-
-void CSubroutine::write( string value )
+string CSubroutine::getMnWithPrefix( const string &mn, const string &var ) // TODO: serviria para simbolos tb ???
 {
-/*	if ( _sourceInfo && *_options->sourceLine > _lastSourceLine ) {
-		string line = _sourceInfo->getLine( *_options->sourceLine );
-		line = alltrim( wo_ctrl_chrs( line, ' ' ) );
-		_file->write(
-				string( "// LINE " ) + string( itoa( *_options->sourceLine ) ) + string( " --> " ) + line
-				);
-		_lastSourceLine = *_options->sourceLine;
-	}*/
+	int primitiveType = _symbolTable->getSymbol (getName(), var, true).getType().getPrimitiveType();
 
-	_file->write( value );
+	switch(primitiveType) {
+		case PortugolParserTokenTypes::T_KW_INTEIRO:    return "i" + mn;
+		case PortugolParserTokenTypes::T_KW_REAL:       return "r" + mn;
+		case PortugolParserTokenTypes::T_KW_CARACTERE:  return "i" + mn;
+		case PortugolParserTokenTypes::T_KW_LITERAL:    return "s" + mn;
+		case PortugolParserTokenTypes::T_KW_LOGICO:     return "i" + mn;
+		case PortugolParserTokenTypes::T_KW_MATRIZ:     return "m" + mn;
+		default:                                        return "undefined_" + mn;
+	}
 }
 
-void CSubroutine::writeln( string value )
-{
-/*	if ( _sourceInfo && *_options->sourceLine > _lastSourceLine ) {
-		string line = _sourceInfo->getLine( *_options->sourceLine );
-		line = alltrim( wo_ctrl_chrs( line, ' ' ) );
-		_file->writeln(
-				string( "// LINE " ) + string( itoa( *_options->sourceLine ) ) + string( " --> " ) + line
-				);
-		_lastSourceLine = *_options->sourceLine;
-	}*/
-
-	_file->writeln( value );
-}
-

Modified: trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/GASMFE_CSubroutine.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -4,52 +4,54 @@
 #include <string>
 #include <vector>
 
-#include "GASMFE_CGptAssemblyFile.hpp"
 #include "GASMFE_COptions.hpp"
 //#include "SourceInfo.hpp"
 
 #include <antlr/LLkParser.hpp>
 #include "PortugolParserTokenTypes.hpp"
 
+#include "SymbolTable.hpp"
+#include "CTextFile.hpp"
+
 using namespace std;
 
 
 class CSubroutine
 {
 public:
-	CSubroutine( COptions *options, CGptAssemblyFile *file, const string &name );
+	CSubroutine( COptions *options, /*CGptAssemblyFile *file,*/ const string &name, SymbolTable *symbolTable );
 	~CSubroutine( );
-	void beginParams( );
-	void endParams( );
-	void addParam( const string &name );
-	void emitCodeToLoadParamValues( );
-        void emitPCALLMn( const string &name );
-        void emitISETMn( const string &var, const string &value );
-        void emitPUSHMn( const antlr::RefToken &_token, const bool &_pushType = false );
-	void emitPUSHMn( const int& value );
-	void emitISUMMn( const string &var, const string &op1, const string &op2 );
-	void emitIMULMn( const string &var, const string &op1, const string &op2 );
-	void emitIGEMn( const string &var, const string &op1, const string &op2 );
-	void emitIFNOTMn( const string &var, const string &label );
-	void emitJMPMn( const string &label );
+	void init( );
+	void finish( );
+	void emitPUSHMn( const string &symbol, const bool &pushType = false );
 	void emitMn( const string &mn, const string &op1 = "", const string &op2 = "", const string &op3 = "");
+	void emitMnWithPrefix( const string &mn, const string &var, const string &op1 = "", const string &op2 = "" );
 
 	void emitLabel( const string &label );
 
-	void write( string value );
-	void writeln( string value = "" );
+	void emitAsmCode( const string &code );
 
+//	void write( string value );
+//	void writeln( string value = "" );
+
 	const string& getName( ) const
 	{
 		return _name;
 	}
+	void emitVarDefinition( const string &name, const int &type );
+	void emitParDefinition( const string &name, const int &type );
+	string getCode( ) const;
 private:
+	string getMnWithPrefix( const string &mn, const string &var );
 	COptions *_options;
 	vector<string> _params;
-	CGptAssemblyFile* _file;
 	//SourceInfo *_sourceInfo;
 	int _lastSourceLine;
 	string _name;
+	SymbolTable *_symbolTable;
+	CTextFile _header;
+	CTextFile _body;
+	CTextFile _footer;
 };
 
 #endif

Modified: trunk/gpt2/src/modules/parser/Makefile.am
===================================================================
--- trunk/gpt2/src/modules/parser/Makefile.am	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/Makefile.am	2007-11-05 16:07:40 UTC (rev 335)
@@ -9,7 +9,7 @@
 nodist_libparser_la_SOURCES = $(BUILT_SOURCES)
 libparser_la_SOURCES = BasePortugolParser.cpp MismatchedUnicodeCharException.cpp GASMFE_CSubroutine.cpp \
                        GASMFE_CArguments.cpp  CTemporarySymbol.cpp   \
-                       GASMFE_CContext.cpp Tools.cpp CTextFile.cpp GASMFE_CGptAssemblyFile.cpp          \
+                       GASMFE_CContext.cpp Tools.cpp CTextFile.cpp   \
                        GASMFE_CAsmProgram.cpp
 
 

Modified: trunk/gpt2/src/modules/parser/Tools.cpp
===================================================================
--- trunk/gpt2/src/modules/parser/Tools.cpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/Tools.cpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -242,9 +242,11 @@
    if (type == PortugolParserTokenTypes::T_INT_LIT) {
       return "int";
    } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
-      return "carac lit ???";
+      return "char";
    } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
       return "string";
+   } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
+      return "real";
    } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
       return "id";
    }
@@ -259,9 +261,11 @@
    } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
       return "string";
    } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
-      return "int";
+      return "char";
    } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
-      return "int";
+      return "bool";
+   } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
+      return "real";
    } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
       return "pointer ???";
    } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
@@ -271,3 +275,25 @@
    return "ERRO !!!";
 }
 
+
+const int typeToLiteral( const int &type )
+{
+   switch (type) {
+      case PortugolParserTokenTypes::T_KW_INTEIRO:
+         return PortugolParserTokenTypes::T_INT_LIT;
+      case PortugolParserTokenTypes::T_KW_LITERAL:
+         return PortugolParserTokenTypes::T_STRING_LIT;
+      case PortugolParserTokenTypes::T_KW_CARACTERE:
+         return PortugolParserTokenTypes::T_CARAC_LIT;
+      case PortugolParserTokenTypes::T_KW_LOGICO:
+         return PortugolParserTokenTypes::T_INT_LIT;
+//      case PortugolParserTokenTypes::T_KW_CORINGA:
+//         return "pointer ???";
+//      case PortugolParserTokenTypes::T_KW_MATRIZ:
+//          return PortugolParserTokenTypes::T_MATRIZ;
+      default:
+          return 0;
+          // trow exception ???
+   }
+}
+

Modified: trunk/gpt2/src/modules/parser/Tools.hpp
===================================================================
--- trunk/gpt2/src/modules/parser/Tools.hpp	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/Tools.hpp	2007-11-05 16:07:40 UTC (rev 335)
@@ -34,5 +34,6 @@
 // string& getStringWithTab(string, string);
 const string typeToText(const int &type);
 const string typeInAsm( const int &type );
+const int typeToLiteral( const int &type );
 
 #endif

Modified: trunk/gpt2/src/modules/parser/lexer.g
===================================================================
--- trunk/gpt2/src/modules/parser/lexer.g	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/lexer.g	2007-11-05 16:07:40 UTC (rev 335)
@@ -105,9 +105,11 @@
   T_KW_CONSTANTE="constante";
   T_KW_CONSTANTES="constantes";
   T_KW_ESTRUTURA="estrutura";
+  T_KW_FIM_ESTRUTURA="fim-estrutura";
   T_KW_PROCEDIMENTO="procedimento";
   T_KW_SAIR="sair";
   T_KW_ASM="asm";
+  T_KW_FIM_ASM="fim-asm";
 
 
   T_REAL_LIT="n?mero real"; //nondeterminism T_INT_LIT & T_REAL_LIT
@@ -147,6 +149,11 @@
     nextFilename = str;
   }
 
+  string getNextFilename( )
+  {
+    return nextFilename;
+  }
+
 private:
   string nextFilename;
   TokenStreamSelector* selector;  
@@ -290,6 +297,7 @@
 /*-----------------Constant literals ***********************/
 
 
+// TODO: realmente eh nao deterministico ???
 T_INT_LIT
 options {
   paraphrase = "n?mero inteiro";
@@ -408,7 +416,8 @@
   paraphrase = "caractere";
 }
 //  : '\''! ( ~('\''|'\n'|'\r'|'\\') | ESC )? '\''!
-  : '\''! ( ~( '\'' | '\\' ) | ESC )? '\''!
+//  : '\''! ( ~( '\'' | '\\' ) | ESC )? '\''!
+  : '\'' ( ~( '\'' | '\\' ) | ESC )? '\''
   ;
 
 //"Digite um \");
@@ -418,9 +427,11 @@
   paraphrase = "literal";
 }
 //  : '"'! (ESC|~('"'|'\\'|'\n'|'\r'))* '"'!
-  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | ESC)* '"'!
+  : '"' ( ~( '"' | '\\' | '\n' | '\r') | ESC)* '"'
+//  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | ESC)* '"'!
   ;
 
+
 protected
 ESC
   //: '\\' ('n'| 't' | 'r' | '\\' | '\'' | '"')
@@ -462,6 +473,13 @@
   : ','
   ;
 
+T_DOT
+options {
+  paraphrase = "'.'";
+}
+  : '.'
+  ;
+
 T_WS_ : (' '
   | '\t'
   | '\n' { newline(); }
@@ -492,6 +510,42 @@
     {$setType(antlr::Token::SKIP);}
   ;
 
+// TODO: nao consegui seguir a sintaxe de "asm" .. "fim-asm" sem o uso de { }
+T_ASM_CODE
+{int line = getLine();}
+  : '{'!
+    ( 
+      options { generateAmbigWarnings=false; } :  
+        '\n'                     {newline();}
+      | ('\r' '\n')=> '\r' '\n'  {newline();}
+      | '\r'                     {newline();}
+      |~('}')
+//      |~('*'|'\n'|'\r')
+//      | ('*' ~'/' )=> '*' 
+    )* 
+    '}'!
+  ;
+
+//T_ASM
+//  : "asm" (~("fim-asm"))* "fim-asm"
+//  ;
+
+
+//ASM_CODE
+//{int line = getLine();}
+//  : "asm"!
+//    ( 
+//      options { generateAmbigWarnings=false; } :  
+//        '\n'                     {newline();}
+//      | ('\r' '\n')=> '\r' '\n'  {newline();}
+//      | '\r'                     {newline();}
+//      |~('*'|'\n'|'\r')
+//      | ('*' ~'/' )=> '*' 
+//      |~("fim-asm")
+//    )* 
+//    "fim-asm"!
+//  ;
+
 exception
 catch[antlr::RecognitionException] {  
   stringstream s;

Modified: trunk/gpt2/src/modules/parser/parser.g
===================================================================
--- trunk/gpt2/src/modules/parser/parser.g	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/src/modules/parser/parser.g	2007-11-05 16:07:40 UTC (rev 335)
@@ -25,6 +25,9 @@
   #include "GASMFE_CAsmProgram.hpp"
   #include "GASMFE_COptions.hpp"
   #include "CTemporarySymbol.hpp"
+  #include "SymbolTable.hpp"
+  #include "Tools.hpp"
+  #include <stdlib.h>
 }
 
 options {
@@ -39,7 +42,7 @@
 options {
   importVocab=Portugol;  // use vocab generated by lexer
   genHashLines=false;//no #line
-  k=2;
+  k=3;
 }
 
 {  
@@ -47,15 +50,17 @@
       COptions options;
       CAsmProgram  *asmPrg;
       CSubroutine *subroutine;
-      CArguments args;
       CTemporarySymbol tempVar;
       CTemporarySymbol tempLabel;
-      void initParser( )
+      SymbolTable symbolTable;
+      void initParser( string filename )
       {
-         options.sourcefile = "xxx.gpt";
-         options.destfile   = "xxx.gasm";
-         asmPrg = new CAsmProgram( &options );
+         options.filename = filename;
+//         options.sourcefile = filename + ".gpt";
+//         options.destfile   = filename + ".gasm";
+         asmPrg = new CAsmProgram( &options, &symbolTable );
          tempVar.setBaseName( "__temp_" );
+         tempVar.setNextValue( 1 );
          tempLabel.setBaseName( "__label_" );
       }
       void finishParser( )
@@ -63,23 +68,50 @@
          delete asmPrg;
          asmPrg = NULL;
       }
+      void declareProgramVar(const string& scope, const string& lexeme, int line, int type)
+      {
+         symbolTable.declareVar( scope, lexeme, line, type );
+         asmPrg->emitVarDefinition( lexeme, type );
+      }
+      void declareSubroutineVar(const string& scope, const string& lexeme, int line, int type)
+      {
+         symbolTable.declareVar( scope, lexeme, line, type );
+         subroutine->emitVarDefinition( lexeme, type );
+      }
+      void declareParameter(const string& lexeme, int line, int type)
+      {
+         symbolTable.declareVar( subroutine->getName(), lexeme, line, type );
+         subroutine->emitParDefinition( lexeme, type );
+      }
+      int getSymbolType( const string& lexeme )
+      {
+         return symbolTable.getSymbol(subroutine->getName(), lexeme, true).getType().getPrimitiveType();
+      }
+//      string getAsmProgram( ) const
+//      {
+//         return asmPrg->getAsm( );
+//      }
 }
 
 
-//#########################
-//## In?cio da gram?tica ##
-//#########################
+//####################################################################
+//####################### In?cio da gram?tica ########################
+//####################################################################
 
 //##############
 //## Programa ##
 //##############
 
 //--------
-  programa
+  programa [string filename] returns [string ret]
 //-------- 
-  : { initParser( ); } (declaracao_algoritmo)? (importacao)*
-    (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis)* corpo EOF
-    { finishParser( ); }
+  : { initParser( filename ); asmPrg->init( ); } (declaracao_algoritmo)? (importacao)*
+    (declaracao_constantes | bloco_declaracao_estrutura | declaracao_variaveis[false])* corpo EOF
+    {
+       asmPrg->finish( );
+       ret = asmPrg->getAsm( );
+       finishParser( );
+    }
   ;
 
 declaracao_algoritmo
@@ -102,74 +134,96 @@
 //#############################
 
 //--------------------
-  declaracao_variaveis
+  declaracao_variaveis [bool isLocal]
 //--------------------
-  : bloco_declaracao_variaveis
-  | "vari?vel" declaracao_variavel
+  : bloco_declaracao_variaveis[isLocal]
+  | "vari?vel" declaracao_variavel[isLocal]
   ;
 
-bloco_declaracao_variaveis
-  : "vari?veis" (declaracao_variavel)+ "fim-vari?veis"
+bloco_declaracao_variaveis [bool isLocal]
+  : "vari?veis" (declaracao_variavel[isLocal])+ "fim-vari?veis"
   ;
 
-declaracao_variavel
+declaracao_variavel [bool isLocal]
 {
-  RefToken tk_type;
+  int tk_type;
 }
   : tk_id:T_IDENTIFICADOR 
     (T_COMMA T_IDENTIFICADOR)* 
-    T_COLON tipo {tk_type = lastToken; }
+    //T_COLON tipo {tk_type = lastToken; }
+    T_COLON tk_type=tipo
     (lista_inicializacao)? T_SEMICOL
     { // TODO: nao esta correto porque so gera uma variavel...
-       asmPrg->emitVarDefinition( tk_id->getText( ), tk_type->getType( ) );
+       if (isLocal) {
+          declareSubroutineVar( SymbolTable::GlobalScope, tk_id->getText( ), 0, tk_type );
+       } else {
+          declareProgramVar( SymbolTable::GlobalScope, tk_id->getText( ), 0, tk_type );
+       }
     }
   ;
 
-declaracao_variavel_sing
-  : T_IDENTIFICADOR T_COLON tipo (lista_inicializacao)? T_SEMICOL
-  ;
+//declaracao_variavel_sing
+//{
+//  int type;
+//}
+//  : T_IDENTIFICADOR T_COLON type=tipo (lista_inicializacao)? T_SEMICOL
+//  ;
 
-tipo 
-  : tipo_primitivo 
-  | tipo_matriz 
-  | T_IDENTIFICADOR
+tipo returns [int ret]
+  : ret=tipo_primitivo 
+  | ret=tipo_matriz 
+  | T_IDENTIFICADOR {ret=T_KW_ESTRUTURA;}
   ;
 
 lista_inicializacao
-  : T_ATTR (expr | inicializacao_composta)
+{
+  string result;
+}
+  : T_ATTR (result=expr | inicializacao_composta)
   ;
 
 inicializacao_composta
-  : "[" (inicializacao_indices) (T_COLON inicializacao_indices)* "]"
-  | "{" (inicializacao_membros) (T_COLON inicializacao_membros)* "}"
+  : T_ABREC inicializacao_indice (T_COLON inicializacao_indice)* T_FECHAC
+//  | "{" (inicializacao_membro) (T_COLON inicializacao_membro)* "}"
   ;
 
-inicializacao_indices
-  : (expr | inicializacao_composta)
+inicializacao_indice
+{
+  string result;
+}
+  : result=expr
+//  : (result=expr | inicializacao_composta)
   ;
 
-inicializacao_membros
-  : T_IDENTIFICADOR T_ATTR (expr | inicializacao_composta)
+inicializacao_membro
+{
+  string result;
+}
+  : T_IDENTIFICADOR T_ATTR (result=expr | inicializacao_composta)
   ;
 
-tipo_primitivo
-  : "inteiro"
-  | "real"
-  | "caractere"
-  | "literal"
-  | "l?gico"
-  | "coringa"
+tipo_primitivo returns [int ret]
+  : "inteiro"   {ret=T_KW_INTEIRO;}
+  | "real"      {ret=T_KW_REAL;}
+  | "caractere" {ret=T_KW_CARACTERE;}
+  | "literal"   {ret=T_KW_LITERAL;}
+  | "l?gico"    {ret=T_KW_LOGICO;}
+  | "coringa"   {ret=T_KW_CORINGA;}
   ;
 
-tipo_matriz
-  : "matriz" ("[" (T_INT_LIT)? "]")+ "do" "tipo" (tipo_primitivo | T_IDENTIFICADOR)
+tipo_matriz returns [int ret]
+{
+  int type;
+}
+  : "matriz" (T_ABREC (T_INT_LIT)? T_FECHAC)+ "do" "tipo" (type=tipo_primitivo | T_IDENTIFICADOR)
+    {ret=T_KW_MATRIZ;}
   ;
 
 
 /****************************************************************************/
 declaracao_constantes
   : bloco_declaracao_constantes
-  | "constante" declaracao_constante T_SEMICOL
+  | "constante" declaracao_constante
   ;
 
 bloco_declaracao_constantes
@@ -177,13 +231,16 @@
   ;
 
 declaracao_constante
-  : T_IDENTIFICADOR T_COLON tipo lista_inicializacao T_SEMICOL
+{
+  int type;
+}
+  : T_IDENTIFICADOR T_COLON type=tipo lista_inicializacao T_SEMICOL
   ;
 
 
 /****************************************************************************/
 bloco_declaracao_estrutura
-  : "estrutura" T_IDENTIFICADOR (declaracao_variavel)+ "fim-estrutura"
+  : "estrutura" T_IDENTIFICADOR (declaracao_variavel[false])+ "fim-estrutura"
   ;
 
 
@@ -194,23 +251,44 @@
   ;
 
 declaracao_funcao
+{
+   int tk_type;
+}
 //  : "fun??o" T_IDENTIFICADOR "(" (lista_parametros)? ")" ":" tipo
-  : "fun??o" T_IDENTIFICADOR "(" ")" T_COLON tipo
-    (declaracao_constantes | declaracao_variaveis)*
+  : "fun??o" tk_id:T_IDENTIFICADOR
+    { subroutine = asmPrg->initSubroutine( tk_id->getText( ) ); }
+    T_ABREP (lista_parametros)? T_FECHAP T_COLON tk_type=tipo
+    {
+       declareSubroutineVar( SymbolTable::GlobalScope, "__result", 0, tk_type );
+    }
+    (declaracao_constantes | declaracao_variaveis[true])*
     bloco_codigo
+    { asmPrg->finishSubroutine( subroutine ); }
   ;
 
 declaracao_procedimento
   //: "procedimento" T_IDENTIFICADOR "(" (lista_parametros)? ")"
-  : "procedimento" T_IDENTIFICADOR "(" ")"
-    (declaracao_constantes | declaracao_variaveis)*
+  : "procedimento" tk_id:T_IDENTIFICADOR
+    { subroutine = asmPrg->initSubroutine( tk_id->getText( ) ); }
+    T_ABREP (lista_parametros)? T_FECHAP
+    (declaracao_constantes | declaracao_variaveis[true])*
     bloco_codigo
+    { asmPrg->finishSubroutine( subroutine ); }
   ;
 
-//lista_parametros
-//  : ( ("constante")? "ref")? T_IDENTIFICADOR T_COLON tipo (T_COMMA lista_parametros)*
-//  ;
+lista_parametros
+  : parametro (T_COMMA parametro)*
+  ;
 
+parametro
+{
+  int type;
+}
+  : (("constante")? ("ref"))? tk_id:T_IDENTIFICADOR T_COLON type=tipo
+  {
+    declareParameter( tk_id->getText( ), 0, type );
+  }
+  ;
 
 /****************************************************************************/
 bloco_codigo
@@ -222,17 +300,23 @@
   ;
 
 enunciado
-  : (lvalue T_ATTR)=> en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-//  | en_repita
-  | en_para
-  | en_caso
-  | en_asm
-  | expr
-  | "sair" T_SEMICOL
-  | T_SEMICOL
+  :
+  ( (lvalue T_ATTR)=> en_atribuicao
+    | en_retorne
+    | en_se
+    | en_enquanto
+    | en_repita
+    | en_para
+    | en_caso
+    | en_asm_code
+    | chamada_procedimento
+//    | expr
+    | "sair" T_SEMICOL
+    | T_SEMICOL
+  )
+// Nao eh tao simples assim de resolver. E se outra temp tiver o mesmo nome mas tipo diferentes ???
+// Uma solucao talvez seja cada temporaria tem baseName formado pelo seu tipo tambem.
+//  { tempVar.setNextValue(1); }
   ;
 
 en_atribuicao
@@ -243,19 +327,30 @@
   : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
 //  : tklvalue=lvalue T_ATTR tkexpret=expr T_SEMICOL
 //  : (lvalue T_ATTR)=> stm_attr {tkexpret=lastToken;} T_SEMICOL
-    { subroutine->emitISETMn( tklvalue, tkexpret ); }
+    { subroutine->emitMnWithPrefix( "set", tklvalue, tkexpret ); }
   ;
 
-stm_attr
-  : lvalue T_ATTR expr
-  ;
+//stm_attr
+//  : lvalue T_ATTR expr
+//  ;
 
 en_retorne
-  : "retorne" (expr)? T_SEMICOL
+{
+  string result;
+}
+  : "retorne"
+    (result=expr {subroutine->emitMnWithPrefix( "set", "__result", result ); } )?
+    { subroutine->emitMn( "ret" ); }
+    T_SEMICOL
   ;
 
 lvalue returns [string tk_id]
-  : T_IDENTIFICADOR {tk_id=lastToken->getText( );} //(T_ABREC expr T_FECHAC)*
+{
+  string ret;
+}
+  : T_IDENTIFICADOR {tk_id=lastToken->getText( );}
+    (T_ABREC ret=expr T_FECHAC)*
+  | T_IDENTIFICADOR T_DOT T_IDENTIFICADOR
   ;
 
 en_se
@@ -264,10 +359,10 @@
   string elseLabel;
   string nextLabel;
 }
-  : "se" expRet=expr "ent?o" { elseLabel = tempLabel.getNew( ); subroutine->emitIFNOTMn( expRet, elseLabel ); }
+  : "se" expRet=expr "ent?o" { elseLabel = tempLabel.getNew( ); subroutine->emitMn( "ifnot", expRet, elseLabel ); }
     lista_enunciados
-    { nextLabel = tempLabel.getNew( ); subroutine->emitJMPMn( nextLabel ); }
-    ("sen?o" { subroutine->emitLabel( elseLabel ); } lista_enunciados)? "fim-se"
+    { nextLabel = tempLabel.getNew( ); subroutine->emitMn( "jmp", nextLabel ); subroutine->emitLabel( elseLabel ); }
+    ("sen?o" lista_enunciados)? "fim-se"
     { subroutine->emitLabel( nextLabel ); }
   ;
 
@@ -285,12 +380,12 @@
     }
     expRet=expr "fa?a"
     {
-       subroutine->emitIFNOTMn( expRet, nextCommandLabel );
+       subroutine->emitMn( "ifnot", expRet, nextCommandLabel );
     }
     lista_enunciados
     "fim-enquanto"
     {
-       subroutine->emitJMPMn( testLabel );
+       subroutine->emitMn( "jmp", testLabel );
        subroutine->emitLabel( nextCommandLabel );
     }
   ;
@@ -303,35 +398,64 @@
   string testLabel;
   string nextCommandLabel;
   string testVar;
+  int    step=1;
 }
-  : "para" lvalueRet=lvalue "de" exp1=expr "at?" exp2=expr (passo)? "fa?a"
+  : "para" lvalueRet=lvalue "de" exp1=expr "at?" exp2=expr (step=passo)? "fa?a"
     {
-       subroutine->emitISETMn( lvalueRet, exp1 );
+       subroutine->emitMnWithPrefix( "set", lvalueRet, exp1 );
        testLabel = tempLabel.getNew( );
        nextCommandLabel = tempLabel.getNew( );
        testVar   = tempVar.getNew( );
+       declareSubroutineVar( SymbolTable::GlobalScope, testVar, 0, T_KW_INTEIRO );
        subroutine->emitLabel( testLabel );
-       subroutine->emitMn( "ile", testVar, lvalueRet, exp2 );
-       subroutine->emitIFNOTMn( testVar, nextCommandLabel );
+       if (step >= 0) {
+          subroutine->emitMnWithPrefix( "le", testVar, lvalueRet, exp2 );
+       } else {
+          subroutine->emitMnWithPrefix( "ge", testVar, lvalueRet, exp2 );
+       }
+       subroutine->emitMn( "ifnot", testVar, nextCommandLabel );
     }
     lista_enunciados
     "fim-para"
     {
-       subroutine->emitMn( "iinc", lvalueRet, "1" );
-       subroutine->emitJMPMn( testLabel );
+       subroutine->emitMnWithPrefix( step > 0 ? "inc" : "dec", lvalueRet, itoa( abs( step ) ) );
+       subroutine->emitMn( "jmp", testLabel );
        subroutine->emitLabel( nextCommandLabel );
     }
   ;
 
-passo
-  : "passo" (T_MAIS|T_MENOS)? T_INT_LIT
+passo returns [int ret]
+{
+  string signal;
+}
+  : "passo" (T_MAIS|T_MENOS{signal="-";})? T_INT_LIT { ret=atoi((signal+lastToken->getText( )).c_str( )); }
   ;
 
 //en_repita
-//  : "repita" lista_enunciados "enquanto" expr
-//  | "repita" lista_enunciados "at?" expr
+//  : ("repita" lista_enunciados "enquanto") => en_repita_enquanto
+//  | ("repita" lista_enunciados "at?") => en_repita_ate
 //  ;
 
+en_repita
+{
+  string labelBegin = tempLabel.getNew( );
+  string exp;
+}
+  : "repita"
+    { subroutine->emitLabel( labelBegin ); }
+    lista_enunciados
+    "at?" exp=expr
+    { subroutine->emitMn( "ifnot", exp, labelBegin ); }
+  ;
+
+//en_repita_enquanto
+//  : "repita" lista_enunciados "enquanto" expr T_SEMICOL
+//  ;
+
+//en_repita_ate
+//  : "repita" lista_enunciados "at?" expr T_SEMICOL
+//  ;
+
 //en_repita
 //  : "repita" lista_enunciados "at?" expr
 //  ;
@@ -346,12 +470,13 @@
   : "caso" expret=expr "seja" 
     {
        varTest = tempVar.getNew( );
-       subroutine->emitISETMn( varTest, expret );
+       declareSubroutineVar( SymbolTable::GlobalScope, varTest, 0, T_KW_INTEIRO );
+       subroutine->emitMnWithPrefix( "set", varTest, expret );
        nextCommandLabel = tempLabel.getNew( );
     }
     (
        nextTestLabel=teste_caso[varTest]
-       {subroutine->emitJMPMn( nextCommandLabel ); subroutine->emitLabel( nextTestLabel );}
+       {subroutine->emitMn( "jmp", nextCommandLabel ); subroutine->emitLabel( nextTestLabel );}
     )+ ("sen?o" lista_enunciados "fim-sen?o")? "fim-caso" 
     {
        subroutine->emitLabel( nextCommandLabel );
@@ -364,43 +489,112 @@
 }
   : lit=literal "fa?a" 
     {
-       subroutine->emitMn( "ieq", tempVar.getNew( ), varTest, lit );
+       declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew(), 0, getSymbolType( varTest ) );
+       subroutine->emitMnWithPrefix( "eq", tempVar.getLast(), varTest, lit );
        nextTestLabel = tempLabel.getNew( );
-       subroutine->emitIFNOTMn( tempVar.getLast( ), nextTestLabel );
+       subroutine->emitMn( "ifnot", tempVar.getLast( ), nextTestLabel );
     }
     lista_enunciados
     "fim-fa?a"
   ;
 
-en_asm
-  : "asm" (~("fim-asm"))* "fim-asm"
+en_asm_code
+//  : ASM_CODE { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
+  : "asm"
+    T_ASM_CODE { subroutine->emitAsmCode( lastToken->getText( ) ); }
+    "fim-asm"
+//(
+//       ~("fim-asm") { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
+//    )*
+//    "fim-asm"
   ;
 
+//en_asm_code
+////  : ASM_CODE { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
+//  : "asm"
+//    (
+//       ~("fim-asm") { cout << "ASM=\"" + lastToken->getText( ) << "\"" << endl; }
+//    )*
+//    "fim-asm"
+//  ;
 
 /****************************************************************************/
-chamada_subrotina
+chamada_procedimento
+{
+   CArguments args;
+}
   : tk_id:T_IDENTIFICADOR T_ABREP
-    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos { args.emitMnsInSubroutineCall( ); })? T_FECHAP
-    { subroutine->emitPCALLMn( tk_id->getText( ) ); }
+    ( {args.init( subroutine, tk_id->getText( ) ); } lista_argumentos[args] { args.emitMnsInSubroutineCall( ); })? T_FECHAP
+    { subroutine->emitMn( "pcall", tk_id->getText( ) ); }
   ; 
 
-lista_argumentos
+chamada_funcao returns [string ret]
 {
-   RefToken exp;
+   CArguments args;
 }
-  : expr { args.push_back( lastToken ); }
-    (T_COMMA expr { args.push_back( lastToken ); } )*
+  : tk_id:T_IDENTIFICADOR T_ABREP
+    { subroutine->emitMn( "push_0" ); }
+    ( 
+      { args.init( subroutine, tk_id->getText( ) ); }
+      lista_argumentos[args]
+      { args.emitMnsInSubroutineCall( ); }
+    )? T_FECHAP
+    {
+      subroutine->emitMn( "pcall", tk_id->getText( ) );
+      ret = tempVar.getNew( );
+      declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, T_KW_INTEIRO );
+      subroutine->emitMn( "pop", ret );
+    }
+  ; 
+
+lista_argumentos [CArguments &args]
+{
+  string ret;
+}
+  // TODO: a gente poderia sempre adicionar o token (string) retornado por expr. Na tabela de simbolos
+  // vao existir TODOS os simbolos. Com isso sera facil identificar o tipo (para push_<type>) 
+  // sem necessitar de RefToken.
+  : ret=expr { args.push_back( ret ); }
+    (
+      T_COMMA ret=expr
+      { args.push_back( ret ); }
+    )*
   ;
 
+//lista_argumentos
+//{
+//   RefToken exp;
+//}
+//  : expr { args.push_back( lastToken ); }
+//    (T_COMMA expr { args.push_back( lastToken ); } )*
+//  ;
+
 literal returns [string ret]
-  : ( T_STRING_LIT | T_INT_LIT | T_REAL_LITERAL | T_CARAC_LITERAL | "verdadeiro" | "falso" ) {ret=lastToken->getText( );}
+  : ( 
+        T_STRING_LIT {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LITERAL );}
+      | T_INT_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_INTEIRO );}
+      | T_REAL_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_REAL );}
+      | T_CARAC_LIT  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_CARACTERE );}
+      | "verdadeiro"  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LOGICO );} // ???
+      | "falso"  {symbolTable.addConstant( SymbolTable::GlobalScope, lastToken->getText( ), 0, T_KW_LOGICO );}      // ???
+    ) {ret=lastToken->getText( );}
   ;
 
-
 /* ----------------------------- Expressoes ---------------------------------- */
 
 expr returns [string ret]
-  : ret=expr_e (T_KW_OU expr_e)*
+{
+  string op2;
+}
+  : ret=expr_e 
+    (
+      T_KW_OU op2=expr_e 
+      {
+         subroutine->emitMn( "or", tempVar.getNew( ), ret, op2 );
+         ret=tempVar.getLast( );
+         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+      }
+    )*
   ;
   
 expr_e  returns [string ret]
@@ -410,35 +604,92 @@
 {
   string op2;
 }
-  : ret=expr_bit_ou (T_KW_E op2=expr_bit_ou {subroutine->emitMn( "and", tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
+  : ret=expr_bit_ou
+    (
+      T_KW_E op2=expr_bit_ou
+      {
+         subroutine->emitMn( "and", tempVar.getNew( ), ret, op2 );
+         ret=tempVar.getLast( );
+         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+      }
+    )*
   ;
 
 expr_bit_ou returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
-  : ret=expr_bit_xou (T_BIT_OU expr_bit_xou)*
+{
+  string op2;
+}
+  : ret=expr_bit_xou
+    (
+      T_BIT_OU op2=expr_bit_xou
+      {
+         subroutine->emitMn( "bor", tempVar.getNew( ), ret, op2 );
+         ret=tempVar.getLast( );
+         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+      }
+    )*
   ;
 
 expr_bit_xou  returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
-  : ret=expr_bit_e (T_BIT_XOU expr_bit_e)*
+{
+  string op2;
+}
+  : ret=expr_bit_e 
+    (
+      T_BIT_XOU op2=expr_bit_e
+      {
+         subroutine->emitMn( "bxor", tempVar.getNew( ), ret, op2 );
+         ret=tempVar.getLast( );
+         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+      }
+    )*
   ;
 
 expr_bit_e returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
-  : ret=expr_igual (T_BIT_E expr_igual)*
+{
+  string op2;
+}
+  : ret=expr_igual
+    (
+      T_BIT_E op2=expr_igual
+      {
+         subroutine->emitMn( "band", tempVar.getNew( ), ret, op2 );
+         ret=tempVar.getLast( );
+         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+      }
+    )*
   ;
   
 expr_igual returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
-  : ret=expr_relacional (T_IGUAL expr_relacional|T_DIFERENTE expr_relacional)*
+{
+  string op2;
+  string mn;
+}
+  : ret=expr_relacional
+    (
+      ( T_IGUAL {mn="eq";} | T_DIFERENTE {mn="ne";} )
+      op2=expr_relacional
+      {
+//         subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
+//         ret=tempVar.getLast( );
+//         declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
+         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
+         ret=tempVar.getLast( );
+      }
+    )*
   ;
         
 expr_relacional returns [string ret]
@@ -447,9 +698,21 @@
 }
 {
   string op2;
+  string mn;
 }
-  : ret=expr_ad ((T_MAIOR| T_MAIOR_EQ| T_MENOR| T_MENOR_EQ)
-    op2=expr_ad {subroutine->emitIGEMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); } )*
+  : ret=expr_ad 
+    (
+      ( T_MAIOR {mn="gt";} | T_MAIOR_EQ {mn="ge";} | T_MENOR {mn="lt";} | T_MENOR_EQ {mn="le";} )
+      op2=expr_ad
+      {
+         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
+         //ret=tempVar.getLast( );
+         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
+         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
+         ret=tempVar.getLast( );
+      }
+    )*
   ;
 
 expr_ad returns [string ret]
@@ -458,28 +721,52 @@
 }
 {
    string op2;
+   string mn;
 }
-  : ret=expr_multip (T_MAIS op2=expr_multip {subroutine->emitISUMMn( tempVar.getNew( ), ret, op2 ); ret=tempVar.getLast( ); }
-                    | T_MENOS expr_multip)*
+  : ret=expr_multip 
+    (
+      ( T_MAIS {mn="sum";} | T_MENOS {mn="sub";} )
+      op2=expr_multip
+      {
+         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
+         //ret=tempVar.getLast( );
+         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType( op2 ) );
+         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
+         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
+         ret=tempVar.getLast( );
+      }
+    )*
   ;
 
-expr_multip returns [string op1]
+expr_multip returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
 {
   string op2;
-  RefToken op;
+  string mn;
 }
-  : op1=expr_unario
-    (( T_DIV | T_MULTIP | T_MOD ) {op=lastToken;} op2=expr_unario {subroutine->emitIMULMn( tempVar.getNew( ), op1, op2 ); op1=tempVar.getLast( ); } )*
+  : ret=expr_unario
+    (
+      ( T_DIV {mn="div";} | T_MULTIP {mn="mul";} | T_MOD {mn="mod";} )
+      op2=expr_unario
+      {
+         //subroutine->emitMnWithPrefix( mn, tempVar.getNew( ), ret, op2 );
+         //ret=tempVar.getLast( );
+         //declareSubroutineVar( SymbolTable::GlobalScope, ret, 0, getSymbolType(op2) );
+         declareSubroutineVar( SymbolTable::GlobalScope, tempVar.getNew( ), 0, getSymbolType( op2 ) );
+         subroutine->emitMnWithPrefix( mn, tempVar.getLast( ), ret, op2 );
+         ret=tempVar.getLast( );
+      } 
+    )*
   ;
 
 expr_unario returns [string ret]
 options {
   defaultErrorHandler=false; //noviable should be caught on expr
 }
-  : op_unario ret=expr_elemento
+  //: op_unario ret=expr_elemento
+  : ret=expr_elemento
   ;
 
 op_unario
@@ -492,7 +779,7 @@
   ; 
 
 expr_elemento returns [string ret]
-  : (T_IDENTIFICADOR T_ABREP)=> chamada_subrotina // ret= ???
+  : (T_IDENTIFICADOR T_ABREP)=> ret=chamada_funcao
   | ret=lvalue
   | ret=literal
   | t:T_ABREP ret=expr T_FECHAP 

Added: trunk/gpt2/test/check.sh
===================================================================
--- trunk/gpt2/test/check.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/check.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,92 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+echo "Realizando o teste regressivo no arquivo $1.gpt"
+
+exist_file $1.gpt
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.gpt
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.gasm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+#exist_file checked/$1.stdout
+#if [ $? -ne 0 ]
+#then
+#	exit 2
+#fi
+
+diff $1.gpt checked/$1.gpt >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Os arquivos $1.gpt e checked/$1.gpt sao diferentes. Nao eh possivel realizar o teste regressivo !"
+	exit 2
+fi
+
+./comp.sh $1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Arquivo $1.gpt nao foi compilado corretamente"
+	exit 2
+fi
+
+diff $1.gasm checked/$1.gasm >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Teste regressivo falhou. Os arquivos $1.gasm e checked/$1.gasm sao diferentes !!!"
+	vimdiff $1.gasm checked/$1.gasm
+	exit 1
+fi
+
+#diff $1.gvm checked/$1.gvm >/dev/null 2>&1
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: Teste regressivo falhou. Os arquivos $1.gvm e checked/$1.gvm sao diferentes !!!"
+#	gdumpasm -D$1
+#	gdumpasm -Dchecked/$1
+#	vimdiff $1.dump checked/$1.dump
+#	exit 1
+#fi
+
+#diff $1.stdout checked/$1.stdout >/dev/null 2>&1
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: Teste regressivo falhou. Os arquivos $1.stdout e checked/$1.stdout sao diferentes !!!"
+#	vimdiff $1.stdout checked/$1.stdout
+#	exit 1
+#fi
+
+echo "Ok: Teste regressivo ok para $1.gpt"
+
+exit 0
+


Property changes on: trunk/gpt2/test/check.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/check_all.sh
===================================================================
--- trunk/gpt2/test/check_all.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/check_all.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+echo "Realizando o teste regressivo em todos os arquivos .gpt do diretorio"
+
+rm *.gasm 1>/dev/null 2>&1
+#rm *.gvm 1>/dev/null 2>&1
+#rm *.stdout 1>/dev/null 2>&1
+
+for i in `ls *.gpt -1 | sed s/"\.gpt"//g`
+do
+	./check.sh $i 
+	echo ""
+#	if [ $? -ne 0 ]
+#	then
+#		echo "Falha no teste regressivo do arquivo $i";
+#	fi
+done


Property changes on: trunk/gpt2/test/check_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/comp.sh
===================================================================
--- trunk/gpt2/test/comp.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/comp.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,32 @@
+rm $1.gasm 1>/dev/null 2>&1
+#rm $1.gvm 1>/dev/null 2>&1
+#rm $1.stdout 1>/dev/null 2>&1
+
+../../src/gpt $1.gpt
+if [ $? -ne 0 ]
+then
+	echo "Erro: nao foi possivel compilar $1.gpt"
+	exit 1
+fi
+#echo ""
+
+#./gptasm $1
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: nao foi possivel assemblar $1.gasm"
+#	exit 1
+#fi
+#echo ""
+
+#./gvm $1 > $1.stdout
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: nao foi possivel executar $1.gvm"
+#	exit 1
+#fi
+#echo ""
+
+#cat $1.stdout
+
+#cat $1.gasm
+


Property changes on: trunk/gpt2/test/comp.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/comp_all.sh
===================================================================
--- trunk/gpt2/test/comp_all.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/comp_all.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+echo "Compilando todos os arquivos .gpt do diretorio"
+
+rm *.gasm
+#rm *.gvm
+#rm *.stdout
+
+for i in `ls *.gpt -1 | sed s/"\.gpt"//g`
+do
+	./comp.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/test/comp_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/gpt
===================================================================
--- trunk/gpt2/test/gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1 @@
+link ../src/gpt
\ No newline at end of file


Property changes on: trunk/gpt2/test/gpt
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/gpt2/test/prep_tests.sh
===================================================================
--- trunk/gpt2/test/prep_tests.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/prep_tests.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,12 @@
+cd wikki/
+
+ln -s ../check_all.sh     check_all.sh
+ln -s ../check.sh         check.sh
+ln -s ../comp_all.sh      comp_all.sh
+ln -s ../comp.sh          comp.sh
+ln -s ../show_and_comp.sh show_and_comp.sh
+ln -s ../test_ok_all.sh   test_ok_all.sh
+ln -s ../test_ok.sh       test_ok.sh
+
+cd ..
+


Property changes on: trunk/gpt2/test/prep_tests.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/show_and_comp.sh
===================================================================
--- trunk/gpt2/test/show_and_comp.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/show_and_comp.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,17 @@
+echo "ARQUIVO $1.gpt"
+cat $1.gpt
+
+./comp.sh $1
+if [ $? -ne 0 ]
+then
+	exit 1
+fi
+
+echo ""
+
+echo "ARQUIVO $1.gasm"
+cat $1.gasm
+
+#echo "ARQUIVO $1.stdout"
+#cat $1.stdout
+


Property changes on: trunk/gpt2/test/show_and_comp.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/test_ok.sh
===================================================================
--- trunk/gpt2/test/test_ok.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/test_ok.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,59 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+
+exist_file $1.gpt
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file $1.gasm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+#exist_file $1.gvm
+#if [ $? -ne 0 ]
+#then
+#	exit 2
+#fi
+
+#exist_file $1.stdout
+#if [ $? -ne 0 ]
+#then
+#	exit 2
+#fi
+
+echo "Copiando o arquivo $1.gpt p/ o diretorio checked"
+cp $1.gpt checked/
+
+echo "Copiando o arquivo $1.gasm p/ o diretorio checked"
+cp $1.gasm checked/
+
+#echo "Copiando o arquivo $1.gvm p/ o diretorio checked"
+#cp $1.gvm  checked/
+
+#echo "Copiando o arquivo $1.stdout p/ o diretorio checked"
+#cp $1.stdout  checked/
+


Property changes on: trunk/gpt2/test/test_ok.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/test_ok_all.sh
===================================================================
--- trunk/gpt2/test/test_ok_all.sh	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/test_ok_all.sh	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,7 @@
+echo "Executando test ok para todos os arquivos .gpt do diretorio"
+
+for i in `ls *.gpt -1 | sed s/"\.gpt"//g`
+do
+	./test_ok.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/test/test_ok_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/test/teste_chamada_subrotinas.gpt
===================================================================
--- trunk/gpt2/test/teste_chamada_subrotinas.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/teste_chamada_subrotinas.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,9 @@
+algoritmo teste ;
+
+in?cio
+    v := 2;
+    imprima( 1 );
+    imprima( "Hello world !!!" );
+    subrotina1( "aaa", 2 );
+fim
+

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,24 @@
+// Programa estruturas_condicionais_1.gasm gerado a partir de estruturas_condicionais_1.gpt
+program estruturas_condicionais_1
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 10
+	ige __temp_1, x, 20
+	ifnot __temp_1, __label_1
+	iset x, 2
+	jmp __label_2
+	__label_1:
+	iset x, 1
+	__label_2:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,13 @@
+algoritmo exemplo;
+
+vari?vel x : inteiro;
+
+in?cio
+    x := 10;
+    se x >= 20 ent?o
+        x := 2;
+    sen?o
+        x := 1;
+    fim-se
+    imprima( x );
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,36 @@
+// Programa estruturas_condicionais_2.gasm gerado a partir de estruturas_condicionais_2.gpt
+program estruturas_condicionais_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 20
+	ige __temp_1, x, 0
+	ifnot __temp_1, __label_1
+	igt __temp_2, x, 40
+	ifnot __temp_2, __label_2
+	push "x>40"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_3
+	__label_2:
+	push "x<=40"
+	push_string
+	push 1
+	pcall imprima
+	__label_3:
+	jmp __label_4
+	__label_1:
+	push "x eh negativo !!!"
+	push_string
+	push 1
+	pcall imprima
+	__label_4:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,16 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := 20;
+    se x >= 0 ent?o
+        se x > 40 ent?o
+            imprima( "x>40" );
+        sen?o
+            imprima( "x<=40" );
+        fim-se
+    sen?o
+        imprima( "x eh negativo !!!" );
+    fim-se
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,30 @@
+// Programa estruturas_condicionais_3.gasm gerado a partir de estruturas_condicionais_3.gpt
+program estruturas_condicionais_3
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	iset x, 1
+	ige __temp_1, x, 1
+	ile __temp_2, x, 10
+	and __temp_3, __temp_1, __temp_2
+	ifnot __temp_3, __label_1
+	push "x entre 1 e 10"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_2
+	__label_1:
+	push "x n?o est? entre 1 e 10"
+	push_string
+	push 1
+	pcall imprima
+	__label_2:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_3.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,12 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := 1;
+    se x >= 1 e x <= 10 ent?o
+        imprima( "x entre 1 e 10" );
+    sen?o
+        imprima( "x n?o est? entre 1 e 10" );
+    fim-se
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,41 @@
+// Programa estruturas_condicionais_4.gasm gerado a partir de estruturas_condicionais_4.gpt
+program estruturas_condicionais_4
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	push_0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	iset __temp_2, x
+	ieq __temp_3, __temp_2, 1
+	ifnot __temp_3, __label_2
+	push "x = um"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_1
+	__label_2:
+	ieq __temp_4, __temp_2, 2
+	ifnot __temp_4, __label_3
+	push "x = dois"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_1
+	__label_3:
+	push "x diferente de um e dois"
+	push_string
+	push 1
+	pcall imprima
+	__label_1:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,18 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := leia( );
+    caso x seja
+    1 fa?a
+        imprima( "x = um" );
+    fim-fa?a
+    2 fa?a
+        imprima( "x = dois" );
+    fim-fa?a
+    sen?o
+        imprima( "x diferente de um e dois" );
+    fim-sen?o
+    fim-caso
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,23 @@
+// Programa estruturas_condicionais_5.gasm gerado a partir de estruturas_condicionais_5.gpt
+program estruturas_condicionais_5
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 10
+	ige __temp_1, x, 20
+	ifnot __temp_1, __label_1
+	iset x, 2
+	jmp __label_2
+	__label_1:
+	__label_2:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_condicionais_5.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+algoritmo exemplo;
+
+vari?vel x : inteiro;
+
+in?cio
+    x := 10;
+    se x >= 20 ent?o
+        x := 2;
+    fim-se
+    imprima( x );
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_1.gasm gerado a partir de estruturas_repeticao_1.gpt
+program estruturas_repeticao_1
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 1
+	__label_1:
+	ile __temp_1, x, 10
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	iinc x, 1
+	jmp __label_1
+	__label_2:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,9 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    para x de 1 at? 10 fa?a
+        imprima( x );
+    fim-para
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_2.gasm gerado a partir de estruturas_repeticao_2.gpt
+program estruturas_repeticao_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 100
+	__label_1:
+	ige __temp_1, x, 0
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	idec x, 2
+	jmp __label_1
+	__label_2:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,9 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    para x de 100 at? 0 passo -2 fa?a
+        imprima( x );
+    fim-para
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,25 @@
+// Programa estruturas_repeticao_3.gasm gerado a partir de estruturas_repeticao_3.gpt
+program estruturas_repeticao_3
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 1
+	__label_1:
+	ile __temp_1, x, 10
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	isum __temp_2, x, 1
+	iset x, __temp_2
+	jmp __label_1
+	__label_2:
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_3.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := 1;
+    enquanto x <= 10 fa?a
+        imprima( x );
+        x := x + 1;
+    fim-enquanto
+fim

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_4.gasm gerado a partir de estruturas_repeticao_4.gpt
+program estruturas_repeticao_4
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 1
+	__label_1:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	isum __temp_1, x, 1
+	iset x, __temp_1
+	igt __temp_2, x, 10
+	ifnot __temp_2, __label_1
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/estruturas_repeticao_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := 1;
+    repita
+        imprima( x );
+        x := x + 1;
+    at? x > 10
+fim

Added: trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,38 @@
+// Programa expressoes_matematicas_1.gasm gerado a partir de expressoes_matematicas_1.gpt
+program expressoes_matematicas_1
+
+var t1 int
+var t2 int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	var __temp_5 int
+	isum __temp_1, 1, 2
+	iset t1, __temp_1
+	imul __temp_2, 5, 3
+	iset t1, __temp_2
+	isum __temp_3, 2, t1
+	iset t2, __temp_3
+	push t2
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	imul __temp_4, 5, 3
+	isum __temp_5, 2, __temp_4
+	iset t1, __temp_5
+	push t1
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/expressoes_matematicas_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,13 @@
+algoritmo exemplo;
+
+vari?vel t1: inteiro;
+vari?vel t2: inteiro;
+
+in?cio
+    t1 := 1+2;
+    t1 := 5*3;
+    t2 := 2+t1;
+    imprima( "2+5*3=", t2 );
+    t1 := 2+5*3;
+    imprima( "2+5*3=", t1 );
+fim

Added: trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,20 @@
+// Programa expressoes_matematicas_2.gasm gerado a partir de expressoes_matematicas_2.gpt
+program expressoes_matematicas_2
+
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	imul __temp_1, 5, 3
+	isum __temp_2, 2, __temp_1
+	push __temp_2
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/expressoes_matematicas_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,5 @@
+algoritmo exemplo;
+
+in?cio
+    imprima( "2+5*3=", 2+5*3 );
+fim

Added: trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,34 @@
+// Programa funcoes_definidas_usuario_1.gasm gerado a partir de funcoes_definidas_usuario_1.gpt
+program funcoes_definidas_usuario_1
+
+// Procedure main
+proc main
+	var __temp_1 int
+	push_0
+	push 7
+	push 2
+	pcall soma
+	pop __temp_1
+	push __temp_1
+	push_int
+	push "A soma ?: "
+	push_string
+	push 2
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	par x int
+	par y int
+	var __result int
+	var __temp_2 int
+	isum __temp_2, x, y
+	iset __result, __temp_2
+	ret
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+// Fun??es n?o recursivas
+algoritmo exemplo;
+
+in?cio
+    imprima( "A soma ?: ", soma( 2, 7 ) );
+fim
+
+fun??o soma( x: inteiro, y: inteiro ) : inteiro
+in?cio
+    retorne( x + y );
+fim	

Added: trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,61 @@
+// Programa funcoes_definidas_usuario_2.gasm gerado a partir de funcoes_definidas_usuario_2.gpt
+program funcoes_definidas_usuario_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	push "Digite um n?mero:"
+	push_string
+	push 1
+	pcall imprima
+	push_0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	push_0
+	push x
+	pcall fatorial
+	pop __temp_2
+	push __temp_2
+	push_int
+	push "? "
+	push_string
+	push x
+	push_int
+	push "Fatorial de "
+	push_string
+	push 4
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure fatorial
+proc fatorial
+	par z int
+	var __result int
+	var __temp_3 int
+	var __temp_4 int
+	var __temp_5 int
+	var __temp_6 int
+	ieq __temp_3, z, 1
+	ifnot __temp_3, __label_1
+	iset __result, 1
+	ret
+	jmp __label_2
+	__label_1:
+	push_0
+	isub __temp_4, z, 1
+	push __temp_4
+	pcall fatorial
+	pop __temp_5
+	imul __temp_6, z, __temp_5
+	iset __result, __temp_6
+	ret
+	__label_2:
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/funcoes_definidas_usuario_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,20 @@
+// Fun??es recursivas
+
+algoritmo fatorial_recursivo;
+
+vari?vel x: inteiro;
+
+in?cio
+    imprima( "Digite um n?mero:" );
+    x := leia( );
+    imprima( "Fatorial de ", x, "? ", fatorial( x ) );
+fim
+
+fun??o fatorial( z: inteiro ) : inteiro
+in?cio
+    se z = 1 ent?o
+        retorne 1;
+    sen?o
+        retorne z * fatorial( z - 1 );
+    fim-se
+fim	

Added: trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,28 @@
+// Programa inline_codigo_gptassembly.gasm gerado a partir de inline_codigo_gptassembly.gpt
+program inline_codigo_gptassembly
+
+var x int
+// Procedure main
+proc main
+	iset x, 10
+	push x
+	push_int
+	push 1
+	pcall imprima
+
+	// asm-begin
+	
+        iset x, 20
+        isum x, x, 80
+    
+	// asm-end
+
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/inline_codigo_gptassembly.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    x := 10;
+    imprima( x );
+    asm
+    {
+        iset x, 20
+        isum x, x, 80
+    }
+    fim-asm
+    imprima( x );
+fim

Added: trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,14 @@
+// Programa invocando_subrotinas_linguagem_1.gasm gerado a partir de invocando_subrotinas_linguagem_1.gpt
+program invocando_subrotinas_linguagem_1
+
+// Procedure main
+proc main
+	push "Ol? mundo !!!"
+	push_string
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,5 @@
+algoritmo exemplo;
+
+in?cio
+    imprima( "Ol? mundo !!!" );
+fim

Added: trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,26 @@
+// Programa invocando_subrotinas_linguagem_2.gasm gerado a partir de invocando_subrotinas_linguagem_2.gpt
+program invocando_subrotinas_linguagem_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	push "Digite um n?mero: "
+	push_string
+	push 1
+	pcall imprima
+	push_0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	push x
+	push_int
+	push "O n?mero digitado foi "
+	push_string
+	push 2
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/invocando_subrotinas_linguagem_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,9 @@
+algoritmo exemplo;
+
+vari?vel x: inteiro;
+
+in?cio
+    imprima( "Digite um n?mero: " );
+    x := leia( );
+    imprima( "O n?mero digitado foi ", x );
+fim

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,24 @@
+// Programa procedimentos_definidos_usuario_1.gasm gerado a partir de procedimentos_definidos_usuario_1.gpt
+program procedimentos_definidos_usuario_1
+
+// Procedure main
+proc main
+	pcall soma
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	var __temp_1 int
+	isum __temp_1, 2, 7
+	push __temp_1
+	push_int
+	push "A soma de 2 + 7 ?: "
+	push_string
+	push 2
+	pcall imprima
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+// Procedimento sem passagem de par?metros
+algoritmo exemplo;
+
+in?cio
+    soma( );
+fim
+
+procedimento soma( )
+in?cio
+    imprima( "A soma de 2 + 7 ?: ", 2 + 7 );
+fim	

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,28 @@
+// Programa procedimentos_definidos_usuario_2.gasm gerado a partir de procedimentos_definidos_usuario_2.gpt
+program procedimentos_definidos_usuario_2
+
+// Procedure main
+proc main
+	push 7
+	push 2
+	pcall soma
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	par x int
+	par y int
+	var __temp_1 int
+	isum __temp_1, x, y
+	push __temp_1
+	push_int
+	push "A soma ?: "
+	push_string
+	push 2
+	pcall imprima
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+// Procedimento com passagem de par?metros por valor
+algoritmo exemplo;
+
+in?cio
+    soma( 2, 7 );
+fim
+
+procedimento soma( x: inteiro, y: inteiro )
+in?cio
+    imprima( "A soma ?: ", x + y );
+fim

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,42 @@
+// Programa procedimentos_definidos_usuario_3.gasm gerado a partir de procedimentos_definidos_usuario_3.gpt
+program procedimentos_definidos_usuario_3
+
+var g int
+// Procedure main
+proc main
+	iset g, 0
+	iset g, g
+	push 10
+	push g
+	pcall roda
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure roda
+proc roda
+	par p1 int
+	par p2 int
+	var l1 int
+	var l2 int
+	iset l1, 0
+	iset l1, l2
+	iset l1, g
+	iset g, l1
+	iset p1, p2
+	iset l1, p1
+	iset p1, l1
+	iset p1, g
+	iset g, p1
+	push l1
+	push_int
+	push p1
+	push_int
+	push g
+	push_int
+	push 3
+	pcall imprima
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_3.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,26 @@
+// Procedimento com passagem de par?metros por valor
+algoritmo exemplo;
+
+vari?vel g: inteiro;
+
+in?cio
+    g := 0;
+    g := g;
+    roda( g, 10 );
+fim
+
+procedimento roda( p1: inteiro, p2: inteiro )
+vari?vel l1: inteiro;
+vari?vel l2: inteiro;
+in?cio
+    l1 := 0;
+    l1 := l2;
+    l1 := g;
+    g := l1;
+    p1 := p2;
+    l1 := p1;
+    p1 := l1;
+    p1 := g;
+    g := p1;
+    imprima( g, p1, l1 );
+fim

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,34 @@
+// Programa procedimentos_definidos_usuario_4.gasm gerado a partir de procedimentos_definidos_usuario_4.gpt
+program procedimentos_definidos_usuario_4
+
+var x int
+var y int
+// Procedure main
+proc main
+	iset x, 10
+	iset y, 20
+	push 30
+	pcall soma
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	par z int
+	var s int
+	var __temp_1 int
+	var __temp_2 int
+	isum __temp_1, x, y
+	isum __temp_2, __temp_1, z
+	iset s, __temp_2
+	push s
+	push_int
+	push "A soma de x, y e z ?: "
+	push_string
+	push 2
+	pcall imprima
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/procedimentos_definidos_usuario_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,20 @@
+// Vari?veis globais sendo acessadas em um procedimento com par?metros
+algoritmo exemplo;
+
+vari?veis
+    x: inteiro;
+    y: inteiro;
+fim-vari?veis
+
+in?cio
+    x := 10;
+    y := 20;
+    soma( 30 );
+fim
+
+procedimento soma( z: inteiro )
+vari?vel s: inteiro;
+in?cio
+    s := x + y + z;
+    imprima( "A soma de x, y e z ?: ", s );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_1.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_1.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_1.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,24 @@
+// Programa variaveis_1.gasm gerado a partir de variaveis_1.gpt
+program variaveis_1
+
+var x int
+var y int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 10
+	iset y, 20
+	imul __temp_1, x, y
+	isum __temp_2, __temp_1, 4
+	push __temp_2
+	push_int
+	push "x*y+4="
+	push_string
+	push 2
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,12 @@
+algoritmo exemplo;
+
+vari?veis
+    x: inteiro;
+    y: inteiro;
+fim-vari?veis
+
+in?cio
+    x := 10;
+    y := 20;
+    imprima( "x*y+4=", x*y+4 );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_2.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_2.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_2.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,33 @@
+// Programa variaveis_2.gasm gerado a partir de variaveis_2.gpt
+program variaveis_2
+
+var v int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	iset v, 10
+	iset v, v
+	isum __temp_1, 10, 20
+	iset v, __temp_1
+	isum __temp_2, v, 20
+	iset v, __temp_2
+	isum __temp_3, 30, v
+	iset v, __temp_3
+	isum __temp_4, v, v
+	iset v, __temp_4
+	push 10
+	push_int
+	push 1
+	pcall imprima
+	push v
+	push_int
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+algoritmo exemplo;
+
+vari?vel v: inteiro;
+
+in?cio
+    // testes com inteiro
+    v := 10;
+    v := v;
+    v := 10 + 20;
+    v := v + 20;
+    v := 30 + v;
+    v := v + v;
+    imprima( 10 );
+    imprima( v );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_3.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_3.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_3.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,33 @@
+// Programa variaveis_3.gasm gerado a partir de variaveis_3.gpt
+program variaveis_3
+
+var v real
+// Procedure main
+proc main
+	var __temp_1 real
+	var __temp_2 real
+	var __temp_3 real
+	var __temp_4 real
+	rset v, 10.0
+	rset v, v
+	rsum __temp_1, 10.0, 20.0
+	rset v, __temp_1
+	rsum __temp_2, v, 20.0
+	rset v, __temp_2
+	rsum __temp_3, 30.0, v
+	rset v, __temp_3
+	rsum __temp_4, v, v
+	rset v, __temp_4
+	push 10.0
+	push_real
+	push 1
+	pcall imprima
+	push v
+	push_real
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_3.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_3.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_3.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+algoritmo exemplo;
+
+vari?vel v: real;
+
+in?cio
+    // testes com real
+    v := 10.0;
+    v := v;
+    v := 10.0 + 20.0;
+    v := v + 20.0;
+    v := 30.0 + v;
+    v := v + v;
+    imprima( 10.0 );
+    imprima( v );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_4.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_4.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_4.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,33 @@
+// Programa variaveis_4.gasm gerado a partir de variaveis_4.gpt
+program variaveis_4
+
+var v char
+// Procedure main
+proc main
+	var __temp_1 char
+	var __temp_2 char
+	var __temp_3 char
+	var __temp_4 char
+	iset v, 'a'
+	iset v, v
+	isum __temp_1, 'a', 'b'
+	iset v, __temp_1
+	isum __temp_2, v, 'b'
+	iset v, __temp_2
+	isum __temp_3, 'c', v
+	iset v, __temp_3
+	isum __temp_4, v, v
+	iset v, __temp_4
+	push 'a'
+	push_char
+	push 1
+	pcall imprima
+	push v
+	push_char
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+algoritmo exemplo;
+
+vari?vel v: caractere;
+
+in?cio
+    // testes com caractere
+    v := 'a';
+    v := v;
+    v := 'a' + 'b';
+    v := v + 'b';
+    v := 'c' + v;
+    v := v + v;
+    imprima( 'a' );
+    imprima( v );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_5.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_5.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_5.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,33 @@
+// Programa variaveis_5.gasm gerado a partir de variaveis_5.gpt
+program variaveis_5
+
+var v string
+// Procedure main
+proc main
+	var __temp_1 string
+	var __temp_2 string
+	var __temp_3 string
+	var __temp_4 string
+	sset v, "a"
+	sset v, v
+	ssum __temp_1, "a", "b"
+	sset v, __temp_1
+	ssum __temp_2, v, "b"
+	sset v, __temp_2
+	ssum __temp_3, "c", v
+	sset v, __temp_3
+	ssum __temp_4, v, v
+	sset v, __temp_4
+	push "aa"
+	push_string
+	push 1
+	pcall imprima
+	push v
+	push_string
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_5.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_5.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_5.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,15 @@
+algoritmo exemplo;
+
+vari?vel v: literal;
+
+in?cio
+    // testes com literal
+    v := "a";
+    v := v;
+    v := "a" + "b";
+    v := v + "b";
+    v := "c" + v;
+    v := v + v;
+    imprima( "aa" );
+    imprima( v );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_6.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_6.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_6.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,26 @@
+// Programa variaveis_6.gasm gerado a partir de variaveis_6.gpt
+program variaveis_6
+
+var v bool
+// Procedure main
+proc main
+	iset v, verdadeiro
+	iset v, falso
+	iset v, v
+	push verdadeiro
+	push_bool
+	push 1
+	pcall imprima
+	push falso
+	push_bool
+	push 1
+	pcall imprima
+	push v
+	push_bool
+	push 1
+	pcall imprima
+	exit_0
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_6.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_6.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_6.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,13 @@
+algoritmo exemplo;
+
+vari?vel v: l?gico;
+
+in?cio
+    // testes com l?gico
+    v := verdadeiro;
+    v := falso;
+    v := v;
+    imprima( verdadeiro );
+    imprima( falso );
+    imprima( v );
+fim

Added: trunk/gpt2/test/wikki/checked/variaveis_7.gasm
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_7.gasm	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_7.gasm	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,26 @@
+// Programa variaveis_7.gasm gerado a partir de variaveis_7.gpt
+program variaveis_7
+
+// Procedure main
+proc main
+	pcall mostra
+	exit_0
+end-proc
+// Fim da procedure
+
+// Procedure mostra
+proc mostra
+	var resultado int
+	var __temp_1 int
+	isum __temp_1, 4, 5
+	iset resultado, __temp_1
+	push resultado
+	push_int
+	push "soma de 4 e 5 ?: "
+	push_string
+	push 2
+	pcall imprima
+end-proc
+// Fim da procedure
+
+end-program

Added: trunk/gpt2/test/wikki/checked/variaveis_7.gpt
===================================================================
--- trunk/gpt2/test/wikki/checked/variaveis_7.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/checked/variaveis_7.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,12 @@
+algoritmo variavel_local;
+
+in?cio
+    mostra( );
+fim
+
+procedimento mostra( )
+vari?vel resultado: inteiro;
+in?cio
+    resultado := 4 + 5;
+    imprima( "soma de 4 e 5 ?: ", resultado );
+fim

Modified: trunk/gpt2/test/wikki/constantes_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/constantes_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/constantes_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,6 +1,6 @@
 algoritmo exemplo;
 
-constante total: inteiro = 100;
+constante total: inteiro := 100;
 
 vari?vel i: inteiro;
 

Added: trunk/gpt2/test/wikki/estruturas_condicionais_5.gpt
===================================================================
--- trunk/gpt2/test/wikki/estruturas_condicionais_5.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/estruturas_condicionais_5.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,11 @@
+algoritmo exemplo;
+
+vari?vel x : inteiro;
+
+in?cio
+    x := 10;
+    se x >= 20 ent?o
+        x := 2;
+    fim-se
+    imprima( x );
+fim

Modified: trunk/gpt2/test/wikki/estruturas_repeticao_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/estruturas_repeticao_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/estruturas_repeticao_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -7,5 +7,5 @@
     repita
         imprima( x );
         x := x + 1;
-    enquanto x <= 10
+    at? x > 10
 fim

Modified: trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt
===================================================================
--- trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/expressoes_matematicas_1.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,6 +1,7 @@
 algoritmo exemplo;
 
 vari?vel t1: inteiro;
+vari?vel t2: inteiro;
 
 in?cio
     t1 := 1+2;

Added: trunk/gpt2/test/wikki/expressoes_matematicas_2.gpt
===================================================================
--- trunk/gpt2/test/wikki/expressoes_matematicas_2.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/expressoes_matematicas_2.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -0,0 +1,5 @@
+algoritmo exemplo;
+
+in?cio
+    imprima( "2+5*3=", 2+5*3 );
+fim

Modified: trunk/gpt2/test/wikki/inline_codigo_gptassembly.gpt
===================================================================
--- trunk/gpt2/test/wikki/inline_codigo_gptassembly.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/inline_codigo_gptassembly.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -6,8 +6,10 @@
     x := 10;
     imprima( x );
     asm
+    {
         iset x, 20
         isum x, x, 80
+    }
     fim-asm
     imprima( x );
 fim

Modified: trunk/gpt2/test/wikki/matrizes_3.gpt
===================================================================
--- trunk/gpt2/test/wikki/matrizes_3.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/matrizes_3.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -5,7 +5,7 @@
 fim
 
 procedimento mostra( )
-vari?vel resultado: matriz[3] de inteiros;
+vari?vel resultado: matriz[3] do tipo inteiro;
 in?cio
     resultado[0] := 10;
     resultado[1] := 20;

Modified: trunk/gpt2/test/wikki/variaveis_4.gpt
===================================================================
--- trunk/gpt2/test/wikki/variaveis_4.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/variaveis_4.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -4,12 +4,12 @@
 
 in?cio
     // testes com caractere
-    v3 := 'a';
-    v3 := v3;
-    v3 := 'a' + 'b';
-    v3 := v3 + 'b';
-    v3 := 'c' + v3;
-    v3 := v3 + v3;
+    v := 'a';
+    v := v;
+    v := 'a' + 'b';
+    v := v + 'b';
+    v := 'c' + v;
+    v := v + v;
     imprima( 'a' );
-    imprima( v3 );
+    imprima( v );
 fim

Modified: trunk/gpt2/test/wikki/variaveis_7.gpt
===================================================================
--- trunk/gpt2/test/wikki/variaveis_7.gpt	2007-11-01 13:42:58 UTC (rev 334)
+++ trunk/gpt2/test/wikki/variaveis_7.gpt	2007-11-05 16:07:40 UTC (rev 335)
@@ -1,4 +1,4 @@
-algoritmo vari?vel_local;
+algoritmo variavel_local;
 
 in?cio
     mostra( );



From gpt-commit-noreply at mail.berlios.de  Mon Nov  5 17:41:23 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 5 Nov 2007 17:41:23 +0100
Subject: [gpt-commit] r336 - trunk/gpt2/src/modules/parser
Message-ID: <200711051641.lA5GfNCM032188@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-05 17:41:22 +0100 (Mon, 05 Nov 2007)
New Revision: 336

Removed:
   trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp
   trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp
Log:
REGULAR:
- Removendo classes inutilizadas no refactory


Deleted: trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.cpp
===================================================================

Deleted: trunk/gpt2/src/modules/parser/GASMFE_CGptAssemblyFile.hpp
===================================================================



From gpt-commit-noreply at mail.berlios.de  Thu Nov  8 06:58:29 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 8 Nov 2007 06:58:29 +0100
Subject: [gpt-commit] r338 - in trunk/gpt2: . doc src tests
Message-ID: <200711080558.lA85wTlb001153@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-08 06:58:29 +0100 (Thu, 08 Nov 2007)
New Revision: 338

Added:
   trunk/gpt2/doc/
   trunk/gpt2/doc/gptasm/
   trunk/gpt2/doc/gptc/
   trunk/gpt2/doc/gptlib/
   trunk/gpt2/doc/gptvm/
   trunk/gpt2/src/
   trunk/gpt2/src/common/
   trunk/gpt2/src/gptasm/
   trunk/gpt2/src/gptc/
   trunk/gpt2/src/gptlib/
   trunk/gpt2/src/gptvm/
   trunk/gpt2/tests/
   trunk/gpt2/tests/gptasm/
   trunk/gpt2/tests/gptc/
   trunk/gpt2/tests/gptlib/
   trunk/gpt2/tests/gptvm/
Log:
DEVNULL:-Montando esqueleto de diretorios



From gpt-commit-noreply at mail.berlios.de  Thu Nov  8 08:43:10 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 8 Nov 2007 08:43:10 +0100
Subject: [gpt-commit] r339 - in trunk/gpt2/src/gptc: . testes
Message-ID: <200711080743.lA87hAYd013908@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-08 08:43:09 +0100 (Thu, 08 Nov 2007)
New Revision: 339

Added:
   trunk/gpt2/src/gptc/Makefile
   trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp
   trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp
   trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp
   trunk/gpt2/src/gptc/UnicodeCharScanner.hpp
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
   trunk/gpt2/src/gptc/teste.cpp
   trunk/gpt2/src/gptc/testes/
   trunk/gpt2/src/gptc/testes/lex_teste.gpt
   trunk/gpt2/src/gptc/testes/tree_teste.gpt
Log:
-lexer/parser infanto-juvenil
  * refatoracao do lexer em relacao a v1.0
  * parser limpo (sem codigo de tratamento de erros)
  * finalizada a estrutura inicial da AST
  * Faltando da gramatica: enunciado::expressao e en_asm

Added: trunk/gpt2/src/gptc/Makefile
===================================================================
--- trunk/gpt2/src/gptc/Makefile	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/Makefile	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,36 @@
+objects = PortugolLexer.o PortugolParser.o \
+			    MismatchedUnicodeCharException.o teste.o
+
+teste: $(objects)
+	g++ -o teste $(objects) /usr/local/lib/libantlr.a
+
+PortugolLexer.o: PortugolLexer.hpp PortugolLexer.cpp
+	g++ -c PortugolLexer.cpp
+
+PortugolParser.o: PortugolParser.hpp PortugolParser.cpp
+	g++ -c PortugolParser.cpp
+
+MismatchedUnicodeCharException.o:
+	g++ -c MismatchedUnicodeCharException.cpp
+
+teste.o: teste.cpp table.hpp
+	g++ -c teste.cpp
+
+PortugolLexer.hpp PortugolLexer.cpp: lexer.g
+	antlr lexer.g
+
+PortugolParser.hpp PortugolParser.cpp: parser.g
+	antlr parser.g
+
+table.hpp:
+	grep = PortugolTokenTypes.txt > table.hpp
+	sed -i -e 's/([^=]*)//' table.hpp
+	sed -i -e 's/"[^"]*"//' table.hpp
+	sed -i -e 's/==/=/' table.hpp
+	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' table.hpp
+
+
+clean:
+	rm -f *.o PortugolLexer.cpp PortugolLexer.hpp PortugolTokenTypes.hpp \
+	PortugolTokenTypes.txt PortugolParser.cpp PortugolParser.hpp teste \
+	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp

Added: trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/MismatchedUnicodeCharException.cpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,110 @@
+
+#include <iostream>
+
+#include <antlr/config.hpp>
+#include <antlr/RecognitionException.hpp>
+#include <antlr/BitSet.hpp>
+#include <antlr/String.hpp>
+#include "MismatchedUnicodeCharException.hpp"
+#include "UnicodeCharScanner.hpp"
+
+
+MismatchedUnicodeCharException::MismatchedUnicodeCharException()
+: RecognitionException("Mismatched char")
+{
+}
+
+// Expected range / not range
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	char_type lower,
+	char_type up,
+	bool matchNot,
+	UnicodeCharScanner* cs
+)
+: RecognitionException("Mismatched char",
+							  cs->getFilename(),
+							  cs->getLine(), cs->getColumn())
+, mismatchType(matchNot ? NOT_RANGE : RANGE)
+, foundChar(c)
+, expecting(lower)
+, upper(up)
+, scanner(cs)
+{
+}
+
+// Expected char / not char
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	char_type expect,
+	bool matchNot,
+	UnicodeCharScanner* cs
+) : RecognitionException("Mismatched char",
+                      cs->getFilename(),
+							 cs->getLine(), cs->getColumn())
+, mismatchType(matchNot ? NOT_CHAR : CHAR)
+, foundChar(c)
+, expecting(expect)
+, scanner(cs)
+{
+}
+
+// Expected BitSet / not BitSet
+MismatchedUnicodeCharException::MismatchedUnicodeCharException(
+	char_type c,
+	antlr::BitSet s,
+	bool matchNot,
+	UnicodeCharScanner* cs
+) : RecognitionException("Mismatched char",
+                      cs->getFilename(),
+							 cs->getLine(), cs->getColumn())
+, mismatchType(matchNot ? NOT_SET : SET)
+, foundChar(c)
+, set(s)
+, scanner(cs)
+{
+}
+
+MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
+
+/**
+ * Returns a clean error message (no line number/column information)
+ */
+std::string MismatchedUnicodeCharException::getMessage() const
+{
+	ANTLR_USE_NAMESPACE(std)string s;
+
+	switch (mismatchType) {
+	case CHAR :
+		s += "expecting '" + antlr::charName(expecting) + "', found '" + antlr::charName(foundChar) + "'";
+		break;
+	case NOT_CHAR :
+		s += "expecting anything but '" + antlr::charName(expecting) + "'; got it anyway";
+		break;
+	case RANGE :
+		s += "expecting token in range: '" + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
+		break;
+	case NOT_RANGE :
+		s += "expecting token NOT in range: " + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
+		break;
+	case SET :
+	case NOT_SET :
+		{
+			s += ANTLR_USE_NAMESPACE(std)string("expecting ") + (mismatchType == NOT_SET ? "NOT " : "") + "one of (";
+			ANTLR_USE_NAMESPACE(std)vector<unsigned int> elems = set.toArray();
+			for ( unsigned int i = 0; i < elems.size(); i++ )
+			{
+				s += " '";
+				s += antlr::charName(elems[i]);
+				s += "'";
+			}
+			s += "), found '" + antlr::charName(foundChar) + "'";
+		}
+		break;
+	default :
+		s += RecognitionException::getMessage();
+		break;
+	}
+
+	return s;
+}

Added: trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/MismatchedUnicodeCharException.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,82 @@
+#ifndef INC_MismatchedUnicodeCharException_hpp__
+#define INC_MismatchedUnicodeCharException_hpp__
+
+/* ANTLR Translator Generator
+ * Project led by Terence Parr at http://www.jGuru.com
+ * Software rights: http://www.antlr.org/license.html
+ *
+ * $Id:$
+ */
+
+#include <antlr/config.hpp>
+#include <antlr/RecognitionException.hpp>
+#include <antlr/BitSet.hpp>
+#include <antlr/String.hpp>
+
+class UnicodeCharScanner;
+
+class MismatchedUnicodeCharException : public antlr::RecognitionException {
+public:
+	typedef unsigned int char_type;
+	typedef enum {
+		CHAR = 1,
+		NOT_CHAR = 2,
+		RANGE = 3,
+		NOT_RANGE = 4,
+		SET = 5,
+		NOT_SET = 6
+	} MATCH_TYPE;
+
+	MismatchedUnicodeCharException();
+
+	// Expected range / not range
+	MismatchedUnicodeCharException(
+		char_type c,
+		char_type lower,
+		char_type up,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	// Expected char / not char
+	MismatchedUnicodeCharException(
+		char_type c,
+		char_type expect,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	// Expected BitSet / not BitSet
+	MismatchedUnicodeCharException(
+		char_type c,
+		antlr::BitSet s,
+		bool matchNot,
+		UnicodeCharScanner* cs
+	);
+
+	~MismatchedUnicodeCharException() throw();
+
+	/**
+	 * Returns a clean error message (no line number/column information)
+	 */
+	std::string getMessage() const;
+private:
+	// One of the above
+	MATCH_TYPE mismatchType;
+
+	// what was found on the input stream
+	char_type foundChar;
+
+	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
+	char_type expecting;
+
+	// For RANGE/NOT_RANGE (expecting is lower bound of range)
+	char_type upper;
+
+	// For SET/NOT_SET
+	antlr::BitSet set;
+	// who knows...they may want to ask scanner questions
+	UnicodeCharScanner* scanner;
+};
+
+#endif

Added: trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/UnicodeCharBuffer.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,83 @@
+#ifndef INC_UnicodeCharBuffer_hpp__
+#define INC_UnicodeCharBuffer_hpp__
+
+#include <istream>
+#include <cassert>
+#include <antlr/config.hpp>
+#include <antlr/InputBuffer.hpp>
+#include <antlr/CharStreamIOException.hpp>
+
+class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
+public:
+	typedef unsigned int char_type;	// should be 32 bits!
+
+	/// Create a character buffer
+	UnicodeCharBuffer(std::istream& inp)
+	: input(inp)
+	{
+		//	input.exceptions(std::ios_base::badbit|
+		//						  std::ios_base::failbit);
+	}
+	/// Get the next character from the stream
+	int getChar()
+	{
+		char_type ch = 0;
+		int inchar = input.get();
+		if( inchar == EOF )
+			return -1;
+
+// This is how UTF8 is encoded
+// +---------------------------+----------+----------+----------+----------+
+// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
+// +---------------------------+----------+----------+----------+----------+
+// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
+// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
+// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
+// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
+// +---------------------------+----------+----------+----------+----------+
+
+		if( (inchar & 0x80) == 0 )
+			return inchar;
+
+		unsigned int need = 0;
+		if( (inchar & 0xF8) == 0xF8 )
+		{
+			ch = inchar & 7;
+			need = 3;
+		}
+		else if( (inchar & 0xE0) == 0xE0 )
+		{
+			ch = inchar & 0xF;
+			need = 2;
+		}
+		else if( (inchar & 0xC0) == 0xC0 )
+		{
+			ch = inchar & 0x1F;
+			need = 1;
+		}
+		else
+		{
+			assert("Invalid UTF8");
+		}
+		while( need )
+		{
+			inchar = input.get();
+			if( inchar == EOF )
+				assert("Invalid UTF8");
+//				throw antlr::CharStreamIOException(std::logic_error());
+			ch <<= 6;
+			ch += inchar & 0x3F;
+			need--;
+		}
+		return ch;
+	}
+private:
+	// character source
+	std::istream& input;
+
+	// NOTE: Unimplemented
+	UnicodeCharBuffer(const UnicodeCharBuffer& other);
+	UnicodeCharBuffer& operator=(const UnicodeCharBuffer& other);
+};
+
+#endif //INC_UnicodeCharBuffer_hpp__

Added: trunk/gpt2/src/gptc/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/src/gptc/UnicodeCharScanner.hpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/UnicodeCharScanner.hpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,561 @@
+#ifndef INC_UnicodeCharScanner_hpp__
+#define INC_UnicodeCharScanner_hpp__
+
+#include <map>
+#include <cctype>
+
+#include <antlr/config.hpp>
+#include <antlr/CommonToken.hpp>
+#include <antlr/TokenStream.hpp>
+#include <antlr/RecognitionException.hpp>
+#include <antlr/SemanticException.hpp>
+#include <antlr/InputBuffer.hpp>
+#include <antlr/BitSet.hpp>
+#include <antlr/LexerSharedInputState.hpp>
+
+#include "MismatchedUnicodeCharException.hpp"
+
+/** Superclass of generated lexers
+ */
+class UnicodeCharScanner : public antlr::TokenStream {
+protected:
+	typedef antlr::RefToken (*factory_type)();
+public:
+	typedef int char_type;
+	typedef std::map<std::string,int> string_map;
+
+	UnicodeCharScanner( antlr::InputBuffer& cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(new antlr::LexerInputState(cb))
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+	UnicodeCharScanner( const antlr::LexerSharedInputState& state, bool case_sensitive )
+	: saveConsumedInput(true)
+	, caseSensitive(case_sensitive)
+	, literals()
+	, inputState(state)
+	, commitToPath(false)
+	, tabsize(8)
+	, traceDepth(0)
+	{
+		setTokenObjectFactory(&antlr::CommonToken::factory);
+	}
+
+	virtual ~UnicodeCharScanner()
+	{
+	}
+
+	virtual char_type LA(char_type i)
+	{
+		char_type c = inputState->getInput().LA(i);
+		return c;
+	}
+
+	virtual void append(char_type c)
+	{
+		if (saveConsumedInput)
+		{
+			size_t len = text.length();
+
+			if( (len % 256) == 0 )
+				text.reserve(len+256);
+
+// This is how UTF8 is encoded
+// +---------------------------+----------+----------+----------+----------+
+// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
+// +---------------------------+----------+----------+----------+----------+
+// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
+// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
+// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
+// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
+// +---------------------------+----------+----------+----------+----------+
+
+			if (c < 0x80)
+			{
+				text += c;
+				return;
+			}
+			else if (c < 0x800)
+			{
+				text += ( (c >> 6) | 0xC0 );
+				text += ( c & 0x3F | 0x80 );
+			}
+			else if (c < 0x10000)
+			{
+				text += ( (c >> 12) | 0xE0 );
+				text += ( ((c >> 6) & 0x3F) | 0x80 );
+				text += ( (c & 0x3F) | 0x80 );
+			}
+			else if (c < 0x200000)
+			{
+				text += ( (c >> 18) | 0xF0 );				// first 3 bits
+				text += ( (((c >> 16) & 0x3) << 4) |
+								 ((c >> 12) & 0xF) | 0x80 );
+				text += ( ((c >> 6) & 0x3F) | 0x80 );
+				text += ( (c & 0x3F) | 0x80 );
+			}
+			else
+				assert(0);
+		}
+	}
+
+	virtual void append(const std::string& s)
+	{
+		assert(0);
+		if (saveConsumedInput)
+			text+=s;
+	}
+
+	virtual void commit()
+	{
+		inputState->getInput().commit();
+	}
+
+	virtual void consume()
+	{
+		if (inputState->guessing == 0)
+		{
+			char_type c = LA(1);
+			append(c);
+			inputState->column++;
+		}
+		inputState->getInput().consume();
+	}
+
+	/** Consume chars until one matches the given char */
+	virtual void consumeUntil(char_type c)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast<char_type>(EOF_CHAR) == la_1 || la_1 == c )
+				break;
+			consume();
+		}
+	}
+
+	/** Consume chars until one matches the given set */
+	virtual void consumeUntil(const antlr::BitSet& set)
+	{
+		for(;;)
+		{
+			char_type la_1 = LA(1);
+			if( static_cast<char_type>(EOF_CHAR) == la_1 || set.member(la_1) )
+				break;
+			consume();
+		}
+	}
+
+	/// Mark the current position and return a id for it
+	virtual unsigned int mark()
+	{
+		return inputState->getInput().mark();
+	}
+
+	/// Rewind the scanner to a previously marked position
+	virtual void rewind(unsigned int pos)
+	{
+		inputState->getInput().rewind(pos);
+	}
+
+	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
+	virtual void match(char_type c)
+	{
+		char_type la_1 = LA(1);
+		if ( la_1 != c )
+			throw MismatchedUnicodeCharException(la_1, c, false, this);
+		consume();
+	}
+
+	/** See if input contains element from bitset b
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void match(const antlr::BitSet& b)
+	{
+		char_type la_1 = LA(1);
+
+		if ( !b.member(la_1) )
+			throw MismatchedUnicodeCharException( la_1, b, false, this );
+		consume();
+	}
+
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match( const char* s )
+	{
+		while( *s != '\0' )
+		{
+			// the & 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (*s++ & 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
+	 * @note the string cannot match EOF
+	 */
+	virtual void match(const std::string& s)
+	{
+		size_t len = s.length();
+
+		for (size_t i = 0; i < len; i++)
+		{
+			// the & 0xFF is here to prevent sign extension lateron
+			char_type la_1 = LA(1), c = (s[i] & 0xFF);
+
+			if ( la_1 != c )
+				throw MismatchedUnicodeCharException(la_1, c, false, this);
+
+			consume();
+		}
+	}
+	/** See if input does not contain character 'c'
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchNot(char_type c)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 == c )
+			throw MismatchedUnicodeCharException(la_1, c, true, this);
+
+		consume();
+	}
+	/** See if input contains character in range c1-c2
+	 * throw MismatchedUnicodeCharException if not
+	 */
+	virtual void matchRange(char_type c1, char_type c2)
+	{
+		char_type la_1 = LA(1);
+
+		if ( la_1 < c1 || la_1 > c2 )
+			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
+
+		consume();
+	}
+
+	/// Get the line the scanner currently is in (starts at 1)
+	virtual int getLine() const
+	{
+		return inputState->line;
+	}
+
+	/// set the line number
+	virtual void setLine(int l)
+	{
+		inputState->line = l;
+	}
+
+	/// Get the column the scanner currently is in (starts at 1)
+	virtual int getColumn() const
+	{
+		return inputState->column;
+	}
+	/// set the column number
+	virtual void setColumn(int c)
+	{
+		inputState->column = c;
+	}
+
+	/// get the filename for the file currently used
+	virtual const std::string& getFilename() const
+	{
+		return inputState->filename;
+	}
+	/// Set the filename the scanner is using (used in error messages)
+	virtual void setFilename(const std::string& f)
+	{
+		inputState->filename = f;
+	}
+
+	virtual bool getCommitToPath() const
+	{
+		return commitToPath;
+	}
+
+	virtual void setCommitToPath(bool commit)
+	{
+		commitToPath = commit;
+	}
+
+	/** return a copy of the current text buffer */
+	virtual const std::string& getText() const
+	{
+		return text;
+	}
+
+	virtual void setText(const std::string& s)
+	{
+		text = s;
+	}
+
+	virtual void resetText()
+	{
+		text = "";
+		inputState->tokenStartColumn = inputState->column;
+		inputState->tokenStartLine = inputState->line;
+	}
+
+	virtual antlr::RefToken getTokenObject() const
+	{
+		return _returnToken;
+	}
+
+	///{ These need different handling in unicode case
+
+	virtual bool getCaseSensitiveLiterals() const=0;
+
+	virtual bool getCaseSensitive() const
+	{
+		return caseSensitive;
+	}
+
+	virtual void setCaseSensitive(bool t)
+	{
+		caseSensitive = t;
+	}
+
+	/** Override this method to get more specific case handling
+	 * @note some platforms probably require setting the right locale for
+	 * correct functioning.
+	 */
+	virtual char_type toLower(char_type c) const
+	{
+		return std::tolower(c);
+	}
+
+	/** Used to keep track of line breaks, needs to be called from
+	 * within generated lexers when a \n \r is encountered.
+	 */
+	virtual void newline()
+	{
+		++inputState->line;
+		inputState->column = 1;
+	}
+
+	/** Advance the current column number by an appropriate amount according
+	 * to the tabsize. This method needs to be explicitly called from the
+	 * lexer rules encountering tabs.
+	 */
+	virtual void tab()
+	{
+		int c = getColumn();
+		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
+		setColumn( nc );
+	}
+	/// set the tabsize. Returns the old tabsize
+	int setTabsize( int size )
+	{
+		int oldsize = tabsize;
+		tabsize = size;
+		return oldsize;
+	}
+	/// Return the tabsize used by the scanner
+	int getTabSize() const
+	{
+		return tabsize;
+	}
+	///}
+
+	/** Report exception errors caught in nextToken() */
+	virtual void reportError(const antlr::RecognitionException& ex)
+	{
+		std::cerr << ex.toString().c_str() << std::endl;
+	}
+
+	/** Parser error-reporting function can be overridden in subclass */
+	virtual void reportError(const std::string& s)
+	{
+		if (getFilename() == "")
+			std::cerr << "error: " << s.c_str() << std::endl;
+		else
+			std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
+	}
+
+	/** Parser warning-reporting function can be overridden in subclass */
+	virtual void reportWarning(const std::string& s)
+	{
+		if (getFilename() == "")
+			std::cerr << "warning: " << s.c_str() << std::endl;
+		else
+			std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
+	}
+
+	virtual antlr::InputBuffer& getInputBuffer()
+	{
+		return inputState->getInput();
+	}
+
+	virtual antlr::LexerSharedInputState getInputState()
+	{
+		return inputState;
+	}
+
+	/** set the input state for the lexer.
+	 * @note state is a reference counted object, hence no reference */
+	virtual void setInputState(antlr::LexerSharedInputState state)
+	{
+		inputState = state;
+	}
+
+	/// Set the factory for created tokens
+	virtual void setTokenObjectFactory(factory_type factory)
+	{
+		tokenFactory = factory;
+	}
+
+	/** Test the token text against the literals table
+	 * Override this method to perform a different literals test
+	 */
+	virtual int testLiteralsTable(int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** Test the text passed in against the literals table
+	 * Override this method to perform a different literals test
+	 * This is used primarily when you want to test a portion of
+	 * a token
+	 */
+	virtual int testLiteralsTable(const std::string& text, int ttype) const
+	{
+		string_map::const_iterator i = literals.find(text);
+		if (i != literals.end())
+			ttype = (*i).second;
+		return ttype;
+	}
+
+	/** This method is called by YourLexer::nextToken() when the lexer has
+	 *  hit EOF condition.  EOF is NOT a character.
+	 *  This method is not called if EOF is reached during
+	 *  syntactic predicate evaluation or during evaluation
+	 *  of normal lexical rules, which presumably would be
+	 *  an IOException.  This traps the "normal" EOF condition.
+	 *
+	 *  uponEOF() is called after the complete evaluation of
+	 *  the previous token and only if your parser asks
+	 *  for another token beyond that last non-EOF token.
+	 *
+	 *  You might want to throw token or char stream exceptions
+	 *  like: "Heh, premature eof" or a retry stream exception
+	 *  ("I found the end of this file, go back to referencing file").
+	 */
+	virtual void uponEOF()
+	{
+	}
+
+	/// Methods used to change tracing behavior
+	void traceIndent()
+	{
+		for( int i = 0; i < traceDepth; i++ )
+			std::cout << " ";
+	}
+
+	void traceIn(const char* rname)
+	{
+		traceDepth++;
+		traceIndent();
+		std::cout << "> lexer " << rname
+			<< "; c==" << LA(1) << std::endl;
+	}
+
+	void traceOut(const char* rname)
+	{
+		traceIndent();
+		std::cout << "< lexer " << rname
+			<< "; c==" << LA(1) << std::endl;
+		traceDepth--;
+	}
+
+#ifndef NO_STATIC_CONSTS
+	static const int EOF_CHAR = EOF;
+#else
+	enum {
+		EOF_CHAR = EOF
+	};
+#endif
+protected:
+	std::string text; ///< Text of current token
+ 	/// flag indicating wether consume saves characters
+	bool saveConsumedInput;
+	factory_type tokenFactory;				///< Factory for tokens
+	bool caseSensitive; 						///< Is this lexer case sensitive
+	string_map literals;						 // set by subclass
+
+	antlr::RefToken _returnToken;		///< used to return tokens w/o using return val
+
+	/// Input state, gives access to input stream, shared among different lexers
+	antlr::LexerSharedInputState inputState;
+
+	/** Used during filter mode to indicate that path is desired.
+	 * A subsequent scan error will report an error as usual
+	 * if acceptPath=true;
+	 */
+	bool commitToPath;
+
+	unsigned int tabsize; 	///< tab size the scanner uses.
+
+	/// Create a new RefToken of type t
+	virtual antlr::RefToken makeToken(int t)
+	{
+		antlr::RefToken tok = tokenFactory();
+		// actually at this point you want to convert the stored lexeme text
+		// into the format you want to have it in in the backend...
+		tok->setType(t);
+		tok->setColumn(inputState->tokenStartColumn);
+		tok->setLine(inputState->tokenStartLine);
+		return tok;
+	}
+
+	/** Tracer class, used when -traceLexer is passed to antlr
+	 */
+	class Tracer {
+	private:
+		UnicodeCharScanner* parser;
+		const char* text;
+
+		Tracer(const Tracer& other); 					// undefined
+		Tracer& operator=(const Tracer& other); 	// undefined
+	public:
+		Tracer( UnicodeCharScanner* p, const char* t )
+		: parser(p), text(t)
+		{
+			parser->traceIn(text);
+		}
+		~Tracer()
+		{
+			parser->traceOut(text);
+		}
+	};
+
+	int traceDepth;
+private:
+	UnicodeCharScanner( const UnicodeCharScanner& other ); 		  		// undefined
+	UnicodeCharScanner& operator=( const UnicodeCharScanner& other );	// undefined
+};
+
+#endif //INC_UnicodeCharScanner_hpp__

Added: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,583 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+header {
+  #include <string>
+  #include <sstream>
+  #include <iostream>
+  #include <ctype.h>
+  #include "UnicodeCharBuffer.hpp"
+  #include "UnicodeCharScanner.hpp"
+}
+
+options {
+  language="Cpp";
+}
+
+class PortugolLexer extends Lexer("UnicodeCharScanner");
+
+options {
+  k=2;
+  genHashLines   = false;
+  exportVocab    = Portugol;
+  filter         = T_INVALIDO;
+  testLiterals   = false;
+}
+
+tokens {
+  T_KW_ALGORITMO="algoritmo";
+  T_KW_USE="use";
+  T_KW_VARIAVEL="vari?vel";
+  T_KW_VARIAVEIS="vari?veis";
+  T_KW_FIM_VARIAVEIS="fim-vari?veis";
+  T_KW_INTEIRO="inteiro";
+  T_KW_REAL="real";
+  T_KW_CARACTERE="caractere";
+  T_KW_LITERAL="literal";
+  T_KW_LOGICO="l?gico";
+  T_KW_CORINGA="coringa";
+  T_KW_MATRIZ="matriz";
+  T_KW_DO="do";
+  T_KW_TIPO="tipo";
+  T_KW_CONSTANTE="constante";
+  T_KW_CONSTANTES="constantes";
+  T_KW_FIM_CONSTANTES="fim-constantes";
+  T_KW_ESTRUTURA="estrutura";
+  T_KW_FIM_ESTRUTURA="fim-estrutura";
+  T_KW_FUNCAO="fun??o";
+  T_KW_PROCEDIMENTO="procedimento";
+  T_KW_REF="ref";
+  T_KW_INICIO="in?cio";
+  T_KW_FIM="fim";
+  T_KW_SAIR="sair";
+  T_KW_RETORNE="retorne";
+  T_KW_SE="se";
+  T_KW_ENTAO="ent?o";
+  T_KW_SENAO="sen?o";
+  T_KW_FIM_SE="fim-se";
+  T_KW_ENQUANTO="enquanto";
+  T_KW_FACA="fa?a";
+  T_KW_FIM_ENQUANTO="fim-enquanto";
+  T_KW_PARA="para";
+  T_KW_DE="de";
+  T_KW_ATE="at?";
+  T_KW_FIM_PARA="fim-para";
+  T_KW_PASSO="passo";
+  T_KW_REPITA="repita";
+  T_KW_CASO="caso";
+  T_KW_SEJA="seja";
+  T_KW_FIM_SENAO="fim-sen?o";
+  T_KW_FIM_CASO="fim-caso";
+  T_KW_FIM_FACA="fim-fa?a";
+  T_KW_OU="ou";
+  T_KW_E="e";
+  T_KW_NAO="n?o";
+  T_KW_VERDADEIRO="verdadeiro";
+  T_KW_FALSO="falso";
+  T_KW_ASM="asm";
+  T_KW_FIMASM="fim-asm";
+
+  T_REAL_LITERAL="n?mero real"; //a regra T_INTEIRO_LITERAL lida com reais
+
+
+  //imagin?rios para a AST
+
+  TI_VALOR;
+  TI_VMATRIZ;    //valor da matriz    (literal [])
+  TI_VESTRUTURA; //valor da estrutura (literal {})
+
+  TI_MATRIZ;
+  TI_DIMENSOES;
+  TI_NULL;
+
+  TI_UN_POSITIVO;
+  TI_UN_NEGATIVO;
+  TI_UN_NEGACAO;
+  TI_UN_NEGACAOB;
+  TI_PARENTESIS;
+
+  TI_CALL;
+}
+
+
+{
+public:
+  PortugolLexer(std::istream& in, bool case_s)
+   : UnicodeCharScanner(new UnicodeCharBuffer(in), case_s)
+    {
+      initLiterals();
+    }
+
+private:
+
+  std::string toBase10(const std::string& oct, int from) {
+    std::stringstream stream;
+    unsigned long long base10;
+    base10 = strtoull(oct.c_str(), NULL, from);
+    stream << base10;
+    return stream.str();
+  }
+
+  bool isOctal(const std::string& num) {
+    std::stringstream s;
+    if ((num.find("8",0)  != std::string::npos) ||
+        (num.find("9",0)  != std::string::npos)) {
+      return false;
+    } else {
+      for (unsigned int i = 2; i < num.length(); ++i) {
+        if (!isdigit(num[i])) {
+          return false;
+        }
+      }
+    }
+    return true;
+  }
+
+  bool isHex(const std::string& num) {
+    for (unsigned int i = 2; i < num.length(); ++i) {
+      if (!isxdigit(num[i])) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  bool isBin(const std::string& num) {
+    for(unsigned int i = 2; i < num.length(); ++i) {
+      if ((num[i] != '0') && (num[i] != '1')) {
+        return false;
+      }
+    }
+    return true;
+  }
+}
+
+
+//####################################
+//##             Regras             ##
+//####################################
+
+
+
+T_ESPACO :
+  (   ' '
+    | '\t'
+    | '\n' { newline(); }
+    | '\r'
+  )
+  { $setType(antlr::Token::SKIP); }
+  ;
+
+COMENTARIO_CPP
+  : "//" (~('\n'))* ('\n')?
+    {
+      newline();
+      $setType(antlr::Token::SKIP);
+    }
+  ;
+
+COMENTARIO_C
+{int line = getLine();}
+  : "/*"
+    (
+      options { generateAmbigWarnings=false; } :
+        '\n'                     {newline();}
+      | ('\r' '\n')=> '\r' '\n'  {newline();}
+      | '\r'                     {newline();}
+      |~('*'|'\n'|'\r')
+      | ('*' ~'/' )=> '*'
+    )*
+    "*/"
+    {$setType(antlr::Token::SKIP);}
+  ;
+exception
+catch[antlr::RecognitionException] {
+  std::stringstream s;
+  //aviso! n?o ? erro!
+  s << "coment?rio iniciado na linha " << line << " n?o termina com \"*/\".";
+  std::cerr << s.str() << ", na linha " << getLine() << std::endl;
+  $setType(antlr::Token::SKIP);
+}
+
+T_PONTO_VIRGULA
+options {
+  paraphrase = "';'";
+}
+  : ';'
+  ;
+
+T_VIRGULA
+options {
+  paraphrase = "','";
+}
+  : ','
+  ;
+
+T_2_PONTOS
+options {
+  paraphrase = "':'";
+}
+
+  : ':'
+  ;
+
+T_ABRE_CHAVE
+options {
+  paraphrase = "'['";
+}
+  : '['
+  ;
+
+T_FECHA_CHAVE
+options {
+  paraphrase = "']'";
+}
+  : ']'
+  ;
+
+T_ABRE_COLCHETE
+options {
+  paraphrase = "'{'";
+}
+  : '{'
+  ;
+
+T_FECHA_COLCHETE
+options {
+  paraphrase = "'}'";
+}
+  : '}'
+  ;
+
+T_ABRE_PAREN
+options {
+  paraphrase = "'('";
+}
+  : '('
+  ;
+T_FECHA_PAREN
+options {
+  paraphrase = "')'";
+}
+  : ')'
+  ;
+
+T_ATRIBUICAO
+options {
+  paraphrase = "':='";
+}
+  : ":="
+  ;
+
+T_BIT_OU
+options {
+  paraphrase = "operador '|'";
+}
+  : '|'
+  ;
+
+T_BIT_OUX
+options {
+  paraphrase = "operador '^'";
+}
+  : '^'
+  ;
+
+T_BIT_E
+options {
+  paraphrase = "operador '&'";
+}
+  : '&'
+  ;
+
+T_BIT_NAO
+options {
+  paraphrase = "operador '~'";
+}
+  : '~'
+  ;
+
+
+T_IGUAL
+options {
+  paraphrase = "operador '='";
+}
+  : '='
+  ;
+
+T_DIFERENTE
+options {
+  paraphrase = "operador '<>'";
+}
+  : "<>"
+  ;
+
+T_MAIOR
+options {
+  paraphrase = "operador '>'";
+}
+  : '>'
+  ;
+
+T_MAIOR_EQ
+options {
+  paraphrase = "operador '>='";
+}
+  : ">="
+  ;
+
+T_MENOR
+options {
+  paraphrase = "operador '<'";
+}
+  : '<'
+  ;
+T_MENOR_EQ
+options {
+  paraphrase = "operador '<='";
+}
+  : "<="
+  ;
+
+T_MAIS
+options {
+  paraphrase = "operador '+'";
+}
+  : '+'
+  ;
+
+T_MENOS
+options {
+  paraphrase = "operador '-'";
+}
+  : '-'
+  ;
+
+T_DIV
+options {
+  paraphrase = "operador '/'";
+}
+  : '/'
+  ;
+
+T_MULTIP
+options {
+  paraphrase = "operador '*'";
+}
+  : '*'
+  ;
+
+T_MOD
+options {
+  paraphrase = "operador '%'";
+}
+  : '%'
+  ;
+
+/* Literais */
+
+
+T_INTEIRO_LITERAL
+options {
+  paraphrase = "n?mero inteiro";
+}
+  : ('0' ('c'|'C') )=> T_OCTAL_LIT
+  | ('0' ('x'|'X') )=> T_HEX_LIT
+  | ('0' ('b'|'B') )=> T_BIN_LIT
+  | (T_DIGITO)+
+    (
+      '.' (T_DIGITO)+
+      {$setType(T_REAL_LITERAL);}
+    )?
+  ;
+
+T_TEXTO_LITERAL
+options {
+  paraphrase = "literal";
+}
+  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | T_ESCAPE )* '"'!
+  ;
+
+
+T_CARACTERE_LITERAL
+options {
+  paraphrase = "caractere";
+}
+  : '\''! ( ~( '\'' | '\\' ) | T_ESCAPE )? '\''!
+  ;
+
+
+
+/*
+  Ok, um pouco de malabarismo...
+
+  Eis o problema:
+
+  N?s precisamos que uma string como "fim-vari?veis" seja
+  identificada pelo scanner. Para isso, as keywords em tokens{} devem
+  ser cobertos pelas regras T_*. No caso, T_IDENTIFICADOR
+  costuma ser a regra que identifica keywords.
+
+  Por?m, "fim-vari?veis" n?o ? um identificador v?lido
+  (ambig. com "fim - vari?veis").
+
+  Ent?o, T_IDENTIFICADOR aqui representa a regra mais geral poss?vel,
+  para cobrir as keywords em tokens{}. Mas, para o caso problem?tico
+  de T_IDENTIFICADOres com "-", verificamos se o lexema atual
+  ? uma keyword ou um identificador seguido de T_MENOS, utilizando
+  "testLiteralsTable" manualmente.
+
+  Se testLiteralsTable indicar que o lexema atual com hifen for uma keyword,
+  ? a pr?pria, obviamente.
+
+  Se n?o, trata-se de um ID seguido de T_MENOS. Ent?o, fazemos o rollback
+  at? o ponto do hifen.
+*/
+
+T_IDENTIFICADOR
+options {
+  testLiterals = true;
+}
+  { int m = -1,len; }
+
+  : T_ID_AUX
+      {
+        len = $getText.length();
+        if (LA(1) == '-') {
+          m = mark();
+        }
+      }
+
+    ('-' (T_LETRA_OU_DIGITO)*)?
+  {
+    if ((m != -1) && (testLiteralsTable(_ttype) == T_IDENTIFICADOR)) {
+      rewind(m);
+      std::string s = $getText;
+      $setText(s.substr(0,len));
+    }
+  }
+  ;
+
+
+
+//####################################
+//##            Protecteds          ##
+//####################################
+
+
+protected
+T_ESCAPE
+  : '\\' .  /* ex. \a */
+  ;
+
+protected
+T_DIGITO
+  : '0'..'9'
+  ;
+
+protected
+T_LETRA
+  : 'a'..'z'|'A'..'Z' | '\u00C0' .. '\u00FF' /* latim-1 */
+  ;
+
+
+protected
+T_LETRA_OU_DIGITO
+  : T_LETRA | T_DIGITO | '_'
+  ;
+
+
+//mais detalhes em T_IDENTIFICADOR
+protected
+T_ID_AUX
+  : (T_LETRA | '_') (T_LETRA_OU_DIGITO)*
+  ;
+
+protected
+T_OCTAL_LIT
+  : '0' ('c'|'C') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isOctal(str)) {
+      $setText(toBase10(str.substr(2), 8));
+    } else {
+      std::stringstream s;
+      s << "\"" << str << "\" n?o ? um n?mero octal v?lido";
+      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
+    }
+  }
+  ;
+
+protected
+T_HEX_LIT
+  : '0' ('x'|'X') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isHex(str)) {
+      $setText(toBase10(str, 16));
+    } else {
+      std::stringstream s;
+      s << "\"" << str << "\" n?o ? um n?mero hexadecimal v?lido";
+      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
+    }
+  }
+  ;
+
+protected
+T_BIN_LIT
+  : '0' ('b'|'B') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
+                                        //apenas para exibir
+                                        //erro precisamente
+  {
+    std::string str = $getText;
+    if (isBin(str)) {
+      $setText(toBase10(str.substr(2), 2));
+    } else {
+      std::stringstream s;
+      s << "\"" << str << "\" n?o ? um n?mero bin?rio v?lido";
+      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
+    }
+  }
+  ;
+
+protected
+T_INVALIDO
+  : .
+    {
+      //caracteres de espa?o inexistentes na tabela ascii
+      //([160] == [-96] == ' ' == [32] == 160-128)
+      if ($getText.c_str()[0] == (int)0xffffffa0) {
+        $setType(antlr::Token::SKIP);
+      } else {
+        std::stringstream s;
+        if (($getText != "\"") && ($getText != "'")) {
+          s << "Caractere inv?lido: \"" << $getText << "\".\n";
+          s << "Verifique se a codifica??o do texto est? em UTF-8";
+        } else {
+          s << "Faltando fechar aspas";
+        }
+        std::cerr << s.str() << ", na linha " << getLine() << std::endl;
+      }
+    }
+  ;

Added: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,477 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+options {
+  language="Cpp";
+}
+
+class PortugolParser extends Parser;
+options {
+  importVocab  = Portugol;
+  genHashLines = false;
+  buildAST     = true;
+}
+
+{
+private:
+  void createRootNode(antlr::ASTPair& ast, antlr::RefToken token) {
+    astFactory->makeASTRoot(ast, astFactory->create(token));
+  }
+
+  void createRootNode(antlr::ASTPair& ast, int token) {
+    astFactory->makeASTRoot(ast, astFactory->create(token));
+  }
+
+  void addChildNode(antlr::ASTPair& ast, antlr::RefToken token) {
+    astFactory->addASTChild(ast, astFactory->create(token));
+  }
+
+  void addChildNode(antlr::ASTPair& ast, antlr::RefAST child) {
+    astFactory->addASTChild(ast, child);
+  }
+
+  antlr::RefAST createNode(int type, const std::string& txt) {
+    return astFactory->create(type, txt);
+  }
+}
+
+
+
+//####################################
+//##             In?cio             ##
+//####################################
+
+programa
+  : (declaracao_algoritmo)?
+
+    (importacao)*
+
+    (   declaracao_variaveis
+      | declaracao_constantes
+      | bloco_declaracao_estrutura
+    )*
+
+    corpo
+
+    EOF
+  ;
+
+declaracao_algoritmo!
+  : T_KW_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
+  ;
+
+importacao
+  : T_KW_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
+  ;
+
+corpo
+  :  (declaracao_subrotina)*
+      bloco_codigo
+     (declaracao_subrotina)*
+  ;
+
+
+
+//####################################
+//##    Declara??o de Vari?veis     ##
+//####################################
+
+declaracao_variaveis
+  : bloco_declaracao_variaveis
+  | T_KW_VARIAVEL! declaracao_variavel_uniq
+  ;
+
+bloco_declaracao_variaveis
+  : T_KW_VARIAVEIS^ (declaracao_variavel)+ T_KW_FIM_VARIAVEIS!
+  ;
+
+declaracao_variavel!
+  : ids:lista_identificadores   T_2_PONTOS
+    t:tipo (l:lista_inicializacao)? T_PONTO_VIRGULA
+
+            {
+              if (l_AST == antlr::nullAST) {
+                #declaracao_variavel =
+                    #([T_KW_VARIAVEL,"&var"], t,ids);
+              } else {
+                #declaracao_variavel =
+                    #([T_KW_VARIAVEL,"&var"], t,ids,([TI_VALOR,"&valor"],l));
+              }
+            }
+  ;
+
+lista_identificadores
+  : T_IDENTIFICADOR (T_VIRGULA! T_IDENTIFICADOR)*
+  ;
+
+declaracao_variavel_uniq!
+  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    (l:lista_inicializacao)? T_PONTO_VIRGULA
+
+            {
+              if (l_AST == antlr::nullAST) {
+                #declaracao_variavel_uniq=
+                    #([T_KW_VARIAVEL,"&var"], t,id);
+              } else {
+                #declaracao_variavel_uniq =
+                    #([T_KW_VARIAVEL,"&var"], t,id,([TI_VALOR,"&valor"],l));
+              }
+            }
+  ;
+
+tipo
+  : tipo_primitivo
+  | tipo_matriz
+  | T_IDENTIFICADOR
+  ;
+
+lista_inicializacao
+  : T_ATRIBUICAO! (expressao | inicializacao_composta)
+  ;
+
+inicializacao_composta!
+  : T_ABRE_CHAVE!
+      idx:inicializacao_indices
+    T_FECHA_CHAVE!
+
+                 {#inicializacao_composta = #([TI_VMATRIZ, "&vmatriz"],idx);}
+
+  | T_ABRE_COLCHETE!
+      mem:inicializacao_membros
+    T_FECHA_COLCHETE!
+
+                 {#inicializacao_composta = #([TI_VESTRUTURA, "&vestr"],mem);}
+  ;
+
+inicializacao_indices
+  : (expressao | inicializacao_composta) (T_VIRGULA! inicializacao_indices)?
+  ;
+
+inicializacao_membros
+  : T_IDENTIFICADOR T_ATRIBUICAO! (expressao | inicializacao_composta)
+    (T_VIRGULA! inicializacao_membros)?
+  ;
+
+tipo_primitivo
+  : T_KW_INTEIRO
+  | T_KW_REAL
+  | T_KW_CARACTERE
+  | T_KW_LITERAL
+  | T_KW_LOGICO
+  | T_KW_CORINGA
+  ;
+
+tipo_matriz!
+  : T_KW_MATRIZ dim:matriz_dimensoes
+    T_KW_DO T_KW_TIPO t:matriz_tipo
+
+    {#tipo_matriz = #([TI_MATRIZ, "&matriz"], t,dim);}
+  ;
+
+matriz_dimensoes
+  : ( T_ABRE_CHAVE!
+      ( T_INTEIRO_LITERAL
+        | /*vazio*/  {addChildNode(currentAST, createNode(TI_NULL,"&null"));}
+      )
+      T_FECHA_CHAVE!
+    )+
+  ;
+
+matriz_tipo
+  : tipo_primitivo | T_IDENTIFICADOR
+  ;
+
+
+
+//####################################
+//##    Declara??o de Constantes    ##
+//####################################
+
+
+declaracao_constantes
+  : bloco_declaracao_constantes
+  | T_KW_CONSTANTE! declaracao_constante
+  ;
+
+bloco_declaracao_constantes
+  : T_KW_CONSTANTES^ (declaracao_constante)+ T_KW_FIM_CONSTANTES!
+  ;
+
+declaracao_constante!
+  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    l:lista_inicializacao T_PONTO_VIRGULA
+
+               {#declaracao_constante = #([T_KW_CONSTANTE,"&const"], t,id,l);}
+  ;
+
+
+
+
+//####################################
+//##    Declara??o de Estruturas    ##
+//####################################
+
+
+bloco_declaracao_estrutura
+  : T_KW_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_KW_FIM_ESTRUTURA!
+  ;
+
+
+
+
+//####################################
+//##    Declara??o de Subrotinas    ##
+//####################################
+
+declaracao_subrotina
+  : declaracao_funcao
+  | declaracao_procedimento
+  ;
+
+declaracao_funcao
+  : T_KW_FUNCAO^ T_IDENTIFICADOR
+      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo
+    (declaracao_constantes | declaracao_variaveis)*
+    bloco_codigo
+  ;
+
+declaracao_procedimento
+  : T_KW_PROCEDIMENTO^ T_IDENTIFICADOR
+      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
+    (declaracao_constantes | declaracao_variaveis)*
+    bloco_codigo
+  ;
+
+lista_parametros
+  : parametro (T_VIRGULA! parametro)*
+  ;
+
+parametro!
+  : ((c:T_KW_CONSTANTE)? r:T_KW_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+    {#parametro = #([T_KW_VARIAVEL,"&param"],t,id,c,r);}
+  ;
+
+
+
+//####################################
+//##         Bloco de c?digo        ##
+//####################################
+
+bloco_codigo
+  : T_KW_INICIO^ lista_enunciados T_KW_FIM!
+  ;
+
+lista_enunciados
+  : (enunciado)*
+  ;
+
+enunciado
+  : (lvalue T_ATRIBUICAO)=> en_atribuicao
+  | en_retorne
+  | en_se
+  | en_enquanto
+  | en_repita
+  | en_para
+  | en_caso
+
+  | en_asm
+
+  | T_KW_SAIR^ T_PONTO_VIRGULA!
+  | T_PONTO_VIRGULA!
+
+//  TODO: retirar da gramatica ou resolver a ambiguidade
+//        se esta producao vingar, retirar enunciado::chamada_subrotina
+//   | expressao  T_PONTO_VIRGULA!
+
+  | chamada_subrotina T_PONTO_VIRGULA!
+  ;
+
+en_atribuicao
+  : lvalue T_ATRIBUICAO^ expressao T_PONTO_VIRGULA!
+  ;
+
+
+en_retorne
+  : T_KW_RETORNE^ (expressao)? T_PONTO_VIRGULA!
+  ;
+
+lvalue
+  : T_IDENTIFICADOR^ matriz_indices
+  ;
+
+matriz_indices
+  : ( T_ABRE_CHAVE!
+      expressao
+      T_FECHA_CHAVE!
+    )*
+  ;
+
+en_se
+  : T_KW_SE^ expressao T_KW_ENTAO!
+      lista_enunciados (T_KW_SENAO! lista_enunciados)? T_KW_FIM_SE!
+  ;
+
+en_enquanto
+  : T_KW_ENQUANTO^ expressao T_KW_FACA! lista_enunciados T_KW_FIM_ENQUANTO!
+  ;
+
+en_para
+  : T_KW_PARA^ lvalue T_KW_DE! expressao
+    T_KW_ATE! expressao (passo)? T_KW_FACA!
+      lista_enunciados T_KW_FIM_PARA!
+  ;
+
+passo
+  : T_KW_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
+  ;
+
+en_repita
+  : T_KW_REPITA^ lista_enunciados T_KW_ATE expressao
+  ;
+
+en_caso
+  : T_KW_CASO^ expressao
+      T_KW_SEJA! (teste_caso)+
+      (caso_senao)? T_KW_FIM_CASO!
+  ;
+
+teste_caso!
+  : l:literal T_KW_FACA! en:lista_enunciados T_KW_FIM_FACA!
+
+                                {#teste_caso = #(l, en);}
+  ;
+
+caso_senao
+  : T_KW_SENAO^ lista_enunciados T_KW_FIM_SENAO!
+  ;
+
+
+//TODO: codigo ilustrativo.
+en_asm!
+  : T_KW_ASM (~(T_KW_FIMASM))* T_KW_FIMASM
+  ;
+
+
+//####################################
+//##            Express?es          ##
+//####################################
+
+expressao
+  : expr_e (T_KW_OU^ expr_e)*
+  ;
+
+expr_e
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_ou (T_KW_E^ expr_bit_ou)*
+  ;
+
+expr_bit_ou
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
+  ;
+
+expr_bit_oux
+options {
+  defaultErrorHandler=false;
+}
+  : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
+  ;
+
+expr_bit_e
+options {
+  defaultErrorHandler=false;
+}
+  : expr_igual (T_BIT_E^ expr_igual)*
+  ;
+
+expr_igual
+options {
+  defaultErrorHandler=false;
+}
+  : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
+  ;
+
+expr_relacional
+options {
+  defaultErrorHandler=false;
+}
+  : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
+  ;
+
+expr_ad
+options {
+  defaultErrorHandler=false;
+}
+  : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
+  ;
+
+expr_multip
+options {
+  defaultErrorHandler=false;
+}
+  : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
+  ;
+
+expr_unario
+options {
+  defaultErrorHandler=false;
+}
+  : op_unario expr_elemento
+  ;
+
+op_unario!
+  : ( T_MENOS   {#op_unario = #[TI_UN_NEGATIVO,"&negat"];}
+    | T_MAIS    {#op_unario = #[TI_UN_POSITIVO,"&pos"];}
+    | T_KW_NAO  {#op_unario = #[TI_UN_NEGACAO ,"nega?"];}
+    | T_BIT_NAO {#op_unario = #[TI_UN_NEGACAOB,"&negb"];}
+    )?
+  ;
+
+expr_elemento
+  :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
+  |  lvalue
+  |  literal
+  |! T_ABRE_PAREN e:expressao T_FECHA_PAREN
+     {#expr_elemento = #([TI_PARENTESIS,"&paren"], e);}
+  ;
+
+
+chamada_subrotina!
+  : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
+
+    {#chamada_subrotina = #([TI_CALL,"&call"], id, args);}
+  ;
+
+lista_argumentos
+  : expressao (T_VIRGULA! expressao)*
+  ;
+
+literal
+  : T_TEXTO_LITERAL
+  | T_INTEIRO_LITERAL
+  | T_REAL_LITERAL
+  | T_CARACTERE_LITERAL
+  | T_KW_VERDADEIRO
+  | T_KW_FALSO
+  ;

Added: trunk/gpt2/src/gptc/teste.cpp
===================================================================
--- trunk/gpt2/src/gptc/teste.cpp	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/teste.cpp	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,64 @@
+#include <stdio.h>
+#include "PortugolLexer.hpp"
+#include "PortugolParser.hpp"
+#include "PortugolTokenTypes.hpp"
+#include <antlr/TokenBuffer.hpp>
+#include <antlr/CommonAST.hpp>
+
+#include <fstream>
+
+void dump_tokens(char* fname) {
+  char *table[200];
+  #include "table.hpp"
+  std::ifstream fi(fname);
+  PortugolLexer lexer(fi, true);
+  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
+
+  while (true) {
+    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
+              << table[buffer->LA(1)] << " (" << lexer.getText() << ")";
+    buffer->consume();
+    getchar();
+
+    if (buffer->LA(1) == PortugolTokenTypes::EOF_) {
+      break;
+    }
+  }
+}
+
+void dump_tree(char* fname) {
+
+  std::ifstream fi(fname);
+  PortugolLexer lexer(fi, true);
+  PortugolParser parser(lexer);
+
+  antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,&antlr::CommonAST::factory);
+  parser.initializeASTFactory(ast_factory);
+  parser.setASTFactory(&ast_factory);
+
+  parser.programa();
+
+  antlr::RefCommonAST ast = antlr::RefCommonAST(parser.getAST());
+
+  if (ast) {
+    std::cerr << ast->toStringList() << std::endl << std::endl;
+  } else {
+    std::cerr << ": no parse tree" << std::endl;
+  }
+}
+
+int main(int argc, char** argv) {
+
+  if (argc < 3) {
+    std::cerr << "./test [lp] <file.gpt>" << std::endl;
+    return 0;
+  }
+
+  if (*argv[1] == 't') {
+    dump_tree(argv[2]);
+  } else {
+    dump_tokens(argv[2]);
+  }
+
+  return 0;
+}

Added: trunk/gpt2/src/gptc/testes/lex_teste.gpt
===================================================================
--- trunk/gpt2/src/gptc/testes/lex_teste.gpt	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/testes/lex_teste.gpt	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,110 @@
+algoritmo
+use
+vari?vel
+vari?veis
+fim-vari?veis
+inteiro
+real
+caractere
+literal
+l?gico
+coringa
+matriz
+do
+tipo
+constante
+constantes
+fim-constantes
+estrutura
+fim-estrutura
+fun??o
+procedimento
+ref
+in?cio
+fim
+sair
+retorne
+se
+ent?o
+sen?o
+fim-se
+enquanto
+fa?a
+fim-enquanto
+para
+de
+at?
+fim-para
+passo
+repita
+caso
+seja
+fim-sen?o
+fim-caso
+fim-fa?a
+ou
+e
+n?o
+verdadeiro
+falso
+asm
+fim-asm
+
+//comentario CPP
+
+/* comment
+  ario C */
+
+;
+,
+:
+[
+]
+{
+}
+(
+)
+:=
+|
+^
+&
+=
+<>
+>
+>=
+<
+<=
++
+-
+/
+*
+%
+~
+
+123
+-2
+1.023
+
+0c123
+0C123
+0c987
+0X1AB
+0x1ab
+0xTT
+0b10101
+0B10101
+0b2
+
+"oi
+"ol? \nbla"
+""
+
+'o'
+''
+'?'
+'\b'
+'\\'
+
+teste
+_oum
+p?

Added: trunk/gpt2/src/gptc/testes/tree_teste.gpt
===================================================================
--- trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-08 05:58:29 UTC (rev 338)
+++ trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-08 07:43:09 UTC (rev 339)
@@ -0,0 +1,106 @@
+// algoritmo teste;
+
+// use "bib1";
+// use "bib2";
+// use "bib3";
+// use "bib4";
+
+// vari?veis
+//   p : T;
+//   a,b : real;
+//   c : inteiro := 10;
+//   j : matriz[] do tipo inteiro := [1,2,3];
+//   es,e2 : T := {nome:="foo",id:=6};
+//   e4    : matriz[] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3}];
+// fim-vari?veis
+
+
+// vari?vel q : T;
+// vari?vel j : K := "oi";
+// vari?vel m : matriz[] do tipo I := [9,8,7];
+// vari?vel z : T := {i:=10, j:=20};
+// vari?vel e4    : matriz[10][20] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3}];
+
+// constantes
+//   z  : inteiro := 3;
+//   j  : matriz[] do tipo inteiro := [1,2,3];
+//   es : T := {nome:="foo",id:=6};
+//   e4 : matriz[] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3},{k:=[9,8,7]}];
+// fim-constantes
+//
+// constante x : inteiro := {z := [1,2,3]};
+
+// estrutura T
+//   z   : inteiro := 1;
+//   j,z : kkk;
+// fim-estrutura
+
+in?cio
+//   x := 10;
+//   z[1] := 9;
+//   z[0][0] := n?o(~1 + -2 * +3);
+
+//   se x > 2 ent?o
+//     x := 2;
+//   fim-se
+//
+//   se z = "oi" ent?o
+//     z := 1;
+//   sen?o
+//     z := 2;
+//   fim-se
+
+// enquanto x > 2 fa?a
+//   x := 2;
+// fim-enquanto
+
+// repita
+//   x := 2;
+//   k := 3;
+// at? x > 3
+
+// para x de 1+2 at? 10+100 fa?a
+//   x := 3;
+// fim-para
+
+// para x[y] de 0 at? 100 passo -1 fa?a
+//   x := 3;
+// fim-para
+
+// caso x seja
+//   "oi" fa?a
+//     x := 1;
+//     z := 2;
+//   fim-fa?a
+//
+//   10 fa?a
+//     x:=3;
+//     sair;
+//   fim-fa?a
+//
+//   sen?o
+//     x:= 10;
+//   fim-sen?o
+// fim-caso
+//
+//   retorne 10+10;
+
+  f(10, 1+2, g());
+
+//   "se" x > 10
+/*  asm
+    ola  as "sss" 1 se ent?o
+    adasd "fim-asm"
+  fim-asm*/
+fim
+
+
+// fun??o f(a:I,k:matriz[1][2] do tipo I) : T
+// in?cio
+//   x := 2;
+// fim
+
+// procedimento p(a:I,k:matriz[1][2] do tipo I)
+// in?cio
+//   z := 2;
+// fim



From gpt-commit-noreply at mail.berlios.de  Thu Nov  8 09:02:03 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 8 Nov 2007 09:02:03 +0100
Subject: [gpt-commit] r340 - trunk/gpt2/src/gptc
Message-ID: <200711080802.lA8823vE015628@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-08 09:02:03 +0100 (Thu, 08 Nov 2007)
New Revision: 340

Modified:
   trunk/gpt2/src/gptc/parser.g
Log:
DEVNULL:
-Identacao das actions

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-08 07:43:09 UTC (rev 339)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-08 08:02:03 UTC (rev 340)
@@ -182,7 +182,7 @@
   : T_KW_MATRIZ dim:matriz_dimensoes
     T_KW_DO T_KW_TIPO t:matriz_tipo
 
-    {#tipo_matriz = #([TI_MATRIZ, "&matriz"], t,dim);}
+                    {#tipo_matriz = #([TI_MATRIZ, "&matriz"], t,dim);}
   ;
 
 matriz_dimensoes
@@ -265,7 +265,8 @@
 
 parametro!
   : ((c:T_KW_CONSTANTE)? r:T_KW_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    {#parametro = #([T_KW_VARIAVEL,"&param"],t,id,c,r);}
+
+                        {#parametro = #([T_KW_VARIAVEL,"&param"],t,id,c,r);}
   ;
 
 
@@ -452,15 +453,15 @@
   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
   |  lvalue
   |  literal
-  |! T_ABRE_PAREN e:expressao T_FECHA_PAREN
-     {#expr_elemento = #([TI_PARENTESIS,"&paren"], e);}
+  |! T_ABRE_PAREN e:expressao T_FECHA_PAREN {#expr_elemento =
+                                              #([TI_PARENTESIS,"&paren"], e);}
   ;
 
 
 chamada_subrotina!
   : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
 
-    {#chamada_subrotina = #([TI_CALL,"&call"], id, args);}
+                        {#chamada_subrotina = #([TI_CALL,"&call"], id, args);}
   ;
 
 lista_argumentos



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 03:10:07 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 03:10:07 +0100
Subject: [gpt-commit] r341 - trunk/gpt2/src/gptc
Message-ID: <200711090210.lA92A735024619@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 03:10:06 +0100 (Fri, 09 Nov 2007)
New Revision: 341

Modified:
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
Log:
-Mudanca nos nomes dos tokens / remocao do prefixo KW

Modified: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-08 08:02:03 UTC (rev 340)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-09 02:10:06 UTC (rev 341)
@@ -42,78 +42,74 @@
 }
 
 tokens {
-  T_KW_ALGORITMO="algoritmo";
-  T_KW_USE="use";
-  T_KW_VARIAVEL="vari?vel";
-  T_KW_VARIAVEIS="vari?veis";
-  T_KW_FIM_VARIAVEIS="fim-vari?veis";
-  T_KW_INTEIRO="inteiro";
-  T_KW_REAL="real";
-  T_KW_CARACTERE="caractere";
-  T_KW_LITERAL="literal";
-  T_KW_LOGICO="l?gico";
-  T_KW_CORINGA="coringa";
-  T_KW_MATRIZ="matriz";
-  T_KW_DO="do";
-  T_KW_TIPO="tipo";
-  T_KW_CONSTANTE="constante";
-  T_KW_CONSTANTES="constantes";
-  T_KW_FIM_CONSTANTES="fim-constantes";
-  T_KW_ESTRUTURA="estrutura";
-  T_KW_FIM_ESTRUTURA="fim-estrutura";
-  T_KW_FUNCAO="fun??o";
-  T_KW_PROCEDIMENTO="procedimento";
-  T_KW_REF="ref";
-  T_KW_INICIO="in?cio";
-  T_KW_FIM="fim";
-  T_KW_SAIR="sair";
-  T_KW_RETORNE="retorne";
-  T_KW_SE="se";
-  T_KW_ENTAO="ent?o";
-  T_KW_SENAO="sen?o";
-  T_KW_FIM_SE="fim-se";
-  T_KW_ENQUANTO="enquanto";
-  T_KW_FACA="fa?a";
-  T_KW_FIM_ENQUANTO="fim-enquanto";
-  T_KW_PARA="para";
-  T_KW_DE="de";
-  T_KW_ATE="at?";
-  T_KW_FIM_PARA="fim-para";
-  T_KW_PASSO="passo";
-  T_KW_REPITA="repita";
-  T_KW_CASO="caso";
-  T_KW_SEJA="seja";
-  T_KW_FIM_SENAO="fim-sen?o";
-  T_KW_FIM_CASO="fim-caso";
-  T_KW_FIM_FACA="fim-fa?a";
-  T_KW_OU="ou";
-  T_KW_E="e";
-  T_KW_NAO="n?o";
-  T_KW_VERDADEIRO="verdadeiro";
-  T_KW_FALSO="falso";
-  T_KW_ASM="asm";
-  T_KW_FIMASM="fim-asm";
+  T_ALGORITMO="algoritmo";
+  T_USE="use";
+  T_VARIAVEL="vari?vel";
+  T_VARIAVEIS="vari?veis";
+  T_FIM_VARIAVEIS="fim-vari?veis";
+  T_INTEIRO="inteiro";
+  T_REAL="real";
+  T_CARACTERE="caractere";
+  T_LITERAL="literal";
+  T_LOGICO="l?gico";
+  T_CORINGA="coringa";
+  T_MATRIZ="matriz";
+  T_DO="do";
+  T_TIPO="tipo";
+  T_CONSTANTE="constante";
+  T_CONSTANTES="constantes";
+  T_FIM_CONSTANTES="fim-constantes";
+  T_ESTRUTURA="estrutura";
+  T_FIM_ESTRUTURA="fim-estrutura";
+  T_FUNCAO="fun??o";
+  T_PROCEDIMENTO="procedimento";
+  T_REF="ref";
+  T_INICIO="in?cio";
+  T_FIM="fim";
+  T_SAIR="sair";
+  T_RETORNE="retorne";
+  T_SE="se";
+  T_ENTAO="ent?o";
+  T_SENAO="sen?o";
+  T_FIM_SE="fim-se";
+  T_ENQUANTO="enquanto";
+  T_FACA="fa?a";
+  T_FIM_ENQUANTO="fim-enquanto";
+  T_PARA="para";
+  T_DE="de";
+  T_ATE="at?";
+  T_FIM_PARA="fim-para";
+  T_PASSO="passo";
+  T_REPITA="repita";
+  T_CASO="caso";
+  T_SEJA="seja";
+  T_FIM_SENAO="fim-sen?o";
+  T_FIM_CASO="fim-caso";
+  T_FIM_FACA="fim-fa?a";
+  T_OU="ou";
+  T_E="e";
+  T_NAO="n?o";
+  T_VERDADEIRO="verdadeiro";
+  T_FALSO="falso";
+  T_ASM="asm";
+  T_FIMASM="fim-asm";
 
   T_REAL_LITERAL="n?mero real"; //a regra T_INTEIRO_LITERAL lida com reais
 
 
   //imagin?rios para a AST
 
-  TI_VALOR;
-  TI_VMATRIZ;    //valor da matriz    (literal [])
-  TI_VESTRUTURA; //valor da estrutura (literal {})
+  T_VALOR;
+  T_VAL_MATRIZ;    //valor da matriz    (literal [])
+  T_VAL_ESTRUTURA; //valor da estrutura (literal {})
 
-  TI_MATRIZ;
-  TI_DIMENSOES;
-  TI_NULL;
+  T_DIMENSOES;
+  T_NULL;
 
-  TI_UN_POSITIVO;
-  TI_UN_NEGATIVO;
-  TI_UN_NEGACAO;
-  TI_UN_NEGACAOB;
-  TI_PARENTESIS;
+  T_UN_POSITIVO;
+  T_UN_NEGATIVO;
 
-  TI_CALL;
+  T_CALL;
 }
 
 

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-08 08:02:03 UTC (rev 340)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 02:10:06 UTC (rev 341)
@@ -74,11 +74,11 @@
   ;
 
 declaracao_algoritmo!
-  : T_KW_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
+  : T_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
   ;
 
 importacao
-  : T_KW_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
+  : T_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
   ;
 
 corpo
@@ -95,11 +95,11 @@
 
 declaracao_variaveis
   : bloco_declaracao_variaveis
-  | T_KW_VARIAVEL! declaracao_variavel_uniq
+  | T_VARIAVEL! declaracao_variavel_uniq
   ;
 
 bloco_declaracao_variaveis
-  : T_KW_VARIAVEIS^ (declaracao_variavel)+ T_KW_FIM_VARIAVEIS!
+  : T_VARIAVEIS^ (declaracao_variavel)+ T_FIM_VARIAVEIS!
   ;
 
 declaracao_variavel!
@@ -109,10 +109,10 @@
             {
               if (l_AST == antlr::nullAST) {
                 #declaracao_variavel =
-                    #([T_KW_VARIAVEL,"&var"], t,ids);
+                    #([T_VARIAVEL,"&var"], t,ids);
               } else {
                 #declaracao_variavel =
-                    #([T_KW_VARIAVEL,"&var"], t,ids,([TI_VALOR,"&valor"],l));
+                    #([T_VARIAVEL,"&var"], t,ids,([T_VALOR,"&valor"],l));
               }
             }
   ;
@@ -128,10 +128,10 @@
             {
               if (l_AST == antlr::nullAST) {
                 #declaracao_variavel_uniq=
-                    #([T_KW_VARIAVEL,"&var"], t,id);
+                    #([T_VARIAVEL,"&var"], t,id);
               } else {
                 #declaracao_variavel_uniq =
-                    #([T_KW_VARIAVEL,"&var"], t,id,([TI_VALOR,"&valor"],l));
+                    #([T_VARIAVEL,"&var"], t,id,([T_VALOR,"&valor"],l));
               }
             }
   ;
@@ -151,13 +151,13 @@
       idx:inicializacao_indices
     T_FECHA_CHAVE!
 
-                 {#inicializacao_composta = #([TI_VMATRIZ, "&vmatriz"],idx);}
+                 {#inicializacao_composta = #([T_VAL_MATRIZ, "&vmatriz"],idx);}
 
   | T_ABRE_COLCHETE!
       mem:inicializacao_membros
     T_FECHA_COLCHETE!
 
-                 {#inicializacao_composta = #([TI_VESTRUTURA, "&vestr"],mem);}
+                 {#inicializacao_composta = #([T_VAL_ESTRUTURA, "&vestr"],mem);}
   ;
 
 inicializacao_indices
@@ -170,25 +170,25 @@
   ;
 
 tipo_primitivo
-  : T_KW_INTEIRO
-  | T_KW_REAL
-  | T_KW_CARACTERE
-  | T_KW_LITERAL
-  | T_KW_LOGICO
-  | T_KW_CORINGA
+  : T_INTEIRO
+  | T_REAL
+  | T_CARACTERE
+  | T_LITERAL
+  | T_LOGICO
+  | T_CORINGA
   ;
 
 tipo_matriz!
-  : T_KW_MATRIZ dim:matriz_dimensoes
-    T_KW_DO T_KW_TIPO t:matriz_tipo
+  : m:T_MATRIZ dim:matriz_dimensoes
+    T_DO T_TIPO t:matriz_tipo
 
-                    {#tipo_matriz = #([TI_MATRIZ, "&matriz"], t,dim);}
+                    {#tipo_matriz = #(m, t,dim);}
   ;
 
 matriz_dimensoes
   : ( T_ABRE_CHAVE!
       ( T_INTEIRO_LITERAL
-        | /*vazio*/  {addChildNode(currentAST, createNode(TI_NULL,"&null"));}
+        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULL,"&null"));}
       )
       T_FECHA_CHAVE!
     )+
@@ -207,18 +207,18 @@
 
 declaracao_constantes
   : bloco_declaracao_constantes
-  | T_KW_CONSTANTE! declaracao_constante
+  | T_CONSTANTE! declaracao_constante
   ;
 
 bloco_declaracao_constantes
-  : T_KW_CONSTANTES^ (declaracao_constante)+ T_KW_FIM_CONSTANTES!
+  : T_CONSTANTES^ (declaracao_constante)+ T_FIM_CONSTANTES!
   ;
 
 declaracao_constante!
   : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
     l:lista_inicializacao T_PONTO_VIRGULA
 
-               {#declaracao_constante = #([T_KW_CONSTANTE,"&const"], t,id,l);}
+               {#declaracao_constante = #([T_CONSTANTE,"&const"], t,id,l);}
   ;
 
 
@@ -230,7 +230,7 @@
 
 
 bloco_declaracao_estrutura
-  : T_KW_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_KW_FIM_ESTRUTURA!
+  : T_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_FIM_ESTRUTURA!
   ;
 
 
@@ -246,14 +246,14 @@
   ;
 
 declaracao_funcao
-  : T_KW_FUNCAO^ T_IDENTIFICADOR
+  : T_FUNCAO^ T_IDENTIFICADOR
       T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo
     (declaracao_constantes | declaracao_variaveis)*
     bloco_codigo
   ;
 
 declaracao_procedimento
-  : T_KW_PROCEDIMENTO^ T_IDENTIFICADOR
+  : T_PROCEDIMENTO^ T_IDENTIFICADOR
       T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
     (declaracao_constantes | declaracao_variaveis)*
     bloco_codigo
@@ -264,9 +264,9 @@
   ;
 
 parametro!
-  : ((c:T_KW_CONSTANTE)? r:T_KW_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+  : ((c:T_CONSTANTE)? r:T_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
 
-                        {#parametro = #([T_KW_VARIAVEL,"&param"],t,id,c,r);}
+                        {#parametro = #([T_VARIAVEL,"&param"],t,id,c,r);}
   ;
 
 
@@ -276,7 +276,7 @@
 //####################################
 
 bloco_codigo
-  : T_KW_INICIO^ lista_enunciados T_KW_FIM!
+  : T_INICIO^ lista_enunciados T_FIM!
   ;
 
 lista_enunciados
@@ -294,7 +294,7 @@
 
   | en_asm
 
-  | T_KW_SAIR^ T_PONTO_VIRGULA!
+  | T_SAIR^ T_PONTO_VIRGULA!
   | T_PONTO_VIRGULA!
 
 //  TODO: retirar da gramatica ou resolver a ambiguidade
@@ -310,7 +310,7 @@
 
 
 en_retorne
-  : T_KW_RETORNE^ (expressao)? T_PONTO_VIRGULA!
+  : T_RETORNE^ (expressao)? T_PONTO_VIRGULA!
   ;
 
 lvalue
@@ -325,48 +325,48 @@
   ;
 
 en_se
-  : T_KW_SE^ expressao T_KW_ENTAO!
-      lista_enunciados (T_KW_SENAO! lista_enunciados)? T_KW_FIM_SE!
+  : T_SE^ expressao T_ENTAO!
+      lista_enunciados (T_SENAO! lista_enunciados)? T_FIM_SE!
   ;
 
 en_enquanto
-  : T_KW_ENQUANTO^ expressao T_KW_FACA! lista_enunciados T_KW_FIM_ENQUANTO!
+  : T_ENQUANTO^ expressao T_FACA! lista_enunciados T_FIM_ENQUANTO!
   ;
 
 en_para
-  : T_KW_PARA^ lvalue T_KW_DE! expressao
-    T_KW_ATE! expressao (passo)? T_KW_FACA!
-      lista_enunciados T_KW_FIM_PARA!
+  : T_PARA^ lvalue T_DE! expressao
+    T_ATE! expressao (passo)? T_FACA!
+      lista_enunciados T_FIM_PARA!
   ;
 
 passo
-  : T_KW_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
+  : T_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
   ;
 
 en_repita
-  : T_KW_REPITA^ lista_enunciados T_KW_ATE expressao
+  : T_REPITA^ lista_enunciados T_ATE expressao
   ;
 
 en_caso
-  : T_KW_CASO^ expressao
-      T_KW_SEJA! (teste_caso)+
-      (caso_senao)? T_KW_FIM_CASO!
+  : T_CASO^ expressao
+      T_SEJA! (teste_caso)+
+      (caso_senao)? T_FIM_CASO!
   ;
 
 teste_caso!
-  : l:literal T_KW_FACA! en:lista_enunciados T_KW_FIM_FACA!
+  : l:literal T_FACA! en:lista_enunciados T_FIM_FACA!
 
                                 {#teste_caso = #(l, en);}
   ;
 
 caso_senao
-  : T_KW_SENAO^ lista_enunciados T_KW_FIM_SENAO!
+  : T_SENAO^ lista_enunciados T_FIM_SENAO!
   ;
 
 
 //TODO: codigo ilustrativo.
 en_asm!
-  : T_KW_ASM (~(T_KW_FIMASM))* T_KW_FIMASM
+  : T_ASM (~(T_FIMASM))* T_FIMASM
   ;
 
 
@@ -375,14 +375,14 @@
 //####################################
 
 expressao
-  : expr_e (T_KW_OU^ expr_e)*
+  : expr_e (T_OU^ expr_e)*
   ;
 
 expr_e
 options {
   defaultErrorHandler=false;
 }
-  : expr_bit_ou (T_KW_E^ expr_bit_ou)*
+  : expr_bit_ou (T_E^ expr_bit_ou)*
   ;
 
 expr_bit_ou
@@ -442,10 +442,10 @@
   ;
 
 op_unario!
-  : ( T_MENOS   {#op_unario = #[TI_UN_NEGATIVO,"&negat"];}
-    | T_MAIS    {#op_unario = #[TI_UN_POSITIVO,"&pos"];}
-    | T_KW_NAO  {#op_unario = #[TI_UN_NEGACAO ,"nega?"];}
-    | T_BIT_NAO {#op_unario = #[TI_UN_NEGACAOB,"&negb"];}
+  : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
+    | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
+    | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
+    | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
     )?
   ;
 
@@ -453,15 +453,14 @@
   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
   |  lvalue
   |  literal
-  |! T_ABRE_PAREN e:expressao T_FECHA_PAREN {#expr_elemento =
-                                              #([TI_PARENTESIS,"&paren"], e);}
+  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
   ;
 
 
 chamada_subrotina!
   : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
 
-                        {#chamada_subrotina = #([TI_CALL,"&call"], id, args);}
+                        {#chamada_subrotina = #([T_CALL,"&call"], id, args);}
   ;
 
 lista_argumentos
@@ -473,6 +472,6 @@
   | T_INTEIRO_LITERAL
   | T_REAL_LITERAL
   | T_CARACTERE_LITERAL
-  | T_KW_VERDADEIRO
-  | T_KW_FALSO
+  | T_VERDADEIRO
+  | T_FALSO
   ;



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 03:44:47 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 03:44:47 +0100
Subject: [gpt-commit] r342 - trunk/gpt2/src/gptc
Message-ID: <200711090244.lA92ilsH026625@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 03:44:46 +0100 (Fri, 09 Nov 2007)
New Revision: 342

Modified:
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
Log:
-Adicionado suporte ?\195?\131a parametros variaveis em subprogramas

Modified: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-09 02:10:06 UTC (rev 341)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-09 02:44:46 UTC (rev 342)
@@ -472,7 +472,14 @@
   ;
 
 
+T_RETICENCIAS
+options {
+  paraphrase = "retic?ncias (...)";
+}
+  : "..."
+  ;
 
+
 //####################################
 //##            Protecteds          ##
 //####################################

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 02:10:06 UTC (rev 341)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 02:44:46 UTC (rev 342)
@@ -260,17 +260,20 @@
   ;
 
 lista_parametros
-  : parametro (T_VIRGULA! parametro)*
+  : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
   ;
 
+param_reticencias!
+  : ret:T_RETICENCIAS     {#param_reticencias = #([T_VARIAVEL,"&param"],ret);}
+  ;
+
 parametro!
   : ((c:T_CONSTANTE)? r:T_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
 
-                        {#parametro = #([T_VARIAVEL,"&param"],t,id,c,r);}
+                          {#parametro = #([T_VARIAVEL,"&param"],t,id,c,r);}
   ;
 
 
-
 //####################################
 //##         Bloco de c?digo        ##
 //####################################



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 03:52:30 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 03:52:30 +0100
Subject: [gpt-commit] r343 - trunk/gpt2/src/gptc
Message-ID: <200711090252.lA92qU1g027667@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 03:52:29 +0100 (Fri, 09 Nov 2007)
New Revision: 343

Modified:
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
Log:
-Adicionado acesso a membros de estruturas
-Adicionado valor 'nulo'

Modified: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-09 02:44:46 UTC (rev 342)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-09 02:52:29 UTC (rev 343)
@@ -91,6 +91,7 @@
   T_NAO="n?o";
   T_VERDADEIRO="verdadeiro";
   T_FALSO="falso";
+  T_NULO="nulo";
   T_ASM="asm";
   T_FIMASM="fim-asm";
 
@@ -479,6 +480,12 @@
   : "..."
   ;
 
+T_PONTO
+options {
+  paraphrase = "ponto (.)";
+}
+  : '.'
+  ;
 
 //####################################
 //##            Protecteds          ##

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 02:44:46 UTC (rev 342)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 02:52:29 UTC (rev 343)
@@ -317,7 +317,7 @@
   ;
 
 lvalue
-  : T_IDENTIFICADOR^ matriz_indices
+  : T_IDENTIFICADOR^ (matriz_indices | T_PONTO! lvalue)
   ;
 
 matriz_indices
@@ -477,4 +477,5 @@
   | T_CARACTERE_LITERAL
   | T_VERDADEIRO
   | T_FALSO
+  | T_NULO
   ;



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 04:10:36 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 04:10:36 +0100
Subject: [gpt-commit] r344 - trunk/gpt2/src/gptc
Message-ID: <200711090310.lA93AaZ4028373@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 04:10:35 +0100 (Fri, 09 Nov 2007)
New Revision: 344

Modified:
   trunk/gpt2/src/gptc/parser.g
Log:
-Concertado ast para 'senao' da estrutura 'se'

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 02:52:29 UTC (rev 343)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 03:10:35 UTC (rev 344)
@@ -329,7 +329,7 @@
 
 en_se
   : T_SE^ expressao T_ENTAO!
-      lista_enunciados (T_SENAO! lista_enunciados)? T_FIM_SE!
+      lista_enunciados (T_SENAO lista_enunciados)? T_FIM_SE!
   ;
 
 en_enquanto



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 04:27:10 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 04:27:10 +0100
Subject: [gpt-commit] r345 - trunk/gpt2/src/gptc
Message-ID: <200711090327.lA93RAwK029163@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 04:27:09 +0100 (Fri, 09 Nov 2007)
New Revision: 345

Modified:
   trunk/gpt2/src/gptc/parser.g
Log:
-Permitindo a compilacao de unidades que omitem o bloco inicio/fim

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 03:10:35 UTC (rev 344)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 03:27:09 UTC (rev 345)
@@ -82,9 +82,9 @@
   ;
 
 corpo
-  :  (declaracao_subrotina)*
-      bloco_codigo
-     (declaracao_subrotina)*
+  :  declaracao_subrotina corpo
+  |  bloco_codigo corpo
+  |  /*vazio*/
   ;
 
 



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 04:28:02 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 04:28:02 +0100
Subject: [gpt-commit] r346 - trunk/gpt2/src/gptc
Message-ID: <200711090328.lA93S2p7029196@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 04:28:02 +0100 (Fri, 09 Nov 2007)
New Revision: 346

Modified:
   trunk/gpt2/src/gptc/parser.g
Log:
DEVNULL:-identacao

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 03:27:09 UTC (rev 345)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 03:28:02 UTC (rev 346)
@@ -83,7 +83,7 @@
 
 corpo
   :  declaracao_subrotina corpo
-  |  bloco_codigo corpo
+  |  bloco_codigo         corpo
   |  /*vazio*/
   ;
 



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 05:14:12 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 05:14:12 +0100
Subject: [gpt-commit] r347 - trunk/gpt2/src/gptc
Message-ID: <200711090414.lA94EC7B030944@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 05:14:11 +0100 (Fri, 09 Nov 2007)
New Revision: 347

Modified:
   trunk/gpt2/src/gptc/parser.g
Log:
-Producao renomeada, para nao confundir entre matriz_tipo e tipo_matriz

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 03:28:02 UTC (rev 346)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 04:14:11 UTC (rev 347)
@@ -180,7 +180,7 @@
 
 tipo_matriz!
   : m:T_MATRIZ dim:matriz_dimensoes
-    T_DO T_TIPO t:matriz_tipo
+    T_DO T_TIPO t:tipo_da_matriz
 
                     {#tipo_matriz = #(m, t,dim);}
   ;
@@ -194,7 +194,7 @@
     )+
   ;
 
-matriz_tipo
+tipo_da_matriz
   : tipo_primitivo | T_IDENTIFICADOR
   ;
 



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 05:18:23 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 05:18:23 +0100
Subject: [gpt-commit] r348 - in trunk/gpt2/src/gptc: . testes
Message-ID: <200711090418.lA94INGX031080@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 05:18:22 +0100 (Fri, 09 Nov 2007)
New Revision: 348

Modified:
   trunk/gpt2/src/gptc/Makefile
   trunk/gpt2/src/gptc/parser.g
   trunk/gpt2/src/gptc/teste.cpp
   trunk/gpt2/src/gptc/testes/tree_teste.gpt
Log:
DEVNULL:-Erro de digitacao

Modified: trunk/gpt2/src/gptc/Makefile
===================================================================
--- trunk/gpt2/src/gptc/Makefile	2007-11-09 04:14:11 UTC (rev 347)
+++ trunk/gpt2/src/gptc/Makefile	2007-11-09 04:18:22 UTC (rev 348)
@@ -1,4 +1,4 @@
-objects = PortugolLexer.o PortugolParser.o \
+objects = PortugolLexer.o PortugolParser.o SemanticWalker.o \
 			    MismatchedUnicodeCharException.o teste.o
 
 teste: $(objects)
@@ -10,6 +10,9 @@
 PortugolParser.o: PortugolParser.hpp PortugolParser.cpp
 	g++ -c PortugolParser.cpp
 
+SemanticWalker.o: SemanticWalker.hpp SemanticWalker.cpp
+	g++ -c SemanticWalker.cpp
+
 MismatchedUnicodeCharException.o:
 	g++ -c MismatchedUnicodeCharException.cpp
 
@@ -22,6 +25,9 @@
 PortugolParser.hpp PortugolParser.cpp: parser.g
 	antlr parser.g
 
+SemanticWalker.hpp SemanticWalker.cpp: semantic.g
+	antlr semantic.g
+
 table.hpp:
 	grep = PortugolTokenTypes.txt > table.hpp
 	sed -i -e 's/([^=]*)//' table.hpp
@@ -33,4 +39,6 @@
 clean:
 	rm -f *.o PortugolLexer.cpp PortugolLexer.hpp PortugolTokenTypes.hpp \
 	PortugolTokenTypes.txt PortugolParser.cpp PortugolParser.hpp teste \
-	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp
+	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp \
+	SemanticWalkerTokenTypes.txt SemanticWalkerTokenTypes.hpp \
+	SemanticWalker.hpp SemanticWalker.cpp

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 04:14:11 UTC (rev 347)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-09 04:18:22 UTC (rev 348)
@@ -188,7 +188,7 @@
 matriz_dimensoes
   : ( T_ABRE_CHAVE!
       ( T_INTEIRO_LITERAL
-        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULL,"&null"));}
+        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULO,"&null"));}
       )
       T_FECHA_CHAVE!
     )+

Modified: trunk/gpt2/src/gptc/teste.cpp
===================================================================
--- trunk/gpt2/src/gptc/teste.cpp	2007-11-09 04:14:11 UTC (rev 347)
+++ trunk/gpt2/src/gptc/teste.cpp	2007-11-09 04:18:22 UTC (rev 348)
@@ -1,6 +1,7 @@
 #include <stdio.h>
 #include "PortugolLexer.hpp"
 #include "PortugolParser.hpp"
+#include "SemanticWalker.hpp"
 #include "PortugolTokenTypes.hpp"
 #include <antlr/TokenBuffer.hpp>
 #include <antlr/CommonAST.hpp>
@@ -26,7 +27,7 @@
   }
 }
 
-void dump_tree(char* fname) {
+antlr::RefAST dump_tree(char* fname, bool should_dump) {
 
   std::ifstream fi(fname);
   PortugolLexer lexer(fi, true);
@@ -38,27 +39,44 @@
 
   parser.programa();
 
-  antlr::RefCommonAST ast = antlr::RefCommonAST(parser.getAST());
+  antlr::RefAST ast = parser.getAST();
+  antlr::RefCommonAST cast = antlr::RefCommonAST(ast);
 
-  if (ast) {
-    std::cerr << ast->toStringList() << std::endl << std::endl;
-  } else {
-    std::cerr << ": no parse tree" << std::endl;
+  if (!cast) {
+    std::cerr << "no parse tree!" << std::endl;
   }
+
+  if (should_dump) {
+    std::cerr << cast->toStringList() << std::endl << std::endl;
+  }
+  return ast;
 }
 
+void semantic(char* fname) {
+  antlr::RefAST ast;
+
+  ast = dump_tree(fname, true);
+
+  SemanticWalker semantic;
+  semantic.programa(ast);
+}
+
 int main(int argc, char** argv) {
 
   if (argc < 3) {
-    std::cerr << "./test [lp] <file.gpt>" << std::endl;
+    std::cerr << "./test [lps] <file.gpt>" << std::endl;
     return 0;
   }
 
-  if (*argv[1] == 't') {
-    dump_tree(argv[2]);
-  } else {
-    dump_tokens(argv[2]);
+  switch(*argv[1]) {
+    case 'l':
+      dump_tokens(argv[2]);
+      break;
+    case 'p':
+      dump_tree(argv[2], true);
+      break;
+    case 's':
+    default:
+      semantic(argv[2]);
   }
-
-  return 0;
 }

Modified: trunk/gpt2/src/gptc/testes/tree_teste.gpt
===================================================================
--- trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-09 04:14:11 UTC (rev 347)
+++ trunk/gpt2/src/gptc/testes/tree_teste.gpt	2007-11-09 04:18:22 UTC (rev 348)
@@ -5,17 +5,19 @@
 // use "bib3";
 // use "bib4";
 
-// vari?veis
+// vari?vel q : T;
+
+vari?veis
 //   p : T;
 //   a,b : real;
 //   c : inteiro := 10;
-//   j : matriz[] do tipo inteiro := [1,2,3];
+  j : matriz[] do tipo inteiro := [1,2,3];
 //   es,e2 : T := {nome:="foo",id:=6};
 //   e4    : matriz[] do tipo T := [{nome:="a",id:=2},{nome:="b",id:=3}];
-// fim-vari?veis
+fim-vari?veis
 
 
-// vari?vel q : T;
+
 // vari?vel j : K := "oi";
 // vari?vel m : matriz[] do tipo I := [9,8,7];
 // vari?vel z : T := {i:=10, j:=20};
@@ -34,8 +36,15 @@
 //   z   : inteiro := 1;
 //   j,z : kkk;
 // fim-estrutura
+/*
+fun??o f(a:I,k:matriz[1][2] do tipo I) : T
+in?cio
+  x := 2;
+fim*/
 
-in?cio
+
+
+// in?cio
 //   x := 10;
 //   z[1] := 9;
 //   z[0][0] := n?o(~1 + -2 * +3);
@@ -85,21 +94,16 @@
 //
 //   retorne 10+10;
 
-  f(10, 1+2, g());
+//   f(10, 1+2, g());
 
 //   "se" x > 10
 /*  asm
     ola  as "sss" 1 se ent?o
     adasd "fim-asm"
   fim-asm*/
-fim
+// fim
 
 
-// fun??o f(a:I,k:matriz[1][2] do tipo I) : T
-// in?cio
-//   x := 2;
-// fim
-
 // procedimento p(a:I,k:matriz[1][2] do tipo I)
 // in?cio
 //   z := 2;



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 05:31:14 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 05:31:14 +0100
Subject: [gpt-commit] r349 - trunk/gpt2/src/gptc
Message-ID: <200711090431.lA94VE8b031624@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 05:31:13 +0100 (Fri, 09 Nov 2007)
New Revision: 349

Modified:
   trunk/gpt2/src/gptc/Makefile
Log:
DEVNULL:-isolando arquivos gerados

Modified: trunk/gpt2/src/gptc/Makefile
===================================================================
--- trunk/gpt2/src/gptc/Makefile	2007-11-09 04:18:22 UTC (rev 348)
+++ trunk/gpt2/src/gptc/Makefile	2007-11-09 04:31:13 UTC (rev 349)
@@ -1,42 +1,55 @@
-objects = PortugolLexer.o PortugolParser.o SemanticWalker.o \
-			    MismatchedUnicodeCharException.o teste.o
+output = ./obj
 
-teste: $(objects)
-	g++ -o teste $(objects) /usr/local/lib/libantlr.a
+objects = $(output)/PortugolLexer.o $(output)/PortugolParser.o \
+					$(output)/SemanticWalker.o $(output)/teste.o \
+					$(output)/MismatchedUnicodeCharException.o
 
-PortugolLexer.o: PortugolLexer.hpp PortugolLexer.cpp
-	g++ -c PortugolLexer.cpp
 
-PortugolParser.o: PortugolParser.hpp PortugolParser.cpp
-	g++ -c PortugolParser.cpp
+cpp = g++ -I$(output) -I.
 
-SemanticWalker.o: SemanticWalker.hpp SemanticWalker.cpp
-	g++ -c SemanticWalker.cpp
+teste: bin $(objects)
+	$(cpp) -o $(output)/teste $(objects) /usr/local/lib/libantlr.a
 
-MismatchedUnicodeCharException.o:
-	g++ -c MismatchedUnicodeCharException.cpp
+bin:
+	mkdir -p $(output)
 
-teste.o: teste.cpp table.hpp
-	g++ -c teste.cpp
+$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp $(output)/PortugolLexer.cpp
+	$(cpp) -c $(output)/PortugolLexer.cpp -o $(output)/PortugolLexer.o
 
-PortugolLexer.hpp PortugolLexer.cpp: lexer.g
-	antlr lexer.g
+$(output)/PortugolParser.o: $(output)/PortugolParser.hpp $(output)/PortugolParser.cpp
+	$(cpp) -c $(output)/PortugolParser.cpp -o $(output)/PortugolParser.o
 
-PortugolParser.hpp PortugolParser.cpp: parser.g
-	antlr parser.g
+$(output)/SemanticWalker.o: $(output)/SemanticWalker.hpp $(output)/SemanticWalker.cpp
+	$(cpp) -c $(output)/SemanticWalker.cpp -o $(output)/SemanticWalker.o
 
-SemanticWalker.hpp SemanticWalker.cpp: semantic.g
-	antlr semantic.g
+$(output)/MismatchedUnicodeCharException.o:
+	$(cpp) -c MismatchedUnicodeCharException.cpp \
+	-o $(output)/MismatchedUnicodeCharException.o
 
-table.hpp:
-	grep = PortugolTokenTypes.txt > table.hpp
-	sed -i -e 's/([^=]*)//' table.hpp
-	sed -i -e 's/"[^"]*"//' table.hpp
-	sed -i -e 's/==/=/' table.hpp
-	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' table.hpp
+$(output)/teste.o: teste.cpp $(output)/table.hpp
+	$(cpp) -c teste.cpp -o $(output)/teste.o
 
+$(output)/PortugolLexer.hpp $(output)/PortugolLexer.cpp: lexer.g
+	antlr -o $(output) lexer.g
 
+$(output)/PortugolParser.hpp $(output)/PortugolParser.cpp: parser.g
+	antlr -o $(output) parser.g
+
+$(output)/SemanticWalker.hpp $(output)/SemanticWalker.cpp: semantic.g
+	antlr -o $(output) semantic.g
+
+$(output)/table.hpp:
+	grep = $(output)/PortugolTokenTypes.txt > $(output)/table.hpp
+	sed -i -e 's/([^=]*)//' $(output)/table.hpp
+	sed -i -e 's/"[^"]*"//' $(output)/table.hpp
+	sed -i -e 's/==/=/' $(output)/table.hpp
+	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' $(output)/table.hpp
+
+
 clean:
+	rm -rf $(output)
+
+cleanold:
 	rm -f *.o PortugolLexer.cpp PortugolLexer.hpp PortugolTokenTypes.hpp \
 	PortugolTokenTypes.txt PortugolParser.cpp PortugolParser.hpp teste \
 	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp \



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 05:32:07 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 05:32:07 +0100
Subject: [gpt-commit] r350 - trunk/gpt2/src/gptc
Message-ID: <200711090432.lA94W7GO031663@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 05:32:06 +0100 (Fri, 09 Nov 2007)
New Revision: 350

Added:
   trunk/gpt2/src/gptc/semantic.g
Log:
-Adicionando o SemanticWalker, responsavel pela analise semantica

Added: trunk/gpt2/src/gptc/semantic.g
===================================================================
--- trunk/gpt2/src/gptc/semantic.g	2007-11-09 04:31:13 UTC (rev 349)
+++ trunk/gpt2/src/gptc/semantic.g	2007-11-09 04:32:06 UTC (rev 350)
@@ -0,0 +1,136 @@
+/*
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
+
+
+options {
+  language="Cpp";
+}
+
+class SemanticWalker extends TreeParser;
+options {
+  importVocab   = Portugol;
+  genHashLines  = false;
+}
+
+
+programa
+  : (importacao)*
+
+    (   declaracao_variaveis
+//       | declaracao_constantes
+//       | bloco_declaracao_estrutura
+    )*
+  ;
+
+importacao
+  : #(T_USE T_TEXTO_LITERAL)
+    //TODO: carregar a symboltable das bibliotecas especificadas
+  ;
+
+declaracao_variaveis
+  : #(T_VARIAVEIS (declaracao_variavel)+)
+  | declaracao_variavel
+  ;
+
+declaracao_variavel
+  : #(T_VARIAVEL tipo lista_identificadores (lista_inicializacao)?)
+  ;
+
+lista_identificadores
+  : (T_IDENTIFICADOR)+
+  ;
+
+tipo
+  : tipo_primitivo
+  | tipo_matriz
+  | T_IDENTIFICADOR
+  ;
+
+lista_inicializacao
+  : #(T_VALOR valor_inicializacao)
+  ;
+
+valor_inicializacao
+  : (matriz_literal | estrutura_literal | expressao)
+  ;
+
+matriz_literal
+  : #(T_VAL_MATRIZ (valor_inicializacao)+)
+  ;
+
+estrutura_literal
+  : #(T_VAL_ESTRUTURA (T_IDENTIFICADOR valor_inicializacao)+)
+  ;
+
+tipo_primitivo
+  : T_INTEIRO
+  | T_REAL
+  | T_CARACTERE
+  | T_LITERAL
+  | T_LOGICO
+  | T_CORINGA
+  ;
+
+tipo_matriz
+  : #(T_MATRIZ tipo_da_matriz (T_INTEIRO_LITERAL|T_NULO)+)
+  ;
+
+tipo_da_matriz
+  : tipo_primitivo | T_IDENTIFICADOR
+  ;
+
+
+expressao
+  : expr_elemento
+  ;
+
+expr_elemento
+  : literal
+  ;
+
+literal
+  : T_TEXTO_LITERAL
+  | T_INTEIRO_LITERAL
+  | T_REAL_LITERAL
+  | T_CARACTERE_LITERAL
+  | T_VERDADEIRO
+  | T_FALSO
+  | T_NULO
+  ;
+
+//   T_OU
+//   : expr_bit_ou (T_E^ expr_bit_ou)*
+//   : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
+//   : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
+//   : expr_igual (T_BIT_E^ expr_igual)*
+//   : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
+//   : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
+//   : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
+//   : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
+//   : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
+//     | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
+//     | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
+//     | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
+
+// expr_elemento
+//   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
+//   |  lvalue
+//   |  literal
+//   | T_ABRE_PAREN! expressao T_FECHA_PAREN!
+//   ;



From gpt-commit-noreply at mail.berlios.de  Fri Nov  9 05:56:46 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 9 Nov 2007 05:56:46 +0100
Subject: [gpt-commit] r351 - trunk/gpt2/src/gptc
Message-ID: <200711090456.lA94ukw1032298@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-09 05:56:42 +0100 (Fri, 09 Nov 2007)
New Revision: 351

Added:
   trunk/gpt2/src/gptc/BaseSemanticWalker.cpp
   trunk/gpt2/src/gptc/BaseSemanticWalker.hpp
Modified:
   trunk/gpt2/src/gptc/Makefile
   trunk/gpt2/src/gptc/semantic.g
Log:
-Adicionando classe base para o SemanticWalker

Added: trunk/gpt2/src/gptc/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/src/gptc/BaseSemanticWalker.cpp	2007-11-09 04:32:06 UTC (rev 350)
+++ trunk/gpt2/src/gptc/BaseSemanticWalker.cpp	2007-11-09 04:56:42 UTC (rev 351)
@@ -0,0 +1,3 @@
+#include "BaseSemanticWalker.hpp"
+
+

Added: trunk/gpt2/src/gptc/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/src/gptc/BaseSemanticWalker.hpp	2007-11-09 04:32:06 UTC (rev 350)
+++ trunk/gpt2/src/gptc/BaseSemanticWalker.hpp	2007-11-09 04:56:42 UTC (rev 351)
@@ -0,0 +1,32 @@
+/***************************************************************************
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef BASESEMANTICWALKER_H
+#define BASESEMANTICWALKER_H
+
+#include <antlr/TreeParser.hpp>
+
+class BaseSemanticWalker : public antlr::TreeParser {
+
+public:
+  BaseSemanticWalker() : antlr::TreeParser() {}
+};
+
+#endif

Modified: trunk/gpt2/src/gptc/Makefile
===================================================================
--- trunk/gpt2/src/gptc/Makefile	2007-11-09 04:32:06 UTC (rev 350)
+++ trunk/gpt2/src/gptc/Makefile	2007-11-09 04:56:42 UTC (rev 351)
@@ -1,27 +1,33 @@
 output = ./obj
 
 objects = $(output)/PortugolLexer.o $(output)/PortugolParser.o \
-					$(output)/SemanticWalker.o $(output)/teste.o \
-					$(output)/MismatchedUnicodeCharException.o
+					$(output)/BaseSemanticWalker.o $(output)/SemanticWalker.o \
+					$(output)/teste.o $(output)/MismatchedUnicodeCharException.o
 
 
 cpp = g++ -I$(output) -I.
 
-teste: bin $(objects)
+all: $(output) $(objects) $(output)/teste
+
+$(output)/teste:
 	$(cpp) -o $(output)/teste $(objects) /usr/local/lib/libantlr.a
 
-bin:
+$(output):
 	mkdir -p $(output)
 
-$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp $(output)/PortugolLexer.cpp
+$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp
 	$(cpp) -c $(output)/PortugolLexer.cpp -o $(output)/PortugolLexer.o
 
-$(output)/PortugolParser.o: $(output)/PortugolParser.hpp $(output)/PortugolParser.cpp
+$(output)/PortugolParser.o: $(output)/PortugolParser.hpp
 	$(cpp) -c $(output)/PortugolParser.cpp -o $(output)/PortugolParser.o
 
-$(output)/SemanticWalker.o: $(output)/SemanticWalker.hpp $(output)/SemanticWalker.cpp
+$(output)/SemanticWalker.o: $(output)/BaseSemanticWalker.o \
+		$(output)/SemanticWalker.hpp
 	$(cpp) -c $(output)/SemanticWalker.cpp -o $(output)/SemanticWalker.o
 
+$(output)/BaseSemanticWalker.o: BaseSemanticWalker.hpp BaseSemanticWalker.cpp
+	$(cpp) -c BaseSemanticWalker.cpp -o $(output)/BaseSemanticWalker.o
+
 $(output)/MismatchedUnicodeCharException.o:
 	$(cpp) -c MismatchedUnicodeCharException.cpp \
 	-o $(output)/MismatchedUnicodeCharException.o
@@ -49,9 +55,3 @@
 clean:
 	rm -rf $(output)
 
-cleanold:
-	rm -f *.o PortugolLexer.cpp PortugolLexer.hpp PortugolTokenTypes.hpp \
-	PortugolTokenTypes.txt PortugolParser.cpp PortugolParser.hpp teste \
-	PortugolParserTokenTypes.hpp PortugolParserTokenTypes.txt table.hpp \
-	SemanticWalkerTokenTypes.txt SemanticWalkerTokenTypes.hpp \
-	SemanticWalker.hpp SemanticWalker.cpp

Modified: trunk/gpt2/src/gptc/semantic.g
===================================================================
--- trunk/gpt2/src/gptc/semantic.g	2007-11-09 04:32:06 UTC (rev 350)
+++ trunk/gpt2/src/gptc/semantic.g	2007-11-09 04:56:42 UTC (rev 351)
@@ -18,17 +18,29 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
 
 
+header {
+  #include "BaseSemanticWalker.hpp"
+}
+
+
 options {
   language="Cpp";
 }
 
-class SemanticWalker extends TreeParser;
+class SemanticWalker extends TreeParser("BaseSemanticWalker");
 options {
-  importVocab   = Portugol;
-  genHashLines  = false;
+  importVocab    = Portugol;
+  noConstructors = true;
+  genHashLines   = false;
 }
 
+{
+public:
+  SemanticWalker::SemanticWalker()
+	 : BaseSemanticWalker() { }
+}
 
+
 programa
   : (importacao)*
 



From gpt-commit-noreply at mail.berlios.de  Sat Nov 10 03:06:15 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 10 Nov 2007 03:06:15 +0100
Subject: [gpt-commit] r352 - trunk/gpt2/src/gptc
Message-ID: <200711100206.lAA26FSu015714@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-10 03:06:13 +0100 (Sat, 10 Nov 2007)
New Revision: 352

Modified:
   trunk/gpt2/src/gptc/lexer.g
   trunk/gpt2/src/gptc/parser.g
Log:
-Adicionado operadores de bit shift

Modified: trunk/gpt2/src/gptc/lexer.g
===================================================================
--- trunk/gpt2/src/gptc/lexer.g	2007-11-09 04:56:42 UTC (rev 351)
+++ trunk/gpt2/src/gptc/lexer.g	2007-11-10 02:06:13 UTC (rev 352)
@@ -311,7 +311,21 @@
   : '~'
   ;
 
+T_BIT_SHIFT_LEFT
+options {
+  paraphrase = "operador '<<'";
+}
+  : "<<"
+  ;
 
+T_BIT_SHIFT_RIGHT
+options {
+  paraphrase = "operador '>>'";
+}
+
+  : ">>"
+  ;
+
 T_IGUAL
 options {
   paraphrase = "operador '='";

Modified: trunk/gpt2/src/gptc/parser.g
===================================================================
--- trunk/gpt2/src/gptc/parser.g	2007-11-09 04:56:42 UTC (rev 351)
+++ trunk/gpt2/src/gptc/parser.g	2007-11-10 02:06:13 UTC (rev 352)
@@ -377,6 +377,7 @@
 //##            Express?es          ##
 //####################################
 
+
 expressao
   : expr_e (T_OU^ expr_e)*
   ;
@@ -406,10 +407,10 @@
 options {
   defaultErrorHandler=false;
 }
-  : expr_igual (T_BIT_E^ expr_igual)*
+  : expr_eq (T_BIT_E^ expr_eq)*
   ;
 
-expr_igual
+expr_eq
 options {
   defaultErrorHandler=false;
 }
@@ -420,13 +421,20 @@
 options {
   defaultErrorHandler=false;
 }
-  : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
+  : expr_bit_shift ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_bit_shift)*
   ;
 
-expr_ad
+expr_bit_shift
 options {
   defaultErrorHandler=false;
 }
+  : expr_soma ((T_BIT_SHIFT_LEFT^ | T_BIT_SHIFT_RIGHT^) expr_soma)*
+  ;
+
+expr_soma
+options {
+  defaultErrorHandler=false;
+}
   : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
   ;
 



From gpt-commit-noreply at mail.berlios.de  Sat Nov 10 04:36:44 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 10 Nov 2007 04:36:44 +0100
Subject: [gpt-commit] r353 - in trunk/gpt2: . src
Message-ID: <200711100336.lAA3aiSR024568@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-10 04:36:43 +0100 (Sat, 10 Nov 2007)
New Revision: 353

Added:
   trunk/gpt2/gptc/
Removed:
   trunk/gpt2/src/gptc/
Log:
DEVNULL:-reorganizando arvore de diretorios. Fica melhor para a inter-dependencia dos subprojetos se cada um ficar um pouco 'isolado' um do outro

Copied: trunk/gpt2/gptc (from rev 352, trunk/gpt2/src/gptc)



From gpt-commit-noreply at mail.berlios.de  Sat Nov 10 04:38:08 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 10 Nov 2007 04:38:08 +0100
Subject: [gpt-commit] r354 - trunk/gpt2
Message-ID: <200711100338.lAA3c8Q3024648@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-10 04:38:07 +0100 (Sat, 10 Nov 2007)
New Revision: 354

Added:
   trunk/gpt2/gptasm/
   trunk/gpt2/gptlib/
   trunk/gpt2/gptvm/
Removed:
   trunk/gpt2/src/
Log:
DEVNULL:-reorganizando arvore de diretorios. Fica melhor para a inter-dependencia dos subprojetos se cada um ficar um pouco 'isolado' um do outro



From gpt-commit-noreply at mail.berlios.de  Sat Nov 10 04:38:52 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 10 Nov 2007 04:38:52 +0100
Subject: [gpt-commit] r355 - trunk/gpt2
Message-ID: <200711100338.lAA3cquv024682@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-10 04:38:52 +0100 (Sat, 10 Nov 2007)
New Revision: 355

Removed:
   trunk/gpt2/tests/
Log:
DEVNULL:-reorganizando arvore de diretorios. Fica melhor para a inter-dependencia dos subprojetos se cada um ficar um pouco 'isolado' um do outro



From gpt-commit-noreply at mail.berlios.de  Sat Nov 10 04:46:26 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Sat, 10 Nov 2007 04:46:26 +0100
Subject: [gpt-commit] r356 - trunk/gpt2/gptc
Message-ID: <200711100346.lAA3kQAo024923@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-10 04:46:26 +0100 (Sat, 10 Nov 2007)
New Revision: 356

Added:
   trunk/gpt2/gptc/tmp/
Removed:
   trunk/gpt2/gptc/testes/
Log:
nomsg

Copied: trunk/gpt2/gptc/tmp (from rev 353, trunk/gpt2/gptc/testes)



From gpt-commit-noreply at mail.berlios.de  Tue Nov 13 16:53:07 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 13 Nov 2007 16:53:07 +0100
Subject: [gpt-commit] r357 - in trunk/gpt2/gptc: . test
Message-ID: <200711131553.lADFr7qI014236@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-13 16:53:03 +0100 (Tue, 13 Nov 2007)
New Revision: 357

Added:
   trunk/gpt2/gptc/test/
   trunk/gpt2/gptc/test/Makefile
   trunk/gpt2/gptc/test/compiler_test.g
   trunk/gpt2/gptc/test/first.test
   trunk/gpt2/gptc/test/tester.cpp
Log:
DEVNULL:-Adicionando cofigo inicial de testes

Added: trunk/gpt2/gptc/test/Makefile
===================================================================
--- trunk/gpt2/gptc/test/Makefile	2007-11-10 03:46:26 UTC (rev 356)
+++ trunk/gpt2/gptc/test/Makefile	2007-11-13 15:53:03 UTC (rev 357)
@@ -0,0 +1,42 @@
+output = ./obj
+
+objects = $(output)/LangTestLexer.o $(output)/LangTestParser.o \
+					$(output)/tester.o
+
+other = ../obj/PortugolLexer.o ../obj/PortugolParser.o \
+				../obj/MismatchedUnicodeCharException.o
+
+cpp = g++ -I$(output) -I. -I../ -I../obj
+
+$(output)/tester: $(output) $(objects)
+	$(cpp) -o $(output)/tester $(objects) $(other) /usr/local/lib/libantlr.a
+
+$(output):
+	mkdir -p $(output)
+
+$(output)/LangTestLexer.o: $(output)/LangTestLexer.hpp $(output)/LangTestLexer.cpp
+	$(cpp) -c $(output)/LangTestLexer.cpp -o $(output)/LangTestLexer.o
+
+$(output)/LangTestParser.o: $(output)/LangTestParser.hpp $(output)/LangTestParser.cpp
+	$(cpp) -c $(output)/LangTestParser.cpp -o $(output)/LangTestParser.o
+
+$(output)/tester.o: tester.cpp
+	$(cpp) -c tester.cpp -o $(output)/tester.o
+
+$(output)/LangTestLexer.hpp $(output)/LangTestLexer.cpp \
+$(output)/LangTestParser.hpp $(output)/LangTestParser.cpp: compiler_test.g
+	antlr -o $(output) compiler_test.g
+
+
+# $(output)/table.hpp:
+# 	grep = $(output)/LangTestLexerTokenTypes.txt > $(output)/table.hpp
+# 	sed -i -e 's/([^=]*)//' $(output)/table.hpp
+# 	sed -i -e 's/"[^"]*"//' $(output)/table.hpp
+# 	sed -i -e 's/==/=/' $(output)/table.hpp
+# 	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' $(output)/table.hpp
+
+
+clean:
+	rm -rf $(output)
+
+

Added: trunk/gpt2/gptc/test/compiler_test.g
===================================================================
--- trunk/gpt2/gptc/test/compiler_test.g	2007-11-10 03:46:26 UTC (rev 356)
+++ trunk/gpt2/gptc/test/compiler_test.g	2007-11-13 15:53:03 UTC (rev 357)
@@ -0,0 +1,267 @@
+/*
+
+teste
+  caso {
+    algoritmo teste
+  }
+
+  ast: ([T_ALGORITMO,"algoritmo"] [T_IDENTIFICADOR,"teste"])
+  erros: [ES001] //ponto virgula
+fim
+
+Codigos de erros:
+
+EXXXX - Erro XXXX
+ESXXX - Erro Sintatico
+EMXXX - Erro Semantico
+
+
+*/
+
+header {
+
+  #include "PortugolParser.hpp"
+  #include "PortugolLexer.hpp"
+
+  #include <antlr/TokenBuffer.hpp>
+  #include <antlr/CommonAST.hpp>
+
+  #include <iostream>
+
+  #include "UnicodeCharBuffer.hpp"
+  #include "UnicodeCharScanner.hpp"
+
+  using namespace std;
+  using namespace antlr;
+}
+
+
+options {
+  language="Cpp";
+}
+
+class LangTestLexer extends Lexer("UnicodeCharScanner");
+options {
+  k=2;
+  genHashLines   = false;
+  testLiterals   = false;
+  noConstructors = true;
+  buildAST       = true;
+  ASTLabelType   = "TestAST";
+}
+
+{
+public:
+  LangTestLexer(std::istream& in)
+   : UnicodeCharScanner(new UnicodeCharBuffer(in), true)
+    {
+      initLiterals();
+    }
+}
+
+T_VIRGULA
+  : ','
+  ;
+
+T_DOIS_PONTOS
+  : ':'
+  ;
+
+T_ABRE_PAREN
+  : '('
+  ;
+
+T_FECHA_PAREN
+  : ')'
+  ;
+
+T_ABRE_CHAVE
+  : '['
+  ;
+
+T_FECHA_CHAVE
+  : ']'
+  ;
+
+T_TOKEN_NAME
+options {
+  testLiterals = true;
+}
+  : ('a'..'z' | 'A'..'Z' | '0'..'9' | '_'
+    | '\u00C0' .. '\u00FF' /* latim-1 */)+
+  ;
+
+T_TEXTO_LITERAL
+  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | T_ESCAPE )* '"'!
+  ;
+
+T_CODIGO
+  : '{'!
+
+    (
+        options { generateAmbigWarnings=false; } :
+        '\n'                     {newline();}
+      | ~('}')
+    )*
+
+    '}'!
+  ;
+
+
+T_ESPACO :
+  (   ' '
+    | '\t'
+    | '\n' { newline(); }
+    | '\r'
+  )
+  { $setType(antlr::Token::SKIP); }
+  ;
+
+COMENTARIO_CPP
+  : "//" (~('\n'))* ('\n')?
+    {
+      newline();
+      $setType(antlr::Token::SKIP);
+    }
+  ;
+
+COMENTARIO_C
+{int line = getLine();}
+  : "/*"
+    (
+      options { generateAmbigWarnings=false; } :
+        '\n'                     {newline();}
+      | ('\r' '\n')=> '\r' '\n'  {newline();}
+      | '\r'                     {newline();}
+      |~('*'|'\n'|'\r')
+      | ('*' ~'/' )=> '*'
+    )*
+    "*/"
+    {$setType(antlr::Token::SKIP);}
+  ;
+
+protected
+T_ESCAPE
+  : '\\' .
+  ;
+
+protected
+T_ETC
+  : . {
+        $setType(antlr::Token::SKIP);
+        cerr << "Letra inv?lida: " <<  $getText << endl;
+      }
+  ;
+
+
+//***************************************************************
+
+
+class LangTestParser extends Parser;
+options {
+  k=2;
+  genHashLines = false;
+}
+
+{
+private:
+  string searchToken(int token) {
+    #include "tokenNames.hpp"
+    if (token >= 4) {
+      return tokenNames[token];
+    } else {
+      return "EOF";
+    }
+  }
+}
+
+teste_desc
+  : bloco EOF
+  ;
+
+bloco
+  : "teste" codigo:T_CODIGO
+
+    {
+      stringstream fi(codigo->getText());
+      PortugolLexer lexer(fi, true);
+      PortugolParser parser(lexer,false);
+
+      antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,
+                                      &antlr::CommonAST::factory);
+      parser.initializeASTFactory(ast_factory);
+      parser.setASTFactory(&ast_factory);
+
+      try {
+        parser.programa();
+      } catch ( ... ) {
+        cerr << "Houveram erros...\n";
+      }
+
+      RefAST root = parser.getAST();
+
+      RefCommonAST cast = antlr::RefCommonAST(root);
+
+      if (cast) {
+        std::cerr << cast->toStringList() << std::endl << std::endl;
+      } else {
+        cerr << "no tree!\n";
+      }
+    }
+
+    (erros)? (ast[root])? "fim" (bloco)?
+  ;
+
+erros
+  : "erros" T_DOIS_PONTOS T_ABRE_CHAVE (T_TOKEN_NAME)* T_FECHA_CHAVE
+  ;
+
+ast[RefAST node]
+  : "ast" T_DOIS_PONTOS lista[node]
+  ;
+
+/*
+TODO:
+  Se "ast: ()" omitir n?s, este parser n?o saber?.
+
+  -Criar a AST do "ast ()" e, ao final, comparar com
+    ast->equalsList(other)
+*/
+
+lista[RefAST node]
+{
+  RefAST child;
+  if (node != nullAST) child = node->getFirstChild();
+}
+
+  : T_ABRE_PAREN atomo[node] (cdr[child])? T_FECHA_PAREN
+  ;
+
+cdr[RefAST node]
+{
+  RefAST sib;
+  if (node != nullAST) sib = node->getNextSibling();
+}
+  : (lista[node] | atomo[node])
+    (irmao[sib] {if (sib != nullAST) sib = sib->getNextSibling();})*
+  ;
+
+irmao[RefAST node]
+  : lista[node]
+  | atomo[node]
+  ;
+
+atomo[RefAST node]
+  : tk:T_TOKEN_NAME
+      {
+        if (node == nullAST) {
+          cerr << "erro(ast) " << tk->getLine()
+                << ": esperando " << tk->getText() << " encontrado *null*\n";
+        } else if(tk->getText() != searchToken(node->getType())) {
+          cerr << "erro(ast) " << tk->getLine()
+               << ": esperando " << tk->getText()
+               << ", encontrado '" << searchToken(node->getType()) << "'\n";
+        }
+      }
+  ;
+

Added: trunk/gpt2/gptc/test/first.test
===================================================================
--- trunk/gpt2/gptc/test/first.test	2007-11-10 03:46:26 UTC (rev 356)
+++ trunk/gpt2/gptc/test/first.test	2007-11-13 15:53:03 UTC (rev 357)
@@ -0,0 +1,25 @@
+teste
+  {
+    in?cio
+      x := 2 + 3 * 5;
+    fim
+  }
+
+  erros: []
+
+  ast : ( T_INICIO
+          ( T_ATRIBUICAO T_IDENTIFICADOR
+            (T_MAIS T_INTEIRO_LITERAL
+              (T_MULTIP T_INTEIRO_LITERAL ) ) ) )
+
+fim
+
+
+teste
+  {
+      algoritmo teste;
+  }
+
+
+fim
+

Added: trunk/gpt2/gptc/test/tester.cpp
===================================================================
--- trunk/gpt2/gptc/test/tester.cpp	2007-11-10 03:46:26 UTC (rev 356)
+++ trunk/gpt2/gptc/test/tester.cpp	2007-11-13 15:53:03 UTC (rev 357)
@@ -0,0 +1,63 @@
+#include <stdio.h>
+#include "LangTestLexer.hpp"
+#include "LangTestParser.hpp"
+#include "LangTestLexerTokenTypes.hpp"
+#include <antlr/TokenBuffer.hpp>
+#include <antlr/CommonAST.hpp>
+#include <antlr/ANTLRException.hpp>
+#include <fstream>
+#include <iostream>
+
+using namespace std;
+
+void dump_tokens(char* fname) {
+  #include "tokenNames.hpp"
+  std::ifstream fi(fname);
+  LangTestLexer lexer(fi);
+  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
+
+  while (true) {
+    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
+              << tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
+    buffer->consume();
+    getchar();
+
+    if (buffer->LA(1) == LangTestLexerTokenTypes::EOF_) {
+      break;
+    }
+  }
+}
+
+void f(char* fname) {
+
+  std::ifstream fi(fname);
+  LangTestLexer lexer(fi);
+  LangTestParser parser(lexer);
+
+  parser.teste_desc();
+}
+
+int main(int argc, char** argv) {
+
+  if (argc < 2) {
+    std::cerr << "./tester <file.gpt>" << std::endl;
+    return 0;
+  }
+
+  try {
+//     dump_tokens(argv[1]);
+    f(argv[1]);
+	}
+  catch(antlr::ANTLRException& e)
+	{
+		cerr << "Parse exception: " << e.toString() << endl;
+		return -1;
+	}
+	catch(exception& e)
+	{
+		cerr << "exception: " << e.what() << endl;
+		return -1;
+	}
+
+  return 0;
+}



From gpt-commit-noreply at mail.berlios.de  Tue Nov 13 21:00:29 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 13 Nov 2007 21:00:29 +0100
Subject: [gpt-commit] r358 - trunk/gpt2/gptc/test
Message-ID: <200711132000.lADK0TpP015941@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-13 21:00:29 +0100 (Tue, 13 Nov 2007)
New Revision: 358

Added:
   trunk/gpt2/gptc/test/TestAST.cpp
   trunk/gpt2/gptc/test/TestAST.hpp
   trunk/gpt2/gptc/test/test.example
Removed:
   trunk/gpt2/gptc/test/first.test
Modified:
   trunk/gpt2/gptc/test/Makefile
   trunk/gpt2/gptc/test/compiler_test.g
   trunk/gpt2/gptc/test/tester.cpp
Log:
-Agora, a estrutura de testes para verificacao de ASTs parece estar funcionando. O arquivo test.example tem um exemplo de descricao de testes. Verificacao de erros nao esta funcionando ainda, mas a ideia eh verificar o codigo identificador de cada erro que o compilador gptc emitir, listando os codigos de erro na secao "erros" de cada teste no arquivo de descricao de testes.

Modified: trunk/gpt2/gptc/test/Makefile
===================================================================
--- trunk/gpt2/gptc/test/Makefile	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/Makefile	2007-11-13 20:00:29 UTC (rev 358)
@@ -1,12 +1,12 @@
 output = ./obj
 
 objects = $(output)/LangTestLexer.o $(output)/LangTestParser.o \
-					$(output)/tester.o
+          $(output)/TestAST.o $(output)/tester.o
 
 other = ../obj/PortugolLexer.o ../obj/PortugolParser.o \
 				../obj/MismatchedUnicodeCharException.o
 
-cpp = g++ -I$(output) -I. -I../ -I../obj
+cpp = g++ -g3 -I$(output) -I. -I../ -I../obj
 
 $(output)/tester: $(output) $(objects)
 	$(cpp) -o $(output)/tester $(objects) $(other) /usr/local/lib/libantlr.a
@@ -14,26 +14,36 @@
 $(output):
 	mkdir -p $(output)
 
-$(output)/LangTestLexer.o: $(output)/LangTestLexer.hpp $(output)/LangTestLexer.cpp
+$(output)/LangTestLexer.o: $(output)/LangTestLexer.hpp \
+		$(output)/LangTestLexer.cpp
 	$(cpp) -c $(output)/LangTestLexer.cpp -o $(output)/LangTestLexer.o
 
-$(output)/LangTestParser.o: $(output)/LangTestParser.hpp $(output)/LangTestParser.cpp
+$(output)/LangTestParser.o: $(output)/LangTestParser.hpp \
+		$(output)/LangTestParser.cpp
 	$(cpp) -c $(output)/LangTestParser.cpp -o $(output)/LangTestParser.o
 
-$(output)/tester.o: tester.cpp
+$(output)/tester.o: tester.cpp $(output)/testTokenNames.hpp
 	$(cpp) -c tester.cpp -o $(output)/tester.o
 
+$(output)/TestAST.o: TestAST.cpp TestAST.hpp
+	$(cpp) -c TestAST.cpp -o $(output)/TestAST.o
+
 $(output)/LangTestLexer.hpp $(output)/LangTestLexer.cpp \
 $(output)/LangTestParser.hpp $(output)/LangTestParser.cpp: compiler_test.g
 	antlr -o $(output) compiler_test.g
 
 
-# $(output)/table.hpp:
-# 	grep = $(output)/LangTestLexerTokenTypes.txt > $(output)/table.hpp
-# 	sed -i -e 's/([^=]*)//' $(output)/table.hpp
-# 	sed -i -e 's/"[^"]*"//' $(output)/table.hpp
-# 	sed -i -e 's/==/=/' $(output)/table.hpp
-# 	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' $(output)/table.hpp
+$(output)/testTokenNames.hpp: $(output)/LangTestLexerTokenTypes.txt
+	echo "std::map<int, std::string > testTokenNames;"  \
+		> $(output)/testTokenNames.hpp
+	grep '=' $(output)/LangTestLexerTokenTypes.txt \
+		>> $(output)/testTokenNames.hpp
+	sed -i -e 's/([^=]*)//' $(output)/testTokenNames.hpp
+	sed -i -e 's/"[^"]*"//' $(output)/testTokenNames.hpp
+	sed -i -e 's/==/=/' $(output)/testTokenNames.hpp
+	sed -i -e 's/()//' $(output)/testTokenNames.hpp
+	sed -i -e 's/\([^=]*\)=\(.*\)/testTokenNames[\2]="\1";/' \
+		$(output)/testTokenNames.hpp
 
 
 clean:

Added: trunk/gpt2/gptc/test/TestAST.cpp
===================================================================
--- trunk/gpt2/gptc/test/TestAST.cpp	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/TestAST.cpp	2007-11-13 20:00:29 UTC (rev 358)
@@ -0,0 +1,111 @@
+#include "TestAST.hpp"
+#include <iostream>
+
+#include <map>
+#include <string>
+
+using namespace std;
+
+const char* const TestAST::TYPE_NAME = "TestAST";
+
+TestAST::TestAST()
+    : CommonAST()
+{
+
+}
+
+TestAST::TestAST( RefToken t )
+    : CommonAST(t)
+{
+}
+
+TestAST::TestAST( const CommonAST& other )
+    : CommonAST(other)
+{
+
+}
+
+TestAST::TestAST( const TestAST& other )
+    : CommonAST(other)
+{
+
+}
+
+TestAST::~TestAST()
+{}
+
+RefAST TestAST::clone( void ) const
+{
+  TestAST *ast = new TestAST( *this );
+  return RefAST(ast);
+}
+
+const char* TestAST::typeName( void ) const
+{
+  return TestAST::TYPE_NAME;
+}
+
+void TestAST::initialize( RefToken t )
+{
+  CommonAST::initialize(t);
+}
+
+RefAST TestAST::factory()
+{
+  return RefAST(new TestAST);
+}
+
+
+bool TestAST::equals(RefAST other) const
+{
+	if (!other) {
+		return false;
+  }
+
+  #include "tokenNames.hpp"
+
+  int token = -1;
+  std::map<int, std::string >::iterator it;
+  for (it = tokenNames.begin(); it != tokenNames.end(); it++) {
+    if (it->second == getText()) {
+      token = it->first;
+    }
+  }
+
+  return token  == other->getType();
+}
+
+bool TestAST::equalsList(RefAST t) const
+{
+	// the empty tree is not a match of any non-null tree.
+	if (!t) {
+		return false;
+  }
+	// Otherwise, start walking sibling lists.  First mismatch, return false.
+	RefAST sibling=this;
+	for (;sibling && t;
+			sibling=sibling->getNextSibling(), t=t->getNextSibling()) {
+		// as a quick optimization, check roots first.
+		if (!sibling->equals(t)) {
+			return false;
+    }
+		// if roots match, do full list match test on children.
+		if (sibling->getFirstChild()) {
+			if (!sibling->getFirstChild()->equalsList(t->getFirstChild()))  {
+				return false;
+      }
+		}
+		// sibling has no kids, make sure t doesn't either
+		else if (t->getFirstChild()) {
+			return false;
+    }
+	}
+
+	if (!sibling && !t) {
+		return true;
+  } else if (!sibling && (t->getType() == 1)) {
+    return true;
+  }
+
+	return false;
+}

Added: trunk/gpt2/gptc/test/TestAST.hpp
===================================================================
--- trunk/gpt2/gptc/test/TestAST.hpp	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/TestAST.hpp	2007-11-13 20:00:29 UTC (rev 358)
@@ -0,0 +1,34 @@
+#ifndef TESTAST_HPP
+#define TESTAST_HPP
+
+#include <antlr/CommonAST.hpp>
+#include <string>
+
+using namespace std;
+using namespace antlr
+;
+class TestAST : public CommonAST {
+public:
+  TestAST();
+  TestAST(RefToken t );
+  TestAST(const CommonAST& other);
+  TestAST(const TestAST& other);
+
+  ~TestAST();
+
+  virtual RefAST clone( void ) const;
+
+  virtual void initialize( RefToken t );
+
+  virtual const char* typeName( void ) const;
+
+  virtual bool equals(RefAST t) const;
+  virtual bool equalsList(RefAST t) const;
+
+  static RefAST factory();
+  static const char* const TYPE_NAME;
+};
+
+typedef ASTRefCount<TestAST> RefTestAST;
+
+#endif

Modified: trunk/gpt2/gptc/test/compiler_test.g
===================================================================
--- trunk/gpt2/gptc/test/compiler_test.g	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/compiler_test.g	2007-11-13 20:00:29 UTC (rev 358)
@@ -1,32 +1,16 @@
-/*
-
-teste
-  caso {
-    algoritmo teste
-  }
-
-  ast: ([T_ALGORITMO,"algoritmo"] [T_IDENTIFICADOR,"teste"])
-  erros: [ES001] //ponto virgula
-fim
-
-Codigos de erros:
-
-EXXXX - Erro XXXX
-ESXXX - Erro Sintatico
-EMXXX - Erro Semantico
-
-
-*/
-
 header {
 
   #include "PortugolParser.hpp"
   #include "PortugolLexer.hpp"
 
+  #include "TestAST.hpp"
+
   #include <antlr/TokenBuffer.hpp>
   #include <antlr/CommonAST.hpp>
 
   #include <iostream>
+  #include <map>
+  #include <string>
 
   #include "UnicodeCharBuffer.hpp"
   #include "UnicodeCharScanner.hpp"
@@ -46,8 +30,6 @@
   genHashLines   = false;
   testLiterals   = false;
   noConstructors = true;
-  buildAST       = true;
-  ASTLabelType   = "TestAST";
 }
 
 {
@@ -160,20 +142,27 @@
 class LangTestParser extends Parser;
 options {
   k=2;
-  genHashLines = false;
+  genHashLines   = false;
+  buildAST       = true;
+  ASTLabelType   = "RefTestAST";
 }
 
-{
-private:
-  string searchToken(int token) {
-    #include "tokenNames.hpp"
-    if (token >= 4) {
-      return tokenNames[token];
-    } else {
-      return "EOF";
-    }
-  }
-}
+// {
+// private:
+//   int searchToken(string text) {
+//     #include "tokenNames.hpp"
+//     std::map<int, std::string >::iterator it;
+//     for (it = tokenNames.begin(); it != tokenNames.end(); it++) {
+//       if (it->second == text) {
+//         //return astFactory->create(it->first, "&test_empty");
+//         return it->first;
+//       }
+//     }
+//     cerr << "searchToken::leave2\n";
+// //     return astFactory->create(0, "&test_invalid");
+//     return it->first;
+//   }
+// }
 
 teste_desc
   : bloco EOF
@@ -187,81 +176,102 @@
       PortugolLexer lexer(fi, true);
       PortugolParser parser(lexer,false);
 
-      antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,
+      ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,
                                       &antlr::CommonAST::factory);
       parser.initializeASTFactory(ast_factory);
       parser.setASTFactory(&ast_factory);
 
-      try {
-        parser.programa();
-      } catch ( ... ) {
-        cerr << "Houveram erros...\n";
+      parser.programa();
+
+      if (parser.hasErorrs()) {
+        cerr << "Parser has errors!!\n";
       }
 
       RefAST root = parser.getAST();
 
       RefCommonAST cast = antlr::RefCommonAST(root);
 
-      if (cast) {
+/*      if (cast) {
         std::cerr << cast->toStringList() << std::endl << std::endl;
       } else {
         cerr << "no tree!\n";
-      }
+      }*/
     }
 
-    (erros)? (ast[root])? "fim" (bloco)?
+    (erros)?
+
+    (ast[root])?
+
+    "fim"
+
+    (bloco)?
   ;
 
-erros
+erros!
   : "erros" T_DOIS_PONTOS T_ABRE_CHAVE (T_TOKEN_NAME)* T_FECHA_CHAVE
   ;
 
-ast[RefAST node]
-  : "ast" T_DOIS_PONTOS lista[node]
+
+ast[RefAST gptRoot]
+  : tline:"ast"! T_DOIS_PONTOS! lista
+    {
+      int line = tline->getLine();
+      TestAST* tast = 0;
+      tast = RefTestAST(currentAST.root).get();
+
+      if (!tast->equalsList(gptRoot)) {
+        cerr << "-Erro na AST da linha [" << line << "]\n";
+        cerr << "Esperando: \n-----\n" << tast->toStringList() << endl;
+        cerr << "-----\nEncontrado: \n-----\n" << gptRoot->toStringList() << endl;
+        cerr << "-----\n";
+      }
+    }
   ;
 
-/*
-TODO:
-  Se "ast: ()" omitir n?s, este parser n?o saber?.
 
-  -Criar a AST do "ast ()" e, ao final, comparar com
-    ast->equalsList(other)
-*/
 
-lista[RefAST node]
-{
-  RefAST child;
-  if (node != nullAST) child = node->getFirstChild();
-}
+lista
 
-  : T_ABRE_PAREN atomo[node] (cdr[child])? T_FECHA_PAREN
+  : T_ABRE_PAREN!
+    T_TOKEN_NAME^  (cdr)*
+    T_FECHA_PAREN!
   ;
 
-cdr[RefAST node]
-{
-  RefAST sib;
-  if (node != nullAST) sib = node->getNextSibling();
-}
-  : (lista[node] | atomo[node])
-    (irmao[sib] {if (sib != nullAST) sib = sib->getNextSibling();})*
+cdr
+  : T_TOKEN_NAME
+  | lista
   ;
 
-irmao[RefAST node]
-  : lista[node]
-  | atomo[node]
+/*
+lista!
+{cerr << "lista::enter\n";}
+  : T_ABRE_PAREN t:T_TOKEN_NAME
+    {cerr << "lista::matched token\n";}
+    (c:cdr)? T_FECHA_PAREN
+    {
+      cerr << "lista::buildingAST\n";
+      #lista = #(searchToken(t->getText()),c);
+      {cerr << "lista::leave\n";}
+    }
   ;
 
-atomo[RefAST node]
-  : tk:T_TOKEN_NAME
+cdr
+{cerr << "cdr::enter\n";}
+  :  lista         (cdr)?
+  |! t:T_TOKEN_NAME
+    (
+      c:cdr
       {
-        if (node == nullAST) {
-          cerr << "erro(ast) " << tk->getLine()
-                << ": esperando " << tk->getText() << " encontrado *null*\n";
-        } else if(tk->getText() != searchToken(node->getType())) {
-          cerr << "erro(ast) " << tk->getLine()
-               << ": esperando " << tk->getText()
-               << ", encontrado '" << searchToken(node->getType()) << "'\n";
-        }
+        cerr << "cdr::buildingAST\n";
+        #cdr = #(searchToken(t->getText()),c);
+        cerr << "cdr::leaving\n";
       }
-  ;
 
+      |
+        {
+          cerr << "cdr::building2\n";
+          #cdr = (#t);
+          cerr << "cdr::leaving2\n";
+        }
+    )
+  ;*/

Deleted: trunk/gpt2/gptc/test/first.test
===================================================================
--- trunk/gpt2/gptc/test/first.test	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/first.test	2007-11-13 20:00:29 UTC (rev 358)
@@ -1,25 +0,0 @@
-teste
-  {
-    in?cio
-      x := 2 + 3 * 5;
-    fim
-  }
-
-  erros: []
-
-  ast : ( T_INICIO
-          ( T_ATRIBUICAO T_IDENTIFICADOR
-            (T_MAIS T_INTEIRO_LITERAL
-              (T_MULTIP T_INTEIRO_LITERAL ) ) ) )
-
-fim
-
-
-teste
-  {
-      algoritmo teste;
-  }
-
-
-fim
-

Added: trunk/gpt2/gptc/test/test.example
===================================================================
--- trunk/gpt2/gptc/test/test.example	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/test.example	2007-11-13 20:00:29 UTC (rev 358)
@@ -0,0 +1,42 @@
+teste
+  {
+    in?cio
+      x := 2 + 3 * 5;
+    fim
+  }
+
+  erros: []
+
+  ast : (T_INICIO
+          (T_ATRIBUICAO T_IDENTIFICADOR
+            (T_MAIS T_INTEIRO_LITERAL
+              (T_MULTIP T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))
+
+fim
+
+teste
+  {
+      algoritmo teste;
+
+      fun??o f() : inteiro
+      in?cio
+        x := 2;
+      fim
+  }
+
+  ast : (T_FUNCAO T_IDENTIFICADOR T_INTEIRO
+          (T_INICIO
+            (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL)))
+
+fim
+
+teste
+  {
+      fun??o f() : inteiro
+      in?cio
+      fim
+  }
+
+  ast : (T_OPS)
+
+fim

Modified: trunk/gpt2/gptc/test/tester.cpp
===================================================================
--- trunk/gpt2/gptc/test/tester.cpp	2007-11-13 15:53:03 UTC (rev 357)
+++ trunk/gpt2/gptc/test/tester.cpp	2007-11-13 20:00:29 UTC (rev 358)
@@ -2,23 +2,28 @@
 #include "LangTestLexer.hpp"
 #include "LangTestParser.hpp"
 #include "LangTestLexerTokenTypes.hpp"
+#include "TestAST.hpp"
 #include <antlr/TokenBuffer.hpp>
 #include <antlr/CommonAST.hpp>
 #include <antlr/ANTLRException.hpp>
 #include <fstream>
 #include <iostream>
 
+#include <map>
+#include <string>
+
 using namespace std;
+using namespace antlr;
 
 void dump_tokens(char* fname) {
-  #include "tokenNames.hpp"
-  std::ifstream fi(fname);
+  #include "testTokenNames.hpp"
+  ifstream fi(fname);
   LangTestLexer lexer(fi);
-  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
+  TokenBuffer *buffer = new TokenBuffer(lexer);
 
   while (true) {
-    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
-              << tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
+    cerr << lexer.getLine() << ": [" << buffer->LA(1) << "] "
+              << testTokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
     buffer->consume();
     getchar();
 
@@ -28,27 +33,56 @@
   }
 }
 
-void f(char* fname) {
+RefAST dump_tree(char* fname) {
 
   std::ifstream fi(fname);
   LangTestLexer lexer(fi);
   LangTestParser parser(lexer);
 
+  ASTFactory ast_factory(TestAST::TYPE_NAME,&TestAST::factory);
+  parser.initializeASTFactory(ast_factory);
+  parser.setASTFactory(&ast_factory);
+
   parser.teste_desc();
+
+  RefAST ast    = parser.getAST();
+  RefCommonAST cast = RefCommonAST(ast);
+
+  if (!cast) {
+    cerr << "no parse tree!" << endl;
+  } else {
+    cerr << cast->toStringList() << endl << endl;
+  }
+  return ast;
 }
 
+void f(char* fname) {
+
+  ifstream fi(fname);
+  LangTestLexer lexer(fi);
+  LangTestParser parser(lexer);
+
+  ASTFactory ast_factory(TestAST::TYPE_NAME,&TestAST::factory);
+  parser.initializeASTFactory(ast_factory);
+  parser.setASTFactory(&ast_factory);
+
+  parser.teste_desc();
+}
+
 int main(int argc, char** argv) {
 
   if (argc < 2) {
-    std::cerr << "./tester <file.gpt>" << std::endl;
+    cerr << "./tester <file.gpt>" << endl;
     return 0;
   }
 
+//   DEBUG_PARSER = true;
   try {
 //     dump_tokens(argv[1]);
     f(argv[1]);
+//     dump_tree(argv[1]);
 	}
-  catch(antlr::ANTLRException& e)
+  catch(ANTLRException& e)
 	{
 		cerr << "Parse exception: " << e.toString() << endl;
 		return -1;



From gpt-commit-noreply at mail.berlios.de  Tue Nov 13 21:04:01 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 13 Nov 2007 21:04:01 +0100
Subject: [gpt-commit] r359 - trunk/gpt2/gptc
Message-ID: <200711132004.lADK41hN016301@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-13 21:04:01 +0100 (Tue, 13 Nov 2007)
New Revision: 359

Modified:
   trunk/gpt2/gptc/Makefile
   trunk/gpt2/gptc/parser.g
   trunk/gpt2/gptc/teste.cpp
Log:
-Adicionado codigo para suprimir mensagens de erro, para que os testes nao os mostrem.

Modified: trunk/gpt2/gptc/Makefile
===================================================================
--- trunk/gpt2/gptc/Makefile	2007-11-13 20:00:29 UTC (rev 358)
+++ trunk/gpt2/gptc/Makefile	2007-11-13 20:04:01 UTC (rev 359)
@@ -32,7 +32,7 @@
 	$(cpp) -c MismatchedUnicodeCharException.cpp \
 	-o $(output)/MismatchedUnicodeCharException.o
 
-$(output)/teste.o: teste.cpp $(output)/table.hpp
+$(output)/teste.o: teste.cpp $(output)/tokenNames.hpp
 	$(cpp) -c teste.cpp -o $(output)/teste.o
 
 $(output)/PortugolLexer.hpp $(output)/PortugolLexer.cpp: lexer.g
@@ -44,12 +44,15 @@
 $(output)/SemanticWalker.hpp $(output)/SemanticWalker.cpp: semantic.g
 	antlr -o $(output) semantic.g
 
-$(output)/table.hpp:
-	grep = $(output)/PortugolTokenTypes.txt > $(output)/table.hpp
-	sed -i -e 's/([^=]*)//' $(output)/table.hpp
-	sed -i -e 's/"[^"]*"//' $(output)/table.hpp
-	sed -i -e 's/==/=/' $(output)/table.hpp
-	sed -i -e 's/\([^=]*\)=\(.*\)/table[\2]="\1";/' $(output)/table.hpp
+$(output)/tokenNames.hpp:
+	echo "std::map<int, std::string > tokenNames;"  > $(output)/tokenNames.hpp
+	grep = $(output)/PortugolTokenTypes.txt >> $(output)/tokenNames.hpp
+	sed -i -e 's/([^=]*)//' $(output)/tokenNames.hpp
+	sed -i -e 's/"[^"]*"//' $(output)/tokenNames.hpp
+	sed -i -e 's/==/=/' $(output)/tokenNames.hpp
+	sed -i -e 's/()//' $(output)/tokenNames.hpp
+	sed -i -e 's/\([^=]*\)=\(.*\)/tokenNames[\2]="\1";/' \
+		$(output)/tokenNames.hpp
 
 
 clean:

Modified: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-13 20:00:29 UTC (rev 358)
+++ trunk/gpt2/gptc/parser.g	2007-11-13 20:04:01 UTC (rev 359)
@@ -17,6 +17,11 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
 
+header {
+#include <antlr/NoViableAltException.hpp>
+#include <antlr/SemanticException.hpp>
+  using namespace antlr;
+}
 
 options {
   language="Cpp";
@@ -24,12 +29,53 @@
 
 class PortugolParser extends Parser;
 options {
-  importVocab  = Portugol;
-  genHashLines = false;
-  buildAST     = true;
+  importVocab    = Portugol;
+  genHashLines   = false;
+  buildAST       = true;
+  noConstructors = true;
 }
 
 {
+public:
+  PortugolParser(antlr::TokenBuffer& tokenBuf, bool report = true)
+  : antlr::LLkParser(tokenBuf,1), _reportErrors(report), _hasErrors(false)
+  {
+  }
+
+  PortugolParser(antlr::TokenStream& lexer, bool report = true)
+  : antlr::LLkParser(lexer,1), _reportErrors(report), _hasErrors(false)
+  {
+  }
+
+  void reportError(const RecognitionException& ex) {
+    _hasErrors = true;
+    if (!_reportErrors) return;
+    std::cerr << ex.toString().c_str() << std::endl;
+  }
+
+  void reportError(const std::string& s) {
+    _hasErrors = true;
+    if (!_reportErrors) return;
+    if (getFilename() == "") {
+      std::cerr << "error: " << s.c_str() << std::endl;
+    } else {
+      std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
+    }
+  }
+
+  void reportWarning(const std::string& s) {
+    if (!_reportErrors) return;
+    if (getFilename() == "") {
+      std::cerr << "warning: " << s.c_str() << std::endl;
+    } else {
+      std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
+    }
+  }
+
+  bool hasErorrs() {
+    return _hasErrors;
+  }
+
 private:
   void createRootNode(antlr::ASTPair& ast, antlr::RefToken token) {
     astFactory->makeASTRoot(ast, astFactory->create(token));
@@ -50,6 +96,9 @@
   antlr::RefAST createNode(int type, const std::string& txt) {
     return astFactory->create(type, txt);
   }
+
+  bool _reportErrors;
+  bool _hasErrors;
 }
 
 

Modified: trunk/gpt2/gptc/teste.cpp
===================================================================
--- trunk/gpt2/gptc/teste.cpp	2007-11-13 20:00:29 UTC (rev 358)
+++ trunk/gpt2/gptc/teste.cpp	2007-11-13 20:04:01 UTC (rev 359)
@@ -9,15 +9,14 @@
 #include <fstream>
 
 void dump_tokens(char* fname) {
-  char *table[200];
-  #include "table.hpp"
+  #include "tokenNames.hpp"
   std::ifstream fi(fname);
   PortugolLexer lexer(fi, true);
   antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
 
   while (true) {
     std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
-              << table[buffer->LA(1)] << " (" << lexer.getText() << ")";
+              << tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
     buffer->consume();
     getchar();
 



From gpt-commit-noreply at mail.berlios.de  Tue Nov 13 21:08:59 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 13 Nov 2007 21:08:59 +0100
Subject: [gpt-commit] r360 - trunk/gpt2/gptc
Message-ID: <200711132008.lADK8xJf016811@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-13 21:08:59 +0100 (Tue, 13 Nov 2007)
New Revision: 360

Added:
   trunk/gpt2/gptc/compiler_test/
Removed:
   trunk/gpt2/gptc/test/
Log:
nomsg

Copied: trunk/gpt2/gptc/compiler_test (from rev 359, trunk/gpt2/gptc/test)



From gpt-commit-noreply at mail.berlios.de  Tue Nov 13 21:14:30 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 13 Nov 2007 21:14:30 +0100
Subject: [gpt-commit] r361 - in trunk/gpt2/gptc/compiler_test: . tests
Message-ID: <200711132014.lADKEU52017035@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-13 21:14:30 +0100 (Tue, 13 Nov 2007)
New Revision: 361

Added:
   trunk/gpt2/gptc/compiler_test/tests/
   trunk/gpt2/gptc/compiler_test/tests/ast.test
Log:
DEVNULL:-Adicionando teste de AST

Added: trunk/gpt2/gptc/compiler_test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-13 20:08:59 UTC (rev 360)
+++ trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-13 20:14:30 UTC (rev 361)
@@ -0,0 +1,6 @@
+teste
+  {}
+
+  ast :
+fim
+



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 17:47:46 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 17:47:46 +0100
Subject: [gpt-commit] r362 - trunk/gpt2/gptc
Message-ID: <200711141647.lAEGljjG016283@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 17:47:45 +0100 (Wed, 14 Nov 2007)
New Revision: 362

Modified:
   trunk/gpt2/gptc/parser.g
Log:
-Definindo o root como T_ALGORITMO

Modified: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-13 20:14:30 UTC (rev 361)
+++ trunk/gpt2/gptc/parser.g	2007-11-14 16:47:45 UTC (rev 362)
@@ -81,8 +81,8 @@
     astFactory->makeASTRoot(ast, astFactory->create(token));
   }
 
-  void createRootNode(antlr::ASTPair& ast, int token) {
-    astFactory->makeASTRoot(ast, astFactory->create(token));
+  void createRootNode(antlr::ASTPair& ast, int token, std::string txt = "") {
+    astFactory->makeASTRoot(ast, astFactory->create(token, txt));
   }
 
   void addChildNode(antlr::ASTPair& ast, antlr::RefToken token) {
@@ -108,6 +108,8 @@
 //####################################
 
 programa
+{createRootNode(currentAST, T_ALGORITMO, "&algoritmo");}
+
   : (declaracao_algoritmo)?
 
     (importacao)*



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 17:48:14 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 17:48:14 +0100
Subject: [gpt-commit] r363 - trunk/gpt2/gptc
Message-ID: <200711141648.lAEGmERF016462@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 17:48:14 +0100 (Wed, 14 Nov 2007)
New Revision: 363

Modified:
   trunk/gpt2/gptc/Makefile
Log:
nomsg

Modified: trunk/gpt2/gptc/Makefile
===================================================================
--- trunk/gpt2/gptc/Makefile	2007-11-14 16:47:45 UTC (rev 362)
+++ trunk/gpt2/gptc/Makefile	2007-11-14 16:48:14 UTC (rev 363)
@@ -7,28 +7,29 @@
 
 cpp = g++ -I$(output) -I.
 
-all: $(output) $(objects) $(output)/teste
-
-$(output)/teste:
+$(output)/teste: $(objects)
 	$(cpp) -o $(output)/teste $(objects) /usr/local/lib/libantlr.a
 
 $(output):
 	mkdir -p $(output)
 
-$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp
+$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp \
+		$(output)/PortugolLexer.cpp
 	$(cpp) -c $(output)/PortugolLexer.cpp -o $(output)/PortugolLexer.o
 
-$(output)/PortugolParser.o: $(output)/PortugolParser.hpp
+$(output)/PortugolParser.o: $(output)/PortugolParser.hpp \
+		$(output)/PortugolParser.cpp
 	$(cpp) -c $(output)/PortugolParser.cpp -o $(output)/PortugolParser.o
 
-$(output)/SemanticWalker.o: $(output)/BaseSemanticWalker.o \
-		$(output)/SemanticWalker.hpp
+$(output)/SemanticWalker.o: $(output)/SemanticWalker.hpp \
+		BaseSemanticWalker.hpp
 	$(cpp) -c $(output)/SemanticWalker.cpp -o $(output)/SemanticWalker.o
 
 $(output)/BaseSemanticWalker.o: BaseSemanticWalker.hpp BaseSemanticWalker.cpp
 	$(cpp) -c BaseSemanticWalker.cpp -o $(output)/BaseSemanticWalker.o
 
-$(output)/MismatchedUnicodeCharException.o:
+$(output)/MismatchedUnicodeCharException.o: \
+	MismatchedUnicodeCharException.cpp MismatchedUnicodeCharException.hpp
 	$(cpp) -c MismatchedUnicodeCharException.cpp \
 	-o $(output)/MismatchedUnicodeCharException.o
 



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 17:52:25 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 17:52:25 +0100
Subject: [gpt-commit] r364 - in trunk/gpt2/gptc/compiler_test: . tests
Message-ID: <200711141652.lAEGqP5b017746@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 17:52:24 +0100 (Wed, 14 Nov 2007)
New Revision: 364

Modified:
   trunk/gpt2/gptc/compiler_test/Makefile
   trunk/gpt2/gptc/compiler_test/compiler_test.g
   trunk/gpt2/gptc/compiler_test/tests/ast.test
Log:
DEVNULL:
-Fix na gramatica para parsear a AST
-Tentativa de melhorar a reportagem de erros
-Criacao do teste ast.test


Modified: trunk/gpt2/gptc/compiler_test/Makefile
===================================================================
--- trunk/gpt2/gptc/compiler_test/Makefile	2007-11-14 16:48:14 UTC (rev 363)
+++ trunk/gpt2/gptc/compiler_test/Makefile	2007-11-14 16:52:24 UTC (rev 364)
@@ -6,7 +6,7 @@
 other = ../obj/PortugolLexer.o ../obj/PortugolParser.o \
 				../obj/MismatchedUnicodeCharException.o
 
-cpp = g++ -g3 -I$(output) -I. -I../ -I../obj
+cpp = g++ -I$(output) -I. -I../ -I../obj
 
 $(output)/tester: $(output) $(objects)
 	$(cpp) -o $(output)/tester $(objects) $(other) /usr/local/lib/libantlr.a

Modified: trunk/gpt2/gptc/compiler_test/compiler_test.g
===================================================================
--- trunk/gpt2/gptc/compiler_test/compiler_test.g	2007-11-14 16:48:14 UTC (rev 363)
+++ trunk/gpt2/gptc/compiler_test/compiler_test.g	2007-11-14 16:52:24 UTC (rev 364)
@@ -83,6 +83,7 @@
     (
         options { generateAmbigWarnings=false; } :
         '\n'                     {newline();}
+      | '\\'! '}'
       | ~('}')
     )*
 
@@ -174,7 +175,7 @@
     {
       stringstream fi(codigo->getText());
       PortugolLexer lexer(fi, true);
-      PortugolParser parser(lexer,false);
+      PortugolParser parser(lexer, false);
 
       ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,
                                       &antlr::CommonAST::factory);
@@ -184,7 +185,7 @@
       parser.programa();
 
       if (parser.hasErorrs()) {
-        cerr << "Parser has errors!!\n";
+        cerr << "++++ Parser has errors+++++\n";
       }
 
       RefAST root = parser.getAST();
@@ -213,13 +214,13 @@
 
 
 ast[RefAST gptRoot]
-  : tline:"ast"! T_DOIS_PONTOS! lista
+  : tline:"ast"! T_DOIS_PONTOS! (lista)?
     {
       int line = tline->getLine();
       TestAST* tast = 0;
       tast = RefTestAST(currentAST.root).get();
 
-      if (!tast->equalsList(gptRoot)) {
+      if (tast && !tast->equalsList(gptRoot)) {
         cerr << "-Erro na AST da linha [" << line << "]\n";
         cerr << "Esperando: \n-----\n" << tast->toStringList() << endl;
         cerr << "-----\nEncontrado: \n-----\n" << gptRoot->toStringList() << endl;
@@ -233,7 +234,7 @@
 lista
 
   : T_ABRE_PAREN!
-    T_TOKEN_NAME^  (cdr)*
+    (T_TOKEN_NAME^  (cdr)*)?
     T_FECHA_PAREN!
   ;
 

Modified: trunk/gpt2/gptc/compiler_test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-14 16:48:14 UTC (rev 363)
+++ trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-14 16:52:24 UTC (rev 364)
@@ -1,6 +1,221 @@
+/*************** testes de prologo ****************************/
+
 teste
   {}
 
-  ast :
+  ast : ()
 fim
 
+teste
+  {
+    algoritmo teste;
+  }
+
+  ast : ()
+fim
+
+teste
+  {
+    use "bib1";
+  }
+
+  ast: (T_ALGORITMO (T_USE T_TEXTO_LITERAL))
+fim
+
+teste
+  {
+    use "bib1";
+    use "bib2";
+    use "bib3";
+  }
+
+  ast: (T_ALGORITMO
+        (T_USE T_TEXTO_LITERAL)
+        (T_USE T_TEXTO_LITERAL)
+        (T_USE T_TEXTO_LITERAL))
+fim
+
+
+
+
+
+/*************** testes de variaveis ****************************/
+
+
+
+teste
+  {
+    vari?vel x : inteiro;
+  }
+
+  ast: (T_ALGORITMO
+           (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR))
+fim
+
+teste
+  {
+    vari?vel x : T;
+  }
+
+  ast: (T_ALGORITMO
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR))
+
+fim
+
+teste
+  {
+    vari?vel x : literal := 10;
+  }
+
+  ast: (T_ALGORITMO
+         (T_VARIAVEL T_LITERAL T_IDENTIFICADOR
+           (T_VALOR T_INTEIRO_LITERAL)))
+fim
+
+teste
+  {
+    vari?vel x : matriz[] do tipo real;
+  }
+
+  ast: (T_ALGORITMO
+         (T_VARIAVEL (T_MATRIZ T_REAL T_NULO) T_IDENTIFICADOR))
+fim
+
+teste
+  {
+    vari?vel x : matriz[] do tipo caractere := ['6','5','4'];
+  }
+
+  ast: (T_ALGORITMO
+         (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO) T_IDENTIFICADOR
+           (T_VALOR
+             (T_VAL_MATRIZ
+                T_CARACTERE_LITERAL T_CARACTERE_LITERAL T_CARACTERE_LITERAL))))
+fim
+
+teste
+  {
+    vari?vel z : T;
+  }
+
+  ast: (T_ALGORITMO (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR))
+fim
+
+teste
+  {
+    vari?vel z : T := {chave := valor\};
+  }
+
+  ast: (T_ALGORITMO
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
+fim
+
+teste
+  {
+    vari?vel z : T := {chave := [1,2,3]\};
+  }
+
+  ast: (T_ALGORITMO
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_ESTRUTURA T_IDENTIFICADOR
+                (T_VAL_MATRIZ T_INTEIRO_LITERAL
+                              T_INTEIRO_LITERAL
+                              T_INTEIRO_LITERAL)))))
+fim
+
+teste
+  {
+    vari?vel z : matriz[1][2] do tipo T
+      := [{chave := valor\},
+          {ch:="valor"\},
+          {z:=verdadeiro\}];
+  }
+
+  ast: (T_ALGORITMO
+          (T_VARIAVEL
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+            T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_MATRIZ
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_TEXTO_LITERAL)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_VERDADEIRO)))))
+fim
+
+
+teste
+  {
+    vari?vel z : matriz[1][2] do tipo T
+      := [{chave := valor\},
+          {ch:="valor"\},
+          {z:=verdadeiro\}];
+  }
+
+  ast: (T_ALGORITMO
+          (T_VARIAVEL
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+            T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_MATRIZ
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_TEXTO_LITERAL)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_VERDADEIRO)))))
+fim
+
+teste
+  {
+    vari?veis
+      z : real;
+    fim-vari?veis
+  }
+
+  ast: (T_ALGORITMO (T_VARIAVEIS
+          (T_VARIAVEL T_REAL T_IDENTIFICADOR)))
+fim
+
+teste
+  {
+    vari?veis
+      z,K : real;
+    fim-vari?veis
+  }
+
+  ast: (T_ALGORITMO (T_VARIAVEIS
+          (T_VARIAVEL T_REAL T_IDENTIFICADOR T_IDENTIFICADOR)))
+fim
+
+teste
+  {
+    vari?veis
+      P : T;
+      i,j,k : matriz[1][2] do tipo T
+      := [{chave := valor\},
+          {ch:='a'\},
+          {z:=10.2\}];
+    fim-vari?veis
+  }
+
+  ast: (T_ALGORITMO
+        (T_VARIAVEIS
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+          (T_VARIAVEL
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+            T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_MATRIZ
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+fim
+
+
+teste
+  {
+    vari?vel z : T;
+  }
+fim
+
+
+/*************** testes de prologo ****************************/
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 19:14:24 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 19:14:24 +0100
Subject: [gpt-commit] r365 - trunk/gpt2/gptc
Message-ID: <200711141814.lAEIEO4O022572@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 19:14:23 +0100 (Wed, 14 Nov 2007)
New Revision: 365

Modified:
   trunk/gpt2/gptc/parser.g
Log:
-AST da definicao de constantes corrigida
-Adicao da sintaxe para parametro variavel nomeado

Modified: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-14 16:52:24 UTC (rev 364)
+++ trunk/gpt2/gptc/parser.g	2007-11-14 18:14:23 UTC (rev 365)
@@ -268,8 +268,8 @@
 declaracao_constante!
   : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
     l:lista_inicializacao T_PONTO_VIRGULA
-
-               {#declaracao_constante = #([T_CONSTANTE,"&const"], t,id,l);}
+               {#declaracao_constante =
+                    #([T_CONSTANTE,"&const"],t,id,([T_VALOR,"&valor"],l));}
   ;
 
 
@@ -291,6 +291,7 @@
 //##    Declara??o de Subrotinas    ##
 //####################################
 
+
 declaracao_subrotina
   : declaracao_funcao
   | declaracao_procedimento
@@ -315,7 +316,8 @@
   ;
 
 param_reticencias!
-  : ret:T_RETICENCIAS     {#param_reticencias = #([T_VARIAVEL,"&param"],ret);}
+  : ret:T_RETICENCIAS id:T_IDENTIFICADOR
+                       {#param_reticencias = #([T_VARIAVEL,"&param"],ret,id);}
   ;
 
 parametro!



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 19:16:16 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 19:16:16 +0100
Subject: [gpt-commit] r366 - trunk/gpt2/gptc/compiler_test
Message-ID: <200711141816.lAEIGGND023280@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 19:16:14 +0100 (Wed, 14 Nov 2007)
New Revision: 366

Modified:
   trunk/gpt2/gptc/compiler_test/TestAST.cpp
Log:
SILENT:
-Corrigido comparacao de nohs EOF

Modified: trunk/gpt2/gptc/compiler_test/TestAST.cpp
===================================================================
--- trunk/gpt2/gptc/compiler_test/TestAST.cpp	2007-11-14 18:14:23 UTC (rev 365)
+++ trunk/gpt2/gptc/compiler_test/TestAST.cpp	2007-11-14 18:16:14 UTC (rev 366)
@@ -72,6 +72,11 @@
     }
   }
 
+  if (token == -1) {
+    cerr << "\n\n[TestAST::equals] ops: token n?o encontrado: "
+         << getText() << endl << endl;
+  }
+
   return token  == other->getType();
 }
 
@@ -96,16 +101,15 @@
       }
 		}
 		// sibling has no kids, make sure t doesn't either
-		else if (t->getFirstChild()) {
+		else if (t->getFirstChild() && t->getFirstChild()->getType() != 1) {//1==eof
 			return false;
     }
 	}
 
 	if (!sibling && !t) {
 		return true;
-  } else if (!sibling && (t->getType() == 1)) {
+  } else if (!sibling && (t->getType() == 1)) {//1==eof
     return true;
   }
-
 	return false;
 }



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 19:18:09 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 19:18:09 +0100
Subject: [gpt-commit] r367 - trunk/gpt2/gptc/compiler_test
Message-ID: <200711141818.lAEII9lI027326@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 19:18:09 +0100 (Wed, 14 Nov 2007)
New Revision: 367

Modified:
   trunk/gpt2/gptc/compiler_test/compiler_test.g
Log:
nomsg

Modified: trunk/gpt2/gptc/compiler_test/compiler_test.g
===================================================================
--- trunk/gpt2/gptc/compiler_test/compiler_test.g	2007-11-14 18:16:14 UTC (rev 366)
+++ trunk/gpt2/gptc/compiler_test/compiler_test.g	2007-11-14 18:18:09 UTC (rev 367)
@@ -220,6 +220,13 @@
       TestAST* tast = 0;
       tast = RefTestAST(currentAST.root).get();
 
+      if (!tast && gptRoot) {
+        cerr << "-Erro na AST da linha [" << line << "]\n";
+        cerr << "Esperando: \n-----\n()\n";
+        cerr << "-----\nEncontrado: \n-----\n" << gptRoot->toStringList() << endl;
+        cerr << "-----\n";
+      }
+
       if (tast && !tast->equalsList(gptRoot)) {
         cerr << "-Erro na AST da linha [" << line << "]\n";
         cerr << "Esperando: \n-----\n" << tast->toStringList() << endl;



From gpt-commit-noreply at mail.berlios.de  Wed Nov 14 19:18:34 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 14 Nov 2007 19:18:34 +0100
Subject: [gpt-commit] r368 - trunk/gpt2/gptc/compiler_test/tests
Message-ID: <200711141818.lAEIIYcr028785@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-14 19:18:33 +0100 (Wed, 14 Nov 2007)
New Revision: 368

Modified:
   trunk/gpt2/gptc/compiler_test/tests/ast.test
Log:
nomsg

Modified: trunk/gpt2/gptc/compiler_test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-14 18:18:09 UTC (rev 367)
+++ trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-14 18:18:33 UTC (rev 368)
@@ -1,17 +1,19 @@
-/*************** testes de prologo ****************************/
 
+
+/*************** prologo ****************************/
+
 teste
   {}
 
-  ast : ()
+  ast : (T_ALGORITMO)
 fim
 
 teste
   {
-    algoritmo teste;
+    algoritmo ol?;
   }
 
-  ast : ()
+  ast : (T_ALGORITMO)
 fim
 
 teste
@@ -39,7 +41,7 @@
 
 
 
-/*************** testes de variaveis ****************************/
+/*************** variaveis ****************************/
 
 
 
@@ -64,7 +66,7 @@
 
 teste
   {
-    vari?vel x : literal := 10;
+    vari?vel p? : literal := 10;
   }
 
   ast: (T_ALGORITMO
@@ -74,11 +76,12 @@
 
 teste
   {
-    vari?vel x : matriz[] do tipo real;
+    vari?vel x : matriz[][][][1] do tipo real;
   }
 
   ast: (T_ALGORITMO
-         (T_VARIAVEL (T_MATRIZ T_REAL T_NULO) T_IDENTIFICADOR))
+         (T_VARIAVEL (T_MATRIZ T_REAL T_NULO T_NULO T_NULO T_INTEIRO_LITERAL)
+          T_IDENTIFICADOR))
 fim
 
 teste
@@ -95,6 +98,21 @@
 
 teste
   {
+    vari?vel x : matriz[][] do tipo caractere := [['6','5'],['4','3']];
+  }
+
+  ast: (T_ALGORITMO
+         (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO T_NULO) T_IDENTIFICADOR
+           (T_VALOR
+             (T_VAL_MATRIZ
+                (T_VAL_MATRIZ
+                  T_CARACTERE_LITERAL T_CARACTERE_LITERAL)
+                (T_VAL_MATRIZ
+                  T_CARACTERE_LITERAL T_CARACTERE_LITERAL)))))
+fim
+
+teste
+  {
     vari?vel z : T;
   }
 
@@ -103,12 +121,14 @@
 
 teste
   {
-    vari?vel z : T := {chave := valor\};
+    vari?vel z : T := {chave := valor, i:=2\};
   }
 
   ast: (T_ALGORITMO
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
-            (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
+            (T_VALOR (T_VAL_ESTRUTURA
+                        T_IDENTIFICADOR T_IDENTIFICADOR
+                        T_IDENTIFICADOR T_INTEIRO_LITERAL))))
 fim
 
 teste
@@ -125,6 +145,7 @@
                               T_INTEIRO_LITERAL)))))
 fim
 
+
 teste
   {
     vari?vel z : matriz[1][2] do tipo T
@@ -166,6 +187,27 @@
 
 teste
   {
+    vari?vel z : T := {chave := [1,2,3]\};
+    vari?vel x : matriz[] do tipo caractere := ['6','5','4'];
+    vari?vel z : T;
+  }
+
+  ast: (T_ALGORITMO
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_ESTRUTURA T_IDENTIFICADOR
+                (T_VAL_MATRIZ T_INTEIRO_LITERAL
+                              T_INTEIRO_LITERAL
+                              T_INTEIRO_LITERAL))))
+          (T_VARIAVEL (T_MATRIZ T_CARACTERE T_NULO) T_IDENTIFICADOR
+           (T_VALOR
+             (T_VAL_MATRIZ
+                T_CARACTERE_LITERAL T_CARACTERE_LITERAL T_CARACTERE_LITERAL)))
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR))
+fim
+
+teste
+  {
     vari?veis
       z : real;
     fim-vari?veis
@@ -213,9 +255,266 @@
 
 teste
   {
-    vari?vel z : T;
+    vari?vel x : inteiro;
+    vari?veis
+      P : T;
+      i,j,k : matriz[1][2] do tipo T
+      := [{chave := valor\},
+          {ch:='a'\},
+          {z:=10.2\}];
+    fim-vari?veis
+    vari?vel z : T := {chave := valor\};
   }
+
+  ast:  (T_ALGORITMO
+           (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+           (T_VARIAVEIS
+              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_VARIAVEL
+                  (T_MATRIZ T_IDENTIFICADOR
+                            T_INTEIRO_LITERAL
+                            T_INTEIRO_LITERAL)
+                  T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+                  (T_VALOR (T_VAL_MATRIZ
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
 fim
 
 
-/*************** testes de prologo ****************************/
\ No newline at end of file
+teste
+  {
+    algoritmo teste;
+    use "bib1";
+    use "bib2";
+
+    vari?vel x : inteiro;
+    vari?veis
+      P : T;
+      i,j,k : matriz[1][2] do tipo T
+      := [{chave := valor\},
+          {ch:='a'\},
+          {z:=10.2\}];
+    fim-vari?veis
+    vari?vel z : T := {chave := valor\};
+  }
+
+  ast:  (T_ALGORITMO
+           (T_USE T_TEXTO_LITERAL)
+           (T_USE T_TEXTO_LITERAL)
+           (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+           (T_VARIAVEIS
+              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_VARIAVEL
+                  (T_MATRIZ T_IDENTIFICADOR
+                            T_INTEIRO_LITERAL
+                            T_INTEIRO_LITERAL)
+                  T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+                  (T_VALOR (T_VAL_MATRIZ
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
+fim
+
+
+
+/*************** constantes ****************************/
+
+
+
+teste
+  {
+    constante x : inteiro := 10;
+  }
+
+  ast: (T_ALGORITMO
+          (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+            (T_VALOR T_INTEIRO_LITERAL)))
+fim
+
+
+teste
+  {
+    constante x : matriz[1] do tipo inteiro := [1,2,3];
+  }
+
+  ast: (T_ALGORITMO
+          (T_CONSTANTE
+            (T_MATRIZ T_INTEIRO T_INTEIRO_LITERAL) T_IDENTIFICADOR
+              (T_VALOR
+                (T_VAL_MATRIZ
+                  T_INTEIRO_LITERAL T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))
+fim
+
+teste
+  {
+    constante x : T := {c:=v,c:=10.3\};
+  }
+
+  ast: (T_ALGORITMO
+          (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_ESTRUTURA
+                T_IDENTIFICADOR T_IDENTIFICADOR
+                T_IDENTIFICADOR T_REAL_LITERAL))))
+fim
+
+teste
+  {
+    constante x : matriz[1] do tipo T := [{c:=1,c:=10.3\},{c:='1',c:="1"\}];
+  }
+
+  ast: (T_ALGORITMO
+          (T_CONSTANTE
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL) T_IDENTIFICADOR
+              (T_VALOR
+                (T_VAL_MATRIZ
+                  (T_VAL_ESTRUTURA
+                    T_IDENTIFICADOR T_INTEIRO_LITERAL
+                    T_IDENTIFICADOR T_REAL_LITERAL)
+                  (T_VAL_ESTRUTURA
+                    T_IDENTIFICADOR T_CARACTERE_LITERAL
+                    T_IDENTIFICADOR T_TEXTO_LITERAL)))))
+fim
+
+
+teste
+  {
+    constante x : inteiro := 10;
+    constante x : matriz[1] do tipo T := [{c:=1,c:=10.3\},{c:='1',c:="1"\}];
+  }
+
+  ast: (T_ALGORITMO
+         (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+            (T_VALOR T_INTEIRO_LITERAL))
+          (T_CONSTANTE
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL) T_IDENTIFICADOR
+              (T_VALOR
+                (T_VAL_MATRIZ
+                  (T_VAL_ESTRUTURA
+                    T_IDENTIFICADOR T_INTEIRO_LITERAL
+                    T_IDENTIFICADOR T_REAL_LITERAL)
+                  (T_VAL_ESTRUTURA
+                    T_IDENTIFICADOR T_CARACTERE_LITERAL
+                    T_IDENTIFICADOR T_TEXTO_LITERAL)))))
+fim
+
+teste
+  {
+    constantes
+      x : inteiro := 10;
+      i : matriz[1][2] do tipo T :=
+           [{chave := valor\},
+            {ch:='a'\},
+            {z:=10.2\}];
+    fim-constantes
+  }
+
+  ast : (T_ALGORITMO
+          (T_CONSTANTES
+            (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+                        (T_VALOR T_INTEIRO_LITERAL))
+          (T_CONSTANTE
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+             T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_MATRIZ
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+fim
+
+teste
+  {
+    constantes
+      x : inteiro := 10;
+      i : matriz[1][2] do tipo T :=
+           [{chave := valor\},
+            {ch:='a'\},
+            {z:=10.2\}];
+    fim-constantes
+    constante x : T := {c:=v,c:=10.3\};
+  }
+
+  ast : (T_ALGORITMO
+          (T_CONSTANTES
+            (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+                        (T_VALOR T_INTEIRO_LITERAL))
+          (T_CONSTANTE
+            (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+             T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_MATRIZ
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+                    (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
+            (T_VALOR
+              (T_VAL_ESTRUTURA
+                T_IDENTIFICADOR T_IDENTIFICADOR
+                T_IDENTIFICADOR T_REAL_LITERAL))))
+fim
+
+
+/*************** subprogramas ****************************/
+
+teste
+  {
+    procedimento p()
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR (T_INICIO)))
+fim
+
+teste
+  {
+    procedimento p(i:inteiro, t:T)
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR
+              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+            (T_INICIO)))
+fim
+
+teste
+  {
+    procedimento p(i:inteiro, t:T, ... resto)
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR
+              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_VARIAVEL T_RETICENCIAS T_IDENTIFICADOR)
+            (T_INICIO)))
+fim
+
+
+teste
+  {
+    procedimento p()
+      vari?vel x : inteiro;
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR
+              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_VARIAVEL T_RETICENCIAS T_IDENTIFICADOR)
+            (T_INICIO)))
+fim



From gpt-commit-noreply at mail.berlios.de  Fri Nov 16 05:01:21 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 16 Nov 2007 05:01:21 +0100
Subject: [gpt-commit] r369 - trunk/gpt2/gptc
Message-ID: <200711160401.lAG41L32031887@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-16 05:01:19 +0100 (Fri, 16 Nov 2007)
New Revision: 369

Modified:
   trunk/gpt2/gptc/lexer.g
   trunk/gpt2/gptc/parser.g
Log:
-AST precisa diferenciar entre nohs de variaveis locais e parametros
-Adicionando noh rotulado para tipo de retorno de funcao

Modified: trunk/gpt2/gptc/lexer.g
===================================================================
--- trunk/gpt2/gptc/lexer.g	2007-11-14 18:18:33 UTC (rev 368)
+++ trunk/gpt2/gptc/lexer.g	2007-11-16 04:01:19 UTC (rev 369)
@@ -100,6 +100,9 @@
 
   //imagin?rios para a AST
 
+  T_PARAM;
+  T_TIPO_RETORNO;
+
   T_VALOR;
   T_VAL_MATRIZ;    //valor da matriz    (literal [])
   T_VAL_ESTRUTURA; //valor da estrutura (literal {})

Modified: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-14 18:18:33 UTC (rev 368)
+++ trunk/gpt2/gptc/parser.g	2007-11-16 04:01:19 UTC (rev 369)
@@ -299,7 +299,7 @@
 
 declaracao_funcao
   : T_FUNCAO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo
+      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo_retorno
     (declaracao_constantes | declaracao_variaveis)*
     bloco_codigo
   ;
@@ -311,19 +311,23 @@
     bloco_codigo
   ;
 
+tipo_retorno!
+  : t:tipo {#tipo_retorno = #([T_TIPO_RETORNO,"&ret"],t);}
+  ;
+
 lista_parametros
   : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
   ;
 
 param_reticencias!
   : ret:T_RETICENCIAS id:T_IDENTIFICADOR
-                       {#param_reticencias = #([T_VARIAVEL,"&param"],ret,id);}
+                       {#param_reticencias = #([T_PARAM,"&param"],ret,id);}
   ;
 
 parametro!
   : ((c:T_CONSTANTE)? r:T_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
 
-                          {#parametro = #([T_VARIAVEL,"&param"],t,id,c,r);}
+                          {#parametro = #([T_PARAM,"&param"],t,id,c,r);}
   ;
 
 



From gpt-commit-noreply at mail.berlios.de  Fri Nov 16 05:01:49 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 16 Nov 2007 05:01:49 +0100
Subject: [gpt-commit] r370 - trunk/gpt2/gptc/compiler_test/tests
Message-ID: <200711160401.lAG41nD3031956@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-16 05:01:49 +0100 (Fri, 16 Nov 2007)
New Revision: 370

Modified:
   trunk/gpt2/gptc/compiler_test/tests/ast.test
Log:
nomsg

Modified: trunk/gpt2/gptc/compiler_test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-16 04:01:19 UTC (rev 369)
+++ trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-16 04:01:49 UTC (rev 370)
@@ -482,13 +482,28 @@
 
   ast : (T_ALGORITMO
           (T_PROCEDIMENTO T_IDENTIFICADOR
-              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
-              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_PARAM T_INTEIRO T_IDENTIFICADOR)
+              (T_PARAM T_IDENTIFICADOR T_IDENTIFICADOR)
             (T_INICIO)))
 fim
 
 teste
   {
+    procedimento p(i:inteiro, g: matriz[1][] do tipo real)
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR
+              (T_PARAM T_INTEIRO T_IDENTIFICADOR)
+              (T_PARAM
+                (T_MATRIZ T_REAL T_INTEIRO_LITERAL T_NULO) T_IDENTIFICADOR)
+            (T_INICIO)))
+fim
+
+teste
+  {
     procedimento p(i:inteiro, t:T, ... resto)
     in?cio
     fim
@@ -496,9 +511,9 @@
 
   ast : (T_ALGORITMO
           (T_PROCEDIMENTO T_IDENTIFICADOR
-              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
-              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
-              (T_VARIAVEL T_RETICENCIAS T_IDENTIFICADOR)
+              (T_PARAM T_INTEIRO T_IDENTIFICADOR)
+              (T_PARAM T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_PARAM T_RETICENCIAS T_IDENTIFICADOR)
             (T_INICIO)))
 fim
 
@@ -514,7 +529,182 @@
   ast : (T_ALGORITMO
           (T_PROCEDIMENTO T_IDENTIFICADOR
               (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+            (T_INICIO)))
+fim
+
+
+teste
+  {
+    procedimento p(i:inteiro, t:T)
+      vari?vel x : inteiro;
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_PROCEDIMENTO T_IDENTIFICADOR
+              (T_PARAM T_INTEIRO T_IDENTIFICADOR)
+              (T_PARAM T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+            (T_INICIO)))
+fim
+
+
+
+teste
+  {
+    fun??o f(i:inteiro, t:T, ... resto) : literal
+      vari?vel x : inteiro;
+      vari?veis
+        P : T;
+        i,j,k : matriz[1][2] do tipo T
+        := [{chave := valor\},
+            {ch:='a'\},
+            {z:=10.2\}];
+      fim-vari?veis
+      vari?vel z : T := {chave := valor\};
+    in?cio
+    fim
+  }
+
+  ast : (T_ALGORITMO
+          (T_FUNCAO T_IDENTIFICADOR
+              (T_PARAM T_INTEIRO T_IDENTIFICADOR)
+              (T_PARAM T_IDENTIFICADOR T_IDENTIFICADOR)
+              (T_PARAM T_RETICENCIAS T_IDENTIFICADOR)
+              (T_TIPO_RETORNO T_LITERAL)
+           (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+           (T_VARIAVEIS
               (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
-              (T_VARIAVEL T_RETICENCIAS T_IDENTIFICADOR)
+              (T_VARIAVEL
+                  (T_MATRIZ T_IDENTIFICADOR
+                            T_INTEIRO_LITERAL
+                            T_INTEIRO_LITERAL)
+                  T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+                  (T_VALOR (T_VAL_MATRIZ
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+             (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)))
             (T_INICIO)))
 fim
+
+
+
+
+
+/************** express?es *****************************/
+
+
+
+
+teste
+  {
+    vari?vel x : inteiro;
+    in?cio
+      x := 1 + 1;
+    fim
+  }
+
+  ast: (T_ALGORITMO
+         (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
+         (T_INICIO
+            (T_ATRIBUICAO T_IDENTIFICADOR
+              (T_MAIS T_INTEIRO_LITERAL T_INTEIRO_LITERAL))))
+fim
+
+teste
+  {
+    in?cio
+      x := 1 + 2 * 3;
+    fim
+  }
+
+  ast: (T_ALGORITMO
+         (T_INICIO
+            (T_ATRIBUICAO T_IDENTIFICADOR
+              (T_MAIS T_INTEIRO_LITERAL
+                (T_MULTIP T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))))
+fim
+
+
+
+
+/******************* enunciados **************************/
+
+teste
+  {
+    in?cio
+      para x de 0 at? 10 fa?a
+        para x de 0 at? 1 passo -1 fa?a
+          x := 1;
+        fim-para
+      fim-para
+
+      enquanto x > 10 / 3 fa?a
+        repita
+          se x % 2 <> 3 / 4 ent?o
+            f(x);
+          fim-se
+        at? 10 > 3
+      fim-enquanto
+
+      sair;
+
+      se verdadeiro ent?o
+        retorne a.b >> a[1];
+      sen?o
+        f((1+2)*3);
+      fim-se
+
+      caso x seja
+        "teste" fa?a
+          f(1);
+          x := 1;
+        fim-fa?a
+
+        1.0 fa?a
+          x := 1;
+        fim-fa?a
+
+        sen?o
+          x := 1;
+        fim-sen?o
+      fim-caso
+    fim
+  }
+
+  ast:
+(T_ALGORITMO
+  (T_INICIO
+    (T_PARA T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL
+      (T_PARA T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL
+            ( T_PASSO T_MENOS T_INTEIRO_LITERAL )
+        ( T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL ) ) )
+    (T_ENQUANTO
+      (T_MAIOR T_IDENTIFICADOR (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL))
+        (T_REPITA
+          (T_SE (T_DIFERENTE
+                  (T_MOD T_IDENTIFICADOR T_INTEIRO_LITERAL)
+                  (T_DIV T_INTEIRO_LITERAL T_INTEIRO_LITERAL))
+            (T_CALL T_IDENTIFICADOR T_IDENTIFICADOR))
+          T_ATE ( T_MAIOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)))
+    (T_SAIR)
+    (T_SE T_VERDADEIRO
+      (T_RETORNE (T_BIT_SHIFT_RIGHT
+                    (T_IDENTIFICADOR T_IDENTIFICADOR)
+                    (T_IDENTIFICADOR T_INTEIRO_LITERAL)))
+      T_SENAO (T_CALL T_IDENTIFICADOR (T_MULTIP
+                                      (T_MAIS T_INTEIRO_LITERAL
+                                              T_INTEIRO_LITERAL)
+                                       T_INTEIRO_LITERAL)))
+    (T_CASO T_IDENTIFICADOR
+      (T_TEXTO_LITERAL
+        (T_CALL T_IDENTIFICADOR T_INTEIRO_LITERAL)
+        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL))
+      (T_REAL_LITERAL
+        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL))
+      (T_SENAO
+        (T_ATRIBUICAO T_IDENTIFICADOR T_INTEIRO_LITERAL)))))
+fim
\ No newline at end of file



From gpt-commit-noreply at mail.berlios.de  Fri Nov 16 05:33:16 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 16 Nov 2007 05:33:16 +0100
Subject: [gpt-commit] r371 - in trunk/gpt2/gptc: . compiler_test/tests
Message-ID: <200711160433.lAG4XG8S000443@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-16 05:33:15 +0100 (Fri, 16 Nov 2007)
New Revision: 371

Modified:
   trunk/gpt2/gptc/compiler_test/tests/ast.test
   trunk/gpt2/gptc/parser.g
Log:
-Refatoracao da AST: removendo nodes T_VARIAVEIS e T_CONSTANTES

Modified: trunk/gpt2/gptc/compiler_test/tests/ast.test
===================================================================
--- trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-16 04:01:49 UTC (rev 370)
+++ trunk/gpt2/gptc/compiler_test/tests/ast.test	2007-11-16 04:33:15 UTC (rev 371)
@@ -39,8 +39,6 @@
 
 
 
-
-
 /*************** variaveis ****************************/
 
 
@@ -213,8 +211,8 @@
     fim-vari?veis
   }
 
-  ast: (T_ALGORITMO (T_VARIAVEIS
-          (T_VARIAVEL T_REAL T_IDENTIFICADOR)))
+  ast: (T_ALGORITMO
+          (T_VARIAVEL T_REAL T_IDENTIFICADOR))
 fim
 
 teste
@@ -224,8 +222,8 @@
     fim-vari?veis
   }
 
-  ast: (T_ALGORITMO (T_VARIAVEIS
-          (T_VARIAVEL T_REAL T_IDENTIFICADOR T_IDENTIFICADOR)))
+  ast: (T_ALGORITMO
+          (T_VARIAVEL T_REAL T_IDENTIFICADOR T_IDENTIFICADOR))
 fim
 
 teste
@@ -240,7 +238,6 @@
   }
 
   ast: (T_ALGORITMO
-        (T_VARIAVEIS
           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
           (T_VARIAVEL
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
@@ -249,7 +246,7 @@
               (T_VAL_MATRIZ
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
 fim
 
 
@@ -268,18 +265,18 @@
 
   ast:  (T_ALGORITMO
            (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
-           (T_VARIAVEIS
-              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
-              (T_VARIAVEL
-                  (T_MATRIZ T_IDENTIFICADOR
-                            T_INTEIRO_LITERAL
-                            T_INTEIRO_LITERAL)
-                  T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
-                  (T_VALOR (T_VAL_MATRIZ
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
-           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+           (T_VARIAVEL
+               (T_MATRIZ T_IDENTIFICADOR
+                         T_INTEIRO_LITERAL
+                         T_INTEIRO_LITERAL)
+               T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+               (T_VALOR
+                  (T_VAL_MATRIZ
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                      (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
+          (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
              (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
 fim
 
@@ -305,17 +302,16 @@
            (T_USE T_TEXTO_LITERAL)
            (T_USE T_TEXTO_LITERAL)
            (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
-           (T_VARIAVEIS
-              (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
-              (T_VARIAVEL
-                  (T_MATRIZ T_IDENTIFICADOR
-                            T_INTEIRO_LITERAL
-                            T_INTEIRO_LITERAL)
-                  T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
-                  (T_VALOR (T_VAL_MATRIZ
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+           (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+           (T_VARIAVEL
+               (T_MATRIZ T_IDENTIFICADOR
+                         T_INTEIRO_LITERAL
+                         T_INTEIRO_LITERAL)
+               T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+               (T_VALOR (T_VAL_MATRIZ
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                     (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
              (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR))))
 fim
@@ -415,8 +411,7 @@
   }
 
   ast : (T_ALGORITMO
-          (T_CONSTANTES
-            (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+          (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
                         (T_VALOR T_INTEIRO_LITERAL))
           (T_CONSTANTE
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
@@ -425,7 +420,7 @@
               (T_VAL_MATRIZ
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
 fim
 
 teste
@@ -441,8 +436,7 @@
   }
 
   ast : (T_ALGORITMO
-          (T_CONSTANTES
-            (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
+          (T_CONSTANTE T_INTEIRO T_IDENTIFICADOR
                         (T_VALOR T_INTEIRO_LITERAL))
           (T_CONSTANTE
             (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
@@ -451,7 +445,7 @@
               (T_VAL_MATRIZ
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
                 (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+                (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
                     (T_CONSTANTE T_IDENTIFICADOR T_IDENTIFICADOR
             (T_VALOR
               (T_VAL_ESTRUTURA
@@ -460,6 +454,39 @@
 fim
 
 
+
+/*************** estruturas ****************************/
+
+teste
+  {
+    estrutura T
+      P : T;
+      x : inteiro := 1;
+      i,j,k : matriz[1][2] do tipo T
+        := [{chave := valor\},
+            {ch:='a'\},
+            {z:=10.2\}];
+    fim-estrutura
+  }
+
+  ast: (T_ALGORITMO
+          (T_ESTRUTURA T_IDENTIFICADOR
+            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
+            (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR
+               (T_VALOR T_INTEIRO_LITERAL))
+            (T_VARIAVEL
+              (T_MATRIZ T_IDENTIFICADOR T_INTEIRO_LITERAL T_INTEIRO_LITERAL)
+              T_IDENTIFICADOR T_IDENTIFICADOR T_IDENTIFICADOR
+              (T_VALOR
+                (T_VAL_MATRIZ
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
+                  (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))))
+fim
+
+
+
+
 /*************** subprogramas ****************************/
 
 teste
@@ -574,7 +601,6 @@
               (T_PARAM T_RETICENCIAS T_IDENTIFICADOR)
               (T_TIPO_RETORNO T_LITERAL)
            (T_VARIAVEL T_INTEIRO T_IDENTIFICADOR)
-           (T_VARIAVEIS
               (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR)
               (T_VARIAVEL
                   (T_MATRIZ T_IDENTIFICADOR
@@ -584,7 +610,7 @@
                   (T_VALOR (T_VAL_MATRIZ
                         (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)
                         (T_VAL_ESTRUTURA T_IDENTIFICADOR T_CARACTERE_LITERAL)
-                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL)))))
+                        (T_VAL_ESTRUTURA T_IDENTIFICADOR T_REAL_LITERAL))))
            (T_VARIAVEL T_IDENTIFICADOR T_IDENTIFICADOR
              (T_VALOR (T_VAL_ESTRUTURA T_IDENTIFICADOR T_IDENTIFICADOR)))
             (T_INICIO)))

Modified: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-16 04:01:49 UTC (rev 370)
+++ trunk/gpt2/gptc/parser.g	2007-11-16 04:33:15 UTC (rev 371)
@@ -150,7 +150,7 @@
   ;
 
 bloco_declaracao_variaveis
-  : T_VARIAVEIS^ (declaracao_variavel)+ T_FIM_VARIAVEIS!
+  : T_VARIAVEIS! (declaracao_variavel)+ T_FIM_VARIAVEIS!
   ;
 
 declaracao_variavel!
@@ -262,7 +262,7 @@
   ;
 
 bloco_declaracao_constantes
-  : T_CONSTANTES^ (declaracao_constante)+ T_FIM_CONSTANTES!
+  : T_CONSTANTES! (declaracao_constante)+ T_FIM_CONSTANTES!
   ;
 
 declaracao_constante!



From gpt-commit-noreply at mail.berlios.de  Mon Nov 19 04:42:54 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 19 Nov 2007 04:42:54 +0100
Subject: [gpt-commit] r372 - trunk/gpt2/gptc
Message-ID: <200711190342.lAJ3gs0F026037@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-19 04:42:53 +0100 (Mon, 19 Nov 2007)
New Revision: 372

Modified:
   trunk/gpt2/gptc/lexer.g
Log:
-Token sobrando

Modified: trunk/gpt2/gptc/lexer.g
===================================================================
--- trunk/gpt2/gptc/lexer.g	2007-11-16 04:33:15 UTC (rev 371)
+++ trunk/gpt2/gptc/lexer.g	2007-11-19 03:42:53 UTC (rev 372)
@@ -108,7 +108,6 @@
   T_VAL_ESTRUTURA; //valor da estrutura (literal {})
 
   T_DIMENSOES;
-  T_NULL;
 
   T_UN_POSITIVO;
   T_UN_NEGATIVO;



From gpt-commit-noreply at mail.berlios.de  Mon Nov 19 04:48:21 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 19 Nov 2007 04:48:21 +0100
Subject: [gpt-commit] r373 - in trunk/gpt2/gptc: . src test
Message-ID: <200711190348.lAJ3mLud026223@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-19 04:48:19 +0100 (Mon, 19 Nov 2007)
New Revision: 373

Added:
   trunk/gpt2/gptc/src/
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/src/lexer.g
   trunk/gpt2/gptc/src/parser.g
   trunk/gpt2/gptc/src/semantic.g
   trunk/gpt2/gptc/src/teste.cpp
   trunk/gpt2/gptc/test/
Removed:
   trunk/gpt2/gptc/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/Makefile
   trunk/gpt2/gptc/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/compiler_test/
   trunk/gpt2/gptc/lexer.g
   trunk/gpt2/gptc/parser.g
   trunk/gpt2/gptc/semantic.g
   trunk/gpt2/gptc/test/Makefile
   trunk/gpt2/gptc/teste.cpp
Log:
-Re-estruturando diretorios / preparando para o build system

Deleted: trunk/gpt2/gptc/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/BaseSemanticWalker.cpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/BaseSemanticWalker.cpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,3 +0,0 @@
-#include "BaseSemanticWalker.hpp"
-
-

Deleted: trunk/gpt2/gptc/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/BaseSemanticWalker.hpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/BaseSemanticWalker.hpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,32 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef BASESEMANTICWALKER_H
-#define BASESEMANTICWALKER_H
-
-#include <antlr/TreeParser.hpp>
-
-class BaseSemanticWalker : public antlr::TreeParser {
-
-public:
-  BaseSemanticWalker() : antlr::TreeParser() {}
-};
-
-#endif

Deleted: trunk/gpt2/gptc/Makefile
===================================================================
--- trunk/gpt2/gptc/Makefile	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/Makefile	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,61 +0,0 @@
-output = ./obj
-
-objects = $(output)/PortugolLexer.o $(output)/PortugolParser.o \
-					$(output)/BaseSemanticWalker.o $(output)/SemanticWalker.o \
-					$(output)/teste.o $(output)/MismatchedUnicodeCharException.o
-
-
-cpp = g++ -I$(output) -I.
-
-$(output)/teste: $(objects)
-	$(cpp) -o $(output)/teste $(objects) /usr/local/lib/libantlr.a
-
-$(output):
-	mkdir -p $(output)
-
-$(output)/PortugolLexer.o: $(output)/PortugolLexer.hpp \
-		$(output)/PortugolLexer.cpp
-	$(cpp) -c $(output)/PortugolLexer.cpp -o $(output)/PortugolLexer.o
-
-$(output)/PortugolParser.o: $(output)/PortugolParser.hpp \
-		$(output)/PortugolParser.cpp
-	$(cpp) -c $(output)/PortugolParser.cpp -o $(output)/PortugolParser.o
-
-$(output)/SemanticWalker.o: $(output)/SemanticWalker.hpp \
-		BaseSemanticWalker.hpp
-	$(cpp) -c $(output)/SemanticWalker.cpp -o $(output)/SemanticWalker.o
-
-$(output)/BaseSemanticWalker.o: BaseSemanticWalker.hpp BaseSemanticWalker.cpp
-	$(cpp) -c BaseSemanticWalker.cpp -o $(output)/BaseSemanticWalker.o
-
-$(output)/MismatchedUnicodeCharException.o: \
-	MismatchedUnicodeCharException.cpp MismatchedUnicodeCharException.hpp
-	$(cpp) -c MismatchedUnicodeCharException.cpp \
-	-o $(output)/MismatchedUnicodeCharException.o
-
-$(output)/teste.o: teste.cpp $(output)/tokenNames.hpp
-	$(cpp) -c teste.cpp -o $(output)/teste.o
-
-$(output)/PortugolLexer.hpp $(output)/PortugolLexer.cpp: lexer.g
-	antlr -o $(output) lexer.g
-
-$(output)/PortugolParser.hpp $(output)/PortugolParser.cpp: parser.g
-	antlr -o $(output) parser.g
-
-$(output)/SemanticWalker.hpp $(output)/SemanticWalker.cpp: semantic.g
-	antlr -o $(output) semantic.g
-
-$(output)/tokenNames.hpp:
-	echo "std::map<int, std::string > tokenNames;"  > $(output)/tokenNames.hpp
-	grep = $(output)/PortugolTokenTypes.txt >> $(output)/tokenNames.hpp
-	sed -i -e 's/([^=]*)//' $(output)/tokenNames.hpp
-	sed -i -e 's/"[^"]*"//' $(output)/tokenNames.hpp
-	sed -i -e 's/==/=/' $(output)/tokenNames.hpp
-	sed -i -e 's/()//' $(output)/tokenNames.hpp
-	sed -i -e 's/\([^=]*\)=\(.*\)/tokenNames[\2]="\1";/' \
-		$(output)/tokenNames.hpp
-
-
-clean:
-	rm -rf $(output)
-

Deleted: trunk/gpt2/gptc/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/gptc/MismatchedUnicodeCharException.cpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/MismatchedUnicodeCharException.cpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,110 +0,0 @@
-
-#include <iostream>
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-#include "MismatchedUnicodeCharException.hpp"
-#include "UnicodeCharScanner.hpp"
-
-
-MismatchedUnicodeCharException::MismatchedUnicodeCharException()
-: RecognitionException("Mismatched char")
-{
-}
-
-// Expected range / not range
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type lower,
-	char_type up,
-	bool matchNot,
-	UnicodeCharScanner* cs
-)
-: RecognitionException("Mismatched char",
-							  cs->getFilename(),
-							  cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_RANGE : RANGE)
-, foundChar(c)
-, expecting(lower)
-, upper(up)
-, scanner(cs)
-{
-}
-
-// Expected char / not char
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type expect,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_CHAR : CHAR)
-, foundChar(c)
-, expecting(expect)
-, scanner(cs)
-{
-}
-
-// Expected BitSet / not BitSet
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	antlr::BitSet s,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException("Mismatched char",
-                      cs->getFilename(),
-							 cs->getLine(), cs->getColumn())
-, mismatchType(matchNot ? NOT_SET : SET)
-, foundChar(c)
-, set(s)
-, scanner(cs)
-{
-}
-
-MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
-
-/**
- * Returns a clean error message (no line number/column information)
- */
-std::string MismatchedUnicodeCharException::getMessage() const
-{
-	ANTLR_USE_NAMESPACE(std)string s;
-
-	switch (mismatchType) {
-	case CHAR :
-		s += "expecting '" + antlr::charName(expecting) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_CHAR :
-		s += "expecting anything but '" + antlr::charName(expecting) + "'; got it anyway";
-		break;
-	case RANGE :
-		s += "expecting token in range: '" + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case NOT_RANGE :
-		s += "expecting token NOT in range: " + antlr::charName(expecting) + "'..'" + antlr::charName(upper) + "', found '" + antlr::charName(foundChar) + "'";
-		break;
-	case SET :
-	case NOT_SET :
-		{
-			s += ANTLR_USE_NAMESPACE(std)string("expecting ") + (mismatchType == NOT_SET ? "NOT " : "") + "one of (";
-			ANTLR_USE_NAMESPACE(std)vector<unsigned int> elems = set.toArray();
-			for ( unsigned int i = 0; i < elems.size(); i++ )
-			{
-				s += " '";
-				s += antlr::charName(elems[i]);
-				s += "'";
-			}
-			s += "), found '" + antlr::charName(foundChar) + "'";
-		}
-		break;
-	default :
-		s += RecognitionException::getMessage();
-		break;
-	}
-
-	return s;
-}

Deleted: trunk/gpt2/gptc/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/gptc/MismatchedUnicodeCharException.hpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/MismatchedUnicodeCharException.hpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,82 +0,0 @@
-#ifndef INC_MismatchedUnicodeCharException_hpp__
-#define INC_MismatchedUnicodeCharException_hpp__
-
-/* ANTLR Translator Generator
- * Project led by Terence Parr at http://www.jGuru.com
- * Software rights: http://www.antlr.org/license.html
- *
- * $Id:$
- */
-
-#include <antlr/config.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/String.hpp>
-
-class UnicodeCharScanner;
-
-class MismatchedUnicodeCharException : public antlr::RecognitionException {
-public:
-	typedef unsigned int char_type;
-	typedef enum {
-		CHAR = 1,
-		NOT_CHAR = 2,
-		RANGE = 3,
-		NOT_RANGE = 4,
-		SET = 5,
-		NOT_SET = 6
-	} MATCH_TYPE;
-
-	MismatchedUnicodeCharException();
-
-	// Expected range / not range
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type lower,
-		char_type up,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected char / not char
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type expect,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected BitSet / not BitSet
-	MismatchedUnicodeCharException(
-		char_type c,
-		antlr::BitSet s,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	~MismatchedUnicodeCharException() throw();
-
-	/**
-	 * Returns a clean error message (no line number/column information)
-	 */
-	std::string getMessage() const;
-private:
-	// One of the above
-	MATCH_TYPE mismatchType;
-
-	// what was found on the input stream
-	char_type foundChar;
-
-	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
-	char_type expecting;
-
-	// For RANGE/NOT_RANGE (expecting is lower bound of range)
-	char_type upper;
-
-	// For SET/NOT_SET
-	antlr::BitSet set;
-	// who knows...they may want to ask scanner questions
-	UnicodeCharScanner* scanner;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/gptc/UnicodeCharBuffer.hpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/UnicodeCharBuffer.hpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,83 +0,0 @@
-#ifndef INC_UnicodeCharBuffer_hpp__
-#define INC_UnicodeCharBuffer_hpp__
-
-#include <istream>
-#include <cassert>
-#include <antlr/config.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/CharStreamIOException.hpp>
-
-class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
-public:
-	typedef unsigned int char_type;	// should be 32 bits!
-
-	/// Create a character buffer
-	UnicodeCharBuffer(std::istream& inp)
-	: input(inp)
-	{
-		//	input.exceptions(std::ios_base::badbit|
-		//						  std::ios_base::failbit);
-	}
-	/// Get the next character from the stream
-	int getChar()
-	{
-		char_type ch = 0;
-		int inchar = input.get();
-		if( inchar == EOF )
-			return -1;
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-		if( (inchar & 0x80) == 0 )
-			return inchar;
-
-		unsigned int need = 0;
-		if( (inchar & 0xF8) == 0xF8 )
-		{
-			ch = inchar & 7;
-			need = 3;
-		}
-		else if( (inchar & 0xE0) == 0xE0 )
-		{
-			ch = inchar & 0xF;
-			need = 2;
-		}
-		else if( (inchar & 0xC0) == 0xC0 )
-		{
-			ch = inchar & 0x1F;
-			need = 1;
-		}
-		else
-		{
-			assert("Invalid UTF8");
-		}
-		while( need )
-		{
-			inchar = input.get();
-			if( inchar == EOF )
-				assert("Invalid UTF8");
-//				throw antlr::CharStreamIOException(std::logic_error());
-			ch <<= 6;
-			ch += inchar & 0x3F;
-			need--;
-		}
-		return ch;
-	}
-private:
-	// character source
-	std::istream& input;
-
-	// NOTE: Unimplemented
-	UnicodeCharBuffer(const UnicodeCharBuffer& other);
-	UnicodeCharBuffer& operator=(const UnicodeCharBuffer& other);
-};
-
-#endif //INC_UnicodeCharBuffer_hpp__

Deleted: trunk/gpt2/gptc/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/gptc/UnicodeCharScanner.hpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/UnicodeCharScanner.hpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,561 +0,0 @@
-#ifndef INC_UnicodeCharScanner_hpp__
-#define INC_UnicodeCharScanner_hpp__
-
-#include <map>
-#include <cctype>
-
-#include <antlr/config.hpp>
-#include <antlr/CommonToken.hpp>
-#include <antlr/TokenStream.hpp>
-#include <antlr/RecognitionException.hpp>
-#include <antlr/SemanticException.hpp>
-#include <antlr/InputBuffer.hpp>
-#include <antlr/BitSet.hpp>
-#include <antlr/LexerSharedInputState.hpp>
-
-#include "MismatchedUnicodeCharException.hpp"
-
-/** Superclass of generated lexers
- */
-class UnicodeCharScanner : public antlr::TokenStream {
-protected:
-	typedef antlr::RefToken (*factory_type)();
-public:
-	typedef int char_type;
-	typedef std::map<std::string,int> string_map;
-
-	UnicodeCharScanner( antlr::InputBuffer& cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( const antlr::LexerSharedInputState& state, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(state)
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&antlr::CommonToken::factory);
-	}
-
-	virtual ~UnicodeCharScanner()
-	{
-	}
-
-	virtual char_type LA(char_type i)
-	{
-		char_type c = inputState->getInput().LA(i);
-		return c;
-	}
-
-	virtual void append(char_type c)
-	{
-		if (saveConsumedInput)
-		{
-			size_t len = text.length();
-
-			if( (len % 256) == 0 )
-				text.reserve(len+256);
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-			if (c < 0x80)
-			{
-				text += c;
-				return;
-			}
-			else if (c < 0x800)
-			{
-				text += ( (c >> 6) | 0xC0 );
-				text += ( c & 0x3F | 0x80 );
-			}
-			else if (c < 0x10000)
-			{
-				text += ( (c >> 12) | 0xE0 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else if (c < 0x200000)
-			{
-				text += ( (c >> 18) | 0xF0 );				// first 3 bits
-				text += ( (((c >> 16) & 0x3) << 4) |
-								 ((c >> 12) & 0xF) | 0x80 );
-				text += ( ((c >> 6) & 0x3F) | 0x80 );
-				text += ( (c & 0x3F) | 0x80 );
-			}
-			else
-				assert(0);
-		}
-	}
-
-	virtual void append(const std::string& s)
-	{
-		assert(0);
-		if (saveConsumedInput)
-			text+=s;
-	}
-
-	virtual void commit()
-	{
-		inputState->getInput().commit();
-	}
-
-	virtual void consume()
-	{
-		if (inputState->guessing == 0)
-		{
-			char_type c = LA(1);
-			append(c);
-			inputState->column++;
-		}
-		inputState->getInput().consume();
-	}
-
-	/** Consume chars until one matches the given char */
-	virtual void consumeUntil(char_type c)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || la_1 == c )
-				break;
-			consume();
-		}
-	}
-
-	/** Consume chars until one matches the given set */
-	virtual void consumeUntil(const antlr::BitSet& set)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast<char_type>(EOF_CHAR) == la_1 || set.member(la_1) )
-				break;
-			consume();
-		}
-	}
-
-	/// Mark the current position and return a id for it
-	virtual unsigned int mark()
-	{
-		return inputState->getInput().mark();
-	}
-
-	/// Rewind the scanner to a previously marked position
-	virtual void rewind(unsigned int pos)
-	{
-		inputState->getInput().rewind(pos);
-	}
-
-	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
-	virtual void match(char_type c)
-	{
-		char_type la_1 = LA(1);
-		if ( la_1 != c )
-			throw MismatchedUnicodeCharException(la_1, c, false, this);
-		consume();
-	}
-
-	/** See if input contains element from bitset b
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void match(const antlr::BitSet& b)
-	{
-		char_type la_1 = LA(1);
-
-		if ( !b.member(la_1) )
-			throw MismatchedUnicodeCharException( la_1, b, false, this );
-		consume();
-	}
-
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match( const char* s )
-	{
-		while( *s != '\0' )
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (*s++ & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match(const std::string& s)
-	{
-		size_t len = s.length();
-
-		for (size_t i = 0; i < len; i++)
-		{
-			// the & 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (s[i] & 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input does not contain character 'c'
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchNot(char_type c)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 == c )
-			throw MismatchedUnicodeCharException(la_1, c, true, this);
-
-		consume();
-	}
-	/** See if input contains character in range c1-c2
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchRange(char_type c1, char_type c2)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 < c1 || la_1 > c2 )
-			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
-
-		consume();
-	}
-
-	/// Get the line the scanner currently is in (starts at 1)
-	virtual int getLine() const
-	{
-		return inputState->line;
-	}
-
-	/// set the line number
-	virtual void setLine(int l)
-	{
-		inputState->line = l;
-	}
-
-	/// Get the column the scanner currently is in (starts at 1)
-	virtual int getColumn() const
-	{
-		return inputState->column;
-	}
-	/// set the column number
-	virtual void setColumn(int c)
-	{
-		inputState->column = c;
-	}
-
-	/// get the filename for the file currently used
-	virtual const std::string& getFilename() const
-	{
-		return inputState->filename;
-	}
-	/// Set the filename the scanner is using (used in error messages)
-	virtual void setFilename(const std::string& f)
-	{
-		inputState->filename = f;
-	}
-
-	virtual bool getCommitToPath() const
-	{
-		return commitToPath;
-	}
-
-	virtual void setCommitToPath(bool commit)
-	{
-		commitToPath = commit;
-	}
-
-	/** return a copy of the current text buffer */
-	virtual const std::string& getText() const
-	{
-		return text;
-	}
-
-	virtual void setText(const std::string& s)
-	{
-		text = s;
-	}
-
-	virtual void resetText()
-	{
-		text = "";
-		inputState->tokenStartColumn = inputState->column;
-		inputState->tokenStartLine = inputState->line;
-	}
-
-	virtual antlr::RefToken getTokenObject() const
-	{
-		return _returnToken;
-	}
-
-	///{ These need different handling in unicode case
-
-	virtual bool getCaseSensitiveLiterals() const=0;
-
-	virtual bool getCaseSensitive() const
-	{
-		return caseSensitive;
-	}
-
-	virtual void setCaseSensitive(bool t)
-	{
-		caseSensitive = t;
-	}
-
-	/** Override this method to get more specific case handling
-	 * @note some platforms probably require setting the right locale for
-	 * correct functioning.
-	 */
-	virtual char_type toLower(char_type c) const
-	{
-		return std::tolower(c);
-	}
-
-	/** Used to keep track of line breaks, needs to be called from
-	 * within generated lexers when a \n \r is encountered.
-	 */
-	virtual void newline()
-	{
-		++inputState->line;
-		inputState->column = 1;
-	}
-
-	/** Advance the current column number by an appropriate amount according
-	 * to the tabsize. This method needs to be explicitly called from the
-	 * lexer rules encountering tabs.
-	 */
-	virtual void tab()
-	{
-		int c = getColumn();
-		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
-		setColumn( nc );
-	}
-	/// set the tabsize. Returns the old tabsize
-	int setTabsize( int size )
-	{
-		int oldsize = tabsize;
-		tabsize = size;
-		return oldsize;
-	}
-	/// Return the tabsize used by the scanner
-	int getTabSize() const
-	{
-		return tabsize;
-	}
-	///}
-
-	/** Report exception errors caught in nextToken() */
-	virtual void reportError(const antlr::RecognitionException& ex)
-	{
-		std::cerr << ex.toString().c_str() << std::endl;
-	}
-
-	/** Parser error-reporting function can be overridden in subclass */
-	virtual void reportError(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "error: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
-	}
-
-	/** Parser warning-reporting function can be overridden in subclass */
-	virtual void reportWarning(const std::string& s)
-	{
-		if (getFilename() == "")
-			std::cerr << "warning: " << s.c_str() << std::endl;
-		else
-			std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
-	}
-
-	virtual antlr::InputBuffer& getInputBuffer()
-	{
-		return inputState->getInput();
-	}
-
-	virtual antlr::LexerSharedInputState getInputState()
-	{
-		return inputState;
-	}
-
-	/** set the input state for the lexer.
-	 * @note state is a reference counted object, hence no reference */
-	virtual void setInputState(antlr::LexerSharedInputState state)
-	{
-		inputState = state;
-	}
-
-	/// Set the factory for created tokens
-	virtual void setTokenObjectFactory(factory_type factory)
-	{
-		tokenFactory = factory;
-	}
-
-	/** Test the token text against the literals table
-	 * Override this method to perform a different literals test
-	 */
-	virtual int testLiteralsTable(int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** Test the text passed in against the literals table
-	 * Override this method to perform a different literals test
-	 * This is used primarily when you want to test a portion of
-	 * a token
-	 */
-	virtual int testLiteralsTable(const std::string& text, int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** This method is called by YourLexer::nextToken() when the lexer has
-	 *  hit EOF condition.  EOF is NOT a character.
-	 *  This method is not called if EOF is reached during
-	 *  syntactic predicate evaluation or during evaluation
-	 *  of normal lexical rules, which presumably would be
-	 *  an IOException.  This traps the "normal" EOF condition.
-	 *
-	 *  uponEOF() is called after the complete evaluation of
-	 *  the previous token and only if your parser asks
-	 *  for another token beyond that last non-EOF token.
-	 *
-	 *  You might want to throw token or char stream exceptions
-	 *  like: "Heh, premature eof" or a retry stream exception
-	 *  ("I found the end of this file, go back to referencing file").
-	 */
-	virtual void uponEOF()
-	{
-	}
-
-	/// Methods used to change tracing behavior
-	void traceIndent()
-	{
-		for( int i = 0; i < traceDepth; i++ )
-			std::cout << " ";
-	}
-
-	void traceIn(const char* rname)
-	{
-		traceDepth++;
-		traceIndent();
-		std::cout << "> lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-	}
-
-	void traceOut(const char* rname)
-	{
-		traceIndent();
-		std::cout << "< lexer " << rname
-			<< "; c==" << LA(1) << std::endl;
-		traceDepth--;
-	}
-
-#ifndef NO_STATIC_CONSTS
-	static const int EOF_CHAR = EOF;
-#else
-	enum {
-		EOF_CHAR = EOF
-	};
-#endif
-protected:
-	std::string text; ///< Text of current token
- 	/// flag indicating wether consume saves characters
-	bool saveConsumedInput;
-	factory_type tokenFactory;				///< Factory for tokens
-	bool caseSensitive; 						///< Is this lexer case sensitive
-	string_map literals;						 // set by subclass
-
-	antlr::RefToken _returnToken;		///< used to return tokens w/o using return val
-
-	/// Input state, gives access to input stream, shared among different lexers
-	antlr::LexerSharedInputState inputState;
-
-	/** Used during filter mode to indicate that path is desired.
-	 * A subsequent scan error will report an error as usual
-	 * if acceptPath=true;
-	 */
-	bool commitToPath;
-
-	unsigned int tabsize; 	///< tab size the scanner uses.
-
-	/// Create a new RefToken of type t
-	virtual antlr::RefToken makeToken(int t)
-	{
-		antlr::RefToken tok = tokenFactory();
-		// actually at this point you want to convert the stored lexeme text
-		// into the format you want to have it in in the backend...
-		tok->setType(t);
-		tok->setColumn(inputState->tokenStartColumn);
-		tok->setLine(inputState->tokenStartLine);
-		return tok;
-	}
-
-	/** Tracer class, used when -traceLexer is passed to antlr
-	 */
-	class Tracer {
-	private:
-		UnicodeCharScanner* parser;
-		const char* text;
-
-		Tracer(const Tracer& other); 					// undefined
-		Tracer& operator=(const Tracer& other); 	// undefined
-	public:
-		Tracer( UnicodeCharScanner* p, const char* t )
-		: parser(p), text(t)
-		{
-			parser->traceIn(text);
-		}
-		~Tracer()
-		{
-			parser->traceOut(text);
-		}
-	};
-
-	int traceDepth;
-private:
-	UnicodeCharScanner( const UnicodeCharScanner& other ); 		  		// undefined
-	UnicodeCharScanner& operator=( const UnicodeCharScanner& other );	// undefined
-};
-
-#endif //INC_UnicodeCharScanner_hpp__

Deleted: trunk/gpt2/gptc/lexer.g
===================================================================
--- trunk/gpt2/gptc/lexer.g	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/lexer.g	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,609 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include <string>
-  #include <sstream>
-  #include <iostream>
-  #include <ctype.h>
-  #include "UnicodeCharBuffer.hpp"
-  #include "UnicodeCharScanner.hpp"
-}
-
-options {
-  language="Cpp";
-}
-
-class PortugolLexer extends Lexer("UnicodeCharScanner");
-
-options {
-  k=2;
-  genHashLines   = false;
-  exportVocab    = Portugol;
-  filter         = T_INVALIDO;
-  testLiterals   = false;
-}
-
-tokens {
-  T_ALGORITMO="algoritmo";
-  T_USE="use";
-  T_VARIAVEL="vari?vel";
-  T_VARIAVEIS="vari?veis";
-  T_FIM_VARIAVEIS="fim-vari?veis";
-  T_INTEIRO="inteiro";
-  T_REAL="real";
-  T_CARACTERE="caractere";
-  T_LITERAL="literal";
-  T_LOGICO="l?gico";
-  T_CORINGA="coringa";
-  T_MATRIZ="matriz";
-  T_DO="do";
-  T_TIPO="tipo";
-  T_CONSTANTE="constante";
-  T_CONSTANTES="constantes";
-  T_FIM_CONSTANTES="fim-constantes";
-  T_ESTRUTURA="estrutura";
-  T_FIM_ESTRUTURA="fim-estrutura";
-  T_FUNCAO="fun??o";
-  T_PROCEDIMENTO="procedimento";
-  T_REF="ref";
-  T_INICIO="in?cio";
-  T_FIM="fim";
-  T_SAIR="sair";
-  T_RETORNE="retorne";
-  T_SE="se";
-  T_ENTAO="ent?o";
-  T_SENAO="sen?o";
-  T_FIM_SE="fim-se";
-  T_ENQUANTO="enquanto";
-  T_FACA="fa?a";
-  T_FIM_ENQUANTO="fim-enquanto";
-  T_PARA="para";
-  T_DE="de";
-  T_ATE="at?";
-  T_FIM_PARA="fim-para";
-  T_PASSO="passo";
-  T_REPITA="repita";
-  T_CASO="caso";
-  T_SEJA="seja";
-  T_FIM_SENAO="fim-sen?o";
-  T_FIM_CASO="fim-caso";
-  T_FIM_FACA="fim-fa?a";
-  T_OU="ou";
-  T_E="e";
-  T_NAO="n?o";
-  T_VERDADEIRO="verdadeiro";
-  T_FALSO="falso";
-  T_NULO="nulo";
-  T_ASM="asm";
-  T_FIMASM="fim-asm";
-
-  T_REAL_LITERAL="n?mero real"; //a regra T_INTEIRO_LITERAL lida com reais
-
-
-  //imagin?rios para a AST
-
-  T_PARAM;
-  T_TIPO_RETORNO;
-
-  T_VALOR;
-  T_VAL_MATRIZ;    //valor da matriz    (literal [])
-  T_VAL_ESTRUTURA; //valor da estrutura (literal {})
-
-  T_DIMENSOES;
-
-  T_UN_POSITIVO;
-  T_UN_NEGATIVO;
-
-  T_CALL;
-}
-
-
-{
-public:
-  PortugolLexer(std::istream& in, bool case_s)
-   : UnicodeCharScanner(new UnicodeCharBuffer(in), case_s)
-    {
-      initLiterals();
-    }
-
-private:
-
-  std::string toBase10(const std::string& oct, int from) {
-    std::stringstream stream;
-    unsigned long long base10;
-    base10 = strtoull(oct.c_str(), NULL, from);
-    stream << base10;
-    return stream.str();
-  }
-
-  bool isOctal(const std::string& num) {
-    std::stringstream s;
-    if ((num.find("8",0)  != std::string::npos) ||
-        (num.find("9",0)  != std::string::npos)) {
-      return false;
-    } else {
-      for (unsigned int i = 2; i < num.length(); ++i) {
-        if (!isdigit(num[i])) {
-          return false;
-        }
-      }
-    }
-    return true;
-  }
-
-  bool isHex(const std::string& num) {
-    for (unsigned int i = 2; i < num.length(); ++i) {
-      if (!isxdigit(num[i])) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  bool isBin(const std::string& num) {
-    for(unsigned int i = 2; i < num.length(); ++i) {
-      if ((num[i] != '0') && (num[i] != '1')) {
-        return false;
-      }
-    }
-    return true;
-  }
-}
-
-
-//####################################
-//##             Regras             ##
-//####################################
-
-
-
-T_ESPACO :
-  (   ' '
-    | '\t'
-    | '\n' { newline(); }
-    | '\r'
-  )
-  { $setType(antlr::Token::SKIP); }
-  ;
-
-COMENTARIO_CPP
-  : "//" (~('\n'))* ('\n')?
-    {
-      newline();
-      $setType(antlr::Token::SKIP);
-    }
-  ;
-
-COMENTARIO_C
-{int line = getLine();}
-  : "/*"
-    (
-      options { generateAmbigWarnings=false; } :
-        '\n'                     {newline();}
-      | ('\r' '\n')=> '\r' '\n'  {newline();}
-      | '\r'                     {newline();}
-      |~('*'|'\n'|'\r')
-      | ('*' ~'/' )=> '*'
-    )*
-    "*/"
-    {$setType(antlr::Token::SKIP);}
-  ;
-exception
-catch[antlr::RecognitionException] {
-  std::stringstream s;
-  //aviso! n?o ? erro!
-  s << "coment?rio iniciado na linha " << line << " n?o termina com \"*/\".";
-  std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-  $setType(antlr::Token::SKIP);
-}
-
-T_PONTO_VIRGULA
-options {
-  paraphrase = "';'";
-}
-  : ';'
-  ;
-
-T_VIRGULA
-options {
-  paraphrase = "','";
-}
-  : ','
-  ;
-
-T_2_PONTOS
-options {
-  paraphrase = "':'";
-}
-
-  : ':'
-  ;
-
-T_ABRE_CHAVE
-options {
-  paraphrase = "'['";
-}
-  : '['
-  ;
-
-T_FECHA_CHAVE
-options {
-  paraphrase = "']'";
-}
-  : ']'
-  ;
-
-T_ABRE_COLCHETE
-options {
-  paraphrase = "'{'";
-}
-  : '{'
-  ;
-
-T_FECHA_COLCHETE
-options {
-  paraphrase = "'}'";
-}
-  : '}'
-  ;
-
-T_ABRE_PAREN
-options {
-  paraphrase = "'('";
-}
-  : '('
-  ;
-T_FECHA_PAREN
-options {
-  paraphrase = "')'";
-}
-  : ')'
-  ;
-
-T_ATRIBUICAO
-options {
-  paraphrase = "':='";
-}
-  : ":="
-  ;
-
-T_BIT_OU
-options {
-  paraphrase = "operador '|'";
-}
-  : '|'
-  ;
-
-T_BIT_OUX
-options {
-  paraphrase = "operador '^'";
-}
-  : '^'
-  ;
-
-T_BIT_E
-options {
-  paraphrase = "operador '&'";
-}
-  : '&'
-  ;
-
-T_BIT_NAO
-options {
-  paraphrase = "operador '~'";
-}
-  : '~'
-  ;
-
-T_BIT_SHIFT_LEFT
-options {
-  paraphrase = "operador '<<'";
-}
-  : "<<"
-  ;
-
-T_BIT_SHIFT_RIGHT
-options {
-  paraphrase = "operador '>>'";
-}
-
-  : ">>"
-  ;
-
-T_IGUAL
-options {
-  paraphrase = "operador '='";
-}
-  : '='
-  ;
-
-T_DIFERENTE
-options {
-  paraphrase = "operador '<>'";
-}
-  : "<>"
-  ;
-
-T_MAIOR
-options {
-  paraphrase = "operador '>'";
-}
-  : '>'
-  ;
-
-T_MAIOR_EQ
-options {
-  paraphrase = "operador '>='";
-}
-  : ">="
-  ;
-
-T_MENOR
-options {
-  paraphrase = "operador '<'";
-}
-  : '<'
-  ;
-T_MENOR_EQ
-options {
-  paraphrase = "operador '<='";
-}
-  : "<="
-  ;
-
-T_MAIS
-options {
-  paraphrase = "operador '+'";
-}
-  : '+'
-  ;
-
-T_MENOS
-options {
-  paraphrase = "operador '-'";
-}
-  : '-'
-  ;
-
-T_DIV
-options {
-  paraphrase = "operador '/'";
-}
-  : '/'
-  ;
-
-T_MULTIP
-options {
-  paraphrase = "operador '*'";
-}
-  : '*'
-  ;
-
-T_MOD
-options {
-  paraphrase = "operador '%'";
-}
-  : '%'
-  ;
-
-/* Literais */
-
-
-T_INTEIRO_LITERAL
-options {
-  paraphrase = "n?mero inteiro";
-}
-  : ('0' ('c'|'C') )=> T_OCTAL_LIT
-  | ('0' ('x'|'X') )=> T_HEX_LIT
-  | ('0' ('b'|'B') )=> T_BIN_LIT
-  | (T_DIGITO)+
-    (
-      '.' (T_DIGITO)+
-      {$setType(T_REAL_LITERAL);}
-    )?
-  ;
-
-T_TEXTO_LITERAL
-options {
-  paraphrase = "literal";
-}
-  : '"'! ( ~( '"' | '\\' | '\n' | '\r') | T_ESCAPE )* '"'!
-  ;
-
-
-T_CARACTERE_LITERAL
-options {
-  paraphrase = "caractere";
-}
-  : '\''! ( ~( '\'' | '\\' ) | T_ESCAPE )? '\''!
-  ;
-
-
-
-/*
-  Ok, um pouco de malabarismo...
-
-  Eis o problema:
-
-  N?s precisamos que uma string como "fim-vari?veis" seja
-  identificada pelo scanner. Para isso, as keywords em tokens{} devem
-  ser cobertos pelas regras T_*. No caso, T_IDENTIFICADOR
-  costuma ser a regra que identifica keywords.
-
-  Por?m, "fim-vari?veis" n?o ? um identificador v?lido
-  (ambig. com "fim - vari?veis").
-
-  Ent?o, T_IDENTIFICADOR aqui representa a regra mais geral poss?vel,
-  para cobrir as keywords em tokens{}. Mas, para o caso problem?tico
-  de T_IDENTIFICADOres com "-", verificamos se o lexema atual
-  ? uma keyword ou um identificador seguido de T_MENOS, utilizando
-  "testLiteralsTable" manualmente.
-
-  Se testLiteralsTable indicar que o lexema atual com hifen for uma keyword,
-  ? a pr?pria, obviamente.
-
-  Se n?o, trata-se de um ID seguido de T_MENOS. Ent?o, fazemos o rollback
-  at? o ponto do hifen.
-*/
-
-T_IDENTIFICADOR
-options {
-  testLiterals = true;
-}
-  { int m = -1,len; }
-
-  : T_ID_AUX
-      {
-        len = $getText.length();
-        if (LA(1) == '-') {
-          m = mark();
-        }
-      }
-
-    ('-' (T_LETRA_OU_DIGITO)*)?
-  {
-    if ((m != -1) && (testLiteralsTable(_ttype) == T_IDENTIFICADOR)) {
-      rewind(m);
-      std::string s = $getText;
-      $setText(s.substr(0,len));
-    }
-  }
-  ;
-
-
-T_RETICENCIAS
-options {
-  paraphrase = "retic?ncias (...)";
-}
-  : "..."
-  ;
-
-T_PONTO
-options {
-  paraphrase = "ponto (.)";
-}
-  : '.'
-  ;
-
-//####################################
-//##            Protecteds          ##
-//####################################
-
-
-protected
-T_ESCAPE
-  : '\\' .  /* ex. \a */
-  ;
-
-protected
-T_DIGITO
-  : '0'..'9'
-  ;
-
-protected
-T_LETRA
-  : 'a'..'z'|'A'..'Z' | '\u00C0' .. '\u00FF' /* latim-1 */
-  ;
-
-
-protected
-T_LETRA_OU_DIGITO
-  : T_LETRA | T_DIGITO | '_'
-  ;
-
-
-//mais detalhes em T_IDENTIFICADOR
-protected
-T_ID_AUX
-  : (T_LETRA | '_') (T_LETRA_OU_DIGITO)*
-  ;
-
-protected
-T_OCTAL_LIT
-  : '0' ('c'|'C') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isOctal(str)) {
-      $setText(toBase10(str.substr(2), 8));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero octal v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_HEX_LIT
-  : '0' ('x'|'X') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isHex(str)) {
-      $setText(toBase10(str, 16));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero hexadecimal v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_BIN_LIT
-  : '0' ('b'|'B') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isBin(str)) {
-      $setText(toBase10(str.substr(2), 2));
-    } else {
-      std::stringstream s;
-      s << "\"" << str << "\" n?o ? um n?mero bin?rio v?lido";
-      std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-    }
-  }
-  ;
-
-protected
-T_INVALIDO
-  : .
-    {
-      //caracteres de espa?o inexistentes na tabela ascii
-      //([160] == [-96] == ' ' == [32] == 160-128)
-      if ($getText.c_str()[0] == (int)0xffffffa0) {
-        $setType(antlr::Token::SKIP);
-      } else {
-        std::stringstream s;
-        if (($getText != "\"") && ($getText != "'")) {
-          s << "Caractere inv?lido: \"" << $getText << "\".\n";
-          s << "Verifique se a codifica??o do texto est? em UTF-8";
-        } else {
-          s << "Faltando fechar aspas";
-        }
-        std::cerr << s.str() << ", na linha " << getLine() << std::endl;
-      }
-    }
-  ;

Deleted: trunk/gpt2/gptc/parser.g
===================================================================
--- trunk/gpt2/gptc/parser.g	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/parser.g	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,546 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-header {
-#include <antlr/NoViableAltException.hpp>
-#include <antlr/SemanticException.hpp>
-  using namespace antlr;
-}
-
-options {
-  language="Cpp";
-}
-
-class PortugolParser extends Parser;
-options {
-  importVocab    = Portugol;
-  genHashLines   = false;
-  buildAST       = true;
-  noConstructors = true;
-}
-
-{
-public:
-  PortugolParser(antlr::TokenBuffer& tokenBuf, bool report = true)
-  : antlr::LLkParser(tokenBuf,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  PortugolParser(antlr::TokenStream& lexer, bool report = true)
-  : antlr::LLkParser(lexer,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  void reportError(const RecognitionException& ex) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    std::cerr << ex.toString().c_str() << std::endl;
-  }
-
-  void reportError(const std::string& s) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    if (getFilename() == "") {
-      std::cerr << "error: " << s.c_str() << std::endl;
-    } else {
-      std::cerr << getFilename().c_str() << ": error: " << s.c_str() << std::endl;
-    }
-  }
-
-  void reportWarning(const std::string& s) {
-    if (!_reportErrors) return;
-    if (getFilename() == "") {
-      std::cerr << "warning: " << s.c_str() << std::endl;
-    } else {
-      std::cerr << getFilename().c_str() << ": warning: " << s.c_str() << std::endl;
-    }
-  }
-
-  bool hasErorrs() {
-    return _hasErrors;
-  }
-
-private:
-  void createRootNode(antlr::ASTPair& ast, antlr::RefToken token) {
-    astFactory->makeASTRoot(ast, astFactory->create(token));
-  }
-
-  void createRootNode(antlr::ASTPair& ast, int token, std::string txt = "") {
-    astFactory->makeASTRoot(ast, astFactory->create(token, txt));
-  }
-
-  void addChildNode(antlr::ASTPair& ast, antlr::RefToken token) {
-    astFactory->addASTChild(ast, astFactory->create(token));
-  }
-
-  void addChildNode(antlr::ASTPair& ast, antlr::RefAST child) {
-    astFactory->addASTChild(ast, child);
-  }
-
-  antlr::RefAST createNode(int type, const std::string& txt) {
-    return astFactory->create(type, txt);
-  }
-
-  bool _reportErrors;
-  bool _hasErrors;
-}
-
-
-
-//####################################
-//##             In?cio             ##
-//####################################
-
-programa
-{createRootNode(currentAST, T_ALGORITMO, "&algoritmo");}
-
-  : (declaracao_algoritmo)?
-
-    (importacao)*
-
-    (   declaracao_variaveis
-      | declaracao_constantes
-      | bloco_declaracao_estrutura
-    )*
-
-    corpo
-
-    EOF
-  ;
-
-declaracao_algoritmo!
-  : T_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
-  ;
-
-importacao
-  : T_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
-  ;
-
-corpo
-  :  declaracao_subrotina corpo
-  |  bloco_codigo         corpo
-  |  /*vazio*/
-  ;
-
-
-
-//####################################
-//##    Declara??o de Vari?veis     ##
-//####################################
-
-declaracao_variaveis
-  : bloco_declaracao_variaveis
-  | T_VARIAVEL! declaracao_variavel_uniq
-  ;
-
-bloco_declaracao_variaveis
-  : T_VARIAVEIS! (declaracao_variavel)+ T_FIM_VARIAVEIS!
-  ;
-
-declaracao_variavel!
-  : ids:lista_identificadores   T_2_PONTOS
-    t:tipo (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,"&var"], t,ids);
-              } else {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,"&var"], t,ids,([T_VALOR,"&valor"],l));
-              }
-            }
-  ;
-
-lista_identificadores
-  : T_IDENTIFICADOR (T_VIRGULA! T_IDENTIFICADOR)*
-  ;
-
-declaracao_variavel_uniq!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel_uniq=
-                    #([T_VARIAVEL,"&var"], t,id);
-              } else {
-                #declaracao_variavel_uniq =
-                    #([T_VARIAVEL,"&var"], t,id,([T_VALOR,"&valor"],l));
-              }
-            }
-  ;
-
-tipo
-  : tipo_primitivo
-  | tipo_matriz
-  | T_IDENTIFICADOR
-  ;
-
-lista_inicializacao
-  : T_ATRIBUICAO! (expressao | inicializacao_composta)
-  ;
-
-inicializacao_composta!
-  : T_ABRE_CHAVE!
-      idx:inicializacao_indices
-    T_FECHA_CHAVE!
-
-                 {#inicializacao_composta = #([T_VAL_MATRIZ, "&vmatriz"],idx);}
-
-  | T_ABRE_COLCHETE!
-      mem:inicializacao_membros
-    T_FECHA_COLCHETE!
-
-                 {#inicializacao_composta = #([T_VAL_ESTRUTURA, "&vestr"],mem);}
-  ;
-
-inicializacao_indices
-  : (expressao | inicializacao_composta) (T_VIRGULA! inicializacao_indices)?
-  ;
-
-inicializacao_membros
-  : T_IDENTIFICADOR T_ATRIBUICAO! (expressao | inicializacao_composta)
-    (T_VIRGULA! inicializacao_membros)?
-  ;
-
-tipo_primitivo
-  : T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-tipo_matriz!
-  : m:T_MATRIZ dim:matriz_dimensoes
-    T_DO T_TIPO t:tipo_da_matriz
-
-                    {#tipo_matriz = #(m, t,dim);}
-  ;
-
-matriz_dimensoes
-  : ( T_ABRE_CHAVE!
-      ( T_INTEIRO_LITERAL
-        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULO,"&null"));}
-      )
-      T_FECHA_CHAVE!
-    )+
-  ;
-
-tipo_da_matriz
-  : tipo_primitivo | T_IDENTIFICADOR
-  ;
-
-
-
-//####################################
-//##    Declara??o de Constantes    ##
-//####################################
-
-
-declaracao_constantes
-  : bloco_declaracao_constantes
-  | T_CONSTANTE! declaracao_constante
-  ;
-
-bloco_declaracao_constantes
-  : T_CONSTANTES! (declaracao_constante)+ T_FIM_CONSTANTES!
-  ;
-
-declaracao_constante!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    l:lista_inicializacao T_PONTO_VIRGULA
-               {#declaracao_constante =
-                    #([T_CONSTANTE,"&const"],t,id,([T_VALOR,"&valor"],l));}
-  ;
-
-
-
-
-//####################################
-//##    Declara??o de Estruturas    ##
-//####################################
-
-
-bloco_declaracao_estrutura
-  : T_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_FIM_ESTRUTURA!
-  ;
-
-
-
-
-//####################################
-//##    Declara??o de Subrotinas    ##
-//####################################
-
-
-declaracao_subrotina
-  : declaracao_funcao
-  | declaracao_procedimento
-  ;
-
-declaracao_funcao
-  : T_FUNCAO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo_retorno
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-declaracao_procedimento
-  : T_PROCEDIMENTO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-tipo_retorno!
-  : t:tipo {#tipo_retorno = #([T_TIPO_RETORNO,"&ret"],t);}
-  ;
-
-lista_parametros
-  : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
-  ;
-
-param_reticencias!
-  : ret:T_RETICENCIAS id:T_IDENTIFICADOR
-                       {#param_reticencias = #([T_PARAM,"&param"],ret,id);}
-  ;
-
-parametro!
-  : ((c:T_CONSTANTE)? r:T_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-
-                          {#parametro = #([T_PARAM,"&param"],t,id,c,r);}
-  ;
-
-
-//####################################
-//##         Bloco de c?digo        ##
-//####################################
-
-bloco_codigo
-  : T_INICIO^ lista_enunciados T_FIM!
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-  : (lvalue T_ATRIBUICAO)=> en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-
-  | en_asm
-
-  | T_SAIR^ T_PONTO_VIRGULA!
-  | T_PONTO_VIRGULA!
-
-//  TODO: retirar da gramatica ou resolver a ambiguidade
-//        se esta producao vingar, retirar enunciado::chamada_subrotina
-//   | expressao  T_PONTO_VIRGULA!
-
-  | chamada_subrotina T_PONTO_VIRGULA!
-  ;
-
-en_atribuicao
-  : lvalue T_ATRIBUICAO^ expressao T_PONTO_VIRGULA!
-  ;
-
-
-en_retorne
-  : T_RETORNE^ (expressao)? T_PONTO_VIRGULA!
-  ;
-
-lvalue
-  : T_IDENTIFICADOR^ (matriz_indices | T_PONTO! lvalue)
-  ;
-
-matriz_indices
-  : ( T_ABRE_CHAVE!
-      expressao
-      T_FECHA_CHAVE!
-    )*
-  ;
-
-en_se
-  : T_SE^ expressao T_ENTAO!
-      lista_enunciados (T_SENAO lista_enunciados)? T_FIM_SE!
-  ;
-
-en_enquanto
-  : T_ENQUANTO^ expressao T_FACA! lista_enunciados T_FIM_ENQUANTO!
-  ;
-
-en_para
-  : T_PARA^ lvalue T_DE! expressao
-    T_ATE! expressao (passo)? T_FACA!
-      lista_enunciados T_FIM_PARA!
-  ;
-
-passo
-  : T_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
-  ;
-
-en_repita
-  : T_REPITA^ lista_enunciados T_ATE expressao
-  ;
-
-en_caso
-  : T_CASO^ expressao
-      T_SEJA! (teste_caso)+
-      (caso_senao)? T_FIM_CASO!
-  ;
-
-teste_caso!
-  : l:literal T_FACA! en:lista_enunciados T_FIM_FACA!
-
-                                {#teste_caso = #(l, en);}
-  ;
-
-caso_senao
-  : T_SENAO^ lista_enunciados T_FIM_SENAO!
-  ;
-
-
-//TODO: codigo ilustrativo.
-en_asm!
-  : T_ASM (~(T_FIMASM))* T_FIMASM
-  ;
-
-
-//####################################
-//##            Express?es          ##
-//####################################
-
-
-expressao
-  : expr_e (T_OU^ expr_e)*
-  ;
-
-expr_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_ou (T_E^ expr_bit_ou)*
-  ;
-
-expr_bit_ou
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
-  ;
-
-expr_bit_oux
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
-  ;
-
-expr_bit_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_eq (T_BIT_E^ expr_eq)*
-  ;
-
-expr_eq
-options {
-  defaultErrorHandler=false;
-}
-  : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
-  ;
-
-expr_relacional
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_shift ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_bit_shift)*
-  ;
-
-expr_bit_shift
-options {
-  defaultErrorHandler=false;
-}
-  : expr_soma ((T_BIT_SHIFT_LEFT^ | T_BIT_SHIFT_RIGHT^) expr_soma)*
-  ;
-
-expr_soma
-options {
-  defaultErrorHandler=false;
-}
-  : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
-  ;
-
-expr_multip
-options {
-  defaultErrorHandler=false;
-}
-  : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
-  ;
-
-expr_unario
-options {
-  defaultErrorHandler=false;
-}
-  : op_unario expr_elemento
-  ;
-
-op_unario!
-  : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
-    | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
-    | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
-    | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
-    )?
-  ;
-
-expr_elemento
-  :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
-  |  lvalue
-  |  literal
-  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
-  ;
-
-
-chamada_subrotina!
-  : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
-
-                        {#chamada_subrotina = #([T_CALL,"&call"], id, args);}
-  ;
-
-lista_argumentos
-  : expressao (T_VIRGULA! expressao)*
-  ;
-
-literal
-  : T_TEXTO_LITERAL
-  | T_INTEIRO_LITERAL
-  | T_REAL_LITERAL
-  | T_CARACTERE_LITERAL
-  | T_VERDADEIRO
-  | T_FALSO
-  | T_NULO
-  ;

Deleted: trunk/gpt2/gptc/semantic.g
===================================================================
--- trunk/gpt2/gptc/semantic.g	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/semantic.g	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,148 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   tsilva at sourcecraft.info                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include "BaseSemanticWalker.hpp"
-}
-
-
-options {
-  language="Cpp";
-}
-
-class SemanticWalker extends TreeParser("BaseSemanticWalker");
-options {
-  importVocab    = Portugol;
-  noConstructors = true;
-  genHashLines   = false;
-}
-
-{
-public:
-  SemanticWalker::SemanticWalker()
-	 : BaseSemanticWalker() { }
-}
-
-
-programa
-  : (importacao)*
-
-    (   declaracao_variaveis
-//       | declaracao_constantes
-//       | bloco_declaracao_estrutura
-    )*
-  ;
-
-importacao
-  : #(T_USE T_TEXTO_LITERAL)
-    //TODO: carregar a symboltable das bibliotecas especificadas
-  ;
-
-declaracao_variaveis
-  : #(T_VARIAVEIS (declaracao_variavel)+)
-  | declaracao_variavel
-  ;
-
-declaracao_variavel
-  : #(T_VARIAVEL tipo lista_identificadores (lista_inicializacao)?)
-  ;
-
-lista_identificadores
-  : (T_IDENTIFICADOR)+
-  ;
-
-tipo
-  : tipo_primitivo
-  | tipo_matriz
-  | T_IDENTIFICADOR
-  ;
-
-lista_inicializacao
-  : #(T_VALOR valor_inicializacao)
-  ;
-
-valor_inicializacao
-  : (matriz_literal | estrutura_literal | expressao)
-  ;
-
-matriz_literal
-  : #(T_VAL_MATRIZ (valor_inicializacao)+)
-  ;
-
-estrutura_literal
-  : #(T_VAL_ESTRUTURA (T_IDENTIFICADOR valor_inicializacao)+)
-  ;
-
-tipo_primitivo
-  : T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-tipo_matriz
-  : #(T_MATRIZ tipo_da_matriz (T_INTEIRO_LITERAL|T_NULO)+)
-  ;
-
-tipo_da_matriz
-  : tipo_primitivo | T_IDENTIFICADOR
-  ;
-
-
-expressao
-  : expr_elemento
-  ;
-
-expr_elemento
-  : literal
-  ;
-
-literal
-  : T_TEXTO_LITERAL
-  | T_INTEIRO_LITERAL
-  | T_REAL_LITERAL
-  | T_CARACTERE_LITERAL
-  | T_VERDADEIRO
-  | T_FALSO
-  | T_NULO
-  ;
-
-//   T_OU
-//   : expr_bit_ou (T_E^ expr_bit_ou)*
-//   : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
-//   : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
-//   : expr_igual (T_BIT_E^ expr_igual)*
-//   : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
-//   : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
-//   : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
-//   : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
-//   : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
-//     | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
-//     | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
-//     | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
-
-// expr_elemento
-//   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
-//   |  lvalue
-//   |  literal
-//   | T_ABRE_PAREN! expressao T_FECHA_PAREN!
-//   ;

Copied: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp (from rev 372, trunk/gpt2/gptc/BaseSemanticWalker.cpp)

Copied: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp (from rev 372, trunk/gpt2/gptc/BaseSemanticWalker.hpp)

Copied: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp (from rev 372, trunk/gpt2/gptc/MismatchedUnicodeCharException.cpp)

Copied: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp (from rev 372, trunk/gpt2/gptc/MismatchedUnicodeCharException.hpp)

Copied: trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp (from rev 372, trunk/gpt2/gptc/UnicodeCharBuffer.hpp)

Copied: trunk/gpt2/gptc/src/UnicodeCharScanner.hpp (from rev 372, trunk/gpt2/gptc/UnicodeCharScanner.hpp)

Copied: trunk/gpt2/gptc/src/lexer.g (from rev 372, trunk/gpt2/gptc/lexer.g)

Copied: trunk/gpt2/gptc/src/parser.g (from rev 372, trunk/gpt2/gptc/parser.g)

Copied: trunk/gpt2/gptc/src/semantic.g (from rev 372, trunk/gpt2/gptc/semantic.g)

Copied: trunk/gpt2/gptc/src/teste.cpp (from rev 372, trunk/gpt2/gptc/teste.cpp)

Copied: trunk/gpt2/gptc/test (from rev 372, trunk/gpt2/gptc/compiler_test)

Deleted: trunk/gpt2/gptc/test/Makefile
===================================================================
--- trunk/gpt2/gptc/compiler_test/Makefile	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/test/Makefile	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,52 +0,0 @@
-output = ./obj
-
-objects = $(output)/LangTestLexer.o $(output)/LangTestParser.o \
-          $(output)/TestAST.o $(output)/tester.o
-
-other = ../obj/PortugolLexer.o ../obj/PortugolParser.o \
-				../obj/MismatchedUnicodeCharException.o
-
-cpp = g++ -I$(output) -I. -I../ -I../obj
-
-$(output)/tester: $(output) $(objects)
-	$(cpp) -o $(output)/tester $(objects) $(other) /usr/local/lib/libantlr.a
-
-$(output):
-	mkdir -p $(output)
-
-$(output)/LangTestLexer.o: $(output)/LangTestLexer.hpp \
-		$(output)/LangTestLexer.cpp
-	$(cpp) -c $(output)/LangTestLexer.cpp -o $(output)/LangTestLexer.o
-
-$(output)/LangTestParser.o: $(output)/LangTestParser.hpp \
-		$(output)/LangTestParser.cpp
-	$(cpp) -c $(output)/LangTestParser.cpp -o $(output)/LangTestParser.o
-
-$(output)/tester.o: tester.cpp $(output)/testTokenNames.hpp
-	$(cpp) -c tester.cpp -o $(output)/tester.o
-
-$(output)/TestAST.o: TestAST.cpp TestAST.hpp
-	$(cpp) -c TestAST.cpp -o $(output)/TestAST.o
-
-$(output)/LangTestLexer.hpp $(output)/LangTestLexer.cpp \
-$(output)/LangTestParser.hpp $(output)/LangTestParser.cpp: compiler_test.g
-	antlr -o $(output) compiler_test.g
-
-
-$(output)/testTokenNames.hpp: $(output)/LangTestLexerTokenTypes.txt
-	echo "std::map<int, std::string > testTokenNames;"  \
-		> $(output)/testTokenNames.hpp
-	grep '=' $(output)/LangTestLexerTokenTypes.txt \
-		>> $(output)/testTokenNames.hpp
-	sed -i -e 's/([^=]*)//' $(output)/testTokenNames.hpp
-	sed -i -e 's/"[^"]*"//' $(output)/testTokenNames.hpp
-	sed -i -e 's/==/=/' $(output)/testTokenNames.hpp
-	sed -i -e 's/()//' $(output)/testTokenNames.hpp
-	sed -i -e 's/\([^=]*\)=\(.*\)/testTokenNames[\2]="\1";/' \
-		$(output)/testTokenNames.hpp
-
-
-clean:
-	rm -rf $(output)
-
-

Deleted: trunk/gpt2/gptc/teste.cpp
===================================================================
--- trunk/gpt2/gptc/teste.cpp	2007-11-19 03:42:53 UTC (rev 372)
+++ trunk/gpt2/gptc/teste.cpp	2007-11-19 03:48:19 UTC (rev 373)
@@ -1,81 +0,0 @@
-#include <stdio.h>
-#include "PortugolLexer.hpp"
-#include "PortugolParser.hpp"
-#include "SemanticWalker.hpp"
-#include "PortugolTokenTypes.hpp"
-#include <antlr/TokenBuffer.hpp>
-#include <antlr/CommonAST.hpp>
-
-#include <fstream>
-
-void dump_tokens(char* fname) {
-  #include "tokenNames.hpp"
-  std::ifstream fi(fname);
-  PortugolLexer lexer(fi, true);
-  antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
-
-  while (true) {
-    std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
-              << tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
-    buffer->consume();
-    getchar();
-
-    if (buffer->LA(1) == PortugolTokenTypes::EOF_) {
-      break;
-    }
-  }
-}
-
-antlr::RefAST dump_tree(char* fname, bool should_dump) {
-
-  std::ifstream fi(fname);
-  PortugolLexer lexer(fi, true);
-  PortugolParser parser(lexer);
-
-  antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,&antlr::CommonAST::factory);
-  parser.initializeASTFactory(ast_factory);
-  parser.setASTFactory(&ast_factory);
-
-  parser.programa();
-
-  antlr::RefAST ast = parser.getAST();
-  antlr::RefCommonAST cast = antlr::RefCommonAST(ast);
-
-  if (!cast) {
-    std::cerr << "no parse tree!" << std::endl;
-  }
-
-  if (should_dump) {
-    std::cerr << cast->toStringList() << std::endl << std::endl;
-  }
-  return ast;
-}
-
-void semantic(char* fname) {
-  antlr::RefAST ast;
-
-  ast = dump_tree(fname, true);
-
-  SemanticWalker semantic;
-  semantic.programa(ast);
-}
-
-int main(int argc, char** argv) {
-
-  if (argc < 3) {
-    std::cerr << "./test [lps] <file.gpt>" << std::endl;
-    return 0;
-  }
-
-  switch(*argv[1]) {
-    case 'l':
-      dump_tokens(argv[2]);
-      break;
-    case 'p':
-      dump_tree(argv[2], true);
-      break;
-    case 's':
-    default:
-      semantic(argv[2]);
-  }
-}



From gpt-commit-noreply at mail.berlios.de  Mon Nov 19 20:53:43 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 19 Nov 2007 20:53:43 +0100
Subject: [gpt-commit] r374 - in trunk/gpt2: . common common/src gptasm
	gptasm/src gptasm/test gptasm/test/gerados_pelo_gptc
	gptasm/test/wikki gptvm gptvm/src gptvm/test
	gptvm/test/gerados_pelo_gptasm
Message-ID: <200711191953.lAJJrhou007669@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-19 20:53:34 +0100 (Mon, 19 Nov 2007)
New Revision: 374

Added:
   trunk/gpt2/common/
   trunk/gpt2/common/src/
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/CCode.cpp
   trunk/gpt2/common/src/CCode.hpp
   trunk/gpt2/common/src/CData.cpp
   trunk/gpt2/common/src/CData.hpp
   trunk/gpt2/common/src/CHeader.cpp
   trunk/gpt2/common/src/CHeader.hpp
   trunk/gpt2/common/src/COptions.hpp
   trunk/gpt2/common/src/CSymbol.cpp
   trunk/gpt2/common/src/CSymbol.hpp
   trunk/gpt2/common/src/CSymbolList.cpp
   trunk/gpt2/common/src/CSymbolList.hpp
   trunk/gpt2/common/src/CSymbolTable.cpp
   trunk/gpt2/common/src/CSymbolTable.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/common/test/
   trunk/gpt2/gptasm/src/
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/CGptAsm.cpp
   trunk/gpt2/gptasm/src/CGptAsm.hpp
   trunk/gpt2/gptasm/src/Makefile
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/main.cpp
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/
   trunk/gpt2/gptasm/test/asm.sh
   trunk/gpt2/gptasm/test/asm_all.sh
   trunk/gpt2/gptasm/test/check.sh
   trunk/gpt2/gptasm/test/check_all.sh
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/constantes_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_3.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_4.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_5.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_3.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_4.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/inline_codigo_gptassembly.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_3.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_4.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_4.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_1.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_2.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_3.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_4.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_5.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_6.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_7.gasm
   trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_8.gasm
   trunk/gpt2/gptasm/test/hello_world.gasm
   trunk/gpt2/gptasm/test/prep_tests.sh
   trunk/gpt2/gptasm/test/show_and_asm.sh
   trunk/gpt2/gptasm/test/test_ok.sh
   trunk/gpt2/gptasm/test/test_ok_all.sh
   trunk/gpt2/gptasm/test/wikki/
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CGptVm.cpp
   trunk/gpt2/gptvm/src/CGptVm.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
   trunk/gpt2/gptvm/src/main.cpp
   trunk/gpt2/gptvm/test/
   trunk/gpt2/gptvm/test/check.sh
   trunk/gpt2/gptvm/test/check_all.sh
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/constantes_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/inline_codigo_gptassembly.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_7.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_8.gvm
   trunk/gpt2/gptvm/test/prep_tests.sh
   trunk/gpt2/gptvm/test/run.sh
   trunk/gpt2/gptvm/test/run_all.sh
   trunk/gpt2/gptvm/test/test_ok.sh
   trunk/gpt2/gptvm/test/test_ok_all.sh
Log:
* Gramatica parcial do GptAssembly
* GptASM
  - Gera parcialmente o arquivo GVM
  - Consegue assemblar "Hello world !!!"
  - Alguns exemplos estao sendo assemblados corretamente mas a VM
    nao consegue executa-los no momento
* GptVM
  - Carrega parcialmente o arquivo GVM
  - Consegue executar "Hello world !!!"
  - Consegue executar alguns exemplos com formula matematicas com inteiros


Added: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,115 @@
+#include <iostream>
+
+#include "CBinString.hpp"
+
+
+void CBinString::writeInt(const int &value)
+{
+   char *byte = (char*)&value;
+
+   for( size_t i = 0; i < sizeof(int); i++) {
+      push_back(*byte);
+      byte++;
+   }
+//   std::cout << "writeInt:" << value << std::endl;
+}
+
+
+void CBinString::writeByte(const char &value)
+{
+   (*this) += value;
+//   std::cout << "writeByte:" << value << "(" << (int)value << ")" << std::endl;
+}
+
+
+void CBinString::writeString(const std::string &value, const bool &writeSize)
+{
+   if (writeSize) {
+      writeInt(value.length());
+   }
+   (*this) += value;
+   if (!writeSize) {
+      (*this) += '\0';
+   }
+//   std::cout << "writeString: [" << value << "]" << std::endl;
+}
+
+
+void CBinString::writeBool(const bool &value)
+{
+   char byte = (char)value;
+
+   (*this) += byte;
+//   std::cout << "writeBool:" << value << std::endl;
+}
+
+
+void CBinString::readInt(int &value)
+{
+   int result = 0;
+   char *byte = (char*)&result;
+
+   for( size_t i = 0; i < sizeof(int); i++) {
+      *byte = (*this)[0]; // TODO
+      byte++;
+      erase(0,1);
+   }
+   value = result;
+//   std::cout << "readInt:" << value << std::endl;
+}
+
+
+void CBinString::readByte(char &value)
+{
+   value = (*this)[0];
+   erase(0,1);
+//   std::cout << "readByte:" << value << "(" << (int)value << ")" << std::endl;
+}
+
+
+void CBinString::readString(std::string &value)
+{
+   int size;
+   readInt(size);
+   value=substr(0, size);
+   erase(0, size);
+//   std::cout << "readString:" << value << std::endl;
+}
+
+
+void CBinString::readBool(bool &value)
+{
+   char byte;
+   byte = (*this)[0];
+   erase(0,1);
+   value=byte;
+//   std::cout << "readBool:" << value << std::endl;
+}
+
+
+bool CBinString::removeIfEqual(const int &value)
+{
+   // TODO: nao ta correto pq sempre retira...
+   int data;
+   readInt(data);
+   return value == data;
+}
+
+
+bool CBinString::removeIfEqual(const char &value)
+{
+   // TODO: nao ta correto pq sempre retira...
+   char data;
+   readByte(data);
+   return value == data;
+}
+
+
+bool CBinString::removeIfEqual(const std::string &value)
+{
+   // TODO: nao ta correto pq sempre retira...
+   std::string data;
+   readString(data);
+   return value == data;
+}
+

Added: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+#ifndef GPT_BIN_STRING_H
+#define GPT_BIN_STRING_H
+
+#include <string>
+
+
+class CBinString : public std::string
+{
+public:
+   void writeInt(const int &value);
+   void writeByte(const char &value);
+   void writeString(const std::string &value, const bool &writeSize=true);
+   void writeBool(const bool &value);
+   void readInt(int &value);
+   void readByte(char &value);
+   void readString(std::string &value);
+   void readBool(bool &value);
+   bool removeIfEqual(const int &value);
+   bool removeIfEqual(const char &value);
+   bool removeIfEqual(const std::string &value);
+};
+
+#endif

Added: trunk/gpt2/common/src/CCode.cpp
===================================================================
--- trunk/gpt2/common/src/CCode.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CCode.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,61 @@
+#include "CCode.hpp"
+
+
+CCode::CCode()
+{
+}
+
+
+CCode::~CCode()
+{
+}
+
+
+void CCode::addByte(const char &code)
+{
+   _data += code;
+}
+
+
+void CCode::addInt(const int &code)
+{
+   const char *byte = (const char*) &code;
+
+   for (size_t i = 0; i < sizeof(int); i++) {
+      _data += *byte;
+      byte++;
+   }
+}
+
+
+int CCode::size() const
+{
+   return _data.size();
+}
+
+
+CBinString CCode::getBinary() const
+{
+   return _data;
+}
+
+
+bool CCode::readFromBinary(CBinString &bin)
+{
+   bin.readString(_data);
+   return true;
+}
+
+
+char CCode::getByte(const int &pos)
+{
+   return _data[pos];
+}
+
+
+int CCode::getInt(const int &pos)
+{
+   int *ret = (int*)&(_data[pos]);
+   return *ret;
+}
+

Added: trunk/gpt2/common/src/CCode.hpp
===================================================================
--- trunk/gpt2/common/src/CCode.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CCode.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,27 @@
+#ifndef GPT_CODE_H
+#define GPT_CODE_H
+
+
+#include <string>
+
+#include "CBinString.hpp"
+
+
+class CCode
+{
+public:
+   CCode();
+   ~CCode();
+   void addByte(const char &code);
+   void addInt(const int &code);
+   int size() const;
+   CBinString getBinary() const;
+   bool readFromBinary(CBinString &bin);
+   char getByte(const int &pos);
+   int getInt(const int &pos);
+private:
+   CBinString _data;
+};
+
+#endif
+

Added: trunk/gpt2/common/src/CData.cpp
===================================================================
--- trunk/gpt2/common/src/CData.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CData.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,95 @@
+#include "CData.hpp"
+
+
+CData::CData()
+{
+}
+
+
+CData::~CData()
+{
+}
+
+
+CSymbol* CData::add(CSymbol *symbol)
+{
+//   std::cout << "Adicionando [" << symbol->getName() << "] type [" << symbol->getType() << "] address [" << symbol->getAddress() << "] a Data" << std::endl;
+
+   return CSymbolList::add( symbol );
+}
+
+
+//CSymbol* CData::add(const std::string &name, const int &category, const int &type, const int &address)
+//{
+//   return CSymbolList::add( name, category, type, address, 0 ); // TODO: nao eh zero...
+//}
+
+
+CSymbol* CData::addVariable (const std::string &name, const int &type, const int &address)
+{
+   CSymbol *symbol = new CSymbol (name, type, CSymbol::VAR, address);
+
+   _symbols.push_back(symbol);
+
+   //_data += symbol->getBinary();
+   for (int i=0; i < symbol->getTypeSize(); i++) {
+      // TODO: horrivel :-)
+      _data.writeByte (' ');
+   }
+
+   return symbol;
+}
+
+
+CSymbol* CData::addConstant (const std::string &name, const int &type, const int &address)
+{
+   CSymbol *symbol = new CSymbol (name, type, CSymbol::CONST, address);
+
+   _symbols.push_back(symbol);
+
+   //_data += symbol->getBinary();
+   if (type == CSymbol::STRING) {
+      _data.writeString(name, false);
+   } else if (type == CSymbol::INT) {
+      _data.writeInt(atoi(name.c_str()));
+   }
+
+   return symbol;
+}
+
+
+bool CData::readFromBinary(CBinString &bin)
+{
+   bin.readString(_data);
+   return true;
+}
+
+
+std::string CData::getString(const int &address)
+{
+   int pos = 0;
+
+   pos = _data.find('\0', address);
+
+   if (pos == -1) {
+      abort();
+   }
+
+   return _data.substr(address, pos - address);
+}
+
+
+int CData::getInt(const int &address)
+{
+   int *ret = (int*)&(_data[address]);
+   return *ret;
+}
+
+
+void CData::setInt(const int &address, const int &value)
+{
+   int *targetAddress = (int*)&(_data[address]);
+
+   *targetAddress = value;
+}
+

Added: trunk/gpt2/common/src/CData.hpp
===================================================================
--- trunk/gpt2/common/src/CData.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CData.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,25 @@
+#ifndef GPT_DATA_H
+#define GPT_DATA_H
+
+#include <string>
+#include <map>
+
+#include "CSymbolList.hpp"
+
+
+class CData : public CSymbolList
+{
+public:
+   CData();
+   ~CData();
+   CSymbol* add(CSymbol *symbol);
+   CSymbol* addVariable (const std::string &name, const int &type, const int &address);
+   CSymbol* addConstant (const std::string &name, const int &type, const int &address);
+   bool readFromBinary(CBinString &bin);
+   std::string getString(const int &address);
+   int getInt(const int &address);
+   void setInt(const int &address, const int &value);
+};
+
+#endif
+

Added: trunk/gpt2/common/src/CHeader.cpp
===================================================================
--- trunk/gpt2/common/src/CHeader.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CHeader.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,38 @@
+#include "CHeader.hpp"
+
+
+CHeader::CHeader()
+{
+   const std::string versionStr = "GVM version 0.1";
+   _data.writeInt(0x1234);
+   _data.writeString(versionStr);
+   _data.writeByte(0);
+   _data.writeByte(1);
+}
+
+
+CHeader::~CHeader()
+{
+}
+
+
+CBinString CHeader::getBinary()
+{
+   return _data;
+}
+
+
+bool CHeader::readFromBinary(CBinString &bin)
+{
+   bool result = bin.removeIfEqual(0x1234) &&
+                 bin.removeIfEqual("GVM version 0.1") &&
+                 bin.removeIfEqual((char)0) &&
+                 bin.removeIfEqual((char)1);
+
+   if (result == false) {
+      return false;
+   }
+
+   return true;
+}
+

Added: trunk/gpt2/common/src/CHeader.hpp
===================================================================
--- trunk/gpt2/common/src/CHeader.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CHeader.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,21 @@
+#ifndef GPT_HEADER_H
+#define GPT_HEADER_H
+
+#include <string>
+
+#include "CBinString.hpp"
+
+
+class CHeader
+{
+public:
+   CHeader();
+   ~CHeader();
+   CBinString getBinary();
+   bool readFromBinary(CBinString &bin);
+private:
+   CBinString _data;
+};
+
+#endif
+

Added: trunk/gpt2/common/src/COptions.hpp
===================================================================
--- trunk/gpt2/common/src/COptions.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/COptions.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,22 @@
+#ifndef GPT_OPTIONS_HPP
+#define GPT_OPTIONS_HPP
+
+
+#include <string>
+using namespace std;
+
+
+class COptions {
+public:
+   COptions( ) {
+//      sentences = false;
+//      sourceLine = NULL;
+   }
+   std::string sourcefile;
+   std::string destfile;
+//   bool sentences;
+//   int *sourceLine;
+};
+
+#endif
+

Added: trunk/gpt2/common/src/CSymbol.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbol.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,78 @@
+#include <iostream>
+
+
+#include "CSymbol.hpp"
+
+
+CSymbol::CSymbol()
+{
+}
+
+
+CSymbol::CSymbol (const std::string &name, const char &type, const char &category, const int &address)
+   : _name(name)
+   , _type(type)
+   , _category(category)
+   , _address(address)
+{
+}
+
+
+CSymbol::CSymbol (const std::string &name, const char &type, 
+                  const int &address, const bool &hasVarArguments, 
+                  const int &staticParameters, 
+                  std::vector<CSymbol> parameters)
+   : _name(name)
+   , _type(type)
+   , _category(CSymbol::PROC)
+   , _address(address)
+   , _hasVarArguments(hasVarArguments)
+   , _staticParameters(staticParameters)
+   , _parameters(parameters)
+{
+}
+
+
+CSymbol::~CSymbol()
+{
+}
+
+
+int CSymbol::getTypeSize() const
+{
+   switch(_type) {
+   case INT:
+   case CHAR:
+   case BOOL:
+      return sizeof(int);
+   case REAL:
+      return sizeof(double);
+   case STRING:
+   case MATRIX:
+      return sizeof(void*);
+   }
+   return 0;
+}
+
+
+bool CSymbol::readFromBinary(CBinString &bin)
+{
+   bin.readInt(_address);
+   bin.readByte(_category);
+
+   if (_category == CSymbol::VAR || _category == CSymbol::CONST) {
+      bin.readByte(_type);
+      bin.readString(_name);
+//      std::cout << "var ou const, type=" << _type << " name=" << _name << std::endl;
+   } else { // PROC
+      bool _hasVariableArguments;// TODO
+      char _staticParameters;// TODO
+      bin.readByte(_type);
+      bin.readString(_name);
+      bin.readBool(_hasVariableArguments);
+      bin.readByte(_staticParameters);
+//      std::cout << "proc, type=" << _type << " name=" << _name << std::endl;
+   }
+   return true;
+}
+

Added: trunk/gpt2/common/src/CSymbol.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbol.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,81 @@
+#ifndef GPT_SYMBOL_HPP
+#define GPT_SYMBOL_HPP
+
+#include <vector>
+
+#include "CBinString.hpp"
+
+
+class CSymbol
+{
+public:
+   enum ECategory {
+      PROC = 'P',
+      CONST = 'C',
+      VAR = 'V',
+      PARAM = 'P'
+   };
+   enum EType {
+      NO_TYPE = 'N',
+      STRING = 'S',
+      INT = 'I',
+      CHAR = 'C',
+      BOOL = 'B',
+      REAL = 'R',
+      MATRIX = 'M'
+   };
+   CSymbol ();
+   CSymbol (const std::string &name, const char &type, const char &category,
+            const int &address);
+   CSymbol (const std::string &name, const char &type, const int &address,
+            const bool &hasVarArguments, const int &staticParameters,
+            std::vector<CSymbol> parameters);
+   virtual ~CSymbol();
+   std::string getName() const
+   {
+      return _name;
+   }
+   CBinString getBinary() const
+   {
+      return _data;
+   }
+   int getTypeSize() const;
+   char getType() const
+   {
+      return _type;
+   }
+   char getCategory() const
+   {
+      return _category; 
+   }
+   int getAddress() const
+   {
+      return _address;
+   }
+   bool readFromBinary(CBinString &bin);
+   bool getHasVarArguments() const
+   {
+      return _hasVarArguments;
+   }
+   int getStaticParameters() const
+   {
+      return _staticParameters;
+   }
+   std::vector<CSymbol> getParameters() const
+   {
+      return _parameters;
+   }
+protected:
+   CBinString           _data;
+private:
+   std::string          _name;
+   char                 _type;
+   char                 _category;
+   int                  _address;
+   bool                 _hasVarArguments;
+   int                  _staticParameters;
+   std::vector<CSymbol> _parameters;
+};
+
+#endif
+

Added: trunk/gpt2/common/src/CSymbolList.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolList.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbolList.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,83 @@
+#include "CSymbolList.hpp"
+
+
+CSymbolList::CSymbolList() //: _size(0)
+{
+}
+
+
+CSymbolList::~CSymbolList()
+{
+}
+
+
+CSymbol* CSymbolList::add(CSymbol* symbol)
+{
+   _symbols.push_back(symbol);
+
+   _data += symbol->getBinary();
+   return symbol;
+}
+
+
+CSymbol* CSymbolList::getSymbol(const std::string &name)
+{
+   std::vector<CSymbol*>::iterator it;
+
+   it = find(name);
+
+   return *it;
+}
+
+
+int CSymbolList::getReference( const std::string &name )
+{
+   std::vector<CSymbol*>::iterator it;
+
+   it = find(name);
+
+   if (it == _symbols.end()) {
+      return -1;
+   }
+
+   return (it - _symbols.begin());
+}
+
+
+int CSymbolList::getAddress( const std::string &name )
+{
+   std::vector<CSymbol*>::iterator it;
+
+   it = find(name);
+
+   if (it == _symbols.end()) {
+      return -1;
+   }
+
+   return (*it)->getAddress();
+}
+
+
+std::vector<CSymbol*>::iterator CSymbolList::find(const std::string &name)
+{
+   for(std::vector<CSymbol*>::iterator it = _symbols.begin(); it != _symbols.end(); it++) {
+      if ((*it)->getName() == name) {
+         return it;
+      }
+   }
+
+   return _symbols.end();
+}
+
+
+bool CSymbolList::readFromBinary(CBinString &bin)
+{
+   int size = 0;
+   bin.readInt(size);
+   for (int count=0; count < size; count++) {
+      CSymbol *symbol = new CSymbol();
+      symbol->readFromBinary(bin);
+      add(symbol);
+   }
+   return true;
+}

Added: trunk/gpt2/common/src/CSymbolList.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolList.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbolList.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,43 @@
+#ifndef GPT_SYMBOL_LIST_H
+#define GPT_SYMBOL_LIST_H
+
+#include <string>
+#include <vector>
+#include <iostream>
+
+#include <stdlib.h>
+
+#include "CSymbol.hpp"
+
+
+class CSymbolList
+{
+public:
+   CSymbolList();
+   virtual ~CSymbolList();
+   CSymbol* add(CSymbol* symbol);
+   int getReference(const std::string &name);
+   int getAddress( const std::string &name );
+   CSymbol* getSymbol(const std::string &name);
+   std::vector<CSymbol*>::iterator find(const std::string &name);
+   CBinString getBinary() const
+   {
+      return _data;
+   }
+   int getDataSize() const
+   {
+      return _data.size();
+   }
+   int getSymbolsCount() const
+   {
+      return _symbols.size();
+   }
+   bool readFromBinary(CBinString &bin);
+protected:
+   std::vector<CSymbol*> _symbols;
+   CBinString _data;
+private:
+};
+
+#endif
+

Added: trunk/gpt2/common/src/CSymbolTable.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,83 @@
+#include "CSymbolTable.hpp"
+
+
+CSymbolTable::CSymbolTable()
+{
+}
+
+
+CSymbolTable::~CSymbolTable()
+{
+}
+
+
+CSymbol* CSymbolTable::addProcedure (const std::string &name, const int &type, const int &address, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters)
+{
+   CSymbol *symbol = new CSymbol( name, type, address, hasVarArguments, staticParameters, parameters);
+
+   _symbols.push_back(symbol);
+
+   // Endere?o 0123 (code), procedure, sem retorno, nome "p1",
+   // sem argumentos vari?veis, 2 par?metros fixos, p1 (int) e p2 (string)
+   // 0024: 0123 P N 2 "p1" N 2 I 4 2 "p1" S 30 2 "p2"
+   _data.writeInt( address );
+   _data.writeByte( CSymbol::PROC ); // procedure
+   _data.writeByte( type ); // tipo do retorno // TODO: em asm proc tem retorno ???
+   _data.writeString( name ); // nome da procedure
+   _data.writeBool( hasVarArguments );
+   _data.writeByte( staticParameters );
+   // TODO: falta argumentos
+
+   return symbol;
+}
+
+
+CSymbol* CSymbolTable::addParameter (const std::string &name, const int &type, const int &address)
+{
+   CSymbol *symbol = new CSymbol( name, type, CSymbol::PARAM, address);
+
+   _symbols.push_back(symbol);
+
+   //_data += symbol->getBinary();
+
+   return symbol;
+}
+
+
+CSymbol* CSymbolTable::addConstant (const std::string &name, const int &type, const int &address)
+{
+   CSymbol *symbol = new CSymbol( name, type, CSymbol::CONST, address);
+
+   _symbols.push_back(symbol);
+
+   // Endere?o 0000 (data), constante, string, 8 bytes ???, nome "c1"
+   // 0000: 0000 C S 8??? 2 "c1"
+   _data.writeInt( address );
+   _data.writeByte( CSymbol::CONST ); // categoria: constante
+   _data.writeByte( type );           // tipo
+   _data.writeString( name );         // nome da constante
+
+   return symbol;
+}
+
+
+CSymbol* CSymbolTable::add(CSymbol *symbol)
+{
+//   std::cout << "Adicionando simbolo [" << symbol->getName() << "] type [" << symbol->getType() << "] address [" << symbol->getAddress() << "] a SymbolTable" << std::endl;
+
+   return CSymbolList::add( symbol );
+}
+
+
+bool CSymbolTable::readFromBinary(CBinString &bin)
+{
+   int size;
+   bin.readInt(size);
+   for (int count=0; count < size; count++) {
+      CSymbol *symbol = new CSymbol();
+      symbol->readFromBinary(bin);
+      add(symbol);
+   }
+   return true;
+}
+

Added: trunk/gpt2/common/src/CSymbolTable.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,24 @@
+#ifndef GPT_SYMBOL_TABLE_H
+#define GPT_SYMBOL_TABLE_H
+
+#include <string>
+#include <map>
+
+
+#include "CSymbolList.hpp"
+
+
+class CSymbolTable : public CSymbolList
+{
+public:
+   CSymbolTable();
+   ~CSymbolTable();
+   CSymbol* addProcedure (const std::string &name, const int &type, const int &address, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
+   CSymbol* addParameter (const std::string &name, const int &type, const int &address);
+   CSymbol* addConstant (const std::string &name, const int &type, const int &address);
+   CSymbol* add(CSymbol *symbol);
+   bool readFromBinary(CBinString &bin);
+};
+
+#endif
+

Added: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,116 @@
+#ifndef GPT_COMMON
+#define GPT_COMMON
+
+enum opcode {
+   OP_NOP         = 0,
+   OP_HLT         = 1,
+   OP_EXIT        = 2,
+   OP_ISUM        = 3,
+   OP_SSUM        = 4,
+   OP_RSUM        = 5,
+   OP_ISUB        = 6,
+   OP_SSUB        = 7,
+   OP_RSUB        = 8,
+   OP_IMUL        = 9,
+   OP_RMUL        = 10,
+   OP_IDIV        = 11,
+   OP_RDIV        = 12,
+   OP_IMOD        = 13,
+   OP_RMOD        = 14,
+   OP_IGE         = 15,
+   OP_SGE         = 16,
+   OP_RGE         = 17,
+   OP_ILE         = 18,
+   OP_SLE         = 19,
+   OP_RLE         = 20,
+   OP_INE         = 21,
+   OP_SNE         = 22,
+   OP_RNE         = 23,
+   OP_IGT         = 24,
+   OP_SGT         = 25,
+   OP_RGT         = 26,
+   OP_ILT         = 27,
+   OP_SLT         = 28,
+   OP_RLT         = 29,
+   OP_IEQ         = 30,
+   OP_SEQ         = 31,
+   OP_REQ         = 32,
+   OP_OR = 33,
+   OP_AND         = 34,
+   OP_XOR         = 35,
+   OP_INEG = 36,
+   OP_RNEG = 37,
+   OP_NOT         = 38,
+   OP_IINC = 39,
+   OP_IDEC = 40,
+   OP_I2C         = 41,
+   OP_R2C         = 42,
+   OP_S2C         = 43,
+   OP_B2C         = 44,
+   OP_I2R         = 45,
+   OP_C2R         = 46,
+   OP_S2R         = 47,
+   OP_B2R         = 48,
+   OP_I2B         = 49,
+   OP_C2B         = 50,
+   OP_R2B         = 51,
+   OP_S2B         = 52,
+   OP_I2S         = 53,
+   OP_C2S         = 54,
+   OP_R2S         = 55,
+   OP_B2S         = 56,
+   OP_P2S         = 57,
+   OP_C2I         = 58,
+   OP_R2I         = 59,
+   OP_S2I         = 60,
+   OP_B2I         = 61,
+   OP_ISET = 62,
+   OP_SSET = 63,
+   OP_RSET = 64,
+   OP_GETA = 65,
+   OP_IGETV = 66,
+   OP_SGETV = 67,
+   OP_RGETV = 68,
+   OP_ISETV = 69,
+   OP_SSETV = 70,
+   OP_RSETV = 71,
+   OP_JMP         = 72,
+   OP_IF = 73,
+   OP_IFNOT = 74,
+   OP_PUSH = 75,
+   OP_POP         = 76,
+   OP_INCSP = 77,
+   OP_DECSP = 78,
+   OP_PUSH_INT = 79,
+   OP_PUSH_STRING = 80,
+   OP_PUSH_REAL = 81,
+   OP_PUSH_CHAR = 82,
+   OP_PUSH_BOOL = 83,
+   OP_PUSH_MATRIX = 84,
+   OP_PUSH_SP = 85,
+   OP_POP_SP = 86,
+   OP_INCSP_4 = 87,
+   OP_INCSP_8 = 88,
+   OP_DECSP_4 = 89,
+   OP_DECSP_8 = 90,
+   OP_PCALL = 91,
+   OP_RET         = 92,
+   OP_SALLOC = 93,
+   OP_SFREE = 94,
+   OP_SSETC = 95,
+   OP_SGETC = 96,
+   OP_M1ALLOC = 97,
+   OP_M2ALLOC = 98,
+   OP_MFREE = 99,
+   OP_M1SET = 100,
+   OP_M1GET = 101,
+   OP_M2SET = 102,
+   OP_M2GET = 103,
+   OP_MCOPY = 104,
+   OP_MGETSIZE1 = 105,
+   OP_MGETSIZE2 = 106,
+   OPCODE_NUMBER  = 107 // TODO: Isso nao eh seguro...
+};
+
+#endif
+

Added: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,228 @@
+#include "CGenBytecode.hpp"
+
+#include <sstream>
+#include <iostream>
+
+
+#include "Common.hpp"
+
+
+CGenBytecode::CGenBytecode()
+{
+   _opcodes[ "isum"        ] = OP_ISUM;
+   _opcodes[ "ssum"        ] = OP_SSUM;
+   _opcodes[ "rsum"        ] = OP_RSUM;
+   _opcodes[ "isub"        ] = OP_ISUB;
+   _opcodes[ "ssub"        ] = OP_SSUB;
+   _opcodes[ "rsub"        ] = OP_RSUB;
+   _opcodes[ "imul"        ] = OP_IMUL;
+   _opcodes[ "rmul"        ] = OP_RMUL;
+   _opcodes[ "idiv"        ] = OP_IDIV;
+   _opcodes[ "rdiv"        ] = OP_RDIV;
+   _opcodes[ "imod"        ] = OP_IMOD;
+   _opcodes[ "rmod"        ] = OP_RMOD;
+   _opcodes[ "ige"         ] = OP_IGE;
+   _opcodes[ "sge"         ] = OP_SGE;
+   _opcodes[ "rge"         ] = OP_RGE;
+   _opcodes[ "ile"         ] = OP_ILE;
+   _opcodes[ "sle"         ] = OP_SLE;
+   _opcodes[ "rle"         ] = OP_RLE;
+   _opcodes[ "ine"         ] = OP_INE;
+   _opcodes[ "sne"         ] = OP_SNE;
+   _opcodes[ "rne"         ] = OP_RNE;
+   _opcodes[ "igt"         ] = OP_IGT;
+   _opcodes[ "sgt"         ] = OP_SGT;
+   _opcodes[ "rgt"         ] = OP_RGT;
+   _opcodes[ "ilt"         ] = OP_ILT;
+   _opcodes[ "slt"         ] = OP_SLT;
+   _opcodes[ "rlt"         ] = OP_RLT;
+   _opcodes[ "ieq"         ] = OP_IEQ;
+   _opcodes[ "seq"         ] = OP_SEQ;
+   _opcodes[ "req"         ] = OP_REQ;
+   _opcodes[ "or"          ] = OP_OR;
+   _opcodes[ "and"         ] = OP_AND;
+   _opcodes[ "xor"         ] = OP_XOR;
+   _opcodes[ "ineg"        ] = OP_INEG;
+   _opcodes[ "rneg"        ] = OP_RNEG;
+   _opcodes[ "not"         ] = OP_NOT;
+   _opcodes[ "iinc"        ] = OP_IINC;
+   _opcodes[ "idec"        ] = OP_IDEC;
+   _opcodes[ "i2c"         ] = OP_I2C;
+   _opcodes[ "r2c"         ] = OP_R2C;
+   _opcodes[ "s2c"         ] = OP_S2C;
+   _opcodes[ "b2c"         ] = OP_B2C;
+   _opcodes[ "i2r"         ] = OP_I2R;
+   _opcodes[ "c2r"         ] = OP_C2R;
+   _opcodes[ "s2r"         ] = OP_S2R;
+   _opcodes[ "b2r"         ] = OP_B2R;
+   _opcodes[ "i2b"         ] = OP_I2B;
+   _opcodes[ "c2b"         ] = OP_C2B;
+   _opcodes[ "r2b"         ] = OP_R2B;
+   _opcodes[ "s2b"         ] = OP_S2B;
+   _opcodes[ "i2s"         ] = OP_I2S;
+   _opcodes[ "c2s"         ] = OP_C2S;
+   _opcodes[ "r2s"         ] = OP_R2S;
+   _opcodes[ "b2s"         ] = OP_B2S;
+   _opcodes[ "p2s"         ] = OP_P2S;
+   _opcodes[ "c2i"         ] = OP_C2I;
+   _opcodes[ "r2i"         ] = OP_R2I;
+   _opcodes[ "s2i"         ] = OP_S2I;
+   _opcodes[ "b2i"         ] = OP_B2I;
+   _opcodes[ "iset"        ] = OP_ISET;
+   _opcodes[ "sset"        ] = OP_SSET;
+   _opcodes[ "rset"        ] = OP_RSET;
+   _opcodes[ "geta"        ] = OP_GETA;
+   _opcodes[ "igetv"       ] = OP_IGETV;
+   _opcodes[ "sgetv"       ] = OP_SGETV;
+   _opcodes[ "rgetv"       ] = OP_RGETV;
+   _opcodes[ "isetv"       ] = OP_ISETV;
+   _opcodes[ "ssetv"       ] = OP_SSETV;
+   _opcodes[ "rsetv"       ] = OP_RSETV;
+   _opcodes[ "jmp"         ] = OP_JMP;
+   _opcodes[ "if"          ] = OP_IF;
+   _opcodes[ "ifnot"       ] = OP_IFNOT;
+   _opcodes[ "push"        ] = OP_PUSH;
+   _opcodes[ "pop"         ] = OP_POP;
+   _opcodes[ "incsp"       ] = OP_INCSP;
+   _opcodes[ "decsp"       ] = OP_DECSP;
+//   _opcodes[ "push_0"      ] = OP_PUSH_0;
+//   _opcodes[ "push_1"      ] = OP_PUSH_1;
+//   _opcodes[ "push_2"      ] = OP_PUSH_2;
+//   _opcodes[ "push_3"      ] = OP_PUSH_3;
+//   _opcodes[ "push_4"      ] = OP_PUSH_4;
+//   _opcodes[ "push_5"      ] = OP_PUSH_5;
+   _opcodes[ "push_int"    ] = OP_PUSH_INT;
+   _opcodes[ "push_string" ] = OP_PUSH_STRING;
+   _opcodes[ "push_real"   ] = OP_PUSH_REAL;
+   _opcodes[ "push_char"   ] = OP_PUSH_CHAR;
+   _opcodes[ "push_bool"   ] = OP_PUSH_BOOL;
+   _opcodes[ "push_matrix" ] = OP_PUSH_MATRIX;
+   _opcodes[ "push_sp"     ] = OP_PUSH_SP;
+   _opcodes[ "pop_sp"      ] = OP_POP_SP;
+   _opcodes[ "incsp_4"     ] = OP_INCSP_4;
+   _opcodes[ "incsp_8"     ] = OP_INCSP_8;
+   _opcodes[ "decsp_4"     ] = OP_DECSP_4;
+   _opcodes[ "decsp_8"     ] = OP_DECSP_8;
+   _opcodes[ "pcall"       ] = OP_PCALL;
+   _opcodes[ "ret"         ] = OP_RET;
+   _opcodes[ "salloc"      ] = OP_SALLOC;
+   _opcodes[ "sfree"       ] = OP_SFREE;
+   _opcodes[ "ssetc"       ] = OP_SSETC;
+   _opcodes[ "sgetc"       ] = OP_SGETC;
+   _opcodes[ "m1alloc"     ] = OP_M1ALLOC;
+   _opcodes[ "m2alloc"     ] = OP_M2ALLOC;
+   _opcodes[ "mfree"       ] = OP_MFREE;
+   _opcodes[ "m1set"       ] = OP_M1SET;
+   _opcodes[ "m1get"       ] = OP_M1GET;
+   _opcodes[ "m2set"       ] = OP_M2SET;
+   _opcodes[ "m2get"       ] = OP_M2GET;
+   _opcodes[ "mcopy"       ] = OP_MCOPY;
+   _opcodes[ "mgetsize1"   ] = OP_MGETSIZE1;
+   _opcodes[ "mgetsize2"   ] = OP_MGETSIZE2;
+   _opcodes[ "nop"         ] = OP_NOP;
+//   _opcodes[ "exit_0"      ] = OP_EXIT_0;
+//   _opcodes[ "exit_1"      ] = OP_EXIT_1;
+   _opcodes[ "hlt"         ] = OP_HLT;
+   _opcodes[ "exit"        ] = OP_EXIT;
+}
+
+
+CGenBytecode::~CGenBytecode()
+{
+}
+
+
+void CGenBytecode::initProcedure(const std::string &procedureName, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters)
+{
+// TODO: e qdo procedure vai retornar valor no assembly ???
+// Talvez temos q fazer como em C e gerar procedure_name + retorno + parametros (int_procedure_int_real)
+   _symbolTable.addProcedure (procedureName, CSymbol::NO_TYPE, _code.size(), hasVarArguments, staticParameters, parameters);
+   _currentProcedure = procedureName;
+}
+
+
+void CGenBytecode::finishProcedure()
+{
+   _currentProcedure.clear();
+   // TODO: delete na procedure ???
+}
+
+
+void CGenBytecode::makeVarDefinition(const std::string &lexeme, const int &type)
+{
+//   if (_currentProcedure.empty()) { // assumindo que sao dados globais...
+//      _symbolTable.add(new CVariableDefinition(lexeme, type, _data.getDataSize()));
+//   }
+   _data.addVariable (lexeme, type, _data.getDataSize());
+}
+
+
+void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
+{
+   _symbolTable.addParameter(lexeme, type, 0); // TODO: colocar endereco relativo a SP
+}
+
+
+void CGenBytecode::registryLabel(const std::string &labelName)
+{
+}
+
+
+void CGenBytecode::addOpcode(const std::string &mn)
+{
+//   std::cout << "Mn=" << mn << " opcode: " << (int)_opcodes[mn] << std::endl;
+   _code.addByte(_opcodes[mn]);
+}
+
+
+//void CGenBytecode::addIdReference(const std::string &id)
+//{
+//   int ref = _symbolTable.getReference(id);
+//   _code.add(ref);
+//}
+
+
+//void CGenBytecode::addReference(const std::string &id, const int &category, const int &type)
+//{
+//   int ref = _data.getReference(id);
+//   if (ref == -1) {
+//      ref = _data.add(new CConstantData( id, type, _data.size()))->getAddress();
+//   }
+//   _code.addInt(ref);
+//}
+
+
+void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type)
+{
+   int ref = _data.getAddress(id);
+   if (ref == -1) {
+      //ref = _data.add((new CSymbol())->setAsConstantData( id, type, _data.getDataSize()))->getAddress();
+      ref = _data.addConstant (id, type, _data.getDataSize())->getAddress();
+   }
+   _code.addInt(ref);
+}
+
+
+CBinString CGenBytecode::getBinary()
+{
+//   _header.setSizes(_symbolTable.size(), _data.size(), _code.size());
+
+   CBinString ret;
+
+   ret += _header.getBinary();
+
+//   std::cout << "symbolTable.getSymbolsCount()=" << _symbolTable.getSymbolsCount() << std::endl;
+   ret.writeInt(_symbolTable.getSymbolsCount());
+   ret += _symbolTable.getBinary();
+
+//   std::cout << "data.size()=" << _data.getDataSize() << std::endl;
+   ret.writeInt(_data.getDataSize());
+   ret += _data.getBinary();
+
+//   std::cout << "code.size()=" << _code.size() << std::endl;
+   ret.writeInt(_code.size());
+   ret += _code.getBinary();
+
+   return ret;
+}
+

Added: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,38 @@
+#ifndef GPT_GEN_BYTECODE_H
+#define GPT_GEN_BYTECODE_H
+
+#include <map>
+#include <string>
+#include <vector>
+#include <fstream>
+
+#include "CHeader.hpp"
+#include "CSymbolTable.hpp"
+#include "CData.hpp"
+#include "CCode.hpp"
+#include "CBinString.hpp"
+
+class CGenBytecode
+{
+public:
+   CGenBytecode();
+   ~CGenBytecode();
+   void initProcedure(const std::string &procedureName, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
+   void finishProcedure();
+   void makeVarDefinition(const std::string &lexeme, const int &type);
+   void makeParDefinition(const std::string &lexeme, const int &type);
+   void registryLabel(const std::string &labelName);
+   void addOpcode(const std::string &mn);
+   void addAddress(const std::string &id, const int &category, const int &type);
+   CBinString getBinary();
+private:
+   CHeader                    _header;
+   CSymbolTable               _symbolTable;
+   CData                      _data;
+   CCode                      _code;
+   std::map<std::string,char> _opcodes;
+   std::string                _currentProcedure;
+};
+
+#endif
+

Added: trunk/gpt2/gptasm/src/CGptAsm.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGptAsm.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/CGptAsm.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,32 @@
+#include <fstream>
+
+
+#include "CGptAsm.hpp"
+#include "GptAssemblyLexer.hpp"
+#include "GptAssemblyParser.hpp"
+
+
+CGptAsm::CGptAsm( COptions *options ) : _options( options )
+{
+}
+
+
+bool CGptAsm::run( )
+{
+   ifstream in(_options->sourcefile.c_str());
+   GptAssemblyLexer lexer(in);
+   GptAssemblyParser parser(lexer);
+
+   string asmProgram = parser.program(_options->sourcefile);
+
+   ofstream asmFile(_options->destfile.c_str(), ios_base::out);
+   if (!asmFile) {
+      cout << "ERRO: n?o foi poss?vel abrir o arquivo: \"" << _options->destfile << "\"" << endl;
+      return false;
+   }
+
+   asmFile << asmProgram;
+
+   return true;
+}
+

Added: trunk/gpt2/gptasm/src/CGptAsm.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGptAsm.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/CGptAsm.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,16 @@
+#ifndef GPT_CGPTASM_H
+#define GPT_CGPTASM_H
+
+#include "COptions.hpp"
+
+class CGptAsm
+{
+public:
+   CGptAsm( COptions *options );
+   bool run( );
+private:
+   COptions *_options;
+};
+
+#endif
+

Added: trunk/gpt2/gptasm/src/Makefile
===================================================================
--- trunk/gpt2/gptasm/src/Makefile	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/Makefile	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,31 @@
+COMMON_DIR=../../common/src/
+
+INCLUDE_DIR=-I/usr/include/antlr/ -I$(COMMON_DIR)
+CC=g++
+CCFLAGS=-g -Wall
+
+objects = GptAssemblyLexer.o GptAssemblyParser.o main.o CGptAsm.o CGenBytecode.o \
+	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CCode.o $(COMMON_DIR)CHeader.o \
+        $(COMMON_DIR)CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o
+
+all: $(objects)
+	g++ -o gptasm $(objects) /usr/local/lib/libantlr.a
+
+GptAssemblyLexer.hpp GptAssemblyLexer.cpp: lexer.g
+	antlr lexer.g
+
+GptAssemblyParser.hpp GptAssemblyParser.cpp: parser.g
+	antlr parser.g
+
+
+%.o: %.cpp %.hpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+%.o: %.cpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+
+clean:
+	rm -f *.o $(COMMON_DIR)*.o GptAssemblyLexer.cpp GptAssemblyLexer.hpp GptAssemblyLexerTokenTypes.hpp \
+	GptAssemblyLexerTokenTypes.txt GptAssemblyParser.cpp GptAssemblyParser.hpp gptasm \
+	GptAssemblyParserTokenTypes.hpp GptAssemblyParserTokenTypes.txt 

Added: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,358 @@
+header {
+   #include <string>
+  #include <sstream>
+//  #include <iostream>
+//  #include <ctype.h>
+//  #include <antlr/TokenStreamSelector.hpp>
+//
+//  using namespace antlr;
+//  using namespace std;
+}
+
+
+options {
+   language="Cpp";  
+}
+
+
+class GptAssemblyLexer extends Lexer;
+
+
+options {
+   k=2;
+   charVocabulary='\0'..'\377';
+   exportVocab=GptAssemblyLexer;
+  testLiterals = true;
+//  testLiterals = false;
+//  filter=T_INVALID;
+//  genHashLines=false;//no #line
+}
+
+
+tokens {
+   T_KW_PROGRAM="program";
+   T_KW_ENDPROGRAM="endprogram";
+   T_KW_USER="use";
+   T_KW_VAR="var";
+   T_KW_INT="int";
+   T_KW_REAL="real";
+   T_KW_CHAR="char";
+   T_KW_STRING="string";
+   T_KW_BOOL="bool";
+   T_KW_POINTER="pointer";
+   T_KW_MATRIX="matrix";
+   T_KW_PROC="proc";
+   T_KW_ENDPROC="endproc";
+   T_KW_PARAM="param";
+   T_KW_REF="ref";
+   T_KW_ISUM="isum";
+   T_KW_SSUM="ssum";
+   T_KW_RSUM="rsum";
+   T_KW_ISUB="isub";
+   T_KW_SSUB="ssub";
+   T_KW_RSUB="rsub";
+   T_KW_IMUL="imul";
+   T_KW_RMUL="rmul";
+   T_KW_IDIV="idiv";
+   T_KW_RDIV="rdiv";
+   T_KW_IMOD="imod";
+   T_KW_RMOD="rmod";
+   T_KW_IGE="ige";
+   T_KW_SGE="sge";
+   T_KW_RGE="rge";
+   T_KW_ILE="ile";
+   T_KW_SLE="sle";
+   T_KW_RLE="rle";
+   T_KW_INE="ine";
+   T_KW_SNE="sne";
+   T_KW_RNE="rne";
+   T_KW_IGT="igt";
+   T_KW_SGT="sgt";
+   T_KW_RGT="rgt";
+   T_KW_ILT="ilt";
+   T_KW_SLT="slt";
+   T_KW_RLT="rlt";
+   T_KW_IEQ="ieq";
+   T_KW_SEQ="seq";
+   T_KW_REQ="req";
+   T_KW_OR="or";
+   T_KW_AND="and";
+   T_KW_XOR="xor";
+   T_KW_INEG="ineg";
+   T_KW_RNEG="rneg";
+   T_KW_NOT="not";
+   T_KW_IINC="iinc";
+   T_KW_IDEC="idec";
+   T_KW_I2C="i2c";
+   T_KW_R2C="r2c";
+   T_KW_S2C="s2c";
+   T_KW_B2C="b2c";
+   T_KW_I2R="i2r";
+   T_KW_C2R="c2r";
+   T_KW_S2R="s2r";
+   T_KW_B2R="b2r";
+   T_KW_I2B="i2b";
+   T_KW_C2B="c2b";
+   T_KW_R2B="r2b";
+   T_KW_S2B="s2b";
+   T_KW_I2S="i2s";
+   T_KW_C2S="c2s";
+   T_KW_R2S="r2s";
+   T_KW_B2S="b2s";
+   T_KW_P2S="p2s";
+   T_KW_C2I="c2i";
+   T_KW_R2I="r2i";
+   T_KW_S2I="s2i";
+   T_KW_B2I="b2i";
+   T_KW_ISET="iset";
+   T_KW_SSET="sset";
+   T_KW_RSET="rset";
+   T_KW_GETA="geta";
+   T_KW_IGETV="igetv";
+   T_KW_SGETV="sgetv";
+   T_KW_RGETV="rgetv";
+   T_KW_ISETV="isetv";
+   T_KW_SSETV="ssetv";
+   T_KW_RSETV="rsetv";
+   T_KW_JMP="jmp";
+   T_KW_IF="if";
+   T_KW_IFNOT="ifnot";
+   T_KW_PUSH="push";
+   T_KW_POP="pop";
+   T_KW_INCSP="incsp";
+   T_KW_DECSP="decsp";
+//   T_KW_PUSH_0="push_0";
+//   T_KW_PUSH_1="push_1";
+//   T_KW_PUSH_2="push_2";
+//   T_KW_PUSH_3="push_3";
+//   T_KW_PUSH_4="push_4";
+//   T_KW_PUSH_5="push_5";
+   T_KW_PUSH_INT="push_int";
+   T_KW_PUSH_STRING="push_string";
+   T_KW_PUSH_REAL="push_real";
+   T_KW_PUSH_CHAR="push_char";
+   T_KW_PUSH_BOOL="push_bool";
+   T_KW_PUSH_MATRIX="push_matrix";
+   T_KW_PUSH_SP="push_sp";
+   T_KW_POP_SP="pop_sp";
+   T_KW_INCSP_4="incsp_4";
+   T_KW_INCSP_8="incsp_8";
+   T_KW_DECSP_4="decsp_4";
+   T_KW_DECSP_8="decsp_8";
+   T_KW_PCALL="pcall";
+   T_KW_RET="ret";
+   T_KW_SALLOC="salloc";
+   T_KW_SFREE="sfree";
+   T_KW_SSETC="ssetc";
+   T_KW_SGETC="sgetc";
+   T_KW_M1ALLOC="m1alloc";
+   T_KW_M2ALLOC="m2alloc";
+   T_KW_MFREE="mfree";
+   T_KW_M1SET="m1set";
+   T_KW_M1GET="m1get";
+   T_KW_M2SET="m2set";
+   T_KW_M2GET="m2get";
+   T_KW_MCOPY="mcopy";
+   T_KW_MGETSIZE1="mgetsize1";
+   T_KW_MGETSIZE2="mgetsize2";
+   T_KW_NOP="nop";
+//   T_KW_EXIT_0="exit_0";
+//   T_KW_EXIT_1="exit_1";
+   T_KW_HLT="hlt";
+   T_KW_EXIT="exit";
+   T_KW_TRUE="true";
+   T_KW_FALSE="false";
+   T_REAL_VALUE="n?mero real"; //nondeterminism T_INT_LIT & T_REAL_LIT
+}
+
+
+{
+public:  
+//  void setNextFilename(string str) {
+//    nextFilename = str;
+//  }
+
+//  string getNextFilename( )
+//  {
+//    return nextFilename;
+//  }
+
+private:
+//  string nextFilename;
+//  TokenStreamSelector* selector;  
+//  bool hasLatim;
+}
+
+
+/******************* Constant literals ***********************/
+
+T_INT_VALUE
+options {
+   paraphrase = "int number";
+}
+   : ('0' ('c'|'C') )=> T_OCTAL_VALUE
+   | ('0' ('x'|'X') )=> T_HEX_VALUE
+   | ('0' ('b'|'B') )=> T_BIN_VALUE
+   | T_INTEGER_VALUE
+      (
+         '.' (T_DIGIT)+
+         {$setType(T_REAL_VALUE);}
+      )?
+   ;
+
+protected
+T_INTEGER_VALUE
+   : (T_DIGIT)+
+   ;
+
+protected
+T_OCTAL_VALUE
+   : '0' ('c'|'C')
+      {
+         //convert to base 10
+         std::string str = $getText;
+         int base10;
+         str = str.substr(2);//0c
+         base10 = strtoul(str.c_str(), NULL, 8);
+
+         std::stringstream s;
+         s << base10;        
+         std::string res = s.str();
+         $setText(res);
+      }
+   ;
+
+protected
+T_HEX_VALUE
+   : '0' ('x'|'X')
+      {
+         //convert to base 10
+         std::string str = $getText;
+         int base10;
+         base10 = strtoul(str.c_str(), NULL, 16);
+  
+         std::stringstream s;
+         s << base10;
+         std::string res = s.str();
+         $setText(res);      
+      }
+   ;
+
+protected
+T_BIN_VALUE
+   : '0' ('b'|'B')
+      {
+         //convert to base 10
+         int base10;
+         std::string str = $getText.substr(2);
+         base10 = strtoul(str.c_str(), NULL, 2);//0b
+
+         std::stringstream s;
+         s << base10;
+         std::string res = s.str();
+         $setText(res);
+      }
+   ;
+
+T_CHAR_VALUE
+options {
+   paraphrase = "char";
+}
+   : '\'' ( ~( '\'' | '\\' ) | ESC )? '\''
+   ;
+
+T_STRING_VALUE
+options {
+   paraphrase = "string";
+}
+   : '"'! ( ~( '"' | '\\' | '\n' | '\r') | ESC)* '"'!
+   ;
+
+protected
+ESC
+   : '\\' . //permite "\a" (possibilida ser avaliado posteriormente como "a")
+   ;
+
+
+T_COLON
+options {
+   paraphrase = "':'";
+}
+   : ':'
+   ;
+  
+T_COMMA
+options {
+   paraphrase = "','";
+}
+   : ','
+   ;
+
+//T_DOT
+//options {
+//  paraphrase = "'.'";
+//}
+//  : '.'
+//  ;
+
+T_WS_ : (' '
+   | '\t'
+   | '\n' { newline(); }
+   | '\r')
+      { $setType(antlr::Token::SKIP); }
+   ;
+
+SL_COMMENT
+   : "//" (~('\n'))* ('\n')?
+      { 
+         newline();
+         $setType(antlr::Token::SKIP);
+      }
+   ;
+
+ML_COMMENT
+{int line = getLine();}
+   : "/*" 
+      ( 
+         options { generateAmbigWarnings=false; } :  
+         '\n'                     {newline();}
+         | ('\r' '\n')=> '\r' '\n'  {newline();}
+         | '\r'                     {newline();}
+         |~('*'|'\n'|'\r')
+         | ('*' ~'/' )=> '*' 
+      )* 
+      "*/"
+      {$setType(antlr::Token::SKIP);}
+   ;
+
+exception
+catch[antlr::RecognitionException] {  
+   std::stringstream s;
+   s << "AVISO: coment?rio iniciado na linha " << line << " n?o termina com \"*/\".";
+
+   _ttype = antlr::Token::SKIP;
+}
+
+T_ID
+   : (T_LETTER | '_') (T_LETTER | T_DIGIT | '_')*
+   ;
+
+protected
+T_DIGIT
+   : '0'..'9'
+   ;
+
+protected
+T_LETTER
+   : 'a'..'z'|'A'..'Z' | '\u00C0'..'\u00FF' /* latim-1 */
+   ;
+
+
+protected
+T_INVALID
+   : . 
+      {
+         printf("INVALID %d == '%x' -> '%c'\n", $getText.c_str()[0], $getText.c_str()[0], $getText.c_str()[0]);
+      }
+   ;
+

Added: trunk/gpt2/gptasm/src/main.cpp
===================================================================
--- trunk/gpt2/gptasm/src/main.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/main.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,68 @@
+#include <iostream>
+#include <string>
+
+using namespace std;
+
+
+#include "COptions.hpp"
+#include "CGptAsm.hpp"
+
+
+void showSyntax();
+
+
+int main (int argc, char *argv[])
+{
+   int i;
+   COptions options;
+
+   cout << "GptAsm, release 0.1.0 (development release)" << endl;
+
+   while ((i = getopt(argc, argv, "h")) != -1) {
+      switch (i) {
+         case 'h':
+            showSyntax();
+            return EXIT_SUCCESS;
+            break;
+         default:
+            break;
+      }
+   }
+
+   argc -= optind;
+   argv += optind;
+
+   if (argc < 1) {
+      showSyntax();
+      return EXIT_FAILURE;
+   }
+
+   options.sourcefile = string(argv[0]) + ".gasm";
+   options.destfile   = string(argv[0]) + ".gvm";
+
+   cout << "Compiling " << options.sourcefile << "..." << endl;
+
+   CGptAsm gptc( &options );
+
+   if (gptc.run()) {
+      cout << "Program " << options.sourcefile << " ok !!!" << endl << endl;
+   } else {
+      cout << "Program " << options.sourcefile << " has errors..." << endl << endl;
+      exit( EXIT_FAILURE );
+   }
+
+   return EXIT_SUCCESS;
+}
+
+
+void showSyntax() {
+   cout << endl 
+        << "Desenvolvido por XXX, YYY e ZZZ" << endl 
+        << "Novembro, 2007" << endl 
+        << endl 
+        << "Syntax: gptc [options] file" << endl 
+        << "Options:" << endl 
+        << "         -h help" << endl 
+        << endl;
+}
+

Added: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,371 @@
+header {
+   #include <string>
+   #include "CGenBytecode.hpp"
+   #include <antlr/config.hpp>
+   #include <antlr/TokenStream.hpp>
+   #include <antlr/TokenBuffer.hpp>
+   #include "GptAssemblyParserTokenTypes.hpp"
+   #include <antlr/LLkParser.hpp>
+   #include "CSymbolList.hpp"
+}
+
+options {
+  language="Cpp";  
+}
+
+{
+}
+
+class GptAssemblyParser extends Parser;
+
+options {
+  importVocab=GptAssemblyLexer;  // use vocab generated by lexer
+//  genHashLines=false;//no #line
+  k=2;
+}
+
+{  
+   public:
+      CGenBytecode bytecode;
+      void declareVar(const std::string& lexeme, int type)
+      {
+         bytecode.makeVarDefinition( lexeme, type );
+      }
+      void declareParameter(const std::string& lexeme, int type)
+      {
+         bytecode.makeParDefinition( lexeme, type );
+      }
+      antlr::RefToken getLastToken()
+      {
+         return LT(0);
+      }
+      std::string getLastTokenText()
+      {
+         return LT(0)->getText();
+      }
+}
+
+
+//####################################################################
+//####################### In?cio da gram?tica ########################
+//####################################################################
+
+//##############
+//## Programa ##
+//##############
+
+//--------------------------------------------------------
+  program [std::string filename] returns [std::string ret]
+//--------------------------------------------------------
+   : "program" T_ID
+     (imports)*
+     (var_declaration)*
+     (procedure_declaration)+
+     "endprogram"
+     EOF
+     {
+        ret = bytecode.getBinary();
+     }
+     ;
+
+//-------
+  imports
+//-------
+   : "use" T_STRING_VALUE
+   ;
+
+//#############################
+//## Declara??o de vari?veis ##
+//#############################
+
+//---------------
+  var_declaration
+//---------------
+{
+  char tk_type;
+}
+  : "var" tk_id:T_ID tk_type=primitive_type
+    { declareVar(tk_id->getText(), tk_type); }
+  ;
+
+//--------------------------------
+  primitive_type returns [char ret]
+//--------------------------------
+  : "int"     {ret=CSymbol::INT;}
+  | "real"    {ret=CSymbol::REAL;}
+  | "char"    {ret=CSymbol::CHAR;}
+  | "string"  {ret=CSymbol::STRING;}
+  | "bool"    {ret=CSymbol::BOOL;}
+//  | "pointer" {ret=CSymbol::POINTER;}
+  | "matrix"  {ret=CSymbol::MATRIX;}
+  ;
+
+//#################################
+//## Declaracao de procedimentos ##
+//#################################
+
+//---------------------
+  procedure_declaration
+//---------------------
+  : "proc" 
+   tk_id:T_ID
+    { bytecode.initProcedure(tk_id->getText(), false, 0, std::vector<CSymbol>()); }
+    (parameter_declaration)*
+    (var_declaration)*
+    code_block
+    { bytecode.finishProcedure(); }
+    "endproc"
+  ;
+
+//---------------------
+  parameter_declaration
+//---------------------
+{
+  int tk_type;
+}
+  : "param" ("ref")? tk_id:T_ID tk_type=primitive_type { declareParameter( tk_id->getText(), tk_type ); }
+  ;
+
+//#####################
+//## Bloco de c?digo ##
+//#####################
+
+//----------
+  code_block
+//----------
+  : (statement)*
+  ;
+
+//---------
+  statement
+//---------
+  :
+  ( label_definition
+  | mn_atribuicao_binaria
+  | mn_atribuicao_unaria
+  | mn_conversao_dados
+  | mn_copia_simples
+  | mn_address_and_pointer
+  | mn_salto
+  | mn_chamada_subrotina
+  | mn_manipulacao_strings
+  | mn_manipulacao_matrizes
+  | mn_execucao
+  )
+  ;
+
+//----------------
+  label_definition
+//----------------
+  : tk_id:T_ID T_COLON { bytecode.registryLabel(tk_id->getText()); }
+  ;
+
+//-----
+  label
+//-----
+   : T_ID
+   ;
+
+//---------------------
+  mn_atribuicao_binaria
+//---------------------
+   :  ( "isum"|"ssum"|"rsum"
+      | "isub"|"ssub"|"rsub"
+      | "imul"|"rmul"|"idiv"|"rdiv"
+      | "imod"|"rmod"
+      | "ige" |"sge" |"rge" |"ile"|"sle"|"rle"
+      | "ine" |"sne" |"rne"
+      | "igt" |"sgt" |"rgt"
+      | "ilt" |"slt" |"rlt"
+      | "ieq" |"seq" |"req"
+      | "or"  |"and" |"xor"
+      )
+      {bytecode.addOpcode(getLastTokenText());}
+      identifier T_COMMA element T_COMMA element
+   ;
+
+//--------------------
+  mn_atribuicao_unaria
+//--------------------
+   :  ("ineg"|"rneg"|"not"|"iinc"|"idec") 
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element
+   ;
+
+//------------------
+  mn_conversao_dados
+//------------------
+   :  ( "i2c"|"r2c"|"s2c"|"b2c"
+      | "i2r"|"c2r"|"s2r"|"b2r"
+      | "i2b"|"c2b"|"r2b"|"s2b"
+      | "i2s"|"c2s"|"r2s"|"b2s"|"p2s"
+      | "c2i"|"r2i"|"s2i"|"b2i"
+      )
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element
+   ;
+
+//----------------
+  mn_copia_simples
+//----------------
+   :  ( "iset"|"sset"|"rset" )
+      {bytecode.addOpcode(getLastTokenText());}
+      identifier
+      T_COMMA
+      element
+   ;
+
+//----------------------
+  mn_address_and_pointer
+//----------------------
+   :  "geta"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID
+   |  ("igetv"|"sgetv"|"rgetv")
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element T_COLON element
+   |  ("isetv"|"ssetv"|"rsetv")
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COLON element T_COMMA element
+   ;
+
+//--------
+  mn_salto
+//--------
+   :  "jmp" label
+      {bytecode.addOpcode(getLastTokenText());}
+   |  ("if"|"ifnot")
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA label
+   ;
+
+//--------------------
+  mn_chamada_subrotina
+//--------------------
+   :  "push"
+      {bytecode.addOpcode(getLastTokenText());}
+      element
+   |  "pop"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
+   |  ("incsp"|"decsp")
+      {bytecode.addOpcode(getLastTokenText());}
+      T_INT_VALUE
+      { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+//   |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
+//      {bytecode.addOpcode(getLastTokenText());}
+   |  ("push_int"|"push_string"|"push_real"|"push_char"|"push_bool"|"push_matrix")
+      {bytecode.addOpcode(getLastTokenText());}
+   |  ("push_sp"|"pop_sp")
+      {bytecode.addOpcode(getLastTokenText());}
+   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
+      {bytecode.addOpcode(getLastTokenText());}
+   |  "pcall"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
+      { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
+   |  "ret"
+      {bytecode.addOpcode(getLastTokenText());}
+   ;
+
+//----------------------
+  mn_manipulacao_strings
+//----------------------
+   :  ( "salloc"|"sfree" )
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
+   |  "ssetc"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element T_COMMA element
+   |  "sgetc"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID T_COMMA element
+   ;
+
+//-----------------------
+  mn_manipulacao_matrizes
+//-----------------------
+   :  "m1alloc"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
+      T_COMMA 
+      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      T_COMMA 
+      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+   |  "m2alloc"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_INT_VALUE T_COMMA T_INT_VALUE T_COMMA T_INT_VALUE
+   |  "mfree"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
+   |  "m1set"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element T_COMMA element
+   |  "m1get"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID T_COMMA element
+   |  "m2set"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA element T_COMMA element T_COMMA element
+   |  "m2get"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID T_COMMA element T_COMMA element
+   |  "mcopy"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID
+   |  "mgetsize1"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID
+   |  "mgetsize2"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID T_COMMA T_ID
+   ;
+
+//-----------
+  mn_execucao
+//-----------
+//   :   ("nop"|"exit_0"|"exit_1"|"hlt")
+   :   ("nop"|"hlt")
+      {bytecode.addOpcode(getLastTokenText());}
+   |   "exit"
+      {bytecode.addOpcode(getLastTokenText());}
+       T_INT_VALUE
+  ;
+
+identifier
+  : id:T_ID { bytecode.addAddress(id->getText(),CSymbol::VAR, CSymbol::STRING); }
+  ;
+
+
+//#############
+//## Literal ##
+//#############
+
+//---------------------------------
+  literal //returns [std::string ret]
+//---------------------------------
+  : ( 
+        T_STRING_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::STRING); }
+      | T_INT_VALUE    { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      | T_REAL_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::REAL); }
+      | T_CHAR_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::CHAR); }
+      | "true"         { bytecode.addAddress("1",                CSymbol::CONST, CSymbol::INT); }
+      | "false"        { bytecode.addAddress("0",                CSymbol::CONST, CSymbol::INT); }
+    ) 
+  ;
+
+//op_unario
+//  : (
+//        e:T_MENOS
+//      | a:T_MAIS
+//    )?
+//  ; 
+
+//---------------------------------
+  element //returns [std::string ret]
+//---------------------------------
+  : identifier //{ bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::STRING); }
+//  | ret=literal
+  | literal
+  ;
+

Added: trunk/gpt2/gptasm/test/asm.sh
===================================================================
--- trunk/gpt2/gptasm/test/asm.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/asm.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,22 @@
+rm $1.gvm 1>/dev/null 2>&1
+#rm $1.stdout 1>/dev/null 2>&1
+
+../../gptasm $1
+if [ $? -ne 0 ]
+then
+	echo "Erro: nao foi possivel assemblar $1.gasm"
+	exit 1
+fi
+
+#./gvm $1 > $1.stdout
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: nao foi possivel executar $1.gvm"
+#	exit 1
+#fi
+#echo ""
+
+#cat $1.stdout
+
+#cat $1.gasm
+


Property changes on: trunk/gpt2/gptasm/test/asm.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/asm_all.sh
===================================================================
--- trunk/gpt2/gptasm/test/asm_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/asm_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,10 @@
+echo "Assemblando todos os arquivos .gasm do diretorio"
+
+rm *.gvm
+#rm *.stdout
+
+for i in `ls *.gasm -1 | sed s/"\.gasm"//g`
+do
+	./asm.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/gptasm/test/asm_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/check.sh
===================================================================
--- trunk/gpt2/gptasm/test/check.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/check.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,84 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+echo "Realizando o teste regressivo no arquivo $1.gasm"
+
+exist_file $1.gasm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.gasm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.gvm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+#exist_file checked/$1.stdout
+#if [ $? -ne 0 ]
+#then
+#	exit 2
+#fi
+
+diff $1.gasm checked/$1.gasm >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Os arquivos $1.gasm e checked/$1.gasm sao diferentes. Nao eh possivel realizar o teste regressivo !"
+	exit 2
+fi
+
+./asm.sh $1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Arquivo $1.gasm nao foi compilado corretamente"
+	exit 2
+fi
+
+diff $1.gvm checked/$1.gvm >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Teste regressivo falhou. Os arquivos $1.gvm e checked/$1.gvm sao diferentes !!!"
+	gdumpasm -D$1
+	gdumpasm -Dchecked/$1
+	vimdiff $1.dump checked/$1.dump
+	exit 1
+fi
+
+#diff $1.stdout checked/$1.stdout >/dev/null 2>&1
+#if [ $? -ne 0 ]
+#then
+#	echo "Erro: Teste regressivo falhou. Os arquivos $1.stdout e checked/$1.stdout sao diferentes !!!"
+#	vimdiff $1.stdout checked/$1.stdout
+#	exit 1
+#fi
+
+echo "Ok: Teste regressivo ok para $1.gasm"
+
+exit 0
+


Property changes on: trunk/gpt2/gptasm/test/check.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/check_all.sh
===================================================================
--- trunk/gpt2/gptasm/test/check_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/check_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,14 @@
+echo "Realizando o teste regressivo em todos os arquivos .gasm do diretorio"
+
+rm *.gvm 1>/dev/null 2>&1
+rm *.stdout 1>/dev/null 2>&1
+
+for i in `ls *.gasm -1 | sed s/"\.gasm"//g`
+do
+	./check.sh $i 
+	echo ""
+#	if [ $? -ne 0 ]
+#	then
+#		echo "Falha no teste regressivo do arquivo $i";
+#	fi
+done


Property changes on: trunk/gpt2/gptasm/test/check_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/constantes_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/constantes_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/constantes_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa constantes_1.gasm gerado a partir de constantes_1.gpt
+program constantes_1
+
+var i int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset i, 1
+	__label_1:
+	ile __temp_1, i, total
+	ifnot __temp_1, __label_2
+	push i
+	push_int
+	push 1
+	pcall imprima
+	iinc i, 1
+	jmp __label_1
+	__label_2:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,24 @@
+// Programa estruturas_condicionais_1.gasm gerado a partir de estruturas_condicionais_1.gpt
+program estruturas_condicionais_1
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 10
+	ige __temp_1, x, 20
+	ifnot __temp_1, __label_1
+	iset x, 2
+	jmp __label_2
+	__label_1:
+	iset x, 1
+	__label_2:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,36 @@
+// Programa estruturas_condicionais_2.gasm gerado a partir de estruturas_condicionais_2.gpt
+program estruturas_condicionais_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 20
+	ige __temp_1, x, 0
+	ifnot __temp_1, __label_1
+	igt __temp_2, x, 40
+	ifnot __temp_2, __label_2
+	push "x>40"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_3
+	__label_2:
+	push "x<=40"
+	push_string
+	push 1
+	pcall imprima
+	__label_3:
+	jmp __label_4
+	__label_1:
+	push "x eh negativo !!!"
+	push_string
+	push 1
+	pcall imprima
+	__label_4:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,30 @@
+// Programa estruturas_condicionais_3.gasm gerado a partir de estruturas_condicionais_3.gpt
+program estruturas_condicionais_3
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	iset x, 1
+	ige __temp_1, x, 1
+	ile __temp_2, x, 10
+	and __temp_3, __temp_1, __temp_2
+	ifnot __temp_3, __label_1
+	push "x entre 1 e 10"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_2
+	__label_1:
+	push "x n?o est? entre 1 e 10"
+	push_string
+	push 1
+	pcall imprima
+	__label_2:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,41 @@
+// Programa estruturas_condicionais_4.gasm gerado a partir de estruturas_condicionais_4.gpt
+program estruturas_condicionais_4
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	push 0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	iset __temp_2, x
+	ieq __temp_3, __temp_2, 1
+	ifnot __temp_3, __label_2
+	push "x = um"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_1
+	__label_2:
+	ieq __temp_4, __temp_2, 2
+	ifnot __temp_4, __label_3
+	push "x = dois"
+	push_string
+	push 1
+	pcall imprima
+	jmp __label_1
+	__label_3:
+	push "x diferente de um e dois"
+	push_string
+	push 1
+	pcall imprima
+	__label_1:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_5.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_condicionais_5.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa estruturas_condicionais_5.gasm gerado a partir de estruturas_condicionais_5.gpt
+program estruturas_condicionais_5
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 10
+	ige __temp_1, x, 20
+	ifnot __temp_1, __label_1
+	iset x, 2
+	jmp __label_2
+	__label_1:
+	__label_2:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_1.gasm gerado a partir de estruturas_repeticao_1.gpt
+program estruturas_repeticao_1
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 1
+	__label_1:
+	ile __temp_1, x, 10
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	iinc x, 1
+	jmp __label_1
+	__label_2:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_2.gasm gerado a partir de estruturas_repeticao_2.gpt
+program estruturas_repeticao_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	iset x, 100
+	__label_1:
+	ige __temp_1, x, 0
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	idec x, 2
+	jmp __label_1
+	__label_2:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,25 @@
+// Programa estruturas_repeticao_3.gasm gerado a partir de estruturas_repeticao_3.gpt
+program estruturas_repeticao_3
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 1
+	__label_1:
+	ile __temp_1, x, 10
+	ifnot __temp_1, __label_2
+	push x
+	push_int
+	push 1
+	pcall imprima
+	isum __temp_2, x, 1
+	iset x, __temp_2
+	jmp __label_1
+	__label_2:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/estruturas_repeticao_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa estruturas_repeticao_4.gasm gerado a partir de estruturas_repeticao_4.gpt
+program estruturas_repeticao_4
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 1
+	__label_1:
+	push x
+	push_int
+	push 1
+	pcall imprima
+	isum __temp_1, x, 1
+	iset x, __temp_1
+	igt __temp_2, x, 10
+	ifnot __temp_2, __label_1
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,38 @@
+// Programa expressoes_matematicas_1.gasm gerado a partir de expressoes_matematicas_1.gpt
+program expressoes_matematicas_1
+
+var t1 int
+var t2 int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	var __temp_5 int
+	isum __temp_1, 1, 2
+	iset t1, __temp_1
+	imul __temp_2, 5, 3
+	iset t1, __temp_2
+	isum __temp_3, 2, t1
+	iset t2, __temp_3
+	push t2
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	imul __temp_4, 5, 3
+	isum __temp_5, 2, __temp_4
+	iset t1, __temp_5
+	push t1
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/expressoes_matematicas_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,20 @@
+// Programa expressoes_matematicas_2.gasm gerado a partir de expressoes_matematicas_2.gpt
+program expressoes_matematicas_2
+
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	imul __temp_1, 5, 3
+	isum __temp_2, 2, __temp_1
+	push __temp_2
+	push_int
+	push "2+5*3="
+	push_string
+	push 2
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,34 @@
+// Programa funcoes_definidas_usuario_1.gasm gerado a partir de funcoes_definidas_usuario_1.gpt
+program funcoes_definidas_usuario_1
+
+// Procedure main
+proc main
+	var __temp_1 int
+	push 0
+	push 7
+	push 2
+	pcall soma
+	pop __temp_1
+	push __temp_1
+	push_int
+	push "A soma ?: "
+	push_string
+	push 2
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	param x int
+	param y int
+	var __result int
+	var __temp_2 int
+	isum __temp_2, x, y
+	iset __result, __temp_2
+	ret
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/funcoes_definidas_usuario_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,61 @@
+// Programa funcoes_definidas_usuario_2.gasm gerado a partir de funcoes_definidas_usuario_2.gpt
+program funcoes_definidas_usuario_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	push "Digite um n?mero:"
+	push_string
+	push 1
+	pcall imprima
+	push 0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	push 0
+	push x
+	pcall fatorial
+	pop __temp_2
+	push __temp_2
+	push_int
+	push "? "
+	push_string
+	push x
+	push_int
+	push "Fatorial de "
+	push_string
+	push 4
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure fatorial
+proc fatorial
+	param z int
+	var __result int
+	var __temp_3 int
+	var __temp_4 int
+	var __temp_5 int
+	var __temp_6 int
+	ieq __temp_3, z, 1
+	ifnot __temp_3, __label_1
+	iset __result, 1
+	ret
+	jmp __label_2
+	__label_1:
+	push 0
+	isub __temp_4, z, 1
+	push __temp_4
+	pcall fatorial
+	pop __temp_5
+	imul __temp_6, z, __temp_5
+	iset __result, __temp_6
+	ret
+	__label_2:
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/inline_codigo_gptassembly.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/inline_codigo_gptassembly.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/inline_codigo_gptassembly.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,28 @@
+// Programa inline_codigo_gptassembly.gasm gerado a partir de inline_codigo_gptassembly.gpt
+program inline_codigo_gptassembly
+
+var x int
+// Procedure main
+proc main
+	iset x, 10
+	push x
+	push_int
+	push 1
+	pcall imprima
+
+	// asm-begin
+	
+        iset x, 20
+        isum x, x, 80
+    
+	// asm-end
+
+	push x
+	push_int
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,14 @@
+// Programa invocando_subrotinas_linguagem_1.gasm gerado a partir de invocando_subrotinas_linguagem_1.gpt
+program invocando_subrotinas_linguagem_1
+
+// Procedure main
+proc main
+	push "Ol? mundo !!!"
+	push_string
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/invocando_subrotinas_linguagem_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,26 @@
+// Programa invocando_subrotinas_linguagem_2.gasm gerado a partir de invocando_subrotinas_linguagem_2.gpt
+program invocando_subrotinas_linguagem_2
+
+var x int
+// Procedure main
+proc main
+	var __temp_1 int
+	push "Digite um n?mero: "
+	push_string
+	push 1
+	pcall imprima
+	push 0
+	pcall leia
+	pop __temp_1
+	iset x, __temp_1
+	push x
+	push_int
+	push "O n?mero digitado foi "
+	push_string
+	push 2
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,39 @@
+// Programa matrizes_1.gasm gerado a partir de matrizes_1.gpt
+program matrizes_1
+
+var m matrix
+var i int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	iset i, 1
+	__label_1:
+	ile __temp_1, i, 10
+	ifnot __temp_1, __label_2
+	imul __temp_2, i, 10
+	m1set m, __temp_2
+	iinc i, 1
+	jmp __label_1
+	__label_2:
+	push "Valores das coordenadas:"
+	push_string
+	push 1
+	pcall imprima
+	iset i, 1
+	__label_3:
+	ile __temp_3, i, 10
+	ifnot __temp_3, __label_4
+	push m
+	push_matrix
+	push 1
+	pcall imprima
+	iinc i, 1
+	jmp __label_3
+	__label_4:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,45 @@
+// Programa matrizes_2.gasm gerado a partir de matrizes_2.gpt
+program matrizes_2
+
+var x int
+var y int
+var c ERRO !!!
+var i int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	iset i, 1
+	__label_1:
+	ile __temp_1, i, 10
+	ifnot __temp_1, __label_2
+	imul __temp_2, i, 10
+	iset x, __temp_2
+	imul __temp_3, i, 100
+	iset y, __temp_3
+	iinc i, 1
+	jmp __label_1
+	__label_2:
+	push "Valores das coordenadas:"
+	push_string
+	push 1
+	pcall imprima
+	iset i, 1
+	__label_3:
+	ile __temp_4, i, 10
+	ifnot __temp_4, __label_4
+	push c
+	push_desconhecido
+	push "x="
+	push_string
+	push 2
+	iinc i, 1
+	jmp __label_3
+	__label_4:
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,28 @@
+// Programa matrizes_3.gasm gerado a partir de matrizes_3.gpt
+program matrizes_3
+
+// Procedure main
+proc main
+	pcall mostra
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure mostra
+proc mostra
+	var resultado matrix
+	var __temp_1 matrix
+	m1set resultado, 10
+	m1set resultado, 20
+	m1sum __temp_1, resultado, resultado
+	m1set resultado, __temp_1
+	push resultado
+	push_matrix
+	push "resultado[2]="
+	push_string
+	push 2
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/matrizes_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,15 @@
+// Programa matrizes_4.gasm gerado a partir de matrizes_4.gpt
+program matrizes_4
+
+var x matrix
+// Procedure main
+proc main
+	push x
+	push_matrix
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,24 @@
+// Programa procedimentos_definidos_usuario_1.gasm gerado a partir de procedimentos_definidos_usuario_1.gpt
+program procedimentos_definidos_usuario_1
+
+// Procedure main
+proc main
+	pcall soma
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	var __temp_1 int
+	isum __temp_1, 2, 7
+	push __temp_1
+	push_int
+	push "A soma de 2 + 7 ?: "
+	push_string
+	push 2
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,28 @@
+// Programa procedimentos_definidos_usuario_2.gasm gerado a partir de procedimentos_definidos_usuario_2.gpt
+program procedimentos_definidos_usuario_2
+
+// Procedure main
+proc main
+	push 7
+	push 2
+	pcall soma
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	param x int
+	param y int
+	var __temp_1 int
+	isum __temp_1, x, y
+	push __temp_1
+	push_int
+	push "A soma ?: "
+	push_string
+	push 2
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,42 @@
+// Programa procedimentos_definidos_usuario_3.gasm gerado a partir de procedimentos_definidos_usuario_3.gpt
+program procedimentos_definidos_usuario_3
+
+var g int
+// Procedure main
+proc main
+	iset g, 0
+	iset g, g
+	push 10
+	push g
+	pcall roda
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure roda
+proc roda
+	param p1 int
+	param p2 int
+	var l1 int
+	var l2 int
+	iset l1, 0
+	iset l1, l2
+	iset l1, g
+	iset g, l1
+	iset p1, p2
+	iset l1, p1
+	iset p1, l1
+	iset p1, g
+	iset g, p1
+	push l1
+	push_int
+	push p1
+	push_int
+	push g
+	push_int
+	push 3
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/procedimentos_definidos_usuario_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,34 @@
+// Programa procedimentos_definidos_usuario_4.gasm gerado a partir de procedimentos_definidos_usuario_4.gpt
+program procedimentos_definidos_usuario_4
+
+var x int
+var y int
+// Procedure main
+proc main
+	iset x, 10
+	iset y, 20
+	push 30
+	pcall soma
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure soma
+proc soma
+	param z int
+	var s int
+	var __temp_1 int
+	var __temp_2 int
+	isum __temp_1, x, y
+	isum __temp_2, __temp_1, z
+	iset s, __temp_2
+	push s
+	push_int
+	push "A soma de x, y e z ?: "
+	push_string
+	push 2
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,24 @@
+// Programa variaveis_1.gasm gerado a partir de variaveis_1.gpt
+program variaveis_1
+
+var x int
+var y int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	iset x, 10
+	iset y, 20
+	imul __temp_1, x, y
+	isum __temp_2, __temp_1, 4
+	push __temp_2
+	push_int
+	push "x*y+4="
+	push_string
+	push 2
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,33 @@
+// Programa variaveis_2.gasm gerado a partir de variaveis_2.gpt
+program variaveis_2
+
+var v int
+// Procedure main
+proc main
+	var __temp_1 int
+	var __temp_2 int
+	var __temp_3 int
+	var __temp_4 int
+	iset v, 10
+	iset v, v
+	isum __temp_1, 10, 20
+	iset v, __temp_1
+	isum __temp_2, v, 20
+	iset v, __temp_2
+	isum __temp_3, 30, v
+	iset v, __temp_3
+	isum __temp_4, v, v
+	iset v, __temp_4
+	push 10
+	push_int
+	push 1
+	pcall imprima
+	push v
+	push_int
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,33 @@
+// Programa variaveis_3.gasm gerado a partir de variaveis_3.gpt
+program variaveis_3
+
+var v real
+// Procedure main
+proc main
+	var __temp_1 real
+	var __temp_2 real
+	var __temp_3 real
+	var __temp_4 real
+	rset v, 10.0
+	rset v, v
+	rsum __temp_1, 10.0, 20.0
+	rset v, __temp_1
+	rsum __temp_2, v, 20.0
+	rset v, __temp_2
+	rsum __temp_3, 30.0, v
+	rset v, __temp_3
+	rsum __temp_4, v, v
+	rset v, __temp_4
+	push 10.0
+	push_real
+	push 1
+	pcall imprima
+	push v
+	push_real
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,33 @@
+// Programa variaveis_4.gasm gerado a partir de variaveis_4.gpt
+program variaveis_4
+
+var v char
+// Procedure main
+proc main
+	var __temp_1 char
+	var __temp_2 char
+	var __temp_3 char
+	var __temp_4 char
+	iset v, 'a'
+	iset v, v
+	isum __temp_1, 'a', 'b'
+	iset v, __temp_1
+	isum __temp_2, v, 'b'
+	iset v, __temp_2
+	isum __temp_3, 'c', v
+	iset v, __temp_3
+	isum __temp_4, v, v
+	iset v, __temp_4
+	push 'a'
+	push_char
+	push 1
+	pcall imprima
+	push v
+	push_char
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_5.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_5.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,33 @@
+// Programa variaveis_5.gasm gerado a partir de variaveis_5.gpt
+program variaveis_5
+
+var v string
+// Procedure main
+proc main
+	var __temp_1 string
+	var __temp_2 string
+	var __temp_3 string
+	var __temp_4 string
+	sset v, "a"
+	sset v, v
+	ssum __temp_1, "a", "b"
+	sset v, __temp_1
+	ssum __temp_2, v, "b"
+	sset v, __temp_2
+	ssum __temp_3, "c", v
+	sset v, __temp_3
+	ssum __temp_4, v, v
+	sset v, __temp_4
+	push "aa"
+	push_string
+	push 1
+	pcall imprima
+	push v
+	push_string
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_6.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_6.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,26 @@
+// Programa variaveis_6.gasm gerado a partir de variaveis_6.gpt
+program variaveis_6
+
+var v bool
+// Procedure main
+proc main
+	iset v, true
+	iset v, false
+	iset v, v
+	push true
+	push_bool
+	push 1
+	pcall imprima
+	push false
+	push_bool
+	push 1
+	pcall imprima
+	push v
+	push_bool
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_7.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_7.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_7.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,26 @@
+// Programa variaveis_7.gasm gerado a partir de variaveis_7.gpt
+program variaveis_7
+
+// Procedure main
+proc main
+	pcall mostra
+	exit 0
+endproc
+// Fim da procedure
+
+// Procedure mostra
+proc mostra
+	var resultado int
+	var __temp_1 int
+	isum __temp_1, 4, 5
+	iset resultado, __temp_1
+	push resultado
+	push_int
+	push "soma de 4 e 5 ?: "
+	push_string
+	push 2
+	pcall imprima
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_8.gasm
===================================================================
--- trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_8.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/gerados_pelo_gptc/variaveis_8.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,23 @@
+// Programa variaveis_8.gasm gerado a partir de variaveis_8.gpt
+program variaveis_8
+
+var l string
+var c char
+// Procedure main
+proc main
+	sset l, "test1"
+	sset l, '2'
+	iset c, l
+	push l
+	push_string
+	push 1
+	pcall imprima
+	push c
+	push_char
+	push 1
+	pcall imprima
+	exit 0
+endproc
+// Fim da procedure
+
+endprogram

Added: trunk/gpt2/gptasm/test/hello_world.gasm
===================================================================
--- trunk/gpt2/gptasm/test/hello_world.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/hello_world.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,14 @@
+program exemplo
+
+proc main
+    push_sp
+    push "Ol? mundo !!!"
+    push_string
+    push 1
+    pcall imprima
+    pop_sp
+
+    exit 0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/prep_tests.sh
===================================================================
--- trunk/gpt2/gptasm/test/prep_tests.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/prep_tests.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,20 @@
+cd wikki/
+ln -s ../check_all.sh     check_all.sh
+ln -s ../check.sh         check.sh
+ln -s ../asm_all.sh       asm_all.sh
+ln -s ../asm.sh           asm.sh
+ln -s ../show_and_asm.sh  show_and_asm.sh
+ln -s ../test_ok_all.sh   test_ok_all.sh
+ln -s ../test_ok.sh       test_ok.sh
+cd ..
+
+cd gerados_pelo_gptc/
+ln -s ../check_all.sh     check_all.sh
+ln -s ../check.sh         check.sh
+ln -s ../asm_all.sh       asm_all.sh
+ln -s ../asm.sh           asm.sh
+ln -s ../show_and_asm.sh  show_and_asm.sh
+ln -s ../test_ok_all.sh   test_ok_all.sh
+ln -s ../test_ok.sh       test_ok.sh
+cd ..
+


Property changes on: trunk/gpt2/gptasm/test/prep_tests.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/show_and_asm.sh
===================================================================
--- trunk/gpt2/gptasm/test/show_and_asm.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/show_and_asm.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,17 @@
+echo "ARQUIVO $1.gasm"
+cat $1.gasm
+
+./asm.sh $1
+if [ $? -ne 0 ]
+then
+	exit 1
+fi
+
+echo ""
+
+echo "ARQUIVO $1.gvm"
+cat $1.gvm
+
+#echo "ARQUIVO $1.stdout"
+#cat $1.stdout
+


Property changes on: trunk/gpt2/gptasm/test/show_and_asm.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/test_ok.sh
===================================================================
--- trunk/gpt2/gptasm/test/test_ok.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/test_ok.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,50 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+
+exist_file $1.gasm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file $1.gvm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+#exist_file $1.stdout
+#if [ $? -ne 0 ]
+#then
+#	exit 2
+#fi
+
+echo "Copiando o arquivo $1.gasm p/ o diretorio checked"
+cp $1.gasm checked/
+
+echo "Copiando o arquivo $1.gvm p/ o diretorio checked"
+cp $1.gvm  checked/
+
+#echo "Copiando o arquivo $1.stdout p/ o diretorio checked"
+#cp $1.stdout  checked/
+


Property changes on: trunk/gpt2/gptasm/test/test_ok.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/test_ok_all.sh
===================================================================
--- trunk/gpt2/gptasm/test/test_ok_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/test_ok_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,7 @@
+echo "Executando test ok para todos os arquivos .gasm do diretorio"
+
+for i in `ls *.gasm -1 | sed s/"\.gasm"//g`
+do
+	./test_ok.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/gptasm/test/test_ok_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,40 @@
+program exemplo
+
+//var c byte[8] // sizeof c
+
+proc main
+    var t1 int
+
+    // c.x := 10;
+    isetv c:0, 10 // *( c + 0 ) := 10
+
+    // c.y := 20;
+    isetv c:4, 20 // *(c + 4 ) := 20
+
+    // imprima( "c.x=", c.x );
+    push_sp
+    igetv t1, c:0 // t1 := *( c + 0)
+    push t1
+    push_int
+    push "c.x="
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+
+    // imprima( "c.y=", c.y );
+    push_sp
+    igetv t1, c:4 // t1 := *(c + 4)
+    push t1
+    push_int
+    push "c.y="
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,38 @@
+program exemplo
+
+var x int
+
+proc main
+    var t1 int
+
+    // x := 10;
+    iset x, 10
+
+    // se x >= 20 entao
+    ige t1, x, 20
+    ifnot t1, senao
+
+    // x := 2;
+    iset x, 2
+
+    jmp proximo
+    senao:
+
+    // x := 1;
+    iset x, 1
+
+    proximo:
+
+    // imprima( x );
+    push_sp
+    push x
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,32 @@
+program exemplo
+
+var x int
+
+proc main
+    var t1 int
+
+    // para x de 1 at? 10 fa?a
+    iset x, 1
+    teste:
+    ile t1, x, 10
+    ifnot t1, proximo
+
+    // imprima( x );
+    push_sp
+    push x
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+
+    // fim-para
+    iinc x, 1
+    jmp teste
+
+    proximo:
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,22 @@
+program exemplo
+
+proc main
+    var t1 int
+    var t2 int
+
+    // imprima( "2+5*3=", 2+5*3 );
+    push_sp
+    imul t1, 5, 3
+    isum t2, 2, t1
+    push t2
+    push_int
+    push "2+5*3="
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,31 @@
+program exemplo
+
+proc main
+    // imprima( "A soma ?: ", soma( 2, 7 ) );
+    push_sp
+    push_0 // resultado da fun??o
+    push 7 // empilha 7
+    push 2 // empilha 2
+    pcall soma
+    push_int
+    push "A soma ?: "
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+	
+    exit_0
+endproc
+
+proc soma
+    param __result int
+    param x int
+    param y int
+
+    isum __result, x, y
+
+    ret
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,14 @@
+program exemplo
+
+proc main
+    push_sp
+    push "Ol? mundo !!!"
+    push_string
+    push_1
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram

Added: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,33 @@
+program exemplo
+
+var x int
+
+proc main
+    // imprima( "Digite um n?mero: " );
+    push_sp
+    push "Digite um n?mero: "
+    push_string
+    push_1
+    pcall imprima
+    pop_sp
+    // x := leia( );
+    push_0 // resultado da fun??o
+    push_sp
+    pcall leia
+    pop_sp
+    pop x
+    // imprima( "O n?mero digitado foi ", x );
+    push_sp
+    push x
+    push_int
+    push "O n?mero digitado foi "
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,39 @@
+program exemplo
+
+proc main
+    // soma( 2, 7 );
+    push_sp
+    push 7
+    push 2
+    pcall soma
+    pop_sp
+	
+    exit_0
+endproc
+
+proc soma
+    param x int
+    param y int
+
+    var t1 int
+
+    push_sp
+    push "A soma ?: "
+    push_string
+    push_1
+    pcall imprima
+    pop_sp
+
+    push_sp
+    isum t1, x, y
+    push t1
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+
+    ret	
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,38 @@
+program exemplo
+
+var s int
+
+proc main
+    // soma( s, 2, 7 );
+    push_sp
+    push 7
+    push 2
+    push s
+    pcall soma
+    pop_sp
+	
+    // imprima( s );
+    push_sp
+    push s
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+	
+    exit_0
+endproc
+
+proc soma
+    param r int
+    param v1 int
+    param v2 int
+
+    // r := v1 + v2;
+    isum t1, v1, v2
+    isetv r:0, t1
+
+    ret	
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,32 @@
+program exemplo
+
+var x int
+var y int
+
+proc main
+    var t1 int
+    var t2 int
+
+    // x := 10;
+    iset x, 10
+	
+    // y := 20;
+    iset y, 20
+	
+    // imprima( "x*y+4=", x*y+4 );
+    push_sp
+    imul t1, x, y
+    isum t2, t1, 4
+    push t2
+    push_int
+    push "x*y+4"
+    push_string
+    push_2
+    pcall imprima
+    pop_sp
+	
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,31 @@
+program exemplo
+
+var v int
+
+proc main
+    iset v, 0
+    iset v, v
+    isum v, 10, 10
+    isum v, v, v
+    isum v, v, 10
+    isum v, 10, v
+
+    push_sp
+    push v
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+	
+    push_sp
+    push 10
+    push_int
+    push_1
+    pcall imprima
+    pop_sp
+	
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,31 @@
+program exemplo
+
+var v real
+
+proc main
+    rset v, 0.0
+    rset v, v
+    rsum v, 10.0, 10.0
+    rsum v, v, v
+    rsum v, v, 10.0
+    rsum v, 10.0, v
+
+    push_sp
+    push v
+    push_real
+    push_1
+    pcall imprima
+    pop_sp
+
+    push_sp
+    push 10.0
+    push_real
+    push_1
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,35 @@
+program exemplo
+
+var v string
+
+proc main
+    salloc v
+
+    sset v, "0"
+    sset v, v
+    ssum v, "10", "10"
+    ssum v, v, v
+    ssum v, v, "10"
+    ssum v, "10", v
+
+    push_sp
+    push v
+    push_string
+    push_1
+    pcall imprima
+    pop_sp
+	
+    push_sp
+    push "10"
+    push_string
+    push_1
+    pcall imprima
+    pop_sp
+	
+    sfree v
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,31 @@
+program exemplo
+
+var v char
+
+proc main
+    iset v, 'a'
+    iset v, v
+    isum v, 'a', 'b'
+    isum v, v, v
+    isum v, v, 'a'
+    isum v, 'b', v
+
+    push_sp
+    push v
+    push_char
+    push_1
+    pcall imprima
+    pop_sp
+
+    push_sp
+    push 'a'
+    push_char
+    push_1
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,35 @@
+program exemplo
+
+var v bool
+
+proc main
+    iset v, true
+    iset v, false
+    iset v, v
+
+    push_sp
+    push true
+    push_bool
+    push_1
+    pcall imprima
+    pop_sp
+
+    push_sp
+    push false
+    push_bool
+    push_1
+    pcall imprima
+    pop_sp
+
+    push_sp
+    push v
+    push_bool
+    push_1
+    pcall imprima
+    pop_sp
+
+    exit_0
+endproc
+
+endprogram
+

Added: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,12 @@
+#include "CDataStack.hpp"
+
+
+CDataStack::CDataStack()
+{
+}
+
+
+CDataStack::~CDataStack()
+{
+}
+

Added: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,17 @@
+#ifndef GPT_DATA_STACK_H
+#define GPT_DATA_STACK_H
+
+
+#include <stack>
+
+
+class CDataStack : public std::stack<void*>
+{
+public:
+   CDataStack();
+   ~CDataStack();
+private:
+};
+
+#endif
+

Added: trunk/gpt2/gptvm/src/CGptVm.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CGptVm.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CGptVm.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,20 @@
+#include <fstream>
+
+#include "CGptVm.hpp"
+#include "CRunBytecode.hpp"
+
+
+CGptVm::CGptVm( COptions *options ) : _options( options )
+{
+}
+
+
+bool CGptVm::run( )
+{
+   ifstream in(_options->sourcefile.c_str(),ios::in | ios::binary);
+
+   CRunBytecode bytecode;
+
+   return bytecode.readFromFile(in) && bytecode.run();
+}
+

Added: trunk/gpt2/gptvm/src/CGptVm.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CGptVm.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CGptVm.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,18 @@
+#ifndef GPT_CGPT_VM_H
+#define GPT_CGPT_VM_H
+
+
+#include "COptions.hpp"
+
+
+class CGptVm
+{
+public:
+   CGptVm( COptions *options );
+   bool run( );
+private:
+   COptions *_options;
+};
+
+#endif
+

Added: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,390 @@
+#include "CRunBytecode.hpp"
+
+#include <sstream>
+#include <iostream>
+
+
+CRunBytecode::CRunBytecode()
+{
+}
+
+
+CRunBytecode::~CRunBytecode()
+{
+}
+
+
+bool CRunBytecode::readFromFile(std::ifstream &in)
+{
+   std::stringstream buf;
+   buf << in.rdbuf();
+   CBinString bin;
+   bin.assign(buf.str());
+
+   return _header.readFromBinary(bin) &&
+          _symbolTable.readFromBinary(bin) &&
+          _data.readFromBinary(bin) &&
+          _code.readFromBinary(bin);
+}
+
+void CRunBytecode::initOpcodePointer()
+{
+   for (int i = 0; i < OPCODE_NUMBER; i++) {
+      _opcodePointer[i] = &CRunBytecode::invalidOpcode;
+   }
+
+   _opcodePointer[OP_NOP         ] = &CRunBytecode::nopOpcode;
+   _opcodePointer[OP_PUSH_SP     ] = &CRunBytecode::pushSpOpcode;
+   _opcodePointer[OP_POP_SP      ] = &CRunBytecode::popSpOpcode;
+   _opcodePointer[OP_PUSH        ] = &CRunBytecode::pushOpcode;
+   _opcodePointer[OP_PUSH_STRING ] = &CRunBytecode::pushStringOpcode;
+//   _opcodePointer[OP_PUSH_1      ] = &CRunBytecode::push1Opcode;
+   _opcodePointer[OP_PCALL       ] = &CRunBytecode::pcallOpcode;
+//   _opcodePointer[OP_EXIT_0      ] = &CRunBytecode::exit0Opcode;
+   _opcodePointer[OP_EXIT        ] = &CRunBytecode::exitOpcode;
+
+//   OP_EXIT_1,
+// _opcodePointer[OP_HLT         ] = &CRunBytecode::hltOpcode;
+
+   _opcodePointer[OP_ISUM        ] = &CRunBytecode::isumOpcode;
+//   _opcodePointer[OP_SSUM        ] = &CRunBytecode::ssumOpcode;
+//   _opcodePointer[OP_RSUM        ] = &CRunBytecode::rsumOpcode;
+//   _opcodePointer[OP_ISUB        ] = &CRunBytecode::isubOpcode;
+//   _opcodePointer[OP_SSUB        ] = &CRunBytecode::ssubOpcode;
+//   _opcodePointer[OP_RSUB        ] = &CRunBytecode::rsubOpcode;
+   _opcodePointer[OP_IMUL        ] = &CRunBytecode::imulOpcode;
+//   _opcodePointer[OP_RMUL        ] = &CRunBytecode::rmulOpcode;
+/*
+   OP_IDIV,
+   OP_RDIV,
+   OP_IMOD,
+   OP_RMOD,
+   OP_IGE,
+   OP_SGE,
+   OP_RGE,
+   OP_ILE,
+   OP_SLE,
+   OP_RLE,
+   OP_INE,
+   OP_SNE,
+   OP_RNE,
+   OP_IGT,
+   OP_SGT,
+   OP_RGT,
+   OP_ILT,
+   OP_SLT,
+   OP_RLT,
+   OP_IEQ,
+   OP_SEQ,
+   OP_REQ,
+   OP_OR,
+   OP_AND,
+   OP_XOR,
+   OP_INEG,
+   OP_RNEG,
+   OP_NOT,
+   OP_IINC,
+   OP_IDEC,
+   OP_I2C,
+   OP_R2C,
+   OP_S2C,
+   OP_B2C,
+   OP_I2R,
+   OP_C2R,
+   OP_S2R,
+   OP_B2R,
+   OP_I2B,
+   OP_C2B,
+   OP_R2B,
+   OP_S2B,
+   OP_I2S,
+   OP_C2S,
+   OP_R2S,
+   OP_B2S,
+   OP_P2S,
+   OP_C2I,
+   OP_R2I,
+   OP_S2I,
+   OP_B2I,
+*/
+   _opcodePointer[OP_ISET        ] = &CRunBytecode::isetOpcode;
+/*
+   OP_SSET,
+   OP_RSET,
+   OP_GETA,
+   OP_IGETV,
+   OP_SGETV,
+   OP_RGETV,
+   OP_ISETV,
+   OP_SSETV,
+   OP_RSETV,
+   OP_JMP,
+   OP_IF,
+   OP_IFNOT,
+   OP_POP,
+   OP_INCSP,
+   OP_DECSP,
+   OP_PUSH_0,
+   OP_PUSH_2,
+   OP_PUSH_3,
+   OP_PUSH_4,
+   OP_PUSH_5,
+*/
+   _opcodePointer[OP_PUSH_INT      ] = &CRunBytecode::pushIntOpcode;
+   _opcodePointer[OP_PUSH_REAL     ] = &CRunBytecode::pushRealOpcode;
+   _opcodePointer[OP_PUSH_CHAR     ] = &CRunBytecode::pushCharOpcode;
+   _opcodePointer[OP_PUSH_BOOL     ] = &CRunBytecode::pushBoolOpcode;
+/*
+   OP_PUSH_MATRIX,
+   OP_INCSP_4,
+   OP_INCSP_8,
+   OP_DECSP_4,
+   OP_DECSP_8,
+   OP_RET,
+   OP_SALLOC,
+   OP_SFREE,
+   OP_SSETC,
+   OP_SGETC,
+   OP_M1ALLOC,
+   OP_M2ALLOC,
+   OP_MFREE,
+   OP_M1SET,
+   OP_M1GET,
+   OP_M2SET,
+   OP_M2GET,
+   OP_MCOPY,
+   OP_MGETSIZE1,
+   OP_MGETSIZE2,
+*/
+}
+
+
+bool CRunBytecode::run()
+{
+//   std::cout << "Code lido: [" << _code.getBinary() << "]" << " size=" << _code.getBinary().size() << std::endl;
+
+   initOpcodePointer();
+   _IP = 0;
+   _stop = false;
+
+   while (!_stop) {
+      step();
+   }
+
+   return true;
+}
+
+void CRunBytecode::step()
+{
+    char opcode;
+    opcode = _code.getByte(_IP);
+    _IP++;
+
+   if (opcode >= OPCODE_NUMBER) {
+      error( "Invalid opcode !!!" );
+   }
+
+    (this->*_opcodePointer[(int)opcode]) ( );
+}
+
+void CRunBytecode::trace(const std::string &message)
+{
+   //std::cout << message << std::endl;
+}
+
+void CRunBytecode::error(const std::string &message)
+{
+   std::cerr << message << std::endl;
+   abort();
+}
+
+void CRunBytecode::procImprima()
+{
+   int argNumber = _data.getInt((int)_dataStack.top());
+   _dataStack.pop();
+
+   for (int arg=0; arg < argNumber; arg++) {
+      int type = (int)_dataStack.top();
+      _dataStack.pop();
+      int address = (int)_dataStack.top();
+      _dataStack.pop();
+      int value;
+      switch (type) {
+         case CSymbol::STRING:
+            std::cout << _data.getString(address);
+            break;
+         case CSymbol::INT:
+            std::cout << _data.getInt(address);
+            break;
+         case CSymbol::CHAR:
+            std::cout << (char)_data.getInt(address);
+            break;
+         case CSymbol::BOOL:
+            value = _data.getInt(address);
+            if (value == 0) {
+               std::cout << "false";
+            } else {
+               std::cout << "true";
+            }
+            break;
+         case CSymbol::REAL:
+         case CSymbol::MATRIX:
+         default:
+            std::cout << "Tipo nao suportado !!!" << std::endl;
+            abort();
+      }
+   }
+   std::cout << std::endl;
+}
+
+// opcodes
+
+void CRunBytecode::invalidOpcode()
+{
+   error ("Invalid opcode !!!");
+}
+
+void CRunBytecode::nopOpcode()
+{
+//   trace ("nop opcode");
+   invalidOpcode();
+
+    //nothing to do
+}
+
+void CRunBytecode::pushSpOpcode()
+{
+   trace ("push_sp opcode");
+   // TODO
+}
+
+void CRunBytecode::popSpOpcode()
+{
+   trace ("pop_sp opcode");
+   // TODO
+}
+
+void CRunBytecode::pushOpcode()
+{
+   trace ("push opcode");
+
+   int address = _code.getInt(_IP);
+   _IP += sizeof(int);
+   _dataStack.push((void*)address);
+}
+
+void CRunBytecode::pushStringOpcode()
+{
+   trace ("push_string opcode");
+
+   _dataStack.push((void*)CSymbol::STRING);
+}
+
+void CRunBytecode::pushIntOpcode()
+{
+   trace ("push_int opcode");
+
+   _dataStack.push((void*)CSymbol::INT);
+}
+
+void CRunBytecode::pushBoolOpcode()
+{
+   trace ("push_bool opcode");
+
+   _dataStack.push((void*)CSymbol::BOOL);
+}
+
+void CRunBytecode::pushRealOpcode()
+{
+   trace ("push_real opcode");
+
+   _dataStack.push((void*)CSymbol::REAL);
+}
+
+void CRunBytecode::pushCharOpcode()
+{
+   trace ("push_char opcode");
+
+   _dataStack.push((void*)CSymbol::CHAR);
+}
+
+void CRunBytecode::push1Opcode()
+{
+   trace ("push_1 opcode");
+
+   _dataStack.push((void*)1);
+}
+
+void CRunBytecode::pcallOpcode()
+{
+   trace ("pcall opcode");
+
+   int address = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   std::string temp = _data.getString(address);
+
+   if (_data.getString(address) == "imprima") {
+      procImprima();
+   }
+}
+
+
+void CRunBytecode::exitOpcode()
+{
+   trace ("exit opcode");
+
+   int returnCode = _code.getInt(_IP); // TODO
+   _IP += sizeof(int);
+
+   _stop = true;
+}
+
+
+void CRunBytecode::isetOpcode()
+{
+   trace ("iset opcode");
+
+   int varAddress = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   int valAddress = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   _data.setInt(varAddress, _data.getInt(valAddress));
+}
+
+
+void CRunBytecode::isumOpcode()
+{
+   trace ("isum opcode");
+
+   int varAddress = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   int val1Address = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   int val2Address = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   _data.setInt(varAddress, _data.getInt(val1Address) + _data.getInt(val2Address));
+}
+
+
+void CRunBytecode::imulOpcode()
+{
+   trace ("imul opcode");
+
+   int varAddress = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   int val1Address = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   int val2Address = _code.getInt(_IP);
+   _IP += sizeof(int);
+
+   _data.setInt(varAddress, _data.getInt(val1Address) * _data.getInt(val2Address));
+}
+

Added: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,64 @@
+#ifndef GPT_RUN_BYTECODE_H
+#define GPT_RUN_BYTECODE_H
+
+#include <string>
+#include <vector>
+#include <fstream>
+
+#include "CHeader.hpp"
+#include "CSymbolTable.hpp"
+#include "CData.hpp"
+#include "CCode.hpp"
+#include "Common.hpp"
+#include "CDataStack.hpp"
+
+class CRunBytecode;
+
+typedef void (CRunBytecode:: *OpcodePointer) ( );
+
+
+class CRunBytecode
+{
+public:
+   CRunBytecode();
+   ~CRunBytecode();
+   bool readFromFile(std::ifstream &in);
+   bool run();
+private:
+   void trace(const std::string &message);
+   void error(const std::string &message);
+   void initOpcodePointer();
+   void step();
+   void procImprima();
+   // opcodes
+   void invalidOpcode();
+   void nopOpcode();
+   void pushSpOpcode();
+   void popSpOpcode();
+   void pushOpcode();
+   void pushStringOpcode();
+   void pushIntOpcode();
+   void pushRealOpcode();
+   void pushBoolOpcode();
+   void pushCharOpcode();
+   void push1Opcode();
+   void pcallOpcode();
+//   void exit0Opcode();
+   void exitOpcode();
+   void isetOpcode();
+   void isumOpcode();
+   void imulOpcode();
+
+
+   CHeader       _header;
+   CSymbolTable  _symbolTable;
+   CData         _data;
+   CCode         _code;
+   OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
+   int           _IP;
+   bool          _stop;
+   CDataStack    _dataStack;
+};
+
+#endif
+

Added: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,26 @@
+COMMON_DIR=../../common/src/
+
+INCLUDE_DIR=-I$(COMMON_DIR)
+CC=g++
+CCFLAGS=-g -Wall
+
+GPTASM=../gptasm/
+
+objects = main.o CGptVm.o CRunBytecode.o CDataStack.o \
+          $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CCode.o  \
+          $(COMMON_DIR)CHeader.o $(COMMON_DIR)CData.o       \
+          $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
+          
+
+all: $(objects)
+	g++ -o gptvm $(objects)
+
+%.o: %.cpp %.hpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+%.o: %.cpp
+	$(CC) $(CCFLAGS) -c $(INCLUDE_DIR) $< -o $@
+
+
+clean:
+	rm -f *.o $(COMMON_DIR)*.o gptvm

Added: trunk/gpt2/gptvm/src/main.cpp
===================================================================
--- trunk/gpt2/gptvm/src/main.cpp	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/src/main.cpp	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,66 @@
+#include <iostream>
+#include <string>
+
+using namespace std;
+
+#include "COptions.hpp"
+#include "CGptVm.hpp"
+
+
+void showSyntax();
+
+
+int main (int argc, char *argv[])
+{
+   int i;
+   COptions options;
+
+   cout << "GptVM, release 0.1.0 (development release)" << endl;
+
+   while ((i = getopt(argc, argv, "h")) != -1) {
+      switch (i) {
+         case 'h':
+            showSyntax();
+            return EXIT_SUCCESS;
+            break;
+         default:
+            break;
+      }
+   }
+
+   argc -= optind;
+   argv += optind;
+
+   if (argc < 1) {
+      showSyntax();
+      return EXIT_FAILURE;
+   }
+
+   options.sourcefile = string(argv[0]) + ".gvm";
+
+//   cout << "Running " << options.sourcefile << "..." << endl;
+
+   CGptVm gptvm( &options );
+
+   if (gptvm.run()) {
+//      cout << "Program " << options.sourcefile << " ok !!!" << endl << endl;
+   } else {
+//      cout << "Program " << options.sourcefile << " has errors..." << endl << endl;
+      exit( EXIT_FAILURE );
+   }
+
+   return EXIT_SUCCESS;
+}
+
+
+void showSyntax() {
+   cout << endl 
+        << "Desenvolvido por XXX, YYY e ZZZ" << endl 
+        << "Novembro, 2007" << endl 
+        << endl 
+        << "Syntax: gptvm [options] file" << endl 
+        << "Options:" << endl 
+        << "         -h help" << endl 
+        << endl;
+}
+

Added: trunk/gpt2/gptvm/test/check.sh
===================================================================
--- trunk/gpt2/gptvm/test/check.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/check.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,68 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+echo "Realizando o teste regressivo no arquivo $1.gvm"
+
+exist_file $1.gvm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.gvm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file checked/$1.stdout
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+diff $1.gvm checked/$1.gvm >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Os arquivos $1.gvm e checked/$1.gvm sao diferentes. Nao eh possivel realizar o teste regressivo !"
+	exit 2
+fi
+
+./run.sh $1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Arquivo $1.gvm nao foi executado corretamente"
+	exit 2
+fi
+
+diff $1.stdout checked/$1.stdout >/dev/null 2>&1
+if [ $? -ne 0 ]
+then
+	echo "Erro: Teste regressivo falhou. Os arquivos $1.stdout e checked/$1.stdout sao diferentes !!!"
+	vimdiff $1.stdout checked/$1.stdout
+	exit 1
+fi
+
+echo "Ok: Teste regressivo ok para $1.gvm"
+
+exit 0
+


Property changes on: trunk/gpt2/gptvm/test/check.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/check_all.sh
===================================================================
--- trunk/gpt2/gptvm/test/check_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/check_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,13 @@
+echo "Realizando o teste regressivo em todos os arquivos .gvm do diretorio"
+
+rm *.stdout 1>/dev/null 2>&1
+
+for i in `ls *.gvm -1 | sed s/"\.gvm"//g`
+do
+	./check.sh $i 
+	echo ""
+#	if [ $? -ne 0 ]
+#	then
+#		echo "Falha no teste regressivo do arquivo $i";
+#	fi
+done


Property changes on: trunk/gpt2/gptvm/test/check_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/constantes_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/constantes_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_3.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_3.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_4.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_4.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_5.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_5.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_3.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_3.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_4.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_4.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/inline_codigo_gptassembly.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/inline_codigo_gptassembly.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_3.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/matrizes_4.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_4.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_4.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_7.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_7.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_8.gvm
===================================================================
(Binary files differ)


Property changes on: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_8.gvm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gpt2/gptvm/test/prep_tests.sh
===================================================================
--- trunk/gpt2/gptvm/test/prep_tests.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/prep_tests.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,9 @@
+cd gerados_pelo_gptasm/
+ln -s ../check_all.sh     check_all.sh
+ln -s ../check.sh         check.sh
+ln -s ../run_all.sh       run_all.sh
+ln -s ../run.sh           run.sh
+ln -s ../test_ok_all.sh   test_ok_all.sh
+ln -s ../test_ok.sh       test_ok.sh
+cd ..
+


Property changes on: trunk/gpt2/gptvm/test/prep_tests.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/run.sh
===================================================================
--- trunk/gpt2/gptvm/test/run.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/run.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,12 @@
+rm $1.stdout 1>/dev/null 2>&1
+
+../../gptvm $1 > $1.stdout
+if [ $? -ne 0 ]
+then
+	echo "Erro: nao foi possivel executar $1.gvm"
+	exit 1
+fi
+echo ""
+
+cat $1.stdout
+


Property changes on: trunk/gpt2/gptvm/test/run.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/run_all.sh
===================================================================
--- trunk/gpt2/gptvm/test/run_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/run_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,9 @@
+echo "Executando todos os arquivos .gvm do diretorio"
+
+rm *.stdout
+
+for i in `ls *.gvm -1 | sed s/"\.gvm"//g`
+do
+	./run.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/gptvm/test/run_all.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/test_ok.sh
===================================================================
--- trunk/gpt2/gptvm/test/test_ok.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/test_ok.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,41 @@
+function exist_file( )
+{
+	if [ -z "$1" ]                    # Checks if parameter #1 is zero length.
+	then
+		echo "-Parameter #1 is zero length."
+		return 1
+	fi
+
+	if [ "$2" ] # verifica se o parametro existe
+	then
+		echo "-Parameter #2 is \"$2\".-"
+	fi
+					  
+	if [[ ! -a $1 ]]
+	then
+		echo "Erro: Arquivo $1 nao existe !!!"
+		return 1
+	fi
+
+	return 0
+}
+
+
+exist_file $1.gvm
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+exist_file $1.stdout
+if [ $? -ne 0 ]
+then
+	exit 2
+fi
+
+echo "Copiando o arquivo $1.gvm p/ o diretorio checked"
+cp $1.gvm  checked/
+
+echo "Copiando o arquivo $1.stdout p/ o diretorio checked"
+cp $1.stdout  checked/
+


Property changes on: trunk/gpt2/gptvm/test/test_ok.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptvm/test/test_ok_all.sh
===================================================================
--- trunk/gpt2/gptvm/test/test_ok_all.sh	2007-11-19 03:48:19 UTC (rev 373)
+++ trunk/gpt2/gptvm/test/test_ok_all.sh	2007-11-19 19:53:34 UTC (rev 374)
@@ -0,0 +1,7 @@
+echo "Executando test ok para todos os arquivos .gvm do diretorio"
+
+for i in `ls *.gvm -1 | sed s/"\.gvm"//g`
+do
+	./test_ok.sh $i 
+	echo ""
+done


Property changes on: trunk/gpt2/gptvm/test/test_ok_all.sh
___________________________________________________________________
Name: svn:executable
   + *



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:27:31 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:27:31 +0100
Subject: [gpt-commit] r375 - trunk/gpt2/gptc/src
Message-ID: <200711211727.lALHRVRo023794@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:27:31 +0100 (Wed, 21 Nov 2007)
New Revision: 375

Modified:
   trunk/gpt2/gptc/src/lexer.g
Log:
-Adicionando tokens para a criacao de AST

Modified: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-11-19 19:53:34 UTC (rev 374)
+++ trunk/gpt2/gptc/src/lexer.g	2007-11-21 17:27:31 UTC (rev 375)
@@ -107,7 +107,9 @@
   T_VAL_MATRIZ;    //valor da matriz    (literal [])
   T_VAL_ESTRUTURA; //valor da estrutura (literal {})
 
-  T_DIMENSOES;
+//   T_DIMENSOES;
+  T_SUBSCRITO;
+  T_MEMBRO;
 
   T_UN_POSITIVO;
   T_UN_NEGATIVO;



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:27:56 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:27:56 +0100
Subject: [gpt-commit] r376 - trunk/gpt2/gptc/src
Message-ID: <200711211727.lALHRunr023848@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:27:56 +0100 (Wed, 21 Nov 2007)
New Revision: 376

Modified:
   trunk/gpt2/gptc/src/parser.g
Log:
-Usando PortugolAST.
-Fix na producao 'corpo': permitia 2+ blocos inicio/fim).
-Producao 'parametro': alteracao da ordem do T_CONSTANTE e T_REF.
-Reformulacao da AST do lvalue: mais informacoes (T_SUBSCRITO e T_MEMBRO) para facilitar a travessia.
-Adicao do T_ABRE_PAREN para evitar ambiguidade nas gramaticas de AST.

Modified: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-11-21 17:27:31 UTC (rev 375)
+++ trunk/gpt2/gptc/src/parser.g	2007-11-21 17:27:56 UTC (rev 376)
@@ -18,8 +18,10 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
 
 header {
-#include <antlr/NoViableAltException.hpp>
-#include <antlr/SemanticException.hpp>
+  #include <antlr/NoViableAltException.hpp>
+  #include <antlr/SemanticException.hpp>
+
+  #include "PortugolAST.hpp"
   using namespace antlr;
 }
 
@@ -32,6 +34,7 @@
   importVocab    = Portugol;
   genHashLines   = false;
   buildAST       = true;
+  ASTLabelType   = "RefPortugolAST";
   noConstructors = true;
 }
 
@@ -89,7 +92,7 @@
     astFactory->addASTChild(ast, astFactory->create(token));
   }
 
-  void addChildNode(antlr::ASTPair& ast, antlr::RefAST child) {
+  void addChildNode(antlr::ASTPair& ast, RefAST child) {
     astFactory->addASTChild(ast, child);
   }
 
@@ -133,8 +136,8 @@
   ;
 
 corpo
-  :  declaracao_subrotina corpo
-  |  bloco_codigo         corpo
+  :  declaracao_subprograma corpo
+  |  bloco_codigo           (declaracao_subprograma)*
   |  /*vazio*/
   ;
 
@@ -292,7 +295,7 @@
 //####################################
 
 
-declaracao_subrotina
+declaracao_subprograma
   : declaracao_funcao
   | declaracao_procedimento
   ;
@@ -325,9 +328,9 @@
   ;
 
 parametro!
-  : ((c:T_CONSTANTE)? r:T_REF)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
+  : (r:T_REF (c:T_CONSTANTE)?)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
 
-                          {#parametro = #([T_PARAM,"&param"],t,id,c,r);}
+                          {#parametro = #([T_PARAM,"&param"],t,id,r,c);}
   ;
 
 
@@ -373,15 +376,24 @@
   : T_RETORNE^ (expressao)? T_PONTO_VIRGULA!
   ;
 
-lvalue
-  : T_IDENTIFICADOR^ (matriz_indices | T_PONTO! lvalue)
+lvalue!
+  : id:T_IDENTIFICADOR (m:lvalue_indices)? (T_PONTO es:lvalue_membro)?
+    {#lvalue = #(id, m, es);}
   ;
 
-matriz_indices
+lvalue_membro!
+  : l:lvalue             {#lvalue_membro = #([T_MEMBRO,"&membro"], l);}
+  ;
+
+lvalue_indices
+  : i:indices_matriz     {#lvalue_indices = #([T_SUBSCRITO,"&subscrito"], i);}
+  ;
+
+indices_matriz
   : ( T_ABRE_CHAVE!
       expressao
       T_FECHA_CHAVE!
-    )*
+    )+
   ;
 
 en_se
@@ -521,7 +533,7 @@
   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
   |  lvalue
   |  literal
-  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
+  | T_ABRE_PAREN^ expressao T_FECHA_PAREN!
   ;
 
 



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:29:23 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:29:23 +0100
Subject: [gpt-commit] r377 - trunk/gpt2/gptc/src
Message-ID: <200711211729.lALHTN4a024162@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:29:23 +0100 (Wed, 21 Nov 2007)
New Revision: 377

Added:
   trunk/gpt2/gptc/src/PortugolAST.cpp
   trunk/gpt2/gptc/src/PortugolAST.hpp
Log:
-Usando PortugolAST

Added: trunk/gpt2/gptc/src/PortugolAST.cpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.cpp	2007-11-21 17:27:56 UTC (rev 376)
+++ trunk/gpt2/gptc/src/PortugolAST.cpp	2007-11-21 17:29:23 UTC (rev 377)
@@ -0,0 +1,79 @@
+/***************************************************************************
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#include "PortugolAST.hpp"
+#include <sstream>
+
+const char* const PortugolAST::TYPE_NAME = "PortugolAST";
+
+PortugolAST::PortugolAST()
+    : CommonAST(), line(-1) {
+}
+
+PortugolAST::PortugolAST(RefToken t)
+    : CommonAST(t), line(t->getLine()) {
+}
+
+PortugolAST::PortugolAST( const CommonAST& other )
+    : CommonAST(other), line(-1) {
+}
+
+PortugolAST::PortugolAST( const PortugolAST& other )
+    : CommonAST(other), line(other.line) {
+}
+
+PortugolAST::~PortugolAST() {
+}
+
+RefAST PortugolAST::clone( void ) const
+{
+  PortugolAST *ast = new PortugolAST( *this );
+  return RefAST(ast);
+}
+
+const char* PortugolAST::typeName( void ) const
+{
+  return PortugolAST::TYPE_NAME;
+}
+
+void PortugolAST::initialize(RefToken t)
+{
+  CommonAST::initialize(t);
+  setLine(t->getLine());
+}
+
+void PortugolAST::setLine(int line_) {
+  line = line_;
+}
+
+int PortugolAST::getLine() const {
+  return line;
+}
+
+// std::string PortugolAST::toString() const {
+//   std::stringstream s;
+//   s << "(" << getLine() << ")" << getText();
+//   return s.str();
+// }
+
+RefAST PortugolAST::factory() {
+  return RefAST(new PortugolAST);
+}

Added: trunk/gpt2/gptc/src/PortugolAST.hpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.hpp	2007-11-21 17:27:56 UTC (rev 376)
+++ trunk/gpt2/gptc/src/PortugolAST.hpp	2007-11-21 17:29:23 UTC (rev 377)
@@ -0,0 +1,61 @@
+/***************************************************************************
+ *   Copyright (C) 2003-2006 by Thiago Silva                               *
+ *   tsilva at sourcecraft.info                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef PORTUGOLAST_HPP
+#define PORTUGOLAST_HPP
+
+#include <antlr/CommonAST.hpp>
+#include <string>
+
+using namespace std;
+using namespace antlr;
+
+class PortugolAST : public CommonAST {
+public:
+  PortugolAST();
+  PortugolAST( RefToken t );
+  PortugolAST( const CommonAST& other );
+  PortugolAST( const PortugolAST& other );
+
+  ~PortugolAST();
+
+  void setLine(int line);
+  int getLine() const;
+
+  virtual RefAST clone( void ) const;
+
+  virtual void initialize( RefToken t );
+
+  virtual const char* typeName( void ) const;
+
+//   virtual std::string toString() const;
+
+  static RefAST factory();
+  static const char* const TYPE_NAME;
+protected:
+  int line;
+  int endLine;
+  int eval_type; //evaluated type of expression
+  string filename;
+};
+
+typedef ASTRefCount<PortugolAST> RefPortugolAST;
+
+#endif



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:32:17 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:32:17 +0100
Subject: [gpt-commit] r378 - trunk/gpt2/gptc/src
Message-ID: <200711211732.lALHWHHZ029319@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:32:12 +0100 (Wed, 21 Nov 2007)
New Revision: 378

Added:
   trunk/gpt2/gptc/src/CompilerError.cpp
   trunk/gpt2/gptc/src/CompilerError.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
Infra-estrutura da tabela de simbolos e codigos de registro de ID e tipos.
-Esqueleto de codigo para analise semantica

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -1,3 +1,290 @@
+
 #include "BaseSemanticWalker.hpp"
+#include "PortugolTokenTypes.hpp"
+#include "SymbolTable.hpp"
+#include "Symbol.hpp"
+#include "Types.hpp"
+#include "PortugolAST.hpp"
+#include "SymbolTableExceptions.hpp"
 
+#include <iostream>
 
+BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable)
+ : antlr::TreeParser(), _symtable(symtable) {}
+
+void BaseSemanticWalker::useLib(const  std::string& lib) {
+  //TODO: sanitize lib: "bla\ bla" -> "bla bla"
+
+  std::cerr << "Using lib:" << lib << std::endl;
+}
+
+void BaseSemanticWalker::declare(const IDList& idlist,
+                                 Type* type,
+                                 bool isConst) {
+
+  try {
+    IDList::const_iterator it;
+    for (it = idlist.begin(); it != idlist.end(); ++it) {
+      _symtable->declare(_symtable->newSymbol(
+            (*it)->getText(), type, (*it)->getLine(), isConst));
+    }
+  } catch (RedeclarationException e) {
+    cerr << "catched! Redeclaration: " << e.symbol().toString() <<"\n";
+  }
+}
+
+void BaseSemanticWalker::defineStruct(const std::string& name,
+                                      const SymbolList& fieldList,
+                                      int line) {
+
+  try {
+    _symtable->defineStruct(name, fieldList, line);
+  } catch (RedefinedTypeException e) {
+    cerr << "catched! Redeclared type: " << e.typeName() << "\n";
+  } catch (RedeclarationException e) {
+    cerr << "catched! Redeclaration: " << e.symbol().toString() << "\n";
+  }
+}
+
+void BaseSemanticWalker::declareProc(const std::string& name,
+                                     const SymbolList& params,
+                                     int line,
+                                     Type* ret) {
+
+  SubprogramType* type = new SubprogramType(
+        params.toTypeList(),
+        (ret == 0) ? _symtable->getType(PortugolTokenTypes::T_NULO) : ret);
+
+  try {
+    _symtable->declare(_symtable->newSymbol(name, type,line));
+    _symtable->declare(params, name);
+  } catch (RedeclarationException e) {
+    cerr << "catched! Redeclaration: " << e.symbol().toString() << std::endl;
+    delete type;
+  }
+}
+
+Type* BaseSemanticWalker::getType(const std::string& name) {
+  try {
+    return _symtable->getType(name);
+  } catch (UndeclaredTypeException e) {
+    std::cerr << "catched! Undeclared type: " << e.typeName() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+}
+
+Type* BaseSemanticWalker::getType(int id) {
+  try {
+    return _symtable->getType(id);
+  } catch (UndeclaredTypeException e) {
+    std::cerr << "catched! Undeclared type: " << id << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+}
+
+Type* BaseSemanticWalker::getSymbolType(const std::string& name) {
+  try {
+    return _symtable->getSymbol(name).type();
+  } catch (UndeclaredSymbolException e) {
+    std::cerr << "catched! Undeclared symbol: " << e.lexeme() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+}
+
+void BaseSemanticWalker::evalFCall(const std::string& fname,
+                                   const TypeList& paramTypes) {
+  //TODO
+  //-proibicao de consts passados para parametros "ref" sem constness
+
+// - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
+//   -Avaliacao de qtd e tipos de parametros
+}
+
+void BaseSemanticWalker::evalMatrixSubscript(Type* type) {
+}
+
+void BaseSemanticWalker::evalAttribution(Type*, Type*) {
+  //-proibicao de consts como lvalues
+}
+
+
+template<int>
+Type* BaseSemanticWalker::evalExpr(Type*, Type*) {
+  //nao deve ser chamado!
+  throw;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_OU>(Type* left,
+                                                       Type* right) {
+  std::cerr <<  left->name() << " OU " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_E>(Type* left,
+                                                      Type* right) {
+  std::cerr <<  left->name() << " E " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_OU>(Type* left,
+                                                           Type* right) {
+  std::cerr <<  left->name() << " | " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_OUX>(Type* left,
+                                                            Type* right) {
+  std::cerr <<  left->name() << " ^ " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_E>(Type* left,
+                                                          Type* right) {
+  std::cerr <<  left->name() << " & " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_IGUAL>(Type* left,
+                                                          Type* right) {
+  std::cerr <<  left->name() << " = " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_DIFERENTE>(Type* left,
+                                                              Type* right) {
+  std::cerr <<  left->name() << " = " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIOR>(Type* left,
+                                                          Type* right) {
+  std::cerr <<  left->name() << " > " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOR>(Type* left,
+                                                          Type* right) {
+  std::cerr <<  left->name() << " < " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIOR_EQ>(Type* left,
+                                                             Type* right) {
+  std::cerr <<  left->name() << " >= " << right->name() << endl;
+  return left;
+}
+
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOR_EQ>(Type* left,
+                                                             Type* right) {
+  std::cerr <<  left->name() << " <= " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_SHIFT_LEFT>(
+                                                    Type* left, Type* right) {
+  std::cerr <<  left->name() << " << " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_SHIFT_RIGHT>(
+                                                    Type* left, Type* right) {
+  std::cerr <<  left->name() << " >> " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIS>(Type* left,
+                                                         Type* right) {
+  std::cerr <<  left->name() << " + " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOS>(Type* left,
+                                                          Type* right) {
+  std::cerr <<  left->name() << " - " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_DIV>(Type* left,
+                                                        Type* right) {
+  std::cerr <<  left->name() << " / " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MULTIP>(Type* left,
+                                                           Type* right) {
+  std::cerr <<  left->name() << " * " << right->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MOD>(Type* left,
+                                                        Type* right) {
+  std::cerr <<  left->name() << " % " << right->name() << endl;
+  return left;
+}
+
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_UN_NEGATIVO>(Type* left) {
+  std::cerr <<  " - " << left->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_UN_POSITIVO>(Type* left) {
+  std::cerr <<  " + " << left->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_NAO>(Type* left) {
+  std::cerr <<  " n?o " << left->name() << endl;
+  return left;
+}
+
+template<>
+Type*
+BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_NAO>(Type* left) {
+  std::cerr <<  " ~ " << left->name() << endl;
+  return left;
+}
+

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -22,11 +22,49 @@
 #define BASESEMANTICWALKER_H
 
 #include <antlr/TreeParser.hpp>
+#include <list>
+#include <string>
 
+class PortugolAST;
+class SymbolTable;
+class SymbolList;
+class Type;
+class TypeList;
+
+typedef std::list<PortugolAST*> IDList;
+
 class BaseSemanticWalker : public antlr::TreeParser {
 
 public:
-  BaseSemanticWalker() : antlr::TreeParser() {}
+  BaseSemanticWalker(SymbolTable*);
+
+protected:
+  void useLib(const std::string&);
+
+  void declare(const IDList&, Type*, bool);
+
+  void defineStruct(const std::string&, const SymbolList&, int);
+
+  void declareProc(const std::string&, const SymbolList&, int, Type* = 0);
+
+  Type* getType(const std::string&);
+  Type* getType(int);
+
+  Type* getSymbolType(const std::string&);
+
+  void evalFCall(const std::string&, const TypeList&);
+
+  void evalMatrixSubscript(Type*);
+
+  void evalAttribution(Type*, Type*);
+
+  template<int>
+  Type* evalExpr(Type*, Type*);
+
+  template<int>
+  Type* evalExpr(Type*);
+
+  SymbolTable* _symtable;
 };
 
 #endif

Added: trunk/gpt2/gptc/src/CompilerError.cpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/CompilerError.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1 @@
+ 

Added: trunk/gpt2/gptc/src/CompilerError.hpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/CompilerError.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,15 @@
+
+/*
+  Cada gramatica deve ter sua ErrorList
+*/
+
+class ErrorList {
+
+};
+
+class CompilerError {
+  void addError(unit, line, errorCode, message);
+  //tips
+  //verbose, etc
+  std::string toString();
+};

Added: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,103 @@
+#include "Symbol.hpp"
+
+Symbol::Symbol()
+  : _type(0) {
+}
+
+Symbol::Symbol(const std::string& lexeme, Type* type, int line,
+         const std::string& unit, const std::string& scope,
+         bool isConst, bool isRef)
+    : _lexeme(lexeme), _type(type), _isConst(isConst), _isRef(isRef),
+      _unit(unit), _scope(scope), _line(line) {
+}
+
+const std::string& Symbol::lexeme() const {
+  return _lexeme;
+}
+
+Type* Symbol::type() const {
+  return _type;
+}
+
+bool Symbol::isConst() const {
+  return _isConst;
+}
+
+bool Symbol::isRef() const {
+  return _isRef;
+}
+
+std::string Symbol::toString() const {
+  std::string ret = _unit + "(" + _scope + ") - " + lexeme() + " : ";
+  if (_type) {
+    ret += _type->name();
+  }
+  ret += " {";
+  if (_isConst) {
+    ret += "c";
+  }
+  if (_isRef) {
+    ret += "r";
+  }
+  ret += "}";
+  return ret;
+}
+
+
+//-------------------------------------------------------
+
+
+SymbolList::const_iterator SymbolList::duplicated() const {
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    if (count((*it).lexeme()) > 1) {
+      return it;
+    }
+  }
+  return end();
+}
+
+std::list<StructType::Field> SymbolList::toStructFieldList() const {
+  std::list<StructType::Field> fields;
+
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    fields.push_back(StructType::Field((*it).lexeme(), (*it).type()));
+  }
+  return fields;
+}
+
+TypeList SymbolList::toTypeList() const {
+  TypeList list;
+
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    list.push_back((*it).type());
+  }
+  return list;
+}
+
+int SymbolList::count(const std::string& lexeme) const {
+  int ret = 0;
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    if ((*it).lexeme() == lexeme) {
+      ret++;
+    }
+  }
+  return ret;
+}
+
+SymbolList::const_iterator SymbolList::find(const std::string& lexeme) const {
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    if ((*it).lexeme() == lexeme) {
+      return it;
+    }
+  }
+  return end();
+}
+
+std::string SymbolList::toString() const {
+  std::string ret = "";
+  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+    ret += (*it).toString() + "\n";
+  }
+  return ret;
+}
+

Added: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,53 @@
+#ifndef SYMBOL_HPP
+#define SYMBOL_HPP
+
+#include "Types.hpp"
+
+#include <string>
+
+class Symbol {
+public:
+  Symbol();
+
+  Symbol(const std::string& lexeme, Type* type, int line,
+         const std::string& unit, const std::string& scope,
+         bool isConst = false, bool isRef = false);
+
+  const std::string& lexeme() const;
+
+  Type* type() const;
+
+  bool isConst() const;
+
+  bool isRef() const;
+
+  std::string toString() const;
+
+private:
+  std::string      _lexeme;
+  Type*            _type;
+  bool             _isConst;
+  bool             _isRef;
+
+  std::string _unit;
+  std::string _scope;
+  int         _line;
+};
+
+
+class SymbolList : public std::list<Symbol> {
+public:
+  const_iterator duplicated() const;
+
+  std::list<StructType::Field> toStructFieldList() const;
+
+  TypeList toTypeList() const;
+
+  int count(const std::string& lexeme) const;
+
+  const_iterator find(const std::string& lexeme) const;
+
+  std::string toString() const;
+};
+
+#endif

Added: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,142 @@
+#include "SymbolTable.hpp"
+
+#include "Types.hpp"
+#include "PortugolTokenTypes.hpp"
+#include "Symbol.hpp"
+#include "SymbolTableExceptions.hpp"
+
+#include <iostream>
+
+void SymbolTable::setScope(const std::string& scope) {
+  _scope = scope;
+}
+void SymbolTable::setGlobalScope() {
+  _scope = "@global";
+}
+
+Type* SymbolTable::getType(const std::string& name) {
+  Type* ret = _types.find(name);
+
+  if (ret == 0) {
+    throw UndeclaredTypeException(name);
+  }
+
+  return ret;
+}
+
+Type* SymbolTable::getType(int id) {
+  Type* ret = _types.find(id);
+
+  if (ret == 0) {
+    throw UndeclaredTypeException(id);
+  }
+
+  return ret;
+}
+
+Type* SymbolTable::retrieveMatrixType(Type *ofType, int dimensions) {
+  Type* t = _types.find(ofType, dimensions);
+  if (t == 0) {
+    t = new MatrixType(ofType, dimensions);
+    _types.push_back(t);
+  }
+  return t;
+}
+
+Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
+                int line, const std::string& scope,
+                bool isConst, bool isRef) {
+  return Symbol(name, type, line, _unit, scope, isConst, isRef);
+}
+
+Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
+                int line, bool isConst, bool isRef) {
+  return Symbol(name, type, line, _unit, _scope, isConst, isRef);
+}
+
+void SymbolTable::defineStruct(const std::string& name,
+                               const SymbolList& symbolList,
+                               int line) {
+  SymbolList::const_iterator dup = symbolList.duplicated();
+  if (dup != symbolList.end()) {
+    throw RedeclarationException(*dup);
+  }
+
+  if (_types.find(name) != 0) {
+    throw RedefinedTypeException(name);
+  }
+  _types.push_back(new StructType(name,
+      symbolList.toStructFieldList(), _unit, line));
+}
+
+bool SymbolTable::declared(const Symbol& s) {
+  return _table[_scope].count(s.lexeme()) >= 1;
+}
+
+void SymbolTable::declare(const Symbol& symbol) {
+  if (declared(symbol)) {
+    throw RedeclarationException(symbol);
+  }
+  _table[_scope].push_back(symbol);
+}
+
+void SymbolTable::declare(const SymbolList& params,
+                          const std::string& scope) {
+  try {
+    setScope(scope);
+    for (SymbolList::const_iterator it = params.begin(); it != params.end(); ++it) {
+      declare(*it);
+    }
+  } catch( ... ) {
+    setGlobalScope();
+    throw;
+  }
+}
+
+
+const Symbol& SymbolTable::getSymbol(const std::string& lexeme) {
+  SymbolList::const_iterator it = _table[_scope].find(lexeme);
+  if (it == _table[_scope].end()) {
+    throw UndeclaredSymbolException(lexeme);
+  }
+  return (*it);
+}
+
+
+SymbolTable* SymbolTable::create(const std::string& unit) {
+  SymbolTable* s = new SymbolTable(unit);
+  s->initialize();
+  return s;
+}
+
+void SymbolTable::dump() {
+
+  std::cerr << "Ids...\n";
+  std::map<std::string, SymbolList>::iterator it;
+  for (it = _table.begin(); it != _table.end(); ++it) {
+    std::cerr << it->second.toString() << std::endl;
+  }
+  std::cerr << "Types ... " << std::endl;
+  std::cerr << _types.toString() << std::endl;
+}
+
+
+SymbolTable::SymbolTable(const std::string& unit)
+  : _unit(unit) {
+  setGlobalScope();
+}
+
+SymbolTable::~SymbolTable() {
+  //TODO: delete tables, types, etc...
+}
+
+void SymbolTable::initialize() {
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_INTEIRO,"inteiro"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_REAL,"real"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_CARACTERE,"caractere"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_LITERAL,"literal"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_LOGICO,"l?gico"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_NULO,"nulo"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_CORINGA,"coringa"));
+  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_RETICENCIAS,"retic?ncias"));
+}

Added: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,64 @@
+#ifndef SYMBOLTABLE_HPP
+#define SYMBOLTABLE_HPP
+
+#include <string>
+#include <list>
+#include <map>
+
+#include "Types.hpp"
+
+class Symbol;
+class SymbolList;
+
+class SymbolTable {
+public:
+  //void setCurrentUnit(string file)
+  //void loadSymbolTable(other) //load stable from other units
+
+  void setScope(const std::string& scope);
+  void setGlobalScope();
+
+  Type* getType(const std::string& name);
+
+  Type* getType(int id);
+
+  Type* retrieveMatrixType(Type *ofType, int dimensions);
+
+  Symbol newSymbol(const std::string& name, Type* type,
+                   int line, const std::string& scope,
+                   bool isConst = false, bool isRef = false);
+
+  Symbol newSymbol(const std::string& name, Type* type,
+                   int line, bool isConst = false, bool isRef = false);
+
+  void defineStruct(const std::string& name,
+                   const SymbolList& symbolList,
+                   int line);
+
+  bool declared(const Symbol& s);
+
+  void declare(const Symbol& symbol);
+
+  void declare(const SymbolList& params, const std::string& scope);
+
+  const Symbol& getSymbol(const std::string& lexeme);
+
+
+  static SymbolTable* create(const std::string& unit);
+
+  void dump();
+
+private:
+  SymbolTable(const std::string& unit);
+  ~SymbolTable();
+
+  void initialize();
+
+  std::string                        _scope;
+  std::string                        _unit;
+
+  std::map<std::string, SymbolList>  _table;
+  TypeList                           _types;
+};
+
+#endif

Added: trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,51 @@
+#include "SymbolTableExceptions.hpp"
+#include "TokenNames.hpp"
+
+UndeclaredTypeException::UndeclaredTypeException(const std::string& name)
+  : _id(-1), _name(name) {
+}
+
+UndeclaredTypeException::UndeclaredTypeException(int id)
+  : _id(id) {
+}
+
+std::string UndeclaredTypeException::typeName() const {
+  if (_id == -1) {
+    return _name;
+  } else {
+    return g_tokenNames[_id];
+  }
+}
+
+//--------------------------------------------------------
+
+RedefinedTypeException::RedefinedTypeException(const std::string& name)
+  : _name(name) {
+}
+
+const std::string& RedefinedTypeException::typeName() const {
+  return _name;
+}
+
+
+//--------------------------------------------------------
+
+UndeclaredSymbolException::UndeclaredSymbolException(const std::string& lexeme)
+  : _lexeme(lexeme) {
+}
+
+std::string UndeclaredSymbolException::lexeme() const {
+  return _lexeme;
+}
+
+
+//--------------------------------------------------------
+
+
+RedeclarationException::RedeclarationException(const Symbol& s)
+  : _symbol(s) {
+}
+
+const Symbol& RedeclarationException::symbol() const {
+  return _symbol;
+}

Added: trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,49 @@
+#ifndef SYMBOLTABLEEXCEPTIONS_HPP
+#define SYMBOLTABLEEXCEPTIONS_HPP
+
+#include "Symbol.hpp"
+
+#include <string>
+
+
+class UndeclaredTypeException {
+public:
+  UndeclaredTypeException(const std::string& name);
+  UndeclaredTypeException(int id);
+
+  std::string typeName() const;
+
+private:
+  int _id;
+  std::string _name;
+};
+
+class RedefinedTypeException {
+public:
+  RedefinedTypeException(const std::string& name);
+
+  const std::string& typeName() const;
+private:
+  std::string _name;
+};
+
+class UndeclaredSymbolException {
+public:
+  UndeclaredSymbolException(const std::string& lexeme);
+
+  std::string lexeme() const;
+
+private:
+  std::string _lexeme;
+};
+
+class RedeclarationException {
+public:
+  RedeclarationException(const Symbol& s);
+
+  const Symbol& symbol() const;
+private:
+  Symbol _symbol;
+};
+
+#endif

Added: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,148 @@
+#include "Types.hpp"
+#include "PortugolTokenTypes.hpp"
+
+Type::~Type() {}
+
+
+//------------------------------------------------------------------
+
+
+Type* TypeList::find(const std::string& lexeme) const {
+  const_iterator it;
+
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->name() == lexeme) {
+      return *it;
+    }
+  }
+  return 0;
+}
+
+Type* TypeList::find(Type* ofType, int dimensions) const {
+  const_iterator it;
+
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->equals(ofType, dimensions)) {
+      return *it;
+    }
+  }
+  return 0;
+}
+
+Type* TypeList::find(int id) const {
+  const_iterator it;
+
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->equals(id)) {
+      return *it;
+    }
+  }
+  return 0;
+}
+
+std::string TypeList::toString() const {
+  std::string ret = "";
+  const_iterator it;
+  for (it = begin(); it != end(); ++it) {
+    ret += (*it)->name() + ",";
+  }
+  return ret;
+}
+
+
+//------------------------------------------------------------------
+
+
+PrimitiveType::PrimitiveType(int id, const std::string& name)
+  : _id(id), _name(name) {
+}
+
+std::string PrimitiveType::name() const {
+  return _name;
+}
+
+bool PrimitiveType::equals(Type* ofType, int dimensions) const {
+  return false;
+}
+
+bool PrimitiveType::equals(int id) const {
+  return _id == id;
+}
+
+//------------------------------------------------------------------
+
+
+MatrixType::MatrixType(Type* type, int dimensions)
+  : _ofType(type), _dimensions(dimensions) {
+}
+
+std::string MatrixType::name() const {
+  std::string ret;
+  ret = "matriz";
+  for (int i = 0; i < _dimensions; i++) {
+    ret += "[]";
+  }
+  ret += " do tipo " + _ofType->name();
+  return ret;
+}
+
+bool MatrixType::equals(Type* ofType, int dimensions) const {
+  return (ofType == _ofType) && (dimensions == _dimensions);
+}
+
+bool MatrixType::equals(int id) const {
+  return false;
+}
+
+//------------------------------------------------------------------
+
+
+StructType::StructType(const std::string& name, const std::list<Field>& fields,
+                       const std::string& unit, int line)
+  : _name(name), _fields(fields), _unit(unit), _line(line) {
+}
+
+
+const std::list<StructType::Field>& StructType::fields() {
+  return _fields;
+}
+
+std::string StructType::name() const {
+  return _name;
+}
+
+bool StructType::equals(Type* ofType, int dimensions) const {
+  return false;
+}
+
+bool StructType::equals(int id) const {
+  return false;
+}
+//------------------------------------------------------------------
+
+
+SubprogramType::SubprogramType(const TypeList& paramTypes,
+                               Type* returnType)
+  : _paramTypes(paramTypes), _returnType(returnType) {
+}
+
+std::string SubprogramType::name() const {
+  std::string ret;
+  if (_returnType->equals(PortugolTokenTypes::T_NULO)) {
+    ret = "proc(";
+  } else {
+    ret = "func(";
+  }
+  ret += _paramTypes.toString();
+  ret += ")";
+  ret += " : " + _returnType->name();
+  return ret;
+}
+
+bool SubprogramType::equals(Type* ofType, int dimensions) const {
+  return false;
+}
+
+bool SubprogramType::equals(int id) const {
+  return false;
+}

Added: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-11-21 17:32:12 UTC (rev 378)
@@ -0,0 +1,112 @@
+#ifndef TYPES_HPP
+#define TYPES_HPP
+
+#include <string>
+#include <list>
+
+class Type {
+public:
+  virtual ~Type();
+  virtual std::string name() const = 0;
+
+  virtual bool equals(Type* ofType, int dimensions) const = 0;
+  virtual bool equals(int id) const = 0;
+};
+
+
+
+class TypeList : public std::list<Type*> {
+public:
+
+  Type* find(const std::string& lexeme) const;
+
+  Type* find(Type* ofType, int dimensions) const;
+
+  Type* find(int id) const;
+
+  std::string toString() const;
+};
+
+
+
+class PrimitiveType : public Type {
+public:
+  PrimitiveType(int id, const std::string& name);
+
+  int id();
+  virtual std::string name() const;
+
+  virtual bool equals(Type* ofType, int dimensions) const;
+  virtual bool equals(int id) const;
+
+private:
+  int         _id;
+  std::string _name;
+};
+
+
+
+
+class MatrixType : public Type {
+public:
+  MatrixType(Type* ofType, int dimensions);
+
+  const Type*         ofType();
+  int                 dimensions();
+
+  virtual std::string name() const;
+
+  virtual bool equals(Type* ofType, int dimensions) const;
+  virtual bool equals(int id) const;
+private:
+  Type          *_ofType;
+  int           _dimensions;
+};
+
+
+class StructType : public Type {
+public:
+  class Field {
+    public:
+    Field(const std::string& n, Type* t)
+      : name(n), type(t) {}
+
+    std::string name;
+    Type* type;
+  };
+
+  StructType(const std::string& name, const std::list<Field>& fields,
+             const std::string& unit, int line);
+
+  const std::list<Field>& fields();
+
+  virtual std::string name() const;
+
+  virtual bool equals(Type* ofType, int dimensions) const;
+  virtual bool equals(int id) const;
+
+private:
+  std::string      _name;
+  std::list<Field> _fields;
+  std::string      _unit;
+  int              _line;
+};
+
+
+class SubprogramType : public Type {
+public:
+  SubprogramType(const TypeList& paramTypes, Type* returnType);
+
+  virtual std::string name() const;
+
+
+  virtual bool equals(Type* ofType, int dimensions) const;
+  virtual bool equals(int id) const;
+
+private:
+  TypeList         _paramTypes;
+  Type*            _returnType;
+};
+
+
+#endif

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-11-21 17:29:23 UTC (rev 377)
+++ trunk/gpt2/gptc/src/semantic.g	2007-11-21 17:32:12 UTC (rev 378)
@@ -20,6 +20,9 @@
 
 header {
   #include "BaseSemanticWalker.hpp"
+  #include "PortugolAST.hpp"
+  #include "Symbol.hpp"
+  #include "SymbolTable.hpp"
 }
 
 
@@ -32,117 +35,404 @@
   importVocab    = Portugol;
   noConstructors = true;
   genHashLines   = false;
+  ASTLabelType   = "RefPortugolAST";
+//   defaultErrorHandler=false;
 }
 
 {
 public:
-  SemanticWalker::SemanticWalker()
-	 : BaseSemanticWalker() { }
+  SemanticWalker::SemanticWalker(SymbolTable* stable)
+	 : BaseSemanticWalker(stable) { }
 }
 
 
 programa
-  : (importacao)*
+                                      {RefPortugolAST inicio;}
+  : #(T_ALGORITMO
 
-    (   declaracao_variaveis
-//       | declaracao_constantes
-//       | bloco_declaracao_estrutura
-    )*
+        (importacao)*
+
+        declaracoes_globais
+                                      //recuperando declaracoes globais e
+                                      //de subprogramas para a symtable
+                                      {inicio = _t; /*backup da posicao*/}
+        definicoes_subprogramas
+
+        EOF
+                                      //analise semantica do codigo
+                                      {_t = inicio; /*rollback*/}
+        corpo
+        EOF
+     )
   ;
 
 importacao
-  : #(T_USE T_TEXTO_LITERAL)
-    //TODO: carregar a symboltable das bibliotecas especificadas
+  : #(T_USE lib:T_TEXTO_LITERAL)                  {useLib(lib->getText());}
   ;
 
-declaracao_variaveis
-  : #(T_VARIAVEIS (declaracao_variavel)+)
-  | declaracao_variavel
+//TODO: checar inicializa??o:
+//      ex: vari?vel z : inteiro := f(); //erro!
+
+declaracoes_globais
+  : declaracao_variavel  (declaracoes_globais)?
+  | declaracao_constante (declaracoes_globais)?
+  | definicao_estrutura  (declaracoes_globais)?
   ;
 
+definicoes_subprogramas
+  : definicao_subprograma (definicoes_subprogramas)?
+  | T_INICIO (definicoes_subprogramas)?
+  ;
+
 declaracao_variavel
-  : #(T_VARIAVEL tipo lista_identificadores (lista_inicializacao)?)
+                                {
+                                  IDList ids;
+                                  Type *type;
+                                }
+
+  : #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao)?)
+
+                                {declare(ids, type, false);}
   ;
 
-lista_identificadores
-  : (T_IDENTIFICADOR)+
+identificadores returns [IDList list]
+  : (
+      id:T_IDENTIFICADOR      {list.push_back(id);}
+    )*
   ;
 
-tipo
-  : tipo_primitivo
-  | tipo_matriz
-  | T_IDENTIFICADOR
+declaracao_constante
+                                {
+                                  IDList ids;
+                                  Type *type;
+                                }
+
+  : #(T_CONSTANTE type=tipo ids=identificadores valor_inicialiacao)
+
+                                {declare(ids, type, true);}
   ;
 
-lista_inicializacao
-  : #(T_VALOR valor_inicializacao)
+definicao_estrutura
+                                {SymbolList symbols;}
+
+  : #(T_ESTRUTURA id:T_IDENTIFICADOR symbols=campos_estrutura)
+
+                                {defineStruct(id->getText(),
+                                    symbols, id->getLine());}
   ;
 
-valor_inicializacao
-  : (matriz_literal | estrutura_literal | expressao)
+campos_estrutura returns [SymbolList symbols]
+
+                                {
+                                  IDList ids;
+                                  Type *type;
+                                }
+
+  : (
+      #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao)?)
+
+                                {
+                                  for (IDList::iterator it = ids.begin();
+                                         it != ids.end(); ++it) {
+                                    symbols.push_back(
+                                      _symtable->newSymbol(
+                                          (*it)->getText(), type,
+                                               (*it)->getLine()));
+                                  }
+                                }
+    )+
   ;
 
-matriz_literal
-  : #(T_VAL_MATRIZ (valor_inicializacao)+)
+valor_inicialiacao
+  : #(T_VALOR valor)
   ;
 
-estrutura_literal
-  : #(T_VAL_ESTRUTURA (T_IDENTIFICADOR valor_inicializacao)+)
+valor returns [Type *type]
+  : type=expressao
+  | #(T_VAL_MATRIZ    (valor)*)
+  | #(T_VAL_ESTRUTURA (valor)*)
   ;
 
-tipo_primitivo
-  : T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
+tipo returns [Type *type]
+  : id:T_IDENTIFICADOR       {type = getType(id->getText());}
+  | type=tipo_primitivo
+  | type=tipo_matriz
   ;
 
-tipo_matriz
-  : #(T_MATRIZ tipo_da_matriz (T_INTEIRO_LITERAL|T_NULO)+)
+tipo_primitivo returns [Type *type]
+  : i:T_INTEIRO             {type = getType(i->getText());}
+  | r:T_REAL                {type = getType(r->getText());}
+  | ca:T_CARACTERE          {type = getType(ca->getText());}
+  | li:T_LITERAL            {type = getType(li->getText());}
+  | lo:T_LOGICO             {type = getType(lo->getText());}
+  | co:T_CORINGA            {type = getType(co->getText());}
   ;
 
-tipo_da_matriz
-  : tipo_primitivo | T_IDENTIFICADOR
+tipo_matriz returns [Type *type]
+
+                            {
+                              int d = 0;
+                              Type * ofType;
+                            }
+
+  : #(T_MATRIZ ofType=tipo (dimensao {d++;})*)
+
+                            {type = _symtable->retrieveMatrixType(ofType,d);}
   ;
 
+dimensao
+  : T_INTEIRO_LITERAL
+  | T_NULO
+  ;
 
-expressao
-  : expr_elemento
+definicao_subprograma
+  : declaracao_funcao
+  | declaracao_procedimento
   ;
 
-expr_elemento
-  : literal
+declaracao_procedimento
+                                      {SymbolList params;}
+
+  : #(T_PROCEDIMENTO
+        id:T_IDENTIFICADOR
+        params=lista_parametros[id->getText()]
+
+                                      {
+                                        declareProc(id->getText(),
+                                                   params, id->getLine());
+
+                                        _symtable->setScope(id->getText());
+                                      }
+
+    (declaracao_variavel | declaracao_constante)*)
+
+                                      {_symtable->setGlobalScope();}
   ;
 
-literal
-  : T_TEXTO_LITERAL
-  | T_INTEIRO_LITERAL
-  | T_REAL_LITERAL
-  | T_CARACTERE_LITERAL
-  | T_VERDADEIRO
-  | T_FALSO
-  | T_NULO
+declaracao_funcao
+                                      {
+                                        SymbolList params;
+                                        Type * rettype;
+                                      }
+  : #(T_FUNCAO
+        id:T_IDENTIFICADOR
+        params=lista_parametros[id->getText()]
+        rettype=tipo_retorno
+                                      {
+                                        declareProc(id->getText(),
+                                            params, id->getLine(), rettype);
+
+                                        _symtable->setScope(id->getText());
+                                      }
+
+    (declaracao_variavel | declaracao_constante)*)
+
+                                      {_symtable->setGlobalScope();}
   ;
 
-//   T_OU
-//   : expr_bit_ou (T_E^ expr_bit_ou)*
-//   : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
-//   : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
-//   : expr_igual (T_BIT_E^ expr_igual)*
-//   : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
-//   : expr_ad ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_ad)*
-//   : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
-//   : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
-//   : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,"&negat"];}
-//     | T_MAIS       {#op_unario = #[T_UN_POSITIVO,"&pos"];}
-//     | n:T_NAO      {#op_unario = #[T_NAO        ,"nega?"];}
-//     | bn:T_BIT_NAO {#op_unario = #[T_BIT_NAO    ,"&negb"];}
+tipo_retorno returns [Type * ret]
+  : #(T_TIPO_RETORNO ret=tipo)
+  ;
 
-// expr_elemento
-//   :  (T_IDENTIFICADOR T_ABRE_PAREN)=> chamada_subrotina
-//   |  lvalue
-//   |  literal
-//   | T_ABRE_PAREN! expressao T_FECHA_PAREN!
-//   ;
+lista_parametros[std::string scope] returns [SymbolList list]
+
+                                  {Type *type;}
+  : (
+      #(T_PARAM type=tipo id:T_IDENTIFICADOR (r:T_REF)? (c:T_CONSTANTE)?)
+
+                                  {
+                                    list.push_back(
+                                        _symtable->newSymbol(
+                                          id->getText(), type,
+                                          id->getLine(),
+                                          scope,
+                                          c != antlr::nullAST,
+                                          r != antlr::nullAST));
+
+                                      c = antlr::nullAST;
+                                      r = antlr::nullAST;
+                                  }
+    )*
+  ;
+
+
+corpo
+  :  corpo_subprograma      (corpo)?
+  |  bloco_codigo           (corpo_subprograma)*
+  ;
+
+
+corpo_subprograma
+  : #(T_FUNCAO   f:T_IDENTIFICADOR     {_symtable->setScope(f->getText());}
+                 (~(T_INICIO))*
+                 bloco_codigo          {_symtable->setGlobalScope();}
+    )
+  | #(T_PROCEDIMENTO p:T_IDENTIFICADOR {_symtable->setScope(p->getText());}
+                 (~(T_INICIO))*
+                 bloco_codigo)         {_symtable->setGlobalScope();}
+  ;
+
+
+
+bloco_codigo
+  : #(T_INICIO (enunciado)*)
+  ;
+
+enunciado
+  : en_atribuicao
+//   | en_retorne
+//   | en_se
+//   | en_enquanto
+//   | en_repita
+//   | en_para
+//   | en_caso
+//   | en_asm
+//
+//   | T_SAIR
+//   | chamada_subrotina T_PONTO_VIRGULA!
+  ;
+
+en_atribuicao
+                        {Type *ltype, *rtype;}
+
+  : #(T_ATRIBUICAO ltype=lvalue rtype=expressao)
+
+                        {evalAttribution(ltype, rtype);}
+  ;
+
+expressao returns [Type *type]
+                                                 {Type *l, *r;}
+
+  : #(T_OU              l=expressao r=expressao)
+                                    {type = evalExpr<T_OU>(l,r);}
+
+  | #(T_E               l=expressao r=expressao)
+                                    {type = evalExpr<T_E>(l,r);}
+
+  | #(T_BIT_OU          l=expressao r=expressao)
+                                    {type = evalExpr<T_BIT_OU>(l,r);}
+
+  | #(T_BIT_OUX         l=expressao r=expressao)
+                                    {type = evalExpr<T_BIT_OUX>(l,r);}
+
+  | #(T_BIT_E           l=expressao r=expressao)
+                                    {type = evalExpr<T_BIT_E>(l,r);}
+
+  | #(T_IGUAL           l=expressao r=expressao)
+                                    {type = evalExpr<T_IGUAL>(l,r);}
+
+  | #(T_DIFERENTE       l=expressao r=expressao)
+                                    {type = evalExpr<T_DIFERENTE>(l,r);}
+
+  | #(T_MAIOR           l=expressao r=expressao)
+                                    {type = evalExpr<T_MAIOR>(l,r);}
+
+  | #(T_MENOR           l=expressao r=expressao)
+                                    {type = evalExpr<T_MENOR>(l,r);}
+
+  | #(T_MAIOR_EQ        l=expressao r=expressao)
+                                    {type = evalExpr<T_MAIOR_EQ>(l,r);}
+
+  | #(T_MENOR_EQ        l=expressao r=expressao)
+                                    {type = evalExpr<T_MENOR_EQ>(l,r);}
+
+  | #(T_BIT_SHIFT_LEFT  l=expressao r=expressao)
+                                    {type = evalExpr<T_BIT_SHIFT_LEFT>(l,r);}
+
+  | #(T_BIT_SHIFT_RIGHT l=expressao r=expressao)
+                                    {type = evalExpr<T_BIT_SHIFT_RIGHT>(l,r);}
+
+  | #(T_MAIS            l=expressao r=expressao)
+                                    {type = evalExpr<T_MAIS>(l,r);}
+
+  | #(T_MENOS           l=expressao r=expressao)
+                                    {type = evalExpr<T_MENOS>(l,r);}
+
+  | #(T_DIV             l=expressao r=expressao)
+                                    {type = evalExpr<T_DIV>(l,r);}
+
+  | #(T_MULTIP          l=expressao r=expressao)
+                                    {type = evalExpr<T_MULTIP>(l,r);}
+
+  | #(T_MOD             l=expressao r=expressao)
+                                    {type = evalExpr<T_MOD>(l,r);}
+
+  | #(T_UN_NEGATIVO    l=elemento)
+                                    {type = evalExpr<T_UN_NEGATIVO>(l);}
+
+  | #(T_UN_POSITIVO   l=elemento)
+                                    {type = evalExpr<T_UN_POSITIVO>(l);}
+
+  | #(T_NAO            l=elemento)
+                                    {type = evalExpr<T_NAO>(l);}
+
+  | #(T_BIT_NAO        l=elemento)
+                                    {type = evalExpr<T_BIT_NAO>(l);}
+
+  | type=elemento
+  ;
+
+
+elemento returns [Type *type]
+  : type=literal
+  | type=chamada_subrotina
+  | type=lvalue
+  | #(T_ABRE_PAREN type=expressao)
+  ;
+
+lvalue returns [Type *type]
+
+  : #(id:T_IDENTIFICADOR
+
+      (   lvalue_indices         {type = getSymbolType(id->getText());}
+        | type=lvalue_membro
+        | /*vazio*/              {type = getSymbolType(id->getText());}
+      )
+    )
+  ;
+
+lvalue_membro returns [Type *type]
+  : #(T_MEMBRO type=lvalue)
+  ;
+
+lvalue_indices
+                                {Type *type;}
+  : #(T_SUBSCRITO
+      (
+        type=expressao          {evalMatrixSubscript(type);}
+      )+
+    )
+  ;
+
+chamada_subrotina returns [Type *type]
+
+                                  {
+                                    TypeList params;
+                                  }
+
+  : #(T_CALL id:T_IDENTIFICADOR params=lista_argumentos)
+
+                                  {
+                                    type = getSymbolType(id->getText());
+                                    evalFCall(id->getText(), params);
+                                  }
+  ;
+
+
+lista_argumentos returns [TypeList list]
+
+                                   {Type *type;}
+  : (
+      type=expressao               {list.push_back(type);}
+    )*
+  ;
+
+literal returns [Type *type]
+  : T_TEXTO_LITERAL      {type = getType(T_LITERAL);}
+  | T_INTEIRO_LITERAL    {type = getType(T_INTEIRO);}
+  | T_REAL_LITERAL       {type = getType(T_REAL);}
+  | T_CARACTERE_LITERAL  {type = getType(T_CARACTERE);}
+  | T_VERDADEIRO         {type = getType(T_LOGICO);}
+  | T_FALSO              {type = getType(T_CARACTERE);}
+  | T_NULO               {type = getType(T_NULO);}
+  ;



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:33:15 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:33:15 +0100
Subject: [gpt-commit] r379 - trunk/gpt2/gptc/src
Message-ID: <200711211733.lALHXFTO031919@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:33:15 +0100 (Wed, 21 Nov 2007)
New Revision: 379

Modified:
   trunk/gpt2/gptc/src/teste.cpp
Log:
nomsg

Modified: trunk/gpt2/gptc/src/teste.cpp
===================================================================
--- trunk/gpt2/gptc/src/teste.cpp	2007-11-21 17:32:12 UTC (rev 378)
+++ trunk/gpt2/gptc/src/teste.cpp	2007-11-21 17:33:15 UTC (rev 379)
@@ -1,22 +1,26 @@
 #include <stdio.h>
+#include <fstream>
+
+#include <antlr/TokenBuffer.hpp>
+#include <antlr/CommonAST.hpp>
+
 #include "PortugolLexer.hpp"
 #include "PortugolParser.hpp"
 #include "SemanticWalker.hpp"
 #include "PortugolTokenTypes.hpp"
-#include <antlr/TokenBuffer.hpp>
-#include <antlr/CommonAST.hpp>
+#include "SymbolTable.hpp"
 
-#include <fstream>
+#include "TokenNames.hpp"
 
 void dump_tokens(char* fname) {
-  #include "tokenNames.hpp"
+
   std::ifstream fi(fname);
   PortugolLexer lexer(fi, true);
   antlr::TokenBuffer *buffer = new antlr::TokenBuffer(lexer);
 
   while (true) {
     std::cout << lexer.getLine() << ": [" << buffer->LA(1) << "] "
-              << tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
+              << g_tokenNames[buffer->LA(1)] << " (" << lexer.getText() << ")";
     buffer->consume();
     getchar();
 
@@ -26,20 +30,22 @@
   }
 }
 
-antlr::RefAST dump_tree(char* fname, bool should_dump) {
+RefPortugolAST dump_tree(char* fname, bool should_dump) {
 
   std::ifstream fi(fname);
   PortugolLexer lexer(fi, true);
   PortugolParser parser(lexer);
 
-  antlr::ASTFactory ast_factory(antlr::CommonAST::TYPE_NAME,&antlr::CommonAST::factory);
+  antlr::ASTFactory ast_factory(PortugolAST::TYPE_NAME,
+                                &PortugolAST::factory);
+
   parser.initializeASTFactory(ast_factory);
   parser.setASTFactory(&ast_factory);
 
   parser.programa();
 
   antlr::RefAST ast = parser.getAST();
-  antlr::RefCommonAST cast = antlr::RefCommonAST(ast);
+  RefPortugolAST cast = RefPortugolAST(ast);
 
   if (!cast) {
     std::cerr << "no parse tree!" << std::endl;
@@ -48,16 +54,20 @@
   if (should_dump) {
     std::cerr << cast->toStringList() << std::endl << std::endl;
   }
-  return ast;
+  return cast;
 }
 
 void semantic(char* fname) {
-  antlr::RefAST ast;
+  RefPortugolAST ast;
 
   ast = dump_tree(fname, true);
 
-  SemanticWalker semantic;
+  SymbolTable* symtable = SymbolTable::create(fname);
+
+  SemanticWalker semantic(symtable);
   semantic.programa(ast);
+
+  symtable->dump();
 }
 
 int main(int argc, char** argv) {



From gpt-commit-noreply at mail.berlios.de  Wed Nov 21 18:38:03 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Wed, 21 Nov 2007 18:38:03 +0100
Subject: [gpt-commit] r380 - in trunk/gpt2/gptc: . src
Message-ID: <200711211738.lALHc33H011822@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-21 18:38:00 +0100 (Wed, 21 Nov 2007)
New Revision: 380

Added:
   trunk/gpt2/gptc/AUTHORS
   trunk/gpt2/gptc/COPYING
   trunk/gpt2/gptc/ChangeLog
   trunk/gpt2/gptc/INSTALL
   trunk/gpt2/gptc/Makefile.am
   trunk/gpt2/gptc/NEWS
   trunk/gpt2/gptc/README
   trunk/gpt2/gptc/bootstrap.sh
   trunk/gpt2/gptc/configure.ac
   trunk/gpt2/gptc/src/Makefile.am
Log:
-Adicionando esqueletos de arquivos basicos de um pacote
-Adicionando infra para construcao (autotools). Basta executar ./bootstrap para criar os arquivos necessarios

Added: trunk/gpt2/gptc/AUTHORS
===================================================================

Added: trunk/gpt2/gptc/COPYING
===================================================================
--- trunk/gpt2/gptc/COPYING	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/COPYING	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.

Added: trunk/gpt2/gptc/ChangeLog
===================================================================

Added: trunk/gpt2/gptc/INSTALL
===================================================================
--- trunk/gpt2/gptc/INSTALL	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/INSTALL	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1,236 @@
+Installation Instructions
+*************************
+
+Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005 Free
+Software Foundation, Inc.
+
+This file is free documentation; the Free Software Foundation gives
+unlimited permission to copy, distribute and modify it.
+
+Basic Installation
+==================
+
+These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, and a
+file `config.log' containing compiler output (useful mainly for
+debugging `configure').
+
+   It can also use an optional file (typically called `config.cache'
+and enabled with `--cache-file=config.cache' or simply `-C') that saves
+the results of its tests to speed up reconfiguring.  (Caching is
+disabled by default to prevent problems with accidental use of stale
+cache files.)
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If you are using the cache, and at
+some point `config.cache' contains results you don't want to keep, you
+may remove or edit it.
+
+   The file `configure.ac' (or `configure.in') is used to create
+`configure' by a program called `autoconf'.  You only need
+`configure.ac' if you want to change it or regenerate `configure' using
+a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+Some systems require unusual options for compilation or linking that the
+`configure' script does not know about.  Run `./configure --help' for
+details on some of the pertinent environment variables.
+
+   You can give `configure' initial values for configuration parameters
+by setting variables in the command line or in the environment.  Here
+is an example:
+
+     ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
+
+   *Note Defining Variables::, for more details.
+
+Compiling For Multiple Architectures
+====================================
+
+You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not support the `VPATH'
+variable, you have to compile the package for one architecture at a
+time in the source code directory.  After you have installed the
+package for one architecture, use `make distclean' before reconfiguring
+for another architecture.
+
+Installation Names
+==================
+
+By default, `make install' installs the package's commands under
+`/usr/local/bin', include files under `/usr/local/include', etc.  You
+can specify an installation prefix other than `/usr/local' by giving
+`configure' the option `--prefix=PREFIX'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+pass the option `--exec-prefix=PREFIX' to `configure', the package uses
+PREFIX as the prefix for installing programs and libraries.
+Documentation and other data files still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=DIR' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+There may be some features `configure' cannot figure out automatically,
+but needs to determine by the type of machine the package will run on.
+Usually, assuming the package is built to be run on the _same_
+architectures, `configure' can figure that out, but if it prints a
+message saying it cannot guess the machine type, give it the
+`--build=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name which has the form:
+
+     CPU-COMPANY-SYSTEM
+
+where SYSTEM can have one of these forms:
+
+     OS KERNEL-OS
+
+   See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the machine type.
+
+   If you are _building_ compiler tools for cross-compiling, you should
+use the option `--target=TYPE' to select the type of system they will
+produce code for.
+
+   If you want to _use_ a cross compiler, that generates code for a
+platform different from the build platform, you should specify the
+"host" platform (i.e., that on which the generated programs will
+eventually be run) with `--host=TYPE'.
+
+Sharing Defaults
+================
+
+If you want to set default values for `configure' scripts to share, you
+can create a site shell script called `config.site' that gives default
+values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Defining Variables
+==================
+
+Variables not defined in a site shell script can be set in the
+environment passed to `configure'.  However, some packages may run
+configure again during the build, and the customized values of these
+variables may be lost.  In order to avoid this problem, you should set
+them in the `configure' command line, using `VAR=value'.  For example:
+
+     ./configure CC=/usr/local2/bin/gcc
+
+causes the specified `gcc' to be used as the C compiler (unless it is
+overridden in the site shell script).  Here is a another example:
+
+     /bin/bash ./configure CONFIG_SHELL=/bin/bash
+
+Here the `CONFIG_SHELL=/bin/bash' operand causes subsequent
+configuration-related scripts to be executed by `/bin/bash'.
+
+`configure' Invocation
+======================
+
+`configure' recognizes the following options to control how it operates.
+
+`--help'
+`-h'
+     Print a summary of the options to `configure', and exit.
+
+`--version'
+`-V'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`--cache-file=FILE'
+     Enable the cache: use and save the results of the tests in FILE,
+     traditionally `config.cache'.  FILE defaults to `/dev/null' to
+     disable caching.
+
+`--config-cache'
+`-C'
+     Alias for `--cache-file=config.cache'.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`configure' also accepts some other, not widely useful, options.  Run
+`configure --help' for more details.
+

Added: trunk/gpt2/gptc/Makefile.am
===================================================================
--- trunk/gpt2/gptc/Makefile.am	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/Makefile.am	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1 @@
+SUBDIRS = src
\ No newline at end of file

Added: trunk/gpt2/gptc/NEWS
===================================================================

Added: trunk/gpt2/gptc/README
===================================================================

Added: trunk/gpt2/gptc/bootstrap.sh
===================================================================
--- trunk/gpt2/gptc/bootstrap.sh	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/bootstrap.sh	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+aclocal
+autoheader
+libtoolize -c -f
+automake -ac
+autoconf


Property changes on: trunk/gpt2/gptc/bootstrap.sh
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/gptc/configure.ac
===================================================================
--- trunk/gpt2/gptc/configure.ac	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/configure.ac	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1,93 @@
+AC_PREREQ(2.60)
+
+AC_INIT(gptc, 2.0)
+AC_CONFIG_HEADER([config.h])
+AM_INIT_AUTOMAKE(gptc, 2.0)
+
+AC_LANG(C++)
+AC_PROG_CXX
+AM_PROG_LIBTOOL
+
+#------------------------------
+# debug options
+#------------------------------
+
+AC_ARG_ENABLE(debug,
+        AC_HELP_STRING([--enable-debug=ARG],[enables debug symbols (yes|no|full) [default=no]]),
+[
+  case $enableval in
+    yes)
+      use_debug_code="yes"
+      use_debug_define=yes
+      ;;
+    full)
+      use_debug_code="full"
+      use_debug_define=yes
+      ;;
+    *)
+      use_debug_code="no"
+      use_debug_define=no
+      ;;
+  esac
+],
+  [use_debug_code="no"
+    use_debug_define=no
+])
+
+CXXFLAGS=
+if test "$use_debug_code" != "no"; then
+  if test $use_debug_code = "full"; then
+    CXXFLAGS="-g3 $CXXFLAGS"
+  else
+    CXXFLAGS="-g -O2 $CXXFLAGS"
+  fi
+else
+  CXXFLAGS="-O2 $CXXFLAGS"
+fi
+
+if test "$use_debug_define" = "yes"; then
+  CXXFLAGS="-DDEBUG $CXXFLAGS"
+fi
+
+
+#------------------------------
+# Checks for ANTLR
+#------------------------------
+
+AC_PATH_PROG(ANTLR_BIN, antlr)
+
+if test "x${ANTLR}" = "x"; then
+  AC_PATH_PROG(ANTLR_BIN, runantlr)
+fi
+
+if test "x${ANTLR_BIN}" = "x"; then
+  AC_MSG_ERROR(
+  [
+    O programa "antlr" (ou runantlr) n??o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    Baixe em: http://www.antlr.org
+  ])
+fi
+
+AC_PATH_PROG(ANTLR_CFG, antlr-config)
+if test "x${ANTLR_CFG}" = "x"; then
+  AC_MSG_ERROR(
+  [
+    O programa "antlr-config" n??o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers??o >= 2.6) instalado.
+    Baixe em: http://www.antlr.org
+  ])
+fi
+
+ANTLR_LIB=`${ANTLR_CFG} --libs`
+ANTLR_INC=`${ANTLR_CFG} --cflags`
+
+AC_SUBST(ANTLR_BIN)
+AC_SUBST(ANTLR_INC)
+AC_SUBST(ANTLR_LIB)
+
+
+AC_CONFIG_FILES([Makefile
+                 src/Makefile
+                 test/Makefile])
+AC_OUTPUT

Added: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-11-21 17:33:15 UTC (rev 379)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-11-21 17:38:00 UTC (rev 380)
@@ -0,0 +1,74 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
+
+bin_PROGRAMS = gptc
+gptc_LDADD = $(ANTLR_LIB)
+
+EXTRA_DIST = lexer.g parser.g semantic.g
+
+
+BUILT_SOURCES = PortugolLexer.hpp \
+                PortugolLexer.cpp \
+                PortugolParser.hpp \
+                PortugolParser.cpp \
+                SemanticWalker.hpp \
+                SemanticWalker.cpp \
+                TokenNames.hpp
+
+
+gptc_SOURCES = BaseSemanticWalker.hpp \
+               BaseSemanticWalker.cpp \
+               CompilerError.hpp \
+               CompilerError.cpp \
+               MismatchedUnicodeCharException.hpp \
+               MismatchedUnicodeCharException.cpp \
+               PortugolAST.hpp \
+               PortugolAST.cpp \
+               Symbol.hpp \
+               Symbol.cpp \
+               SymbolTable.hpp \
+               SymbolTable.cpp \
+               SymbolTableExceptions.hpp \
+               SymbolTableExceptions.cpp \
+               teste.cpp \
+               Types.hpp \
+               Types.cpp \
+               UnicodeCharBuffer.hpp \
+               UnicodeCharScanner.hpp \
+               $(BUILT_SOURCES)
+
+
+CLEANFILES = PortugolLexer.cpp \
+             PortugolLexer.hpp \
+             PortugolTokenTypes.hpp \
+             PortugolTokenTypes.txt \
+             PortugolParser.cpp \
+						 PortugolParser.hpp  \
+             PortugolParserTokenTypes.hpp \
+             PortugolParserTokenTypes.txt \
+             SemanticWalker.hpp \
+             SemanticWalker.cpp \
+             SemanticWalkerTokenTypes.hpp \
+             SemanticWalkerTokenTypes.txt \
+             TokenNames.hpp
+
+PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
+	$(ANTLR_BIN) $(srcdir)/lexer.g
+
+PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile \
+                                       PortugolLexer.cpp  PortugolLexer.hpp
+	$(ANTLR_BIN) $(srcdir)/parser.g
+
+SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile \
+                                       PortugolLexer.cpp  PortugolLexer.hpp
+	$(ANTLR_BIN) $(srcdir)/semantic.g
+
+
+TokenNames.hpp: Makefile
+	@echo "#ifndef TOKENNAMES_H" > $@
+	@echo "#define TOKENNAMES_H"  >> $@
+	@echo "static char* g_tokenNames[] = " >> $@
+	@echo '{"", "EOF", "", "",'   >> $@
+	grep = PortugolTokenTypes.txt >> $@
+	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/"\1",/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo "#endif" >> $@



From gpt-commit-noreply at mail.berlios.de  Thu Nov 22 16:45:59 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 22 Nov 2007 16:45:59 +0100
Subject: [gpt-commit] r381 - in trunk/gpt2: common/src gptasm/src
	gptasm/test gptasm/test/wikki gptvm/src
Message-ID: <200711221545.lAMFjxiw018911@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-22 16:45:54 +0100 (Thu, 22 Nov 2007)
New Revision: 381

Added:
   trunk/gpt2/gptvm/src/CBytecode.cpp
   trunk/gpt2/gptvm/src/CBytecode.hpp
Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/CCode.cpp
   trunk/gpt2/common/src/CCode.hpp
   trunk/gpt2/common/src/CData.cpp
   trunk/gpt2/common/src/CData.hpp
   trunk/gpt2/common/src/CSymbol.hpp
   trunk/gpt2/common/src/CSymbolList.cpp
   trunk/gpt2/common/src/CSymbolList.hpp
   trunk/gpt2/common/src/CSymbolTable.cpp
   trunk/gpt2/common/src/CSymbolTable.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/asm.sh
   trunk/gpt2/gptasm/test/asm_all.sh
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
Log:
DEVNULL
* Refactoring em varias classes
* Novos opcodes implementados na VM
* Funcionando "Hello world !!!", alguns calculos matematicos e 
  estruturas de repeticao


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -2,7 +2,20 @@
 
 #include "CBinString.hpp"
 
+// TODO: versoes BEM mais otimizadas :-)
+//int CData::getInt(const int &address)
+//{
+//   int *ret = (int*)&(_data[address]);
+//   return *ret;
+//}
+//void CData::setInt(const int &address, const int &value)
+//{
+//   int *targetAddress = (int*)&(_data[address]);
+//
+//   *targetAddress = value;
+//}
 
+
 void CBinString::writeInt(const int &value)
 {
    char *byte = (char*)&value;
@@ -67,6 +80,28 @@
 }
 
 
+char CBinString::getByte(const int &pos)
+{
+   return (*this)[pos];
+}
+
+void CBinString::getByte(const int &pos, char &value)
+{
+   value = getByte(pos);
+}
+
+int CBinString::getInt(int pos)
+{
+   int result = 0;
+   char *byte = (char*)&result;
+
+   for( size_t i = 0; i < sizeof(int); i++) {
+      *byte++ = (*this)[pos++];
+   }
+   return result;
+}
+
+
 void CBinString::readString(std::string &value)
 {
    int size;
@@ -77,6 +112,17 @@
 }
 
 
+std::string CBinString::readString()
+{
+   std::string result;
+   int size;
+   readInt(size);
+   result=substr(0, size);
+   erase(0, size);
+   return result;
+}
+
+
 void CBinString::readBool(bool &value)
 {
    char byte;
@@ -87,6 +133,19 @@
 }
 
 
+void CBinString::setInt(int pos, const int &value)
+{
+   char *byte = (char*)&value;
+
+   for( size_t i = 0; i < sizeof(int); i++) {
+      (*this)[pos++] = *byte++;
+   }
+   // TODO: BEM mais eficiente...
+   // int *targetAddress = (int*)&(_data[address]);
+   //*targetAddress = value;
+}
+
+
 bool CBinString::removeIfEqual(const int &value)
 {
    // TODO: nao ta correto pq sempre retira...

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -13,11 +13,17 @@
    void writeBool(const bool &value);
    void readInt(int &value);
    void readByte(char &value);
+   char getByte(const int &pos);
+   void getByte(const int &pos, char &value);
+   int getInt(int pos);
    void readString(std::string &value);
+   std::string readString();
    void readBool(bool &value);
+   void setInt(int pos, const int &value);
    bool removeIfEqual(const int &value);
    bool removeIfEqual(const char &value);
    bool removeIfEqual(const std::string &value);
+   std::string::find;
 };
 
 #endif

Modified: trunk/gpt2/common/src/CCode.cpp
===================================================================
--- trunk/gpt2/common/src/CCode.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CCode.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -1,61 +1,2 @@
 #include "CCode.hpp"
 
-
-CCode::CCode()
-{
-}
-
-
-CCode::~CCode()
-{
-}
-
-
-void CCode::addByte(const char &code)
-{
-   _data += code;
-}
-
-
-void CCode::addInt(const int &code)
-{
-   const char *byte = (const char*) &code;
-
-   for (size_t i = 0; i < sizeof(int); i++) {
-      _data += *byte;
-      byte++;
-   }
-}
-
-
-int CCode::size() const
-{
-   return _data.size();
-}
-
-
-CBinString CCode::getBinary() const
-{
-   return _data;
-}
-
-
-bool CCode::readFromBinary(CBinString &bin)
-{
-   bin.readString(_data);
-   return true;
-}
-
-
-char CCode::getByte(const int &pos)
-{
-   return _data[pos];
-}
-
-
-int CCode::getInt(const int &pos)
-{
-   int *ret = (int*)&(_data[pos]);
-   return *ret;
-}
-

Modified: trunk/gpt2/common/src/CCode.hpp
===================================================================
--- trunk/gpt2/common/src/CCode.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CCode.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -7,20 +7,10 @@
 #include "CBinString.hpp"
 
 
-class CCode
+class CCode : public CBinString
 {
 public:
-   CCode();
-   ~CCode();
-   void addByte(const char &code);
-   void addInt(const int &code);
-   int size() const;
-   CBinString getBinary() const;
-   bool readFromBinary(CBinString &bin);
-   char getByte(const int &pos);
-   int getInt(const int &pos);
 private:
-   CBinString _data;
 };
 
 #endif

Modified: trunk/gpt2/common/src/CData.cpp
===================================================================
--- trunk/gpt2/common/src/CData.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CData.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -19,12 +19,6 @@
 }
 
 
-//CSymbol* CData::add(const std::string &name, const int &category, const int &type, const int &address)
-//{
-//   return CSymbolList::add( name, category, type, address, 0 ); // TODO: nao eh zero...
-//}
-
-
 CSymbol* CData::addVariable (const std::string &name, const int &type, const int &address)
 {
    CSymbol *symbol = new CSymbol (name, type, CSymbol::VAR, address);
@@ -34,7 +28,7 @@
    //_data += symbol->getBinary();
    for (int i=0; i < symbol->getTypeSize(); i++) {
       // TODO: horrivel :-)
-      _data.writeByte (' ');
+      writeByte (' ');
    }
 
    return symbol;
@@ -49,47 +43,25 @@
 
    //_data += symbol->getBinary();
    if (type == CSymbol::STRING) {
-      _data.writeString(name, false);
+      writeString(name, false);
    } else if (type == CSymbol::INT) {
-      _data.writeInt(atoi(name.c_str()));
+      writeInt(atoi(name.c_str()));
    }
 
    return symbol;
 }
 
 
-bool CData::readFromBinary(CBinString &bin)
-{
-   bin.readString(_data);
-   return true;
-}
-
-
 std::string CData::getString(const int &address)
 {
    int pos = 0;
 
-   pos = _data.find('\0', address);
+   pos = find('\0', address);
 
    if (pos == -1) {
       abort();
    }
 
-   return _data.substr(address, pos - address);
+   return substr(address, pos - address);
 }
 
-
-int CData::getInt(const int &address)
-{
-   int *ret = (int*)&(_data[address]);
-   return *ret;
-}
-
-
-void CData::setInt(const int &address, const int &value)
-{
-   int *targetAddress = (int*)&(_data[address]);
-
-   *targetAddress = value;
-}
-

Modified: trunk/gpt2/common/src/CData.hpp
===================================================================
--- trunk/gpt2/common/src/CData.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CData.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -17,8 +17,6 @@
    CSymbol* addConstant (const std::string &name, const int &type, const int &address);
    bool readFromBinary(CBinString &bin);
    std::string getString(const int &address);
-   int getInt(const int &address);
-   void setInt(const int &address, const int &value);
 };
 
 #endif

Modified: trunk/gpt2/common/src/CSymbol.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CSymbol.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -22,7 +22,8 @@
       CHAR = 'C',
       BOOL = 'B',
       REAL = 'R',
-      MATRIX = 'M'
+      MATRIX = 'M',
+      POINTER = 'P'
    };
    CSymbol ();
    CSymbol (const std::string &name, const char &type, const char &category,
@@ -35,10 +36,6 @@
    {
       return _name;
    }
-   CBinString getBinary() const
-   {
-      return _data;
-   }
    int getTypeSize() const;
    char getType() const
    {
@@ -65,8 +62,6 @@
    {
       return _parameters;
    }
-protected:
-   CBinString           _data;
 private:
    std::string          _name;
    char                 _type;

Modified: trunk/gpt2/common/src/CSymbolList.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolList.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CSymbolList.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -1,7 +1,7 @@
 #include "CSymbolList.hpp"
 
 
-CSymbolList::CSymbolList() //: _size(0)
+CSymbolList::CSymbolList()
 {
 }
 
@@ -15,7 +15,10 @@
 {
    _symbols.push_back(symbol);
 
-   _data += symbol->getBinary();
+//   Este metodo esta sendo utilizado durante a leitura do binario. Mas durante a leitura nao eh
+//   mais necessario popular "_data". Com isso symbol->getBinary pode ser descartado junto com
+//   varios outros metodos/propriedades
+//   (*this) += symbol->getBinary();
    return symbol;
 }
 

Modified: trunk/gpt2/common/src/CSymbolList.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolList.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CSymbolList.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -8,9 +8,10 @@
 #include <stdlib.h>
 
 #include "CSymbol.hpp"
+#include "CBinString.hpp"
 
 
-class CSymbolList
+class CSymbolList : public CBinString
 {
 public:
    CSymbolList();
@@ -20,22 +21,18 @@
    int getAddress( const std::string &name );
    CSymbol* getSymbol(const std::string &name);
    std::vector<CSymbol*>::iterator find(const std::string &name);
-   CBinString getBinary() const
-   {
-      return _data;
-   }
    int getDataSize() const
    {
-      return _data.size();
+      return size();
    }
    int getSymbolsCount() const
    {
       return _symbols.size();
    }
    bool readFromBinary(CBinString &bin);
+   CBinString::find;
 protected:
    std::vector<CSymbol*> _symbols;
-   CBinString _data;
 private:
 };
 

Modified: trunk/gpt2/common/src/CSymbolTable.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -20,12 +20,12 @@
    // Endere?o 0123 (code), procedure, sem retorno, nome "p1",
    // sem argumentos vari?veis, 2 par?metros fixos, p1 (int) e p2 (string)
    // 0024: 0123 P N 2 "p1" N 2 I 4 2 "p1" S 30 2 "p2"
-   _data.writeInt( address );
-   _data.writeByte( CSymbol::PROC ); // procedure
-   _data.writeByte( type ); // tipo do retorno // TODO: em asm proc tem retorno ???
-   _data.writeString( name ); // nome da procedure
-   _data.writeBool( hasVarArguments );
-   _data.writeByte( staticParameters );
+   writeInt( address );
+   writeByte( CSymbol::PROC ); // procedure
+   writeByte( type ); // tipo do retorno // TODO: em asm proc tem retorno ???
+   writeString( name ); // nome da procedure
+   writeBool( hasVarArguments );
+   writeByte( staticParameters );
    // TODO: falta argumentos
 
    return symbol;
@@ -52,15 +52,32 @@
 
    // Endere?o 0000 (data), constante, string, 8 bytes ???, nome "c1"
    // 0000: 0000 C S 8??? 2 "c1"
-   _data.writeInt( address );
-   _data.writeByte( CSymbol::CONST ); // categoria: constante
-   _data.writeByte( type );           // tipo
-   _data.writeString( name );         // nome da constante
+   writeInt( address );
+   writeByte( CSymbol::CONST ); // categoria: constante
+   writeByte( type );           // tipo
+   writeString( name );         // nome da constante
 
    return symbol;
 }
 
 
+CSymbol* CSymbolTable::addVariable (const std::string &name, const int &type, const int &address)
+{
+   CSymbol *symbol = new CSymbol( name, type, CSymbol::VAR, address);
+
+   _symbols.push_back(symbol);
+
+   // Endere?o 0000 (data), variavel, string, 8 bytes ???, nome "v1"
+   // 0000: 0000 V S 8??? 2 "v1"
+   writeInt( address );
+   writeByte( CSymbol::VAR ); // categoria: variavel
+   writeByte( type );         // tipo
+   writeString( name );       // nome da variavel
+
+   return symbol;
+}
+
+
 CSymbol* CSymbolTable::add(CSymbol *symbol)
 {
 //   std::cout << "Adicionando simbolo [" << symbol->getName() << "] type [" << symbol->getType() << "] address [" << symbol->getAddress() << "] a SymbolTable" << std::endl;

Modified: trunk/gpt2/common/src/CSymbolTable.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -16,6 +16,7 @@
    CSymbol* addProcedure (const std::string &name, const int &type, const int &address, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
    CSymbol* addParameter (const std::string &name, const int &type, const int &address);
    CSymbol* addConstant (const std::string &name, const int &type, const int &address);
+   CSymbol* addVariable (const std::string &name, const int &type, const int &address);
    CSymbol* add(CSymbol *symbol);
    bool readFromBinary(CBinString &bin);
 };

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -109,7 +109,7 @@
    OP_MCOPY = 104,
    OP_MGETSIZE1 = 105,
    OP_MGETSIZE2 = 106,
-   OPCODE_NUMBER  = 107 // TODO: Isso nao eh seguro...
+   OPCODE_NUMBER  = 107
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -8,6 +8,7 @@
 
 
 CGenBytecode::CGenBytecode()
+   : _currentSP(0)
 {
    _opcodes[ "isum"        ] = OP_ISUM;
    _opcodes[ "ssum"        ] = OP_SSUM;
@@ -138,11 +139,15 @@
 // Talvez temos q fazer como em C e gerar procedure_name + retorno + parametros (int_procedure_int_real)
    _symbolTable.addProcedure (procedureName, CSymbol::NO_TYPE, _code.size(), hasVarArguments, staticParameters, parameters);
    _currentProcedure = procedureName;
+   _currentSP = 0;
+   _unsolvedLabels.clear();
+   _solvedLabels.clear();
 }
 
 
 void CGenBytecode::finishProcedure()
 {
+   translateLabelsToAddress();
    _currentProcedure.clear();
    // TODO: delete na procedure ???
 }
@@ -150,48 +155,39 @@
 
 void CGenBytecode::makeVarDefinition(const std::string &lexeme, const int &type)
 {
-//   if (_currentProcedure.empty()) { // assumindo que sao dados globais...
-//      _symbolTable.add(new CVariableDefinition(lexeme, type, _data.getDataSize()));
-//   }
+   if (_currentProcedure.empty()) { // assumindo que sao dados globais...
+      _symbolTable.addVariable (lexeme, type, _data.getDataSize());
+   }
    _data.addVariable (lexeme, type, _data.getDataSize());
 }
 
 
 void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
 {
-   _symbolTable.addParameter(lexeme, type, 0); // TODO: colocar endereco relativo a SP
+   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
+   _currentSP += symbol->getTypeSize();
 }
 
 
 void CGenBytecode::registryLabel(const std::string &labelName)
 {
+   // TODO
+   if (_solvedLabels.find(labelName) != _solvedLabels.end()) {
+      std::cout << "Label ja definido: " << labelName << std::endl;
+      abort();
+   }
+   _solvedLabels[labelName] = _code.size();
+//   std::cout << "Registry label: " << labelName << " address: " << _code.size() << std::endl;
 }
 
 
 void CGenBytecode::addOpcode(const std::string &mn)
 {
 //   std::cout << "Mn=" << mn << " opcode: " << (int)_opcodes[mn] << std::endl;
-   _code.addByte(_opcodes[mn]);
+   _code.writeByte(_opcodes[mn]);
 }
 
 
-//void CGenBytecode::addIdReference(const std::string &id)
-//{
-//   int ref = _symbolTable.getReference(id);
-//   _code.add(ref);
-//}
-
-
-//void CGenBytecode::addReference(const std::string &id, const int &category, const int &type)
-//{
-//   int ref = _data.getReference(id);
-//   if (ref == -1) {
-//      ref = _data.add(new CConstantData( id, type, _data.size()))->getAddress();
-//   }
-//   _code.addInt(ref);
-//}
-
-
 void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type)
 {
    int ref = _data.getAddress(id);
@@ -199,30 +195,52 @@
       //ref = _data.add((new CSymbol())->setAsConstantData( id, type, _data.getDataSize()))->getAddress();
       ref = _data.addConstant (id, type, _data.getDataSize())->getAddress();
    }
-   _code.addInt(ref);
+   _code.writeInt(ref);
 }
 
 
 CBinString CGenBytecode::getBinary()
 {
-//   _header.setSizes(_symbolTable.size(), _data.size(), _code.size());
-
    CBinString ret;
 
    ret += _header.getBinary();
 
 //   std::cout << "symbolTable.getSymbolsCount()=" << _symbolTable.getSymbolsCount() << std::endl;
    ret.writeInt(_symbolTable.getSymbolsCount());
-   ret += _symbolTable.getBinary();
+   ret += _symbolTable;
 
 //   std::cout << "data.size()=" << _data.getDataSize() << std::endl;
    ret.writeInt(_data.getDataSize());
-   ret += _data.getBinary();
+   ret += _data;
 
 //   std::cout << "code.size()=" << _code.size() << std::endl;
    ret.writeInt(_code.size());
-   ret += _code.getBinary();
+   ret += _code;
 
    return ret;
 }
 
+void CGenBytecode::unsolvedLabel(const std::string &label)
+{
+   _unsolvedLabels.push_back(std::pair<std::string, int>(label, _code.size()));
+//   std::cout << "Unsolved label: " << label << " address: " << _code.size() << std::endl;
+   _code.writeInt(0);
+}
+
+
+void CGenBytecode::translateLabelsToAddress()
+{
+   // Varre os labels referenciados
+   for (std::list<std::pair<std::string,int> >::const_iterator unsolvedLabel = _unsolvedLabels.begin();
+         unsolvedLabel != _unsolvedLabels.end(); unsolvedLabel++) {
+      std::map<std::string,int>::const_iterator solvedLabel;
+      solvedLabel = _solvedLabels.find(unsolvedLabel->first);
+      if (solvedLabel == _solvedLabels.end()) {
+         std::cout << "Label nao encontrado: " << unsolvedLabel->second << std::endl;
+         abort();
+      }
+      _code.setInt(unsolvedLabel->second, solvedLabel->second);
+//      std::cout << "code[" << unsolvedLabel->second << "]=" << solvedLabel->second << std::endl;
+   }
+}
+

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -3,8 +3,7 @@
 
 #include <map>
 #include <string>
-#include <vector>
-#include <fstream>
+#include <list>
 
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
@@ -25,13 +24,19 @@
    void addOpcode(const std::string &mn);
    void addAddress(const std::string &id, const int &category, const int &type);
    CBinString getBinary();
+   void unsolvedLabel(const std::string &label);
 private:
+   void translateLabelsToAddress();
+
    CHeader                    _header;
    CSymbolTable               _symbolTable;
    CData                      _data;
    CCode                      _code;
    std::map<std::string,char> _opcodes;
    std::string                _currentProcedure;
+   int                        _currentSP;
+   std::list<std::pair<std::string, int> > _unsolvedLabels;
+   std::map<std::string, int> _solvedLabels;
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-22 15:45:54 UTC (rev 381)
@@ -91,13 +91,13 @@
 //--------------------------------
   primitive_type returns [char ret]
 //--------------------------------
-  : "int"     {ret=CSymbol::INT;}
-  | "real"    {ret=CSymbol::REAL;}
-  | "char"    {ret=CSymbol::CHAR;}
-  | "string"  {ret=CSymbol::STRING;}
-  | "bool"    {ret=CSymbol::BOOL;}
-//  | "pointer" {ret=CSymbol::POINTER;}
-  | "matrix"  {ret=CSymbol::MATRIX;}
+  : "int"     {ret=CSymbol::INT;    }
+  | "real"    {ret=CSymbol::REAL;   }
+  | "char"    {ret=CSymbol::CHAR;   }
+  | "string"  {ret=CSymbol::STRING; }
+  | "bool"    {ret=CSymbol::BOOL;   }
+  | "pointer" {ret=CSymbol::POINTER;}
+  | "matrix"  {ret=CSymbol::MATRIX; }
   ;
 
 //#################################
@@ -107,10 +107,13 @@
 //---------------------
   procedure_declaration
 //---------------------
+{
+   std::vector<CSymbol> parameters;
+}
   : "proc" 
    tk_id:T_ID
     { bytecode.initProcedure(tk_id->getText(), false, 0, std::vector<CSymbol>()); }
-    (parameter_declaration)*
+    (parameter_declaration[parameters])*
     (var_declaration)*
     code_block
     { bytecode.finishProcedure(); }
@@ -118,12 +121,14 @@
   ;
 
 //---------------------
-  parameter_declaration
+  parameter_declaration [std::vector<CSymbol> &parameters]
 //---------------------
 {
   int tk_type;
 }
-  : "param" ("ref")? tk_id:T_ID tk_type=primitive_type { declareParameter( tk_id->getText(), tk_type ); }
+  : "param" ("ref")? tk_id:T_ID tk_type=primitive_type
+    { declareParameter( tk_id->getText(), tk_type ); }
+    { parameters.push_back(CSymbol(tk_id->getText(), tk_type, CSymbol::PARAM, 0)); } // TODO: nao eh zero...
   ;
 
 //#####################
@@ -163,7 +168,7 @@
 //-----
   label
 //-----
-   : T_ID
+   : T_ID { bytecode.unsolvedLabel(getLastTokenText()); }
    ;
 
 //---------------------
@@ -189,7 +194,7 @@
 //--------------------
    :  ("ineg"|"rneg"|"not"|"iinc"|"idec") 
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element
+      identifier T_COMMA element
    ;
 
 //------------------
@@ -202,7 +207,7 @@
       | "c2i"|"r2i"|"s2i"|"b2i"
       )
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element
+      identifier T_COMMA element
    ;
 
 //----------------
@@ -220,23 +225,24 @@
 //----------------------
    :  "geta"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID
+      identifier T_COMMA identifier
    |  ("igetv"|"sgetv"|"rgetv")
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element T_COLON element
+      identifier T_COMMA element T_COLON element
    |  ("isetv"|"ssetv"|"rsetv")
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COLON element T_COMMA element
+      identifier T_COLON element T_COMMA element
    ;
 
 //--------
   mn_salto
 //--------
-   :  "jmp" label
+   :  "jmp"
       {bytecode.addOpcode(getLastTokenText());}
+      label
    |  ("if"|"ifnot")
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA label
+      identifier T_COMMA label
    ;
 
 //--------------------
@@ -247,7 +253,7 @@
       element
    |  "pop"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID
+      identifier
    |  ("incsp"|"decsp")
       {bytecode.addOpcode(getLastTokenText());}
       T_INT_VALUE
@@ -273,13 +279,13 @@
 //----------------------
    :  ( "salloc"|"sfree" )
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID
+      identifier
    |  "ssetc"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element T_COMMA element
+      identifier T_COMMA element T_COMMA element
    |  "sgetc"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID T_COMMA element
+      identifier T_COMMA identifier T_COMMA element
    ;
 
 //-----------------------
@@ -287,38 +293,44 @@
 //-----------------------
    :  "m1alloc"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID
-      T_COMMA 
+      identifier
+      T_COMMA
       T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
       T_COMMA 
       T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
    |  "m2alloc"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_INT_VALUE T_COMMA T_INT_VALUE T_COMMA T_INT_VALUE
+      identifier
+      T_COMMA
+      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      T_COMMA
+      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
+      T_COMMA
+      T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
    |  "mfree"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID
+      identifier
    |  "m1set"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element T_COMMA element
+      identifier T_COMMA element T_COMMA element
    |  "m1get"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID T_COMMA element
+      identifier T_COMMA identifier T_COMMA element
    |  "m2set"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA element T_COMMA element T_COMMA element
+      identifier T_COMMA element T_COMMA element T_COMMA element
    |  "m2get"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID T_COMMA element T_COMMA element
+      identifier T_COMMA identifier T_COMMA element T_COMMA element
    |  "mcopy"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID
+      identifier T_COMMA identifier
    |  "mgetsize1"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID
+      identifier T_COMMA identifier
    |  "mgetsize2"
       {bytecode.addOpcode(getLastTokenText());}
-      T_ID T_COMMA T_ID
+      identifier T_COMMA identifier
    ;
 
 //-----------
@@ -329,11 +341,11 @@
       {bytecode.addOpcode(getLastTokenText());}
    |   "exit"
       {bytecode.addOpcode(getLastTokenText());}
-       T_INT_VALUE
+       T_INT_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
   ;
 
 identifier
-  : id:T_ID { bytecode.addAddress(id->getText(),CSymbol::VAR, CSymbol::STRING); }
+  : id:T_ID { bytecode.addAddress(id->getText(), CSymbol::VAR, CSymbol::STRING); }
   ;
 
 
@@ -346,11 +358,11 @@
 //---------------------------------
   : ( 
         T_STRING_VALUE { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::STRING); }
-      | T_INT_VALUE    { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
-      | T_REAL_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::REAL); }
-      | T_CHAR_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::CHAR); }
-      | "true"         { bytecode.addAddress("1",                CSymbol::CONST, CSymbol::INT); }
-      | "false"        { bytecode.addAddress("0",                CSymbol::CONST, CSymbol::INT); }
+      | T_INT_VALUE    { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT);    }
+      | T_REAL_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::REAL);   }
+      | T_CHAR_VALUE   { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::CHAR);   }
+      | "true"         { bytecode.addAddress("1",                CSymbol::CONST, CSymbol::INT);    }
+      | "false"        { bytecode.addAddress("0",                CSymbol::CONST, CSymbol::INT);    }
     ) 
   ;
 

Modified: trunk/gpt2/gptasm/test/asm.sh
===================================================================
--- trunk/gpt2/gptasm/test/asm.sh	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/test/asm.sh	2007-11-22 15:45:54 UTC (rev 381)
@@ -1,7 +1,7 @@
 rm $1.gvm 1>/dev/null 2>&1
 #rm $1.stdout 1>/dev/null 2>&1
 
-../../gptasm $1
+../../src/gptasm $1
 if [ $? -ne 0 ]
 then
 	echo "Erro: nao foi possivel assemblar $1.gasm"

Modified: trunk/gpt2/gptasm/test/asm_all.sh
===================================================================
--- trunk/gpt2/gptasm/test/asm_all.sh	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/test/asm_all.sh	2007-11-22 15:45:54 UTC (rev 381)
@@ -1,6 +1,6 @@
 echo "Assemblando todos os arquivos .gasm do diretorio"
 
-rm *.gvm
+rm *.gvm > /dev/null 2>&1
 #rm *.stdout
 
 for i in `ls *.gasm -1 | sed s/"\.gasm"//g`

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-22 15:45:54 UTC (rev 381)
@@ -1,9 +1,10 @@
 program exemplo
 
 var x int
+var t1 int
 
 proc main
-    var t1 int
+//    var t1 int
 
     // para x de 1 at? 10 fa?a
     iset x, 1
@@ -15,7 +16,7 @@
     push_sp
     push x
     push_int
-    push_1
+    push 1
     pcall imprima
     pop_sp
 
@@ -25,7 +26,7 @@
 
     proximo:
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-22 15:45:54 UTC (rev 381)
@@ -4,11 +4,11 @@
     push_sp
     push "Ol? mundo !!!"
     push_string
-    push_1
+    push 1
     pcall imprima
     pop_sp
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-22 15:45:54 UTC (rev 381)
@@ -19,13 +19,13 @@
     isum t2, t1, 4
     push t2
     push_int
-    push "x*y+4"
+    push "x*y+4="
     push_string
-    push_2
+    push 2
     pcall imprima
     pop_sp
 	
-    exit_0
+    exit 0
 endproc
 
 endprogram

Added: trunk/gpt2/gptvm/src/CBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -0,0 +1,34 @@
+#include "CBytecode.hpp"
+
+CBytecode::CBytecode()
+   : _IP(0)
+{
+}
+
+
+CBytecode::~CBytecode()
+{
+}
+
+
+char CBytecode::fetchByte()
+{
+   char result = getByte(_IP);
+   _IP += sizeof(char);
+   return result;
+}
+
+
+int  CBytecode::fetchInt()
+{
+   int result = getInt(_IP);
+   _IP += sizeof(int);
+   return result;
+}
+
+
+void CBytecode::setIP(const int &IP)
+{
+   _IP = IP;
+}
+

Added: trunk/gpt2/gptvm/src/CBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -0,0 +1,22 @@
+#ifndef GPT_BYTECODE_H
+#define GPT_BYTECODE_H
+
+
+#include "CBinString.hpp"
+
+
+class CBytecode : public CBinString
+{
+public:
+   CBytecode();
+  ~CBytecode();
+   char fetchByte();
+   int  fetchInt();
+   void setIP(const int &IP);
+   CBinString::readString;
+private:
+   int _IP;
+};
+
+#endif
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -21,141 +21,143 @@
    CBinString bin;
    bin.assign(buf.str());
 
-   return _header.readFromBinary(bin) &&
-          _symbolTable.readFromBinary(bin) &&
-          _data.readFromBinary(bin) &&
-          _code.readFromBinary(bin);
+   _header.readFromBinary(bin) &&
+         _symbolTable.readFromBinary(bin);
+
+   bin.readString(_data);
+
+   _code.assign(bin.readString());
+
+   return true;
 }
 
 void CRunBytecode::initOpcodePointer()
 {
    for (int i = 0; i < OPCODE_NUMBER; i++) {
-      _opcodePointer[i] = &CRunBytecode::invalidOpcode;
+      _opcodePointer[i] = NULL; //&CRunBytecode::invalidOpcode;
    }
 
-   _opcodePointer[OP_NOP         ] = &CRunBytecode::nopOpcode;
-   _opcodePointer[OP_PUSH_SP     ] = &CRunBytecode::pushSpOpcode;
-   _opcodePointer[OP_POP_SP      ] = &CRunBytecode::popSpOpcode;
-   _opcodePointer[OP_PUSH        ] = &CRunBytecode::pushOpcode;
-   _opcodePointer[OP_PUSH_STRING ] = &CRunBytecode::pushStringOpcode;
-//   _opcodePointer[OP_PUSH_1      ] = &CRunBytecode::push1Opcode;
-   _opcodePointer[OP_PCALL       ] = &CRunBytecode::pcallOpcode;
-//   _opcodePointer[OP_EXIT_0      ] = &CRunBytecode::exit0Opcode;
-   _opcodePointer[OP_EXIT        ] = &CRunBytecode::exitOpcode;
+   _opcodePointer[OP_NOP        ] = &CRunBytecode::nopOpcode;
+   _opcodePointer[OP_PUSH_SP    ] = &CRunBytecode::pushSpOpcode;
+   _opcodePointer[OP_POP_SP     ] = &CRunBytecode::popSpOpcode;
+   _opcodePointer[OP_PUSH       ] = &CRunBytecode::pushOpcode;
+   _opcodePointer[OP_PUSH_STRING] = &CRunBytecode::pushStringOpcode;
+//   _opcodePointer[OP_PUSH_1     ] = &CRunBytecode::push1Opcode;
+   _opcodePointer[OP_PCALL      ] = &CRunBytecode::pcallOpcode;
+//   _opcodePointer[OP_EXIT_0     ] = &CRunBytecode::exit0Opcode;
+   _opcodePointer[OP_EXIT       ] = &CRunBytecode::exitOpcode;
 
 //   OP_EXIT_1,
-// _opcodePointer[OP_HLT         ] = &CRunBytecode::hltOpcode;
+   _opcodePointer[OP_HLT        ] = &CRunBytecode::hltOpcode;
 
-   _opcodePointer[OP_ISUM        ] = &CRunBytecode::isumOpcode;
-//   _opcodePointer[OP_SSUM        ] = &CRunBytecode::ssumOpcode;
-//   _opcodePointer[OP_RSUM        ] = &CRunBytecode::rsumOpcode;
-//   _opcodePointer[OP_ISUB        ] = &CRunBytecode::isubOpcode;
-//   _opcodePointer[OP_SSUB        ] = &CRunBytecode::ssubOpcode;
-//   _opcodePointer[OP_RSUB        ] = &CRunBytecode::rsubOpcode;
-   _opcodePointer[OP_IMUL        ] = &CRunBytecode::imulOpcode;
-//   _opcodePointer[OP_RMUL        ] = &CRunBytecode::rmulOpcode;
-/*
-   OP_IDIV,
-   OP_RDIV,
-   OP_IMOD,
-   OP_RMOD,
-   OP_IGE,
-   OP_SGE,
-   OP_RGE,
-   OP_ILE,
-   OP_SLE,
-   OP_RLE,
-   OP_INE,
-   OP_SNE,
-   OP_RNE,
-   OP_IGT,
-   OP_SGT,
-   OP_RGT,
-   OP_ILT,
-   OP_SLT,
-   OP_RLT,
-   OP_IEQ,
-   OP_SEQ,
-   OP_REQ,
-   OP_OR,
-   OP_AND,
-   OP_XOR,
-   OP_INEG,
-   OP_RNEG,
-   OP_NOT,
-   OP_IINC,
-   OP_IDEC,
-   OP_I2C,
-   OP_R2C,
-   OP_S2C,
-   OP_B2C,
-   OP_I2R,
-   OP_C2R,
-   OP_S2R,
-   OP_B2R,
-   OP_I2B,
-   OP_C2B,
-   OP_R2B,
-   OP_S2B,
-   OP_I2S,
-   OP_C2S,
-   OP_R2S,
-   OP_B2S,
-   OP_P2S,
-   OP_C2I,
-   OP_R2I,
-   OP_S2I,
-   OP_B2I,
-*/
-   _opcodePointer[OP_ISET        ] = &CRunBytecode::isetOpcode;
-/*
-   OP_SSET,
-   OP_RSET,
-   OP_GETA,
-   OP_IGETV,
-   OP_SGETV,
-   OP_RGETV,
-   OP_ISETV,
-   OP_SSETV,
-   OP_RSETV,
-   OP_JMP,
-   OP_IF,
-   OP_IFNOT,
-   OP_POP,
-   OP_INCSP,
-   OP_DECSP,
-   OP_PUSH_0,
-   OP_PUSH_2,
-   OP_PUSH_3,
-   OP_PUSH_4,
-   OP_PUSH_5,
-*/
-   _opcodePointer[OP_PUSH_INT      ] = &CRunBytecode::pushIntOpcode;
-   _opcodePointer[OP_PUSH_REAL     ] = &CRunBytecode::pushRealOpcode;
-   _opcodePointer[OP_PUSH_CHAR     ] = &CRunBytecode::pushCharOpcode;
-   _opcodePointer[OP_PUSH_BOOL     ] = &CRunBytecode::pushBoolOpcode;
-/*
-   OP_PUSH_MATRIX,
-   OP_INCSP_4,
-   OP_INCSP_8,
-   OP_DECSP_4,
-   OP_DECSP_8,
-   OP_RET,
-   OP_SALLOC,
-   OP_SFREE,
-   OP_SSETC,
-   OP_SGETC,
-   OP_M1ALLOC,
-   OP_M2ALLOC,
-   OP_MFREE,
-   OP_M1SET,
-   OP_M1GET,
-   OP_M2SET,
-   OP_M2GET,
-   OP_MCOPY,
-   OP_MGETSIZE1,
-   OP_MGETSIZE2,
-*/
+   _opcodePointer[OP_ISUM       ] = &CRunBytecode::isumOpcode;
+   _opcodePointer[OP_SSUM       ] = &CRunBytecode::ssumOpcode;
+   _opcodePointer[OP_RSUM       ] = &CRunBytecode::rsumOpcode;
+   _opcodePointer[OP_ISUB       ] = &CRunBytecode::isubOpcode;
+   _opcodePointer[OP_SSUB       ] = &CRunBytecode::ssubOpcode;
+   _opcodePointer[OP_RSUB       ] = &CRunBytecode::rsubOpcode;
+   _opcodePointer[OP_IMUL       ] = &CRunBytecode::imulOpcode;
+   _opcodePointer[OP_RMUL       ] = &CRunBytecode::rmulOpcode;
+   _opcodePointer[OP_IDIV       ] = &CRunBytecode::idivOpcode;
+   _opcodePointer[OP_RDIV       ] = &CRunBytecode::rdivOpcode;
+   _opcodePointer[OP_IMOD       ] = &CRunBytecode::imodOpcode;
+   _opcodePointer[OP_RMOD       ] = &CRunBytecode::rmodOpcode;
+   _opcodePointer[OP_IGE        ] = &CRunBytecode::igeOpcode;
+   _opcodePointer[OP_SGE        ] = &CRunBytecode::sgeOpcode;
+   _opcodePointer[OP_RGE        ] = &CRunBytecode::rgeOpcode;
+   _opcodePointer[OP_ILE        ] = &CRunBytecode::ileOpcode;
+   _opcodePointer[OP_SLE        ] = &CRunBytecode::sleOpcode;
+   _opcodePointer[OP_RLE        ] = &CRunBytecode::rleOpcode;
+   _opcodePointer[OP_INE        ] = &CRunBytecode::ineOpcode;
+   _opcodePointer[OP_SNE        ] = &CRunBytecode::sneOpcode;
+   _opcodePointer[OP_RNE        ] = &CRunBytecode::rneOpcode;
+   _opcodePointer[OP_IGT        ] = &CRunBytecode::igtOpcode;
+   _opcodePointer[OP_SGT        ] = &CRunBytecode::sgtOpcode;
+   _opcodePointer[OP_RGT        ] = &CRunBytecode::rgtOpcode;
+   _opcodePointer[OP_ILT        ] = &CRunBytecode::iltOpcode;
+   _opcodePointer[OP_SLT        ] = &CRunBytecode::sltOpcode;
+   _opcodePointer[OP_RLT        ] = &CRunBytecode::rltOpcode;
+   _opcodePointer[OP_IEQ        ] = &CRunBytecode::ieqOpcode;
+   _opcodePointer[OP_SEQ        ] = &CRunBytecode::seqOpcode;
+   _opcodePointer[OP_REQ        ] = &CRunBytecode::reqOpcode;
+   _opcodePointer[OP_OR         ] = &CRunBytecode::orOpcode;
+   _opcodePointer[OP_AND        ] = &CRunBytecode::andOpcode;
+   _opcodePointer[OP_XOR        ] = &CRunBytecode::xorOpcode;
+   _opcodePointer[OP_INEG       ] = &CRunBytecode::inegOpcode;
+   _opcodePointer[OP_RNEG       ] = &CRunBytecode::rnegOpcode;
+   _opcodePointer[OP_NOT        ] = &CRunBytecode::notOpcode;
+   _opcodePointer[OP_IINC       ] = &CRunBytecode::iincOpcode;
+   _opcodePointer[OP_IDEC       ] = &CRunBytecode::idecOpcode;
+   _opcodePointer[OP_I2C        ] = &CRunBytecode::i2cOpcode;
+   _opcodePointer[OP_R2C        ] = &CRunBytecode::r2cOpcode;
+   _opcodePointer[OP_S2C        ] = &CRunBytecode::s2cOpcode;
+   _opcodePointer[OP_B2C        ] = &CRunBytecode::b2cOpcode;
+   _opcodePointer[OP_I2R        ] = &CRunBytecode::i2rOpcode;
+   _opcodePointer[OP_C2R        ] = &CRunBytecode::c2rOpcode;
+   _opcodePointer[OP_S2R        ] = &CRunBytecode::s2rOpcode;
+   _opcodePointer[OP_B2R        ] = &CRunBytecode::b2rOpcode;
+   _opcodePointer[OP_I2B        ] = &CRunBytecode::i2bOpcode;
+   _opcodePointer[OP_C2B        ] = &CRunBytecode::c2bOpcode;
+   _opcodePointer[OP_R2B        ] = &CRunBytecode::r2bOpcode;
+   _opcodePointer[OP_S2B        ] = &CRunBytecode::s2bOpcode;
+   _opcodePointer[OP_I2S        ] = &CRunBytecode::i2sOpcode;
+   _opcodePointer[OP_C2S        ] = &CRunBytecode::c2sOpcode;
+   _opcodePointer[OP_R2S        ] = &CRunBytecode::r2sOpcode;
+   _opcodePointer[OP_B2S        ] = &CRunBytecode::b2sOpcode;
+   _opcodePointer[OP_P2S        ] = &CRunBytecode::p2sOpcode;
+   _opcodePointer[OP_C2I        ] = &CRunBytecode::c2iOpcode;
+   _opcodePointer[OP_R2I        ] = &CRunBytecode::r2iOpcode;
+   _opcodePointer[OP_S2I        ] = &CRunBytecode::s2iOpcode;
+   _opcodePointer[OP_B2I        ] = &CRunBytecode::b2iOpcode;
+   _opcodePointer[OP_ISET       ] = &CRunBytecode::isetOpcode;
+   _opcodePointer[OP_SSET       ] = &CRunBytecode::ssetOpcode;
+   _opcodePointer[OP_RSET       ] = &CRunBytecode::rsetOpcode;
+   _opcodePointer[OP_GETA       ] = &CRunBytecode::getaOpcode;
+   _opcodePointer[OP_IGETV      ] = &CRunBytecode::igetvOpcode;
+   _opcodePointer[OP_SGETV      ] = &CRunBytecode::sgetvOpcode;
+   _opcodePointer[OP_RGETV      ] = &CRunBytecode::rgetvOpcode;
+   _opcodePointer[OP_ISETV      ] = &CRunBytecode::isetvOpcode;
+   _opcodePointer[OP_SSETV      ] = &CRunBytecode::ssetvOpcode;
+   _opcodePointer[OP_RSETV      ] = &CRunBytecode::rsetvOpcode;
+   _opcodePointer[OP_JMP        ] = &CRunBytecode::jmpOpcode;
+   _opcodePointer[OP_IF         ] = &CRunBytecode::ifOpcode;
+   _opcodePointer[OP_IFNOT      ] = &CRunBytecode::ifnotOpcode;
+   _opcodePointer[OP_POP        ] = &CRunBytecode::popOpcode;
+   _opcodePointer[OP_INCSP      ] = &CRunBytecode::incspOpcode;
+   _opcodePointer[OP_DECSP      ] = &CRunBytecode::decspOpcode;
+
+//   OP_PUSH_0,
+//   OP_PUSH_2,
+//   OP_PUSH_3,
+//   OP_PUSH_4,
+//   OP_PUSH_5,
+
+   _opcodePointer[OP_PUSH_INT   ] = &CRunBytecode::pushIntOpcode;
+   _opcodePointer[OP_PUSH_REAL  ] = &CRunBytecode::pushRealOpcode;
+   _opcodePointer[OP_PUSH_CHAR  ] = &CRunBytecode::pushCharOpcode;
+   _opcodePointer[OP_PUSH_BOOL  ] = &CRunBytecode::pushBoolOpcode;
+   _opcodePointer[OP_PUSH_MATRIX] = &CRunBytecode::pushMatrixOpcode;
+
+//   OP_INCSP_4,
+//   OP_INCSP_8,
+//   OP_DECSP_4,
+//   OP_DECSP_8,
+
+   _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
+   _opcodePointer[OP_SALLOC     ] = &CRunBytecode::sallocOpcode;
+   _opcodePointer[OP_SFREE      ] = &CRunBytecode::sfreeOpcode;
+   _opcodePointer[OP_SSETC      ] = &CRunBytecode::ssetcOpcode;
+   _opcodePointer[OP_SGETC      ] = &CRunBytecode::sgetcOpcode;
+   _opcodePointer[OP_M1ALLOC    ] = &CRunBytecode::m1allocOpcode;
+   _opcodePointer[OP_M2ALLOC    ] = &CRunBytecode::m2allocOpcode;
+   _opcodePointer[OP_MFREE      ] = &CRunBytecode::mfreeOpcode;
+   _opcodePointer[OP_M1SET      ] = &CRunBytecode::m1setOpcode;
+   _opcodePointer[OP_M1GET      ] = &CRunBytecode::m1getOpcode;
+   _opcodePointer[OP_M2SET      ] = &CRunBytecode::m2setOpcode;
+   _opcodePointer[OP_M2GET      ] = &CRunBytecode::m2getOpcode;
+   _opcodePointer[OP_MCOPY      ] = &CRunBytecode::mcopyOpcode;
+   _opcodePointer[OP_MGETSIZE1  ] = &CRunBytecode::mgetSize1Opcode;
+   _opcodePointer[OP_MGETSIZE2  ] = &CRunBytecode::mgetSize2Opcode;
 }
 
 
@@ -164,7 +166,7 @@
 //   std::cout << "Code lido: [" << _code.getBinary() << "]" << " size=" << _code.getBinary().size() << std::endl;
 
    initOpcodePointer();
-   _IP = 0;
+   _code.setIP(0); // TODO: pegar o endereco de main
    _stop = false;
 
    while (!_stop) {
@@ -174,11 +176,11 @@
    return true;
 }
 
+
 void CRunBytecode::step()
 {
     char opcode;
-    opcode = _code.getByte(_IP);
-    _IP++;
+    opcode = _code.fetchByte();
 
    if (opcode >= OPCODE_NUMBER) {
       error( "Invalid opcode !!!" );
@@ -239,15 +241,15 @@
 
 // opcodes
 
-void CRunBytecode::invalidOpcode()
+void CRunBytecode::invalidOpcode(const std::string &opcode)
 {
-   error ("Invalid opcode !!!");
+   error ("Invalid opcode: [" + opcode + "] !!!");
 }
 
 void CRunBytecode::nopOpcode()
 {
 //   trace ("nop opcode");
-   invalidOpcode();
+   invalidOpcode(__FUNCTION__);
 
     //nothing to do
 }
@@ -268,8 +270,7 @@
 {
    trace ("push opcode");
 
-   int address = _code.getInt(_IP);
-   _IP += sizeof(int);
+   int address = _code.fetchInt();
    _dataStack.push((void*)address);
 }
 
@@ -280,111 +281,569 @@
    _dataStack.push((void*)CSymbol::STRING);
 }
 
-void CRunBytecode::pushIntOpcode()
+
+void CRunBytecode::pcallOpcode()
 {
-   trace ("push_int opcode");
+   trace ("pcall opcode");
 
-   _dataStack.push((void*)CSymbol::INT);
+   int address = _code.fetchInt();
+
+   std::string temp = _data.getString(address);
+
+   if (_data.getString(address) == "imprima") {
+      procImprima();
+   }
 }
 
-void CRunBytecode::pushBoolOpcode()
+
+void CRunBytecode::exitOpcode()
 {
-   trace ("push_bool opcode");
+   trace ("exit opcode");
 
-   _dataStack.push((void*)CSymbol::BOOL);
+   int returnCode = _code.fetchInt();
+
+   _stop = true;
 }
 
-void CRunBytecode::pushRealOpcode()
+
+void CRunBytecode::hltOpcode()
 {
-   trace ("push_real opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   _dataStack.push((void*)CSymbol::REAL);
+void CRunBytecode::isumOpcode()
+{
+   trace ("isum opcode");
+
+   int varAddress = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) + _data.getInt(val2Address));
 }
 
-void CRunBytecode::pushCharOpcode()
+void CRunBytecode::ssumOpcode()
 {
-   trace ("push_char opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   _dataStack.push((void*)CSymbol::CHAR);
+void CRunBytecode::rsumOpcode()
+{
+   invalidOpcode(__FUNCTION__);
 }
 
-void CRunBytecode::push1Opcode()
+void CRunBytecode::isubOpcode()
 {
-   trace ("push_1 opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   _dataStack.push((void*)1);
+void CRunBytecode::ssubOpcode()
+{
+   invalidOpcode(__FUNCTION__);
 }
 
-void CRunBytecode::pcallOpcode()
+void CRunBytecode::rsubOpcode()
 {
-   trace ("pcall opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   int address = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::imulOpcode()
+{
+   trace ("imul opcode");
 
-   std::string temp = _data.getString(address);
+   int varAddress = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
 
-   if (_data.getString(address) == "imprima") {
-      procImprima();
-   }
+   _data.setInt(varAddress, _data.getInt(val1Address) * _data.getInt(val2Address));
 }
 
+void CRunBytecode::rmulOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-void CRunBytecode::exitOpcode()
+void CRunBytecode::idivOpcode()
 {
-   trace ("exit opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   int returnCode = _code.getInt(_IP); // TODO
-   _IP += sizeof(int);
+void CRunBytecode::rdivOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-   _stop = true;
+void CRunBytecode::imodOpcode()
+{
+   invalidOpcode(__FUNCTION__);
 }
 
+void CRunBytecode::rmodOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
+void CRunBytecode::igeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sgeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rgeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::ileOpcode()
+{
+   trace ("ile opcode");
+
+   int varAddress = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) <= _data.getInt(val2Address));
+}
+
+void CRunBytecode::sleOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rleOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::ineOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sneOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rneOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::igtOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sgtOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rgtOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::iltOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sltOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rltOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::ieqOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::seqOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::reqOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::orOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::andOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::xorOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::inegOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::rnegOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::notOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::iincOpcode()
+{
+   trace ("iinc opcode");
+
+   int varAddress = _code.fetchInt();
+   int valAddress = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(varAddress)+_data.getInt(valAddress));
+}
+
+void CRunBytecode::idecOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::i2cOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::r2cOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::s2cOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::b2cOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::i2rOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::c2rOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::s2rOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::b2rOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::i2bOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::c2bOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::r2bOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::s2bOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::i2sOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::c2sOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::r2sOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::b2sOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::p2sOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::c2iOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::r2iOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::s2iOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::b2iOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
 void CRunBytecode::isetOpcode()
 {
    trace ("iset opcode");
 
-   int varAddress = _code.getInt(_IP);
-   _IP += sizeof(int);
+   int varAddress = _code.fetchInt();
+   int valAddress = _code.fetchInt();
 
-   int valAddress = _code.getInt(_IP);
-   _IP += sizeof(int);
-
    _data.setInt(varAddress, _data.getInt(valAddress));
 }
 
+void CRunBytecode::ssetOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-void CRunBytecode::isumOpcode()
+void CRunBytecode::rsetOpcode()
 {
-   trace ("isum opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   int varAddress = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::getaOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-   int val1Address = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::igetvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-   int val2Address = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::sgetvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-   _data.setInt(varAddress, _data.getInt(val1Address) + _data.getInt(val2Address));
+void CRunBytecode::rgetvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
 }
 
+void CRunBytecode::isetvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-void CRunBytecode::imulOpcode()
+void CRunBytecode::ssetvOpcode()
 {
-   trace ("imul opcode");
+   invalidOpcode(__FUNCTION__);
+}
 
-   int varAddress = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::rsetvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
 
-   int val1Address = _code.getInt(_IP);
-   _IP += sizeof(int);
+void CRunBytecode::jmpOpcode()
+{
+   trace ("jmp opcode");
 
-   int val2Address = _code.getInt(_IP);
-   _IP += sizeof(int);
+   int labelAddress = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) * _data.getInt(val2Address));
+   _code.setIP(labelAddress);
 }
 
+void CRunBytecode::ifOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::ifnotOpcode()
+{
+   trace ("ifnot opcode");
+
+   int varAddress = _code.fetchInt();
+   int labelAddress = _code.fetchInt();
+
+   if (!_data.getInt(varAddress)) {
+      _code.setIP(labelAddress);
+   }
+}
+
+void CRunBytecode::popOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::incspOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::decspOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+
+//   OP_PUSH_0,
+//   OP_PUSH_2,
+//   OP_PUSH_3,
+//   OP_PUSH_4,
+//   OP_PUSH_5,
+
+void CRunBytecode::pushIntOpcode()
+{
+   trace ("push_int opcode");
+
+   _dataStack.push((void*)CSymbol::INT);
+}
+
+void CRunBytecode::pushRealOpcode()
+{
+   trace ("push_real opcode");
+
+   _dataStack.push((void*)CSymbol::REAL);
+}
+
+void CRunBytecode::pushCharOpcode()
+{
+   trace ("push_char opcode");
+
+   _dataStack.push((void*)CSymbol::CHAR);
+}
+
+void CRunBytecode::pushBoolOpcode()
+{
+   trace ("push_bool opcode");
+
+   _dataStack.push((void*)CSymbol::BOOL);
+}
+
+void CRunBytecode::pushMatrixOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+
+//   OP_INCSP_4,
+//   OP_INCSP_8,
+//   OP_DECSP_4,
+//   OP_DECSP_8,
+
+void CRunBytecode::retOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sallocOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sfreeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::ssetcOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::sgetcOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m1allocOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m2allocOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::mfreeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m1setOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m1getOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m2setOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::m2getOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::mcopyOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::mgetSize1Opcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::mgetSize2Opcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 15:45:54 UTC (rev 381)
@@ -8,7 +8,7 @@
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
 #include "CData.hpp"
-#include "CCode.hpp"
+#include "CBytecode.hpp"
 #include "Common.hpp"
 #include "CDataStack.hpp"
 
@@ -31,31 +31,135 @@
    void step();
    void procImprima();
    // opcodes
-   void invalidOpcode();
+   void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
    void pushSpOpcode();
    void popSpOpcode();
    void pushOpcode();
    void pushStringOpcode();
-   void pushIntOpcode();
-   void pushRealOpcode();
-   void pushBoolOpcode();
-   void pushCharOpcode();
-   void push1Opcode();
+//   void push1Opcode();
    void pcallOpcode();
 //   void exit0Opcode();
    void exitOpcode();
-   void isetOpcode();
+
+//   OP_EXIT_1,
+   void hltOpcode();
+
    void isumOpcode();
+   void ssumOpcode();
+   void rsumOpcode();
+   void isubOpcode();
+   void ssubOpcode();
+   void rsubOpcode();
    void imulOpcode();
+   void rmulOpcode();
+   void idivOpcode();
+   void rdivOpcode();
+   void imodOpcode();
+   void rmodOpcode();
+   void igeOpcode();
+   void sgeOpcode();
+   void rgeOpcode();
+   void ileOpcode();
+   void sleOpcode();
+   void rleOpcode();
+   void ineOpcode();
+   void sneOpcode();
+   void rneOpcode();
+   void igtOpcode();
+   void sgtOpcode();
+   void rgtOpcode();
+   void iltOpcode();
+   void sltOpcode();
+   void rltOpcode();
+   void ieqOpcode();
+   void seqOpcode();
+   void reqOpcode();
+   void orOpcode();
+   void andOpcode();
+   void xorOpcode();
+   void inegOpcode();
+   void rnegOpcode();
+   void notOpcode();
+   void iincOpcode();
+   void idecOpcode();
+   void i2cOpcode();
+   void r2cOpcode();
+   void s2cOpcode();
+   void b2cOpcode();
+   void i2rOpcode();
+   void c2rOpcode();
+   void s2rOpcode();
+   void b2rOpcode();
+   void i2bOpcode();
+   void c2bOpcode();
+   void r2bOpcode();
+   void s2bOpcode();
+   void i2sOpcode();
+   void c2sOpcode();
+   void r2sOpcode();
+   void b2sOpcode();
+   void p2sOpcode();
+   void c2iOpcode();
+   void r2iOpcode();
+   void s2iOpcode();
+   void b2iOpcode();
+   void isetOpcode();
+   void ssetOpcode();
+   void rsetOpcode();
+   void getaOpcode();
+   void igetvOpcode();
+   void sgetvOpcode();
+   void rgetvOpcode();
+   void isetvOpcode();
+   void ssetvOpcode();
+   void rsetvOpcode();
+   void jmpOpcode();
+   void ifOpcode();
+   void ifnotOpcode();
+   void popOpcode();
+   void incspOpcode();
+   void decspOpcode();
 
+//   OP_PUSH_0,
+//   OP_PUSH_2,
+//   OP_PUSH_3,
+//   OP_PUSH_4,
+//   OP_PUSH_5,
 
+   void pushIntOpcode();
+   void pushRealOpcode();
+   void pushCharOpcode();
+   void pushBoolOpcode();
+   void pushMatrixOpcode();
+
+//   OP_INCSP_4,
+//   OP_INCSP_8,
+//   OP_DECSP_4,
+//   OP_DECSP_8,
+
+   void retOpcode();
+   void sallocOpcode();
+   void sfreeOpcode();
+   void ssetcOpcode();
+   void sgetcOpcode();
+   void m1allocOpcode();
+   void m2allocOpcode();
+   void mfreeOpcode();
+   void m1setOpcode();
+   void m1getOpcode();
+   void m2setOpcode();
+   void m2getOpcode();
+   void mcopyOpcode();
+   void mgetSize1Opcode();
+   void mgetSize2Opcode();
+
+
    CHeader       _header;
    CSymbolTable  _symbolTable;
    CData         _data;
-   CCode         _code;
+   CBytecode     _code;
    OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
-   int           _IP;
    bool          _stop;
    CDataStack    _dataStack;
 };

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-21 17:38:00 UTC (rev 380)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-22 15:45:54 UTC (rev 381)
@@ -6,7 +6,7 @@
 
 GPTASM=../gptasm/
 
-objects = main.o CGptVm.o CRunBytecode.o CDataStack.o \
+objects = main.o CGptVm.o CRunBytecode.o CDataStack.o CBytecode.o \
           $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CCode.o  \
           $(COMMON_DIR)CHeader.o $(COMMON_DIR)CData.o       \
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 



From gpt-commit-noreply at mail.berlios.de  Thu Nov 22 17:01:22 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 22 Nov 2007 17:01:22 +0100
Subject: [gpt-commit] r382 - in trunk/gpt2: common/src gptasm/src gptvm/src
Message-ID: <200711221601.lAMG1MM4020037@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-22 17:01:21 +0100 (Thu, 22 Nov 2007)
New Revision: 382

Added:
   trunk/gpt2/gptasm/src/CCode.cpp
   trunk/gpt2/gptasm/src/CCode.hpp
Removed:
   trunk/gpt2/common/src/CCode.cpp
   trunk/gpt2/common/src/CCode.hpp
Modified:
   trunk/gpt2/gptasm/src/Makefile
   trunk/gpt2/gptvm/src/Makefile
Log:
DEVNULL
* Transferindo a classe CCode para o diretorio do GptASM


Deleted: trunk/gpt2/common/src/CCode.cpp
===================================================================
--- trunk/gpt2/common/src/CCode.cpp	2007-11-22 15:45:54 UTC (rev 381)
+++ trunk/gpt2/common/src/CCode.cpp	2007-11-22 16:01:21 UTC (rev 382)
@@ -1,2 +0,0 @@
-#include "CCode.hpp"
-

Deleted: trunk/gpt2/common/src/CCode.hpp
===================================================================
--- trunk/gpt2/common/src/CCode.hpp	2007-11-22 15:45:54 UTC (rev 381)
+++ trunk/gpt2/common/src/CCode.hpp	2007-11-22 16:01:21 UTC (rev 382)
@@ -1,17 +0,0 @@
-#ifndef GPT_CODE_H
-#define GPT_CODE_H
-
-
-#include <string>
-
-#include "CBinString.hpp"
-
-
-class CCode : public CBinString
-{
-public:
-private:
-};
-
-#endif
-

Copied: trunk/gpt2/gptasm/src/CCode.cpp (from rev 381, trunk/gpt2/common/src/CCode.cpp)

Copied: trunk/gpt2/gptasm/src/CCode.hpp (from rev 381, trunk/gpt2/common/src/CCode.hpp)

Modified: trunk/gpt2/gptasm/src/Makefile
===================================================================
--- trunk/gpt2/gptasm/src/Makefile	2007-11-22 15:45:54 UTC (rev 381)
+++ trunk/gpt2/gptasm/src/Makefile	2007-11-22 16:01:21 UTC (rev 382)
@@ -5,7 +5,7 @@
 CCFLAGS=-g -Wall
 
 objects = GptAssemblyLexer.o GptAssemblyParser.o main.o CGptAsm.o CGenBytecode.o \
-	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CCode.o $(COMMON_DIR)CHeader.o \
+	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o CCode.o $(COMMON_DIR)CHeader.o \
         $(COMMON_DIR)CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o
 
 all: $(objects)

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-22 15:45:54 UTC (rev 381)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-22 16:01:21 UTC (rev 382)
@@ -7,7 +7,7 @@
 GPTASM=../gptasm/
 
 objects = main.o CGptVm.o CRunBytecode.o CDataStack.o CBytecode.o \
-          $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CCode.o  \
+          $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
           $(COMMON_DIR)CHeader.o $(COMMON_DIR)CData.o       \
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
           



From gpt-commit-noreply at mail.berlios.de  Thu Nov 22 18:23:09 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 22 Nov 2007 18:23:09 +0100
Subject: [gpt-commit] r383 - in trunk/gpt2: common/src gptvm/src
Message-ID: <200711221723.lAMHN9Zn025542@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-22 18:23:09 +0100 (Thu, 22 Nov 2007)
New Revision: 383

Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/CData.cpp
   trunk/gpt2/common/src/CData.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
Log:
DEVNULL
* Classe CData eh necessaria no GptASM apenas


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -172,3 +172,17 @@
    return value == data;
 }
 
+
+std::string CBinString::getCString(const int &address)
+{
+   int pos = 0;
+
+   pos = find('\0', address);
+
+   if (pos == -1) {
+      abort();
+   }
+
+   return substr(address, pos - address);
+}
+

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -23,6 +23,7 @@
    bool removeIfEqual(const int &value);
    bool removeIfEqual(const char &value);
    bool removeIfEqual(const std::string &value);
+   std::string getCString(const int &address);
    std::string::find;
 };
 

Modified: trunk/gpt2/common/src/CData.cpp
===================================================================
--- trunk/gpt2/common/src/CData.cpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/common/src/CData.cpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -52,16 +52,4 @@
 }
 
 
-std::string CData::getString(const int &address)
-{
-   int pos = 0;
 
-   pos = find('\0', address);
-
-   if (pos == -1) {
-      abort();
-   }
-
-   return substr(address, pos - address);
-}
-

Modified: trunk/gpt2/common/src/CData.hpp
===================================================================
--- trunk/gpt2/common/src/CData.hpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/common/src/CData.hpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -15,8 +15,6 @@
    CSymbol* add(CSymbol *symbol);
    CSymbol* addVariable (const std::string &name, const int &type, const int &address);
    CSymbol* addConstant (const std::string &name, const int &type, const int &address);
-   bool readFromBinary(CBinString &bin);
-   std::string getString(const int &address);
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -213,7 +213,7 @@
       int value;
       switch (type) {
          case CSymbol::STRING:
-            std::cout << _data.getString(address);
+            std::cout << _data.getCString(address);
             break;
          case CSymbol::INT:
             std::cout << _data.getInt(address);
@@ -288,9 +288,9 @@
 
    int address = _code.fetchInt();
 
-   std::string temp = _data.getString(address);
+//   std::string temp = _data.getCString(address);
 
-   if (_data.getString(address) == "imprima") {
+   if (_data.getCString(address) == "imprima") {
       procImprima();
    }
 }

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 17:23:09 UTC (rev 383)
@@ -7,7 +7,8 @@
 
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
-#include "CData.hpp"
+//#include "CData.hpp"
+#include "CBinString.hpp"
 #include "CBytecode.hpp"
 #include "Common.hpp"
 #include "CDataStack.hpp"
@@ -157,7 +158,8 @@
 
    CHeader       _header;
    CSymbolTable  _symbolTable;
-   CData         _data;
+   CBinString    _data;
+//   CData         _data;
    CBytecode     _code;
    OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
    bool          _stop;

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-22 16:01:21 UTC (rev 382)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-22 17:23:09 UTC (rev 383)
@@ -8,7 +8,7 @@
 
 objects = main.o CGptVm.o CRunBytecode.o CDataStack.o CBytecode.o \
           $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
-          $(COMMON_DIR)CHeader.o $(COMMON_DIR)CData.o       \
+          $(COMMON_DIR)CHeader.o \
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
           
 



From gpt-commit-noreply at mail.berlios.de  Thu Nov 22 18:26:11 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 22 Nov 2007 18:26:11 +0100
Subject: [gpt-commit] r384 - in trunk/gpt2: common/src gptasm/src
Message-ID: <200711221726.lAMHQBUS025719@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-22 18:26:11 +0100 (Thu, 22 Nov 2007)
New Revision: 384

Added:
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/CData.hpp
Removed:
   trunk/gpt2/common/src/CData.cpp
   trunk/gpt2/common/src/CData.hpp
Modified:
   trunk/gpt2/gptasm/src/Makefile
Log:
DEVNULL
* Movendo CData para o diretorio do gptasm


Deleted: trunk/gpt2/common/src/CData.cpp
===================================================================
--- trunk/gpt2/common/src/CData.cpp	2007-11-22 17:23:09 UTC (rev 383)
+++ trunk/gpt2/common/src/CData.cpp	2007-11-22 17:26:11 UTC (rev 384)
@@ -1,55 +0,0 @@
-#include "CData.hpp"
-
-
-CData::CData()
-{
-}
-
-
-CData::~CData()
-{
-}
-
-
-CSymbol* CData::add(CSymbol *symbol)
-{
-//   std::cout << "Adicionando [" << symbol->getName() << "] type [" << symbol->getType() << "] address [" << symbol->getAddress() << "] a Data" << std::endl;
-
-   return CSymbolList::add( symbol );
-}
-
-
-CSymbol* CData::addVariable (const std::string &name, const int &type, const int &address)
-{
-   CSymbol *symbol = new CSymbol (name, type, CSymbol::VAR, address);
-
-   _symbols.push_back(symbol);
-
-   //_data += symbol->getBinary();
-   for (int i=0; i < symbol->getTypeSize(); i++) {
-      // TODO: horrivel :-)
-      writeByte (' ');
-   }
-
-   return symbol;
-}
-
-
-CSymbol* CData::addConstant (const std::string &name, const int &type, const int &address)
-{
-   CSymbol *symbol = new CSymbol (name, type, CSymbol::CONST, address);
-
-   _symbols.push_back(symbol);
-
-   //_data += symbol->getBinary();
-   if (type == CSymbol::STRING) {
-      writeString(name, false);
-   } else if (type == CSymbol::INT) {
-      writeInt(atoi(name.c_str()));
-   }
-
-   return symbol;
-}
-
-
-

Deleted: trunk/gpt2/common/src/CData.hpp
===================================================================
--- trunk/gpt2/common/src/CData.hpp	2007-11-22 17:23:09 UTC (rev 383)
+++ trunk/gpt2/common/src/CData.hpp	2007-11-22 17:26:11 UTC (rev 384)
@@ -1,21 +0,0 @@
-#ifndef GPT_DATA_H
-#define GPT_DATA_H
-
-#include <string>
-#include <map>
-
-#include "CSymbolList.hpp"
-
-
-class CData : public CSymbolList
-{
-public:
-   CData();
-   ~CData();
-   CSymbol* add(CSymbol *symbol);
-   CSymbol* addVariable (const std::string &name, const int &type, const int &address);
-   CSymbol* addConstant (const std::string &name, const int &type, const int &address);
-};
-
-#endif
-

Copied: trunk/gpt2/gptasm/src/CData.cpp (from rev 383, trunk/gpt2/common/src/CData.cpp)

Copied: trunk/gpt2/gptasm/src/CData.hpp (from rev 383, trunk/gpt2/common/src/CData.hpp)

Modified: trunk/gpt2/gptasm/src/Makefile
===================================================================
--- trunk/gpt2/gptasm/src/Makefile	2007-11-22 17:23:09 UTC (rev 383)
+++ trunk/gpt2/gptasm/src/Makefile	2007-11-22 17:26:11 UTC (rev 384)
@@ -6,7 +6,7 @@
 
 objects = GptAssemblyLexer.o GptAssemblyParser.o main.o CGptAsm.o CGenBytecode.o \
 	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o CCode.o $(COMMON_DIR)CHeader.o \
-        $(COMMON_DIR)CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o
+        CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o
 
 all: $(objects)
 	g++ -o gptasm $(objects) /usr/local/lib/libantlr.a



From gpt-commit-noreply at mail.berlios.de  Thu Nov 22 20:06:01 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 22 Nov 2007 20:06:01 +0100
Subject: [gpt-commit] r385 - in trunk/gpt2: gptasm/test/wikki gptvm/src
Message-ID: <200711221906.lAMJ60uj016871@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-22 20:06:00 +0100 (Thu, 22 Nov 2007)
New Revision: 385

Modified:
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptvm/src/CGptVm.cpp
   trunk/gpt2/gptvm/src/CGptVm.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/main.cpp
Log:
DEVNULL
* Implementado mais alguns opcodes que atuam sobre dados inteiros
* Mnemonicos condicionais e de salto funcionando


Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
@@ -27,11 +27,11 @@
     push_sp
     push x
     push_int
-    push_1
+    push 1
     pcall imprima
     pop_sp
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
@@ -12,11 +12,11 @@
     push_int
     push "2+5*3="
     push_string
-    push_2
+    push 2
     pcall imprima
     pop_sp
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
@@ -8,7 +8,7 @@
     pcall soma
     pop_sp
 	
-    exit_0
+    exit 0
 endproc
 
 proc soma
@@ -20,7 +20,7 @@
     push_sp
     push "A soma ?: "
     push_string
-    push_1
+    push 1
     pcall imprima
     pop_sp
 
@@ -28,7 +28,7 @@
     isum t1, x, y
     push t1
     push_int
-    push_1
+    push 1
     pcall imprima
     pop_sp
 

Modified: trunk/gpt2/gptvm/src/CGptVm.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CGptVm.cpp	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptvm/src/CGptVm.cpp	2007-11-22 19:06:00 UTC (rev 385)
@@ -4,17 +4,19 @@
 #include "CRunBytecode.hpp"
 
 
-CGptVm::CGptVm( COptions *options ) : _options( options )
+CGptVm::CGptVm(COptions *options) : _options(options)
 {
 }
 
 
-bool CGptVm::run( )
+int CGptVm::run()
 {
    ifstream in(_options->sourcefile.c_str(),ios::in | ios::binary);
 
    CRunBytecode bytecode;
 
-   return bytecode.readFromFile(in) && bytecode.run();
+   bytecode.readFromFile(in);
+
+   return bytecode.run();
 }
 

Modified: trunk/gpt2/gptvm/src/CGptVm.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CGptVm.hpp	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptvm/src/CGptVm.hpp	2007-11-22 19:06:00 UTC (rev 385)
@@ -9,7 +9,7 @@
 {
 public:
    CGptVm( COptions *options );
-   bool run( );
+   int run( );
 private:
    COptions *_options;
 };

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 19:06:00 UTC (rev 385)
@@ -5,6 +5,7 @@
 
 
 CRunBytecode::CRunBytecode()
+   : _returnCode(0)
 {
 }
 
@@ -161,7 +162,7 @@
 }
 
 
-bool CRunBytecode::run()
+int CRunBytecode::run()
 {
 //   std::cout << "Code lido: [" << _code.getBinary() << "]" << " size=" << _code.getBinary().size() << std::endl;
 
@@ -173,7 +174,7 @@
       step();
    }
 
-   return true;
+   return _returnCode;
 }
 
 
@@ -239,7 +240,9 @@
    std::cout << std::endl;
 }
 
-// opcodes
+/////////////
+// opcodes //
+/////////////
 
 void CRunBytecode::invalidOpcode(const std::string &opcode)
 {
@@ -248,22 +251,22 @@
 
 void CRunBytecode::nopOpcode()
 {
-//   trace ("nop opcode");
-   invalidOpcode(__FUNCTION__);
+   trace ("nop opcode");
 
-    //nothing to do
+   // nothing to do
 }
 
 void CRunBytecode::pushSpOpcode()
 {
    trace ("push_sp opcode");
-   // TODO
+   _executionStack.push(0); // TODO
 }
 
 void CRunBytecode::popSpOpcode()
 {
    trace ("pop_sp opcode");
-   // TODO
+   _executionStack.top(); // TODO
+   _executionStack.pop();
 }
 
 void CRunBytecode::pushOpcode()
@@ -300,7 +303,7 @@
 {
    trace ("exit opcode");
 
-   int returnCode = _code.fetchInt();
+   _returnCode = _code.fetchInt();
 
    _stop = true;
 }
@@ -308,14 +311,16 @@
 
 void CRunBytecode::hltOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("hlt opcode");
+
+   exit(0);
 }
 
 void CRunBytecode::isumOpcode()
 {
    trace ("isum opcode");
 
-   int varAddress = _code.fetchInt();
+   int varAddress  = _code.fetchInt();
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
@@ -334,7 +339,13 @@
 
 void CRunBytecode::isubOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("isub opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) - _data.getInt(val2Address));
 }
 
 void CRunBytecode::ssubOpcode()
@@ -351,7 +362,7 @@
 {
    trace ("imul opcode");
 
-   int varAddress = _code.fetchInt();
+   int varAddress  = _code.fetchInt();
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
@@ -365,7 +376,13 @@
 
 void CRunBytecode::idivOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("idiv opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) / _data.getInt(val2Address));
 }
 
 void CRunBytecode::rdivOpcode()
@@ -375,7 +392,13 @@
 
 void CRunBytecode::imodOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("imod opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) % _data.getInt(val2Address));
 }
 
 void CRunBytecode::rmodOpcode()
@@ -385,7 +408,13 @@
 
 void CRunBytecode::igeOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ige opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) >= _data.getInt(val2Address));
 }
 
 void CRunBytecode::sgeOpcode()
@@ -402,7 +431,7 @@
 {
    trace ("ile opcode");
 
-   int varAddress = _code.fetchInt();
+   int varAddress  = _code.fetchInt();
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
@@ -421,7 +450,13 @@
 
 void CRunBytecode::ineOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ine opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) != _data.getInt(val2Address));
 }
 
 void CRunBytecode::sneOpcode()
@@ -436,7 +471,13 @@
 
 void CRunBytecode::igtOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("igt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) > _data.getInt(val2Address));
 }
 
 void CRunBytecode::sgtOpcode()
@@ -451,7 +492,13 @@
 
 void CRunBytecode::iltOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ilt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) < _data.getInt(val2Address));
 }
 
 void CRunBytecode::sltOpcode()
@@ -466,7 +513,13 @@
 
 void CRunBytecode::ieqOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ieq opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) == _data.getInt(val2Address));
 }
 
 void CRunBytecode::seqOpcode()
@@ -481,12 +534,24 @@
 
 void CRunBytecode::orOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("or opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) || _data.getInt(val2Address));
 }
 
 void CRunBytecode::andOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("and opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(val1Address) && _data.getInt(val2Address));
 }
 
 void CRunBytecode::xorOpcode()
@@ -516,12 +581,17 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(varAddress)+_data.getInt(valAddress));
+   _data.setInt(varAddress, _data.getInt(varAddress) + _data.getInt(valAddress));
 }
 
 void CRunBytecode::idecOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("idec opcode");
+
+   int varAddress = _code.fetchInt();
+   int valAddress = _code.fetchInt();
+
+   _data.setInt(varAddress, _data.getInt(varAddress) - _data.getInt(valAddress));
 }
 
 void CRunBytecode::i2cOpcode()
@@ -695,7 +765,14 @@
 
 void CRunBytecode::ifOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("if opcode");
+
+   int varAddress = _code.fetchInt();
+   int labelAddress = _code.fetchInt();
+
+   if (_data.getInt(varAddress)) {
+      _code.setIP(labelAddress);
+   }
 }
 
 void CRunBytecode::ifnotOpcode()
@@ -846,4 +923,3 @@
    invalidOpcode(__FUNCTION__);
 }
 
-

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 19:06:00 UTC (rev 385)
@@ -4,6 +4,7 @@
 #include <string>
 #include <vector>
 #include <fstream>
+#include <stack>
 
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
@@ -24,7 +25,7 @@
    CRunBytecode();
    ~CRunBytecode();
    bool readFromFile(std::ifstream &in);
-   bool run();
+   int run();
 private:
    void trace(const std::string &message);
    void error(const std::string &message);
@@ -163,7 +164,9 @@
    CBytecode     _code;
    OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
    bool          _stop;
+   int           _returnCode;
    CDataStack    _dataStack;
+   std::stack<int> _executionStack;
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/main.cpp
===================================================================
--- trunk/gpt2/gptvm/src/main.cpp	2007-11-22 17:26:11 UTC (rev 384)
+++ trunk/gpt2/gptvm/src/main.cpp	2007-11-22 19:06:00 UTC (rev 385)
@@ -42,14 +42,7 @@
 
    CGptVm gptvm( &options );
 
-   if (gptvm.run()) {
-//      cout << "Program " << options.sourcefile << " ok !!!" << endl << endl;
-   } else {
-//      cout << "Program " << options.sourcefile << " has errors..." << endl << endl;
-      exit( EXIT_FAILURE );
-   }
-
-   return EXIT_SUCCESS;
+   return gptvm.run();
 }
 
 



From gpt-commit-noreply at mail.berlios.de  Fri Nov 23 19:06:27 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 23 Nov 2007 19:06:27 +0100
Subject: [gpt-commit] r386 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src
Message-ID: <200711231806.lANI6Rns018374@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-23 19:06:17 +0100 (Fri, 23 Nov 2007)
New Revision: 386

Added:
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptvm/src/CExecutionStack.cpp
   trunk/gpt2/gptvm/src/CExecutionStack.hpp
Modified:
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptvm/src/CBytecode.cpp
   trunk/gpt2/gptvm/src/CBytecode.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
Log:
DEVNULL
* Mnemonico push_sp e pop_sp trocados por push_sreg e pop_sreg
* Implementado chamada para procedimentos definidos pelo usuario
  sem suporte a parametros e sem suporte a variaveis locais
* Implementado opcode pcall, ret e libcall (versao rudimentar por enquanto)


Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -87,29 +87,30 @@
    OP_PUSH_CHAR = 82,
    OP_PUSH_BOOL = 83,
    OP_PUSH_MATRIX = 84,
-   OP_PUSH_SP = 85,
-   OP_POP_SP = 86,
+   OP_PUSH_SREG = 85,
+   OP_POP_SREG = 86,
    OP_INCSP_4 = 87,
    OP_INCSP_8 = 88,
    OP_DECSP_4 = 89,
    OP_DECSP_8 = 90,
    OP_PCALL = 91,
    OP_RET         = 92,
-   OP_SALLOC = 93,
-   OP_SFREE = 94,
-   OP_SSETC = 95,
-   OP_SGETC = 96,
-   OP_M1ALLOC = 97,
-   OP_M2ALLOC = 98,
-   OP_MFREE = 99,
-   OP_M1SET = 100,
-   OP_M1GET = 101,
-   OP_M2SET = 102,
-   OP_M2GET = 103,
-   OP_MCOPY = 104,
-   OP_MGETSIZE1 = 105,
-   OP_MGETSIZE2 = 106,
-   OPCODE_NUMBER  = 107
+   OP_LIBCALL = 93,
+   OP_SALLOC = 94,
+   OP_SFREE = 95,
+   OP_SSETC = 96,
+   OP_SGETC = 97,
+   OP_M1ALLOC = 98,
+   OP_M2ALLOC = 99,
+   OP_MFREE = 100,
+   OP_M1SET = 101,
+   OP_M1GET = 102,
+   OP_M2SET = 103,
+   OP_M2GET = 104,
+   OP_MCOPY = 105,
+   OP_MGETSIZE1 = 106,
+   OP_MGETSIZE2 = 107,
+   OPCODE_NUMBER  = 108
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -98,14 +98,15 @@
    _opcodes[ "push_char"   ] = OP_PUSH_CHAR;
    _opcodes[ "push_bool"   ] = OP_PUSH_BOOL;
    _opcodes[ "push_matrix" ] = OP_PUSH_MATRIX;
-   _opcodes[ "push_sp"     ] = OP_PUSH_SP;
-   _opcodes[ "pop_sp"      ] = OP_POP_SP;
+   _opcodes[ "push_sreg"   ] = OP_PUSH_SREG;
+   _opcodes[ "pop_sreg"    ] = OP_POP_SREG;
    _opcodes[ "incsp_4"     ] = OP_INCSP_4;
    _opcodes[ "incsp_8"     ] = OP_INCSP_8;
    _opcodes[ "decsp_4"     ] = OP_DECSP_4;
    _opcodes[ "decsp_8"     ] = OP_DECSP_8;
    _opcodes[ "pcall"       ] = OP_PCALL;
    _opcodes[ "ret"         ] = OP_RET;
+   _opcodes[ "libcall"     ] = OP_LIBCALL;
    _opcodes[ "salloc"      ] = OP_SALLOC;
    _opcodes[ "sfree"       ] = OP_SFREE;
    _opcodes[ "ssetc"       ] = OP_SSETC;
@@ -140,14 +141,15 @@
    _symbolTable.addProcedure (procedureName, CSymbol::NO_TYPE, _code.size(), hasVarArguments, staticParameters, parameters);
    _currentProcedure = procedureName;
    _currentSP = 0;
-   _unsolvedLabels.clear();
-   _solvedLabels.clear();
+//   _unsolvedLabels.clear();
+//   _solvedLabels.clear();
+    registryLabel(procedureName);
 }
 
 
 void CGenBytecode::finishProcedure()
 {
-   translateLabelsToAddress();
+//   translateLabelsToAddress();
    _currentProcedure.clear();
    // TODO: delete na procedure ???
 }
@@ -177,7 +179,7 @@
       abort();
    }
    _solvedLabels[labelName] = _code.size();
-//   std::cout << "Registry label: " << labelName << " address: " << _code.size() << std::endl;
+   std::cout << "Registry label: " << labelName << " address: " << _code.size() << std::endl;
 }
 
 
@@ -223,7 +225,7 @@
 void CGenBytecode::unsolvedLabel(const std::string &label)
 {
    _unsolvedLabels.push_back(std::pair<std::string, int>(label, _code.size()));
-//   std::cout << "Unsolved label: " << label << " address: " << _code.size() << std::endl;
+   std::cout << "Unsolved label: " << label << " address: " << _code.size() << std::endl;
    _code.writeInt(0);
 }
 

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -25,8 +25,8 @@
    void addAddress(const std::string &id, const int &category, const int &type);
    CBinString getBinary();
    void unsolvedLabel(const std::string &label);
+   void translateLabelsToAddress();
 private:
-   void translateLabelsToAddress();
 
    CHeader                    _header;
    CSymbolTable               _symbolTable;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-23 18:06:17 UTC (rev 386)
@@ -133,13 +133,14 @@
    T_KW_PUSH_CHAR="push_char";
    T_KW_PUSH_BOOL="push_bool";
    T_KW_PUSH_MATRIX="push_matrix";
-   T_KW_PUSH_SP="push_sp";
-   T_KW_POP_SP="pop_sp";
+   T_KW_PUSH_SP="push_sreg";
+   T_KW_POP_SP="pop_sreg";
    T_KW_INCSP_4="incsp_4";
    T_KW_INCSP_8="incsp_8";
    T_KW_DECSP_4="decsp_4";
    T_KW_DECSP_8="decsp_8";
    T_KW_PCALL="pcall";
+   T_KW_LIBCALL="libcall";
    T_KW_RET="ret";
    T_KW_SALLOC="salloc";
    T_KW_SFREE="sfree";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-23 18:06:17 UTC (rev 386)
@@ -64,6 +64,7 @@
      "endprogram"
      EOF
      {
+        bytecode.translateLabelsToAddress();
         ret = bytecode.getBinary();
      }
      ;
@@ -262,13 +263,17 @@
 //      {bytecode.addOpcode(getLastTokenText());}
    |  ("push_int"|"push_string"|"push_real"|"push_char"|"push_bool"|"push_matrix")
       {bytecode.addOpcode(getLastTokenText());}
-   |  ("push_sp"|"pop_sp")
+   |  ("push_sreg"|"pop_sreg")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
       {bytecode.addOpcode(getLastTokenText());}
    |  "pcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
+      { bytecode.unsolvedLabel(getLastTokenText());}
+   |  "libcall"
+      {bytecode.addOpcode(getLastTokenText());}
+      T_ID
       { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
    |  "ret"
       {bytecode.addOpcode(getLastTokenText());}

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -24,12 +24,12 @@
     proximo:
 
     // imprima( x );
-    push_sp
+    push_sreg
     push x
     push_int
     push 1
-    pcall imprima
-    pop_sp
+    libcall imprima
+    pop_sreg
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -13,12 +13,12 @@
     ifnot t1, proximo
 
     // imprima( x );
-    push_sp
+    push_sreg
     push x
     push_int
     push 1
-    pcall imprima
-    pop_sp
+    libcall imprima
+    pop_sreg
 
     // fim-para
     iinc x, 1

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -5,7 +5,7 @@
     var t2 int
 
     // imprima( "2+5*3=", 2+5*3 );
-    push_sp
+    push_sreg
     imul t1, 5, 3
     isum t2, 2, t1
     push t2
@@ -13,8 +13,8 @@
     push "2+5*3="
     push_string
     push 2
-    pcall imprima
-    pop_sp
+    libcall imprima
+    pop_sreg
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -1,12 +1,12 @@
 program exemplo
 
 proc main
-    push_sp
+    push_sreg
     push "Ol? mundo !!!"
     push_string
     push 1
-    pcall imprima
-    pop_sp
+    libcall imprima
+    pop_sreg
 
     exit 0
 endproc

Added: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -0,0 +1,33 @@
+program exemplo
+
+proc main
+   push_sreg
+   pcall soma
+   pop_sreg
+
+   push_sreg
+   push "Finalizando..."
+   push_string
+   push 1
+   libcall imprima
+   pop_sreg
+
+   exit 0
+endproc
+
+proc soma
+   var temp int
+
+   isum temp, 2, 4
+
+   push_sreg
+   push temp
+   push_int
+   push 1
+   libcall imprima
+   pop_sreg
+
+   ret
+endproc
+   
+endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-23 18:06:17 UTC (rev 386)
@@ -14,7 +14,7 @@
     iset y, 20
 	
     // imprima( "x*y+4=", x*y+4 );
-    push_sp
+    push_sreg
     imul t1, x, y
     isum t2, t1, 4
     push t2
@@ -22,8 +22,8 @@
     push "x*y+4="
     push_string
     push 2
-    pcall imprima
-    pop_sp
+    libcall imprima
+    pop_sreg
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptvm/src/CBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -32,3 +32,9 @@
    _IP = IP;
 }
 
+
+int CBytecode::getIP() const
+{
+   return _IP;
+}
+

Modified: trunk/gpt2/gptvm/src/CBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -13,6 +13,7 @@
    char fetchByte();
    int  fetchInt();
    void setIP(const int &IP);
+   int getIP() const;
    CBinString::readString;
 private:
    int _IP;

Added: trunk/gpt2/gptvm/src/CExecutionStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CExecutionStack.cpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CExecutionStack.cpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -0,0 +1,27 @@
+#include "CExecutionStack.hpp"
+
+
+CExecutionStack::CExecutionStack()
+   : _BP(0)
+   , _SP(0)
+{
+}
+
+
+void CExecutionStack::pushStackRegs()
+{
+   push(_BP);
+   push(_SP);
+   _BP = _SP;
+}
+
+
+void CExecutionStack::popStackRegs()
+{
+   _SP = top();
+   pop();
+
+   _BP = top();
+   pop();
+}
+

Added: trunk/gpt2/gptvm/src/CExecutionStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CExecutionStack.hpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CExecutionStack.hpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -0,0 +1,19 @@
+#ifndef GPT_EXECUTION_STACK_HPP
+#define GPT_EXECUTION_STACK_HPP
+
+#include <stack>
+
+
+class CExecutionStack : public std::stack<int>
+{
+public:
+   CExecutionStack();
+   void pushStackRegs();
+   void popStackRegs();
+private:
+   int _BP;
+   int _SP;
+};
+
+#endif
+

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -39,12 +39,13 @@
    }
 
    _opcodePointer[OP_NOP        ] = &CRunBytecode::nopOpcode;
-   _opcodePointer[OP_PUSH_SP    ] = &CRunBytecode::pushSpOpcode;
-   _opcodePointer[OP_POP_SP     ] = &CRunBytecode::popSpOpcode;
+   _opcodePointer[OP_PUSH_SREG  ] = &CRunBytecode::pushSregOpcode;
+   _opcodePointer[OP_POP_SREG   ] = &CRunBytecode::popSregOpcode;
    _opcodePointer[OP_PUSH       ] = &CRunBytecode::pushOpcode;
    _opcodePointer[OP_PUSH_STRING] = &CRunBytecode::pushStringOpcode;
 //   _opcodePointer[OP_PUSH_1     ] = &CRunBytecode::push1Opcode;
    _opcodePointer[OP_PCALL      ] = &CRunBytecode::pcallOpcode;
+   _opcodePointer[OP_LIBCALL    ] = &CRunBytecode::libcallOpcode;
 //   _opcodePointer[OP_EXIT_0     ] = &CRunBytecode::exit0Opcode;
    _opcodePointer[OP_EXIT       ] = &CRunBytecode::exitOpcode;
 
@@ -256,17 +257,18 @@
    // nothing to do
 }
 
-void CRunBytecode::pushSpOpcode()
+void CRunBytecode::pushSregOpcode()
 {
-   trace ("push_sp opcode");
-   _executionStack.push(0); // TODO
+   trace ("push_sreg opcode");
+
+   _executionStack.pushStackRegs();
 }
 
-void CRunBytecode::popSpOpcode()
+void CRunBytecode::popSregOpcode()
 {
-   trace ("pop_sp opcode");
-   _executionStack.top(); // TODO
-   _executionStack.pop();
+   trace ("pop_sreg opcode");
+
+   _executionStack.popStackRegs();
 }
 
 void CRunBytecode::pushOpcode()
@@ -291,10 +293,21 @@
 
    int address = _code.fetchInt();
 
-//   std::string temp = _data.getCString(address);
+   _executionStack.push(_code.getIP());
+   _code.setIP(address);
+}
 
+
+void CRunBytecode::libcallOpcode()
+{
+   trace ("libcall opcode");
+
+   int address = _code.fetchInt();
+
    if (_data.getCString(address) == "imprima") {
       procImprima();
+   } else {
+      error("libcall invocando subrotina desconhecida !!!");
    }
 }
 
@@ -850,7 +863,10 @@
 
 void CRunBytecode::retOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ret opcode");
+
+   _code.setIP(_executionStack.top());
+   _executionStack.pop();
 }
 
 void CRunBytecode::sallocOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-23 18:06:17 UTC (rev 386)
@@ -8,11 +8,11 @@
 
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
-//#include "CData.hpp"
 #include "CBinString.hpp"
 #include "CBytecode.hpp"
 #include "Common.hpp"
 #include "CDataStack.hpp"
+#include "CExecutionStack.hpp"
 
 class CRunBytecode;
 
@@ -35,12 +35,13 @@
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
-   void pushSpOpcode();
-   void popSpOpcode();
+   void pushSregOpcode();
+   void popSregOpcode();
    void pushOpcode();
    void pushStringOpcode();
 //   void push1Opcode();
    void pcallOpcode();
+   void libcallOpcode();
 //   void exit0Opcode();
    void exitOpcode();
 
@@ -166,7 +167,7 @@
    bool          _stop;
    int           _returnCode;
    CDataStack    _dataStack;
-   std::stack<int> _executionStack;
+   CExecutionStack _executionStack;
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-22 19:06:00 UTC (rev 385)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-23 18:06:17 UTC (rev 386)
@@ -7,6 +7,7 @@
 GPTASM=../gptasm/
 
 objects = main.o CGptVm.o CRunBytecode.o CDataStack.o CBytecode.o \
+          CExecutionStack.o \
           $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
           $(COMMON_DIR)CHeader.o \
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:48:08 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:48:08 +0100
Subject: [gpt-commit] r387 - trunk/gpt2/gptc/src
Message-ID: <200711261248.lAQCm8E4007709@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:48:04 +0100 (Mon, 26 Nov 2007)
New Revision: 387

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Adicionado codigo, de fato, para avaliacao de expressoes
-Implementacao da avaliacao da lista de inicializacao

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-23 18:06:17 UTC (rev 386)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-26 12:48:04 UTC (rev 387)
@@ -4,7 +4,6 @@
 #include "SymbolTable.hpp"
 #include "Symbol.hpp"
 #include "Types.hpp"
-#include "PortugolAST.hpp"
 #include "SymbolTableExceptions.hpp"
 
 #include <iostream>
@@ -40,7 +39,7 @@
   try {
     _symtable->defineStruct(name, fieldList, line);
   } catch (RedefinedTypeException e) {
-    cerr << "catched! Redeclared type: " << e.typeName() << "\n";
+    cerr << "catched! Redefined type: " << e.typeName() << "\n";
   } catch (RedeclarationException e) {
     cerr << "catched! Redeclaration: " << e.symbol().toString() << "\n";
   }
@@ -91,7 +90,7 @@
   }
 }
 
-void BaseSemanticWalker::evalFCall(const std::string& fname,
+Type* BaseSemanticWalker::evalFCall(const std::string& fname,
                                    const TypeList& paramTypes) {
   //TODO
   //-proibicao de consts passados para parametros "ref" sem constness
@@ -101,190 +100,328 @@
 }
 
 void BaseSemanticWalker::evalMatrixSubscript(Type* type) {
+  //TODO
 }
 
-void BaseSemanticWalker::evalAttribution(Type*, Type*) {
-  //-proibicao de consts como lvalues
+  //TODO
+  //-proibicao de consts como lvalues em expressoes
+
+void BaseSemanticWalker::evalAttribution(Type* ltype, Type* rtype) {
+  if (!ltype->isLValueFor(rtype)) {
+    std::cerr << "ilegal: "
+              << ltype->name() << " := " << rtype->name() << endl;
+  }
 }
 
+void BaseSemanticWalker::evalAttribution(Type* ltype, const InitMatrixList& mtx) {
+  Type* rtype = evalHomogeneity(mtx);
+  if (!ltype->isLValueFor(rtype)) {
+    std::cerr << "ilegal: "
+              << ltype->name() << " := " << rtype->name() << endl;
+  }
+}
 
-template<int>
-Type* BaseSemanticWalker::evalExpr(Type*, Type*) {
-  //nao deve ser chamado!
-  throw;
+void BaseSemanticWalker::evalAttribution(Type* ltype, const InitStructList& stc) {
+  StructType* rtype = createAnonymousStructFor(stc);
+
+  if (!ltype->isLValueFor(rtype)) {
+    std::cerr << "ilegal: "
+              << ltype->name() << " := " << rtype->name() << endl;
+  }
 }
 
-template<>
+StructType* BaseSemanticWalker::createAnonymousStructFor(const InitStructList& stc) {
+  SymbolList slist;
+  InitStructList::const_iterator it;
+  for (it = stc.begin(); it != stc.end(); ++it) {
+    slist.push_back(_symtable->newSymbol(it->first, it->second));
+  }
+
+  return _symtable->createAnonymousStruct(slist);
+}
+
+Type* BaseSemanticWalker::evalHomogeneity(const InitMatrixList& mtx) {
+  InitMatrixList::const_iterator it;
+  int dim = 0;
+  Type* type = 0;
+  for (it = mtx.begin(); it != mtx.end(); ++it) {
+    if (dim == 0) {
+      dim = it->first;
+    } else if (dim != it->first) {
+      std::cerr << "err: Numero variavel de dimensoes na matriz!\n";
+    }
+
+    if (type == 0) {
+      type = it->second;
+    } else if (!type->equals(it->second)) {
+      std::cerr << "err: Numero variavel de tipos na matriz!\n";
+    }
+  }
+  return _symtable->retrieveMatrixType(type, dim);
+}
+
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_OU>(Type* left,
-                                                       Type* right) {
-  std::cerr <<  left->name() << " OU " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_OU(Type* left, Type* right) {
+  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
 }
 
-template<>
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_E>(Type* left,
-                                                      Type* right) {
-  std::cerr <<  left->name() << " E " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_E(Type* left, Type* right) {
+  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_OU>(Type* left,
-                                                           Type* right) {
-  std::cerr <<  left->name() << " | " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_OU(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " | " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_OUX>(Type* left,
-                                                            Type* right) {
-  std::cerr <<  left->name() << " ^ " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_OUX(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " ^ " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_E>(Type* left,
-                                                          Type* right) {
-  std::cerr <<  left->name() << " & " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_E(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " & " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_IGUAL>(Type* left,
-                                                          Type* right) {
-  std::cerr <<  left->name() << " = " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_IGUAL(Type* left, Type* right) {
+  if (left->equals(right)) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " = " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_DIFERENTE>(Type* left,
-                                                              Type* right) {
-  std::cerr <<  left->name() << " = " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_DIFERENTE(Type* left, Type* right) {
+  if (left->equals(right)) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " <> " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIOR>(Type* left,
-                                                          Type* right) {
-  std::cerr <<  left->name() << " > " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MAIOR(Type* left, Type* right) {
+  if ((left->isPrimitive() && right->isPrimitive()) &&
+      (left->equals(right) || left->numPromotionWith(right))) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " > " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOR>(Type* left,
-                                                          Type* right) {
-  std::cerr <<  left->name() << " < " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MENOR(Type* left, Type* right) {
+  if ((left->isPrimitive() && right->isPrimitive()) &&
+      (left->equals(right) || left->numPromotionWith(right))) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " < " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIOR_EQ>(Type* left,
-                                                             Type* right) {
-  std::cerr <<  left->name() << " >= " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MAIOR_EQ(Type* left, Type* right) {
+  if ((left->isPrimitive() && right->isPrimitive()) &&
+      (left->equals(right) || left->numPromotionWith(right))) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " >= " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOR_EQ>(Type* left,
-                                                             Type* right) {
-  std::cerr <<  left->name() << " <= " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MENOR_EQ(Type* left, Type* right) {
+  if ((left->isPrimitive() && right->isPrimitive()) &&
+      (left->equals(right) || left->numPromotionWith(right))) {
+    _symtable->getType(PortugolTokenTypes::T_LOGICO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " <= " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_SHIFT_LEFT>(
-                                                    Type* left, Type* right) {
-  std::cerr <<  left->name() << " << " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " << " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_SHIFT_RIGHT>(
-                                                    Type* left, Type* right) {
-  std::cerr <<  left->name() << " >> " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " >> " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MAIS>(Type* left,
-                                                         Type* right) {
-  std::cerr <<  left->name() << " + " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MAIS(Type* left, Type* right) {
+  Type* ret;
+  if (ret = left->numPromotionWith(right)) {
+    return ret;
+  } else if (ret = left->litPromotionWith(right)) {
+    return ret;
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " + " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MENOS>(Type* left,
-                                                          Type* right) {
-  std::cerr <<  left->name() << " - " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MENOS(Type* left, Type* right) {
+  Type* ret;
+  if (ret = left->numPromotionWith(right)) {
+    return ret;
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " - " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_DIV>(Type* left,
-                                                        Type* right) {
-  std::cerr <<  left->name() << " / " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_DIV(Type* left, Type* right) {
+  Type* ret;
+  if (ret = left->numPromotionWith(right)) {
+    return ret;
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " / " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MULTIP>(Type* left,
-                                                           Type* right) {
-  std::cerr <<  left->name() << " * " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MULTIP(Type* left, Type* right) {
+  Type* ret;
+  if (ret = left->numPromotionWith(right)) {
+    return ret;
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " * " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_MOD>(Type* left,
-                                                        Type* right) {
-  std::cerr <<  left->name() << " % " << right->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_MOD(Type* left, Type* right) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) &&
+      right->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << left->name() << " % " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_UN_NEGATIVO>(Type* left) {
-  std::cerr <<  " - " << left->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_UN_NEGATIVO(Type* left) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
+      left->equals(PortugolTokenTypes::T_REAL)) {
+    return left;
+  } else {
+    std::cerr << "ilegal: "
+              << " - " << left->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_UN_POSITIVO>(Type* left) {
-  std::cerr <<  " + " << left->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_UN_POSITIVO(Type* left) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO) ||
+      left->equals(PortugolTokenTypes::T_REAL)) {
+    return left;
+  } else {
+    std::cerr << "ilegal: "
+              << " + " << left->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_NAO>(Type* left) {
-  std::cerr <<  " n?o " << left->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_NAO(Type* left) {
+  return _symtable->getType(PortugolTokenTypes::T_LOGICO);
 }
 
-template<>
+
 Type*
-BaseSemanticWalker::evalExpr<PortugolTokenTypes::T_BIT_NAO>(Type* left) {
-  std::cerr <<  " ~ " << left->name() << endl;
-  return left;
+BaseSemanticWalker::evalExpr_BIT_NAO(Type* left) {
+  if (left->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return _symtable->getType(PortugolTokenTypes::T_INTEIRO);
+  } else {
+    std::cerr << "ilegal: "
+              << " ~ " << left->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
 }
 

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-23 18:06:17 UTC (rev 386)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-26 12:48:04 UTC (rev 387)
@@ -25,14 +25,61 @@
 #include <list>
 #include <string>
 
-class PortugolAST;
+#include "PortugolAST.hpp"
+
 class SymbolTable;
 class SymbolList;
 class Type;
 class TypeList;
+class StructType;
 
-typedef std::list<PortugolAST*> IDList;
+typedef std::list<RefPortugolAST> IDList;
 
+typedef std::list<std::pair<std::string,Type*> > InitStructList;
+typedef std::list<std::pair<int,Type*> >         InitMatrixList;
+
+/*struct InitValue {
+  enum { PRIMITIVE, MATRIX, STRUCT };
+  int id;
+  Type* primtype;
+  std::list<InitValue> mvalues;
+  std::list<pair<std::string, InitValue> > svalues;
+*/
+//   Type* calculatedType(const SymbolTable& symtable) {
+//     std::list<InitValue>::iterator it;
+//     Type *type = 0;
+//
+//     switch (id) {
+//       case PRIMITIVE:
+//         return primtype;
+//       case MATRIX:
+//         for (it = list.begin(); it != list.end(); ++it) {
+//           if (!type) {
+//             type = (*it).calculatedType(symtable);
+//           } else {
+//             type = type;
+//           }
+//         }
+//     }
+//
+//     TypeList types;
+//     Type *ret;
+//     std::list<InitValue>::iterator it;
+//     for (it = list.begin(); it != list.end(); ++it) {
+//       switch ((*it).id) {
+//         case PRIMITIVE:
+//           types.push_back((*it).primtype);
+//           break;
+//         case MATRIX:
+//           types.push_back(
+//       }
+//     }
+//   }
+// };
+
+
+
+
 class BaseSemanticWalker : public antlr::TreeParser {
 
 public:
@@ -50,20 +97,45 @@
   Type* getType(const std::string&);
   Type* getType(int);
 
+  Type* createAnonymousStructFor();
+
   Type* getSymbolType(const std::string&);
 
-  void evalFCall(const std::string&, const TypeList&);
+  Type* evalFCall(const std::string&, const TypeList&);
 
   void evalMatrixSubscript(Type*);
 
   void evalAttribution(Type*, Type*);
+  void evalAttribution(Type*, const InitMatrixList&);
+  void evalAttribution(Type*, const InitStructList&);
 
-  template<int>
-  Type* evalExpr(Type*, Type*);
+  StructType* createAnonymousStructFor(const InitStructList&);
 
-  template<int>
-  Type* evalExpr(Type*);
+  Type* evalHomogeneity(const InitMatrixList&);
 
+  Type* evalExpr_OU(Type* left, Type* right);
+  Type* evalExpr_E(Type* left, Type* right);
+  Type* evalExpr_BIT_OU(Type* left, Type* right);
+  Type* evalExpr_BIT_OUX(Type* left, Type* right);
+  Type* evalExpr_BIT_E(Type* left, Type* right);
+  Type* evalExpr_IGUAL(Type* left, Type* right);
+  Type* evalExpr_DIFERENTE(Type* left, Type* right);
+  Type* evalExpr_MAIOR(Type* left, Type* right);
+  Type* evalExpr_MENOR(Type* left, Type* right);
+  Type* evalExpr_MAIOR_EQ(Type* left, Type* right);
+  Type* evalExpr_MENOR_EQ(Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_LEFT(Type* left, Type* right);
+  Type* evalExpr_BIT_SHIFT_RIGHT(Type* left, Type* right);
+  Type* evalExpr_MAIS(Type* left, Type* right);
+  Type* evalExpr_MENOS(Type* left, Type* right);
+  Type* evalExpr_DIV(Type* left, Type* right);
+  Type* evalExpr_MULTIP(Type* left, Type* right);
+  Type* evalExpr_MOD(Type* left, Type* right);
+  Type* evalExpr_UN_NEGATIVO(Type*);
+  Type* evalExpr_UN_POSITIVO(Type*);
+  Type* evalExpr_NAO(Type*);
+  Type* evalExpr_BIT_NAO(Type*);
+
   SymbolTable* _symtable;
 };
 

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-11-23 18:06:17 UTC (rev 386)
+++ trunk/gpt2/gptc/src/semantic.g	2007-11-26 12:48:04 UTC (rev 387)
@@ -42,7 +42,10 @@
 {
 public:
   SemanticWalker::SemanticWalker(SymbolTable* stable)
-	 : BaseSemanticWalker(stable) { }
+	 : BaseSemanticWalker(stable), _analisingInitializationList(false) { }
+
+private:
+  bool _analisingInitializationList;
 }
 
 
@@ -70,9 +73,6 @@
   : #(T_USE lib:T_TEXTO_LITERAL)                  {useLib(lib->getText());}
   ;
 
-//TODO: checar inicializa??o:
-//      ex: vari?vel z : inteiro := f(); //erro!
-
 declaracoes_globais
   : declaracao_variavel  (declaracoes_globais)?
   | declaracao_constante (declaracoes_globais)?
@@ -90,7 +90,7 @@
                                   Type *type;
                                 }
 
-  : #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao)?)
+  : #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao[type])?)
 
                                 {declare(ids, type, false);}
   ;
@@ -107,7 +107,7 @@
                                   Type *type;
                                 }
 
-  : #(T_CONSTANTE type=tipo ids=identificadores valor_inicialiacao)
+  : #(T_CONSTANTE type=tipo ids=identificadores valor_inicialiacao[type])
 
                                 {declare(ids, type, true);}
   ;
@@ -129,7 +129,7 @@
                                 }
 
   : (
-      #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao)?)
+      #(T_VARIAVEL type=tipo ids=identificadores (valor_inicialiacao[type])?)
 
                                 {
                                   for (IDList::iterator it = ids.begin();
@@ -143,16 +143,71 @@
     )+
   ;
 
-valor_inicialiacao
-  : #(T_VALOR valor)
+valor_inicialiacao[Type* ltype]
+
+                          {
+                            _analisingInitializationList = true;
+                          }
+
+  : #(T_VALOR valor[ltype])
+
+                          {
+                            _analisingInitializationList = false;
+                          }
   ;
 
-valor returns [Type *type]
-  : type=expressao
-  | #(T_VAL_MATRIZ    (valor)*)
-  | #(T_VAL_ESTRUTURA (valor)*)
+valor[Type *ltype]
+                          {
+                            Type *rtype;
+                            InitMatrixList         mtx;
+                            InitStructList         stc;
+                          }
+
+  : rtype=expressao       {evalAttribution(ltype, rtype);}
+
+  | #(T_VAL_MATRIZ  (valor_matriz[1,mtx])+)
+
+                          {evalAttribution(ltype, mtx);}
+
+  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)
+
+                          {evalAttribution(ltype, stc);}
   ;
 
+valor_matriz [int dimension, InitMatrixList& mtx]
+
+                              {
+                                Type *type;
+                                InitStructList stc;
+                              }
+
+  : type=expressao     {mtx.push_back(std::pair<int,Type*>(dimension, type));}
+
+  | #(T_VAL_MATRIZ (valor_matriz[dimension+1, mtx])+)
+
+  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(), stc])+)
+
+                       {mtx.push_back(std::pair<int,Type*>(dimension,
+                            createAnonymousStructFor(stc)));}
+  ;
+
+valor_estrutura [const string& field, InitStructList& stc]
+                              {
+                                Type *type;
+                                InitMatrixList mtx;
+                              }
+  : type=expressao     {stc.push_back(std::pair<std::string,Type*>(field, type));}
+
+  | #(T_VAL_MATRIZ (valor_matriz[1, mtx])+)
+                              {
+                                type = evalHomogeneity(mtx);
+                                stc.push_back(std::pair<std::string,Type*>(field,type));
+                              }
+
+  | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)
+  ;
+
+
 tipo returns [Type *type]
   : id:T_IDENTIFICADOR       {type = getType(id->getText());}
   | type=tipo_primitivo
@@ -204,7 +259,7 @@
                                         _symtable->setScope(id->getText());
                                       }
 
-    (declaracao_variavel | declaracao_constante)*)
+      (declaracao_variavel | declaracao_constante)*)
 
                                       {_symtable->setGlobalScope();}
   ;
@@ -225,7 +280,7 @@
                                         _symtable->setScope(id->getText());
                                       }
 
-    (declaracao_variavel | declaracao_constante)*)
+      (declaracao_variavel | declaracao_constante)*)
 
                                       {_symtable->setGlobalScope();}
   ;
@@ -244,8 +299,8 @@
                                     list.push_back(
                                         _symtable->newSymbol(
                                           id->getText(), type,
+                                          scope,
                                           id->getLine(),
-                                          scope,
                                           c != antlr::nullAST,
                                           r != antlr::nullAST));
 
@@ -301,75 +356,82 @@
   ;
 
 expressao returns [Type *type]
-                                                 {Type *l, *r;}
+                                      {
+                                        Type *l, *r;
+                                        RefPortugolAST op = _t;
+                                      }
+  : (
 
-  : #(T_OU              l=expressao r=expressao)
-                                    {type = evalExpr<T_OU>(l,r);}
+      #(T_OU              l=expressao r=expressao)
+                                      {type = evalExpr_OU(l,r);}
 
-  | #(T_E               l=expressao r=expressao)
-                                    {type = evalExpr<T_E>(l,r);}
+    | #(T_E               l=expressao r=expressao)
+                                      {type = evalExpr_E(l,r);}
 
-  | #(T_BIT_OU          l=expressao r=expressao)
-                                    {type = evalExpr<T_BIT_OU>(l,r);}
+    | #(T_BIT_OU          l=expressao r=expressao)
+                                      {type = evalExpr_BIT_OU(l,r);}
 
-  | #(T_BIT_OUX         l=expressao r=expressao)
-                                    {type = evalExpr<T_BIT_OUX>(l,r);}
+    | #(T_BIT_OUX         l=expressao r=expressao)
+                                      {type = evalExpr_BIT_OUX(l,r);}
 
-  | #(T_BIT_E           l=expressao r=expressao)
-                                    {type = evalExpr<T_BIT_E>(l,r);}
+    | #(T_BIT_E           l=expressao r=expressao)
+                                      {type = evalExpr_BIT_E(l,r);}
 
-  | #(T_IGUAL           l=expressao r=expressao)
-                                    {type = evalExpr<T_IGUAL>(l,r);}
+    | #(T_IGUAL           l=expressao r=expressao)
+                                      {type = evalExpr_IGUAL(l,r);}
 
-  | #(T_DIFERENTE       l=expressao r=expressao)
-                                    {type = evalExpr<T_DIFERENTE>(l,r);}
+    | #(T_DIFERENTE       l=expressao r=expressao)
+                                      {type = evalExpr_DIFERENTE(l,r);}
 
-  | #(T_MAIOR           l=expressao r=expressao)
-                                    {type = evalExpr<T_MAIOR>(l,r);}
+    | #(T_MAIOR           l=expressao r=expressao)
+                                      {type = evalExpr_MAIOR(l,r);}
 
-  | #(T_MENOR           l=expressao r=expressao)
-                                    {type = evalExpr<T_MENOR>(l,r);}
+    | #(T_MENOR           l=expressao r=expressao)
+                                      {type = evalExpr_MENOR(l,r);}
 
-  | #(T_MAIOR_EQ        l=expressao r=expressao)
-                                    {type = evalExpr<T_MAIOR_EQ>(l,r);}
+    | #(T_MAIOR_EQ        l=expressao r=expressao)
+                                      {type = evalExpr_MAIOR_EQ(l,r);}
 
-  | #(T_MENOR_EQ        l=expressao r=expressao)
-                                    {type = evalExpr<T_MENOR_EQ>(l,r);}
+    | #(T_MENOR_EQ        l=expressao r=expressao)
+                                      {type = evalExpr_MENOR_EQ(l,r);}
 
-  | #(T_BIT_SHIFT_LEFT  l=expressao r=expressao)
-                                    {type = evalExpr<T_BIT_SHIFT_LEFT>(l,r);}
+    | #(T_BIT_SHIFT_LEFT  l=expressao r=expressao)
+                                      {type = evalExpr_BIT_SHIFT_LEFT(l,r);}
 
-  | #(T_BIT_SHIFT_RIGHT l=expressao r=expressao)
-                                    {type = evalExpr<T_BIT_SHIFT_RIGHT>(l,r);}
+    | #(T_BIT_SHIFT_RIGHT l=expressao r=expressao)
+                                      {type = evalExpr_BIT_SHIFT_RIGHT(l,r);}
 
-  | #(T_MAIS            l=expressao r=expressao)
-                                    {type = evalExpr<T_MAIS>(l,r);}
+    | #(T_MAIS            l=expressao r=expressao)
+                                      {type = evalExpr_MAIS(l,r);}
 
-  | #(T_MENOS           l=expressao r=expressao)
-                                    {type = evalExpr<T_MENOS>(l,r);}
+    | #(T_MENOS           l=expressao r=expressao)
+                                      {type = evalExpr_MENOS(l,r);}
 
-  | #(T_DIV             l=expressao r=expressao)
-                                    {type = evalExpr<T_DIV>(l,r);}
+    | #(T_DIV             l=expressao r=expressao)
+                                      {type = evalExpr_DIV(l,r);}
 
-  | #(T_MULTIP          l=expressao r=expressao)
-                                    {type = evalExpr<T_MULTIP>(l,r);}
+    | #(T_MULTIP          l=expressao r=expressao)
+                                      {type = evalExpr_MULTIP(l,r);}
 
-  | #(T_MOD             l=expressao r=expressao)
-                                    {type = evalExpr<T_MOD>(l,r);}
+    | #(T_MOD             l=expressao r=expressao)
+                                      {type = evalExpr_MOD(l,r);}
 
-  | #(T_UN_NEGATIVO    l=elemento)
-                                    {type = evalExpr<T_UN_NEGATIVO>(l);}
+    | #(T_UN_NEGATIVO     l=elemento)
+                                      {type = evalExpr_UN_NEGATIVO(l);}
 
-  | #(T_UN_POSITIVO   l=elemento)
-                                    {type = evalExpr<T_UN_POSITIVO>(l);}
+    | #(T_UN_POSITIVO     l=elemento)
+                                      {type = evalExpr_UN_POSITIVO(l);}
 
-  | #(T_NAO            l=elemento)
-                                    {type = evalExpr<T_NAO>(l);}
+    | #(T_NAO             l=elemento)
+                                      {type = evalExpr_NAO(l);}
 
-  | #(T_BIT_NAO        l=elemento)
-                                    {type = evalExpr<T_BIT_NAO>(l);}
+    | #(T_BIT_NAO         l=elemento)
+                                      {type = evalExpr_BIT_NAO(l);}
 
-  | type=elemento
+    | type=elemento
+  )
+
+    {op->setEvalType(type);}
   ;
 
 
@@ -413,8 +475,12 @@
   : #(T_CALL id:T_IDENTIFICADOR params=lista_argumentos)
 
                                   {
-                                    type = getSymbolType(id->getText());
-                                    evalFCall(id->getText(), params);
+                                    if (!_analisingInitializationList) {
+                                      type = evalFCall(id->getText(), params);
+                                    } else {
+                                      type = getType(T_NULO);
+                                      std:: cerr << "illegal fcall in initlist\n";
+                                    }
                                   }
   ;
 



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:48:37 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:48:37 +0100
Subject: [gpt-commit] r388 - trunk/gpt2/gptc/src
Message-ID: <200711261248.lAQCmbGe007755@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:48:37 +0100 (Mon, 26 Nov 2007)
New Revision: 388

Modified:
   trunk/gpt2/gptc/src/PortugolAST.cpp
   trunk/gpt2/gptc/src/PortugolAST.hpp
Log:
-Adicionado informacao de tipo para os nodes

Modified: trunk/gpt2/gptc/src/PortugolAST.cpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.cpp	2007-11-26 12:48:04 UTC (rev 387)
+++ trunk/gpt2/gptc/src/PortugolAST.cpp	2007-11-26 12:48:37 UTC (rev 388)
@@ -20,24 +20,25 @@
 
 
 #include "PortugolAST.hpp"
+#include "Types.hpp"
 #include <sstream>
 
 const char* const PortugolAST::TYPE_NAME = "PortugolAST";
 
 PortugolAST::PortugolAST()
-    : CommonAST(), line(-1) {
+    : CommonAST(), line(-1), type(0) {
 }
 
 PortugolAST::PortugolAST(RefToken t)
-    : CommonAST(t), line(t->getLine()) {
+    : CommonAST(t), line(t->getLine()), type(0) {
 }
 
 PortugolAST::PortugolAST( const CommonAST& other )
-    : CommonAST(other), line(-1) {
+    : CommonAST(other), line(-1), type(0) {
 }
 
 PortugolAST::PortugolAST( const PortugolAST& other )
-    : CommonAST(other), line(other.line) {
+    : CommonAST(other), line(other.line), type(0) {
 }
 
 PortugolAST::~PortugolAST() {
@@ -68,12 +69,24 @@
   return line;
 }
 
-// std::string PortugolAST::toString() const {
-//   std::stringstream s;
-//   s << "(" << getLine() << ")" << getText();
-//   return s.str();
-// }
+void PortugolAST::setEvalType(Type* t) {
+  type = t;
+}
 
+Type* PortugolAST::getEvalType() {
+  return type;
+}
+
+
+std::string PortugolAST::toString() const {
+  std::stringstream s;
+  s << getText();
+  if (type) {
+    s << ":" << type->name();
+  }
+  return s.str();
+}
+
 RefAST PortugolAST::factory() {
   return RefAST(new PortugolAST);
 }

Modified: trunk/gpt2/gptc/src/PortugolAST.hpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.hpp	2007-11-26 12:48:04 UTC (rev 387)
+++ trunk/gpt2/gptc/src/PortugolAST.hpp	2007-11-26 12:48:37 UTC (rev 388)
@@ -27,6 +27,8 @@
 using namespace std;
 using namespace antlr;
 
+class Type;
+
 class PortugolAST : public CommonAST {
 public:
   PortugolAST();
@@ -39,18 +41,22 @@
   void setLine(int line);
   int getLine() const;
 
+  void setEvalType(Type*);
+  Type* getEvalType();
+
   virtual RefAST clone( void ) const;
 
   virtual void initialize( RefToken t );
 
   virtual const char* typeName( void ) const;
 
-//   virtual std::string toString() const;
+  virtual std::string toString() const;
 
   static RefAST factory();
   static const char* const TYPE_NAME;
 protected:
-  int line;
+  int   line;
+  Type* type;
   int endLine;
   int eval_type; //evaluated type of expression
   string filename;



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:49:04 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:49:04 +0100
Subject: [gpt-commit] r389 - trunk/gpt2/gptc/src
Message-ID: <200711261249.lAQCn4Lf007808@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:49:04 +0100 (Mon, 26 Nov 2007)
New Revision: 389

Modified:
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
Log:
-Atualizacao em relacao as modificacoes em Types.?pp
-Adicao do createAnonymousStruct

Modified: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-26 12:48:37 UTC (rev 388)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-26 12:49:04 UTC (rev 389)
@@ -10,41 +10,45 @@
 void SymbolTable::setScope(const std::string& scope) {
   _scope = scope;
 }
+
 void SymbolTable::setGlobalScope() {
   _scope = "@global";
 }
 
 Type* SymbolTable::getType(const std::string& name) {
-  Type* ret = _types.find(name);
+  TypeList::iterator ret = _types.find(name);
 
-  if (ret == 0) {
+  if (ret == _types.end()) {
     throw UndeclaredTypeException(name);
   }
 
-  return ret;
+  return *ret;
 }
 
 Type* SymbolTable::getType(int id) {
-  Type* ret = _types.find(id);
+  TypeList::iterator ret = _types.find(id);
 
-  if (ret == 0) {
+  if (ret == _types.end()) {
     throw UndeclaredTypeException(id);
   }
 
-  return ret;
+  return *ret;
 }
 
 Type* SymbolTable::retrieveMatrixType(Type *ofType, int dimensions) {
-  Type* t = _types.find(ofType, dimensions);
-  if (t == 0) {
-    t = new MatrixType(ofType, dimensions);
-    _types.push_back(t);
+  TypeList::iterator it = _types.find(ofType, dimensions);
+  Type* type;
+  if (it == _types.end()) {
+    type = new MatrixType(ofType, dimensions);
+    _types.push_back(type);
+  } else {
+    type = *it;
   }
-  return t;
+  return type;
 }
 
 Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
-                int line, const std::string& scope,
+                const std::string& scope, int line,
                 bool isConst, bool isRef) {
   return Symbol(name, type, line, _unit, scope, isConst, isRef);
 }
@@ -62,13 +66,19 @@
     throw RedeclarationException(*dup);
   }
 
-  if (_types.find(name) != 0) {
+  if (_types.find(name) != _types.end()) {
     throw RedefinedTypeException(name);
   }
   _types.push_back(new StructType(name,
       symbolList.toStructFieldList(), _unit, line));
 }
 
+StructType* SymbolTable::createAnonymousStruct(const SymbolList& symbolList) {
+  StructType* ret = new StructType(symbolList.toStructFieldList());
+  _types.push_back(ret);
+  return ret;
+}
+
 bool SymbolTable::declared(const Symbol& s) {
   return _table[_scope].count(s.lexeme()) >= 1;
 }
@@ -81,9 +91,9 @@
 }
 
 void SymbolTable::declare(const SymbolList& params,
-                          const std::string& scope) {
+                          const std::string& proc) {
   try {
-    setScope(scope);
+    setScope(proc);
     for (SymbolList::const_iterator it = params.begin(); it != params.end(); ++it) {
       declare(*it);
     }
@@ -111,13 +121,15 @@
 
 void SymbolTable::dump() {
 
-  std::cerr << "Ids...\n";
+  std::cerr << "=== SymbolTable ===\n";
+  std::cerr << "Identifiers ...\n";
   std::map<std::string, SymbolList>::iterator it;
   for (it = _table.begin(); it != _table.end(); ++it) {
     std::cerr << it->second.toString() << std::endl;
   }
   std::cerr << "Types ... " << std::endl;
   std::cerr << _types.toString() << std::endl;
+  std::cerr << "=== End SymbolTable ===\n\n";
 }
 
 

Modified: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-26 12:48:37 UTC (rev 388)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-26 12:49:04 UTC (rev 389)
@@ -25,21 +25,23 @@
   Type* retrieveMatrixType(Type *ofType, int dimensions);
 
   Symbol newSymbol(const std::string& name, Type* type,
-                   int line, const std::string& scope,
+                   const std::string& scope, int line = -1,
                    bool isConst = false, bool isRef = false);
 
   Symbol newSymbol(const std::string& name, Type* type,
-                   int line, bool isConst = false, bool isRef = false);
+                   int line = -1, bool isConst = false, bool isRef = false);
 
   void defineStruct(const std::string& name,
                    const SymbolList& symbolList,
                    int line);
 
+  StructType* createAnonymousStruct(const SymbolList& symbolList);
+
   bool declared(const Symbol& s);
 
   void declare(const Symbol& symbol);
 
-  void declare(const SymbolList& params, const std::string& scope);
+  void declare(const SymbolList& params, const std::string& proc);
 
   const Symbol& getSymbol(const std::string& lexeme);
 



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:49:25 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:49:25 +0100
Subject: [gpt-commit] r390 - trunk/gpt2/gptc/src
Message-ID: <200711261249.lAQCnPj3007867@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:49:24 +0100 (Mon, 26 Nov 2007)
New Revision: 390

Modified:
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
Log:
-Adicao geral de metodos de avaliacao de tipos

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-11-26 12:49:04 UTC (rev 389)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-11-26 12:49:24 UTC (rev 390)
@@ -3,43 +3,48 @@
 
 Type::~Type() {}
 
-
 //------------------------------------------------------------------
 
 
-Type* TypeList::find(const std::string& lexeme) const {
-  const_iterator it;
+TypeList::iterator TypeList::find(const std::string& lexeme) {
+  iterator it;
 
   for (it = begin(); it != end(); ++it) {
     if ((*it)->name() == lexeme) {
-      return *it;
+      return it;
     }
   }
-  return 0;
+  return end();
 }
 
-Type* TypeList::find(Type* ofType, int dimensions) const {
-  const_iterator it;
+TypeList::iterator TypeList::find(Type* ofType, int dimensions) {
+  iterator it;
 
   for (it = begin(); it != end(); ++it) {
     if ((*it)->equals(ofType, dimensions)) {
-      return *it;
+      return it;
     }
   }
-  return 0;
+  return end();
 }
 
-Type* TypeList::find(int id) const {
-  const_iterator it;
+TypeList::iterator TypeList::find(int id) {
+  iterator it;
 
   for (it = begin(); it != end(); ++it) {
     if ((*it)->equals(id)) {
-      return *it;
+      return it;
     }
   }
-  return 0;
+  return end();
 }
 
+// void TypeList::push_back(const TypeList& other) {
+//   for (iterator it = other.begin(); it != other.end(); ++it) {
+//     push_back(*it);
+//   }
+// }
+
 std::string TypeList::toString() const {
   std::string ret = "";
   const_iterator it;
@@ -61,14 +66,98 @@
   return _name;
 }
 
-bool PrimitiveType::equals(Type* ofType, int dimensions) const {
-  return false;
+bool PrimitiveType::equals(const Type* other) const {
+  other->_equals(this);
 }
 
 bool PrimitiveType::equals(int id) const {
   return _id == id;
 }
 
+bool PrimitiveType::equals(Type* ofType, int dimensions) const {
+  return false;
+}
+
+bool PrimitiveType::_equals(const PrimitiveType* other) const {
+  return other->_id == _id;
+}
+
+bool PrimitiveType::_equals(const MatrixType*) const {
+  return false;
+}
+
+bool PrimitiveType::_equals(const StructType*) const {
+  return false;
+}
+
+bool PrimitiveType::_equals(const SubprogramType*) const {
+  return false;
+}
+
+bool PrimitiveType::isPrimitive() const {
+  return true;
+}
+
+Type* PrimitiveType::numPromotionWith(Type* other) {
+  if ((_id == PortugolTokenTypes::T_INTEIRO)
+       &&
+      (other->equals(PortugolTokenTypes::T_INTEIRO) ||
+       other->equals(PortugolTokenTypes::T_REAL))) {
+    return other;
+  } else if ((_id == PortugolTokenTypes::T_REAL)
+              &&
+             (other->equals(PortugolTokenTypes::T_INTEIRO) ||
+              other->equals(PortugolTokenTypes::T_REAL))) {
+    return this;
+  }
+
+  return NULL;
+}
+
+Type* PrimitiveType::litPromotionWith(Type* other) {
+  if ((_id == PortugolTokenTypes::T_LITERAL)
+       &&
+      (other->equals(PortugolTokenTypes::T_LITERAL) ||
+       other->equals(PortugolTokenTypes::T_CARACTERE))) {
+    return this;
+  } else if (other->equals(PortugolTokenTypes::T_LITERAL)
+              &&
+             ((_id == PortugolTokenTypes::T_CARACTERE) ||
+              (_id == PortugolTokenTypes::T_LITERAL))) {
+    return other;
+  }
+
+  return NULL;
+}
+
+bool PrimitiveType::isLValueFor(Type* rtype) {
+  rtype->isRValueFor(this);
+}
+
+bool PrimitiveType::isRValueFor(PrimitiveType* lvalue) {
+  if (lvalue->equals(this)) {
+    return true;
+  }
+
+  if (lvalue->equals(PortugolTokenTypes::T_REAL) &&
+      _id == PortugolTokenTypes::T_INTEIRO) {
+    return true;
+  }
+  return false;
+}
+
+bool PrimitiveType::isRValueFor(MatrixType*) {
+  return false;
+}
+
+bool PrimitiveType::isRValueFor(StructType*) {
+  return false;
+}
+
+bool PrimitiveType::isRValueFor(SubprogramType*) {
+  return false;
+}
+
 //------------------------------------------------------------------
 
 
@@ -86,14 +175,84 @@
   return ret;
 }
 
+const Type* MatrixType::ofType() const {
+  return _ofType;
+}
+
+int MatrixType::dimensions() const {
+  return _dimensions;
+}
+
+bool MatrixType::equals(const Type* other) const {
+  other->_equals(this);
+}
+
+bool MatrixType::equals(int id) const {
+  return false;
+}
+
 bool MatrixType::equals(Type* ofType, int dimensions) const {
   return (ofType == _ofType) && (dimensions == _dimensions);
 }
 
-bool MatrixType::equals(int id) const {
+bool MatrixType::_equals(const PrimitiveType*) const {
   return false;
 }
 
+bool MatrixType::_equals(const MatrixType* other) const {
+  return (other->_ofType == _ofType) && (other->_dimensions == _dimensions);
+}
+
+bool MatrixType::_equals(const StructType*) const {
+  return false;
+}
+
+bool MatrixType::_equals(const SubprogramType*) const {
+  return false;
+}
+
+bool MatrixType::isPrimitive() const {
+  return false;
+}
+
+Type* MatrixType::numPromotionWith(Type*) {
+  return NULL;
+}
+
+Type* MatrixType::litPromotionWith(Type*) {
+  return NULL;
+}
+
+bool MatrixType::isLValueFor(Type* rtype) {
+  rtype->isRValueFor(this);
+}
+
+bool MatrixType::isRValueFor(PrimitiveType*) {
+  return false;
+}
+
+bool MatrixType::isRValueFor(MatrixType* lvalue) {
+  if (_equals(lvalue)) {
+    return true;
+  }
+
+  if ((lvalue->dimensions() == dimensions()) &&
+      lvalue->ofType()->equals(PortugolTokenTypes::T_REAL) &&
+      _ofType->equals(PortugolTokenTypes::T_INTEIRO)) {
+    return true;
+  }
+
+  return false;
+}
+
+bool MatrixType::isRValueFor(StructType*) {
+  return false;
+}
+
+bool MatrixType::isRValueFor(SubprogramType*) {
+  return false;
+}
+
 //------------------------------------------------------------------
 
 
@@ -103,7 +262,11 @@
 }
 
 
-const std::list<StructType::Field>& StructType::fields() {
+StructType::StructType(const std::list<Field>& fields)
+  : _name("<anonymous>"), _fields(fields), _unit("<intern>"), _line(-1) {
+}
+
+const std::list<StructType::Field>& StructType::fields() const {
   return _fields;
 }
 
@@ -111,13 +274,70 @@
   return _name;
 }
 
+bool StructType::equivalent(Type* other) {
+
+}
+
+bool StructType::equals(const Type* other) const {
+  other->_equals(this);
+}
+
+bool StructType::equals(int id) const {
+  return false;
+}
+
 bool StructType::equals(Type* ofType, int dimensions) const {
   return false;
 }
 
-bool StructType::equals(int id) const {
+bool StructType::_equals(const PrimitiveType*) const {
   return false;
 }
+
+bool StructType::_equals(const MatrixType*) const {
+  return false;
+}
+
+bool StructType::_equals(const StructType* other) const {
+  return _name == other->_name;
+}
+
+bool StructType::_equals(const SubprogramType*) const {
+  return false;
+}
+
+bool StructType::isPrimitive() const {
+  return false;
+}
+
+Type* StructType::numPromotionWith(Type*) {
+  return NULL;
+}
+
+Type* StructType::litPromotionWith(Type*) {
+  return NULL;
+}
+
+bool StructType::isLValueFor(Type* rtype) {
+  rtype->isRValueFor(this);
+}
+
+bool StructType::isRValueFor(PrimitiveType*) {
+  return false;
+}
+
+bool StructType::isRValueFor(MatrixType*) {
+  return false;
+}
+
+bool StructType::isRValueFor(StructType* other) {
+  return _equals(other);
+}
+
+bool StructType::isRValueFor(SubprogramType*) {
+  return false;
+}
+
 //------------------------------------------------------------------
 
 
@@ -139,10 +359,63 @@
   return ret;
 }
 
-bool SubprogramType::equals(Type* ofType, int dimensions) const {
-  return false;
+bool SubprogramType::equals(const Type* other) const {
+  other->_equals(this);
 }
 
 bool SubprogramType::equals(int id) const {
   return false;
 }
+
+bool SubprogramType::equals(Type*, int) const {
+  return false;
+}
+
+bool SubprogramType::_equals(const PrimitiveType*) const {
+  return false;
+}
+
+bool SubprogramType::_equals(const MatrixType*) const {
+  return false;
+}
+
+bool SubprogramType::_equals(const StructType*) const {
+  return false;
+}
+
+bool SubprogramType::_equals(const SubprogramType* other) const {
+  return (_paramTypes == other->_paramTypes) &&
+         (_returnType == other->_returnType);
+}
+
+bool SubprogramType::isPrimitive() const {
+  return false;
+}
+
+Type* SubprogramType::numPromotionWith(Type*) {
+  return NULL;
+}
+
+Type* SubprogramType::litPromotionWith(Type*) {
+  return NULL;
+}
+
+bool SubprogramType::isLValueFor(Type*) {
+  return false;
+}
+
+bool SubprogramType::isRValueFor(PrimitiveType*) {
+  return false;
+}
+
+bool SubprogramType::isRValueFor(MatrixType*) {
+  return false;
+}
+
+bool SubprogramType::isRValueFor(StructType*) {
+  return false;
+}
+
+bool SubprogramType::isRValueFor(SubprogramType*) {
+  return false;
+}

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-11-26 12:49:04 UTC (rev 389)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-11-26 12:49:24 UTC (rev 390)
@@ -4,31 +4,55 @@
 #include <string>
 #include <list>
 
+class PrimitiveType;
+class MatrixType;
+class StructType;
+class SubprogramType;
+
+
 class Type {
 public:
   virtual ~Type();
   virtual std::string name() const = 0;
 
+  virtual bool equals(const Type*) const = 0;
+  virtual bool equals(int id) const = 0;
   virtual bool equals(Type* ofType, int dimensions) const = 0;
-  virtual bool equals(int id) const = 0;
+
+  virtual bool _equals(const PrimitiveType*) const = 0;
+  virtual bool _equals(const MatrixType*) const = 0;
+  virtual bool _equals(const StructType*) const = 0;
+  virtual bool _equals(const SubprogramType*) const = 0;
+
+  virtual bool  isPrimitive() const = 0;
+
+  virtual Type* numPromotionWith(Type*) = 0;
+  virtual Type* litPromotionWith(Type*) = 0;
+
+  virtual bool isLValueFor(Type*) = 0;
+
+  virtual bool isRValueFor(PrimitiveType*) = 0;
+  virtual bool isRValueFor(MatrixType*) = 0;
+  virtual bool isRValueFor(StructType*) = 0;
+  virtual bool isRValueFor(SubprogramType*) = 0;
 };
 
 
-
 class TypeList : public std::list<Type*> {
 public:
 
-  Type* find(const std::string& lexeme) const;
+  iterator find(const std::string& lexeme);
 
-  Type* find(Type* ofType, int dimensions) const;
+  iterator find(Type* ofType, int dimensions);
 
-  Type* find(int id) const;
+  iterator find(int id);
 
+//   void push_back(const TypeList&);
+
   std::string toString() const;
 };
 
 
-
 class PrimitiveType : public Type {
 public:
   PrimitiveType(int id, const std::string& name);
@@ -36,9 +60,24 @@
   int id();
   virtual std::string name() const;
 
+  virtual bool equals(const Type*) const;
+  virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
-  virtual bool equals(int id) const;
 
+  virtual bool _equals(const PrimitiveType*) const;
+  virtual bool _equals(const MatrixType*) const;
+  virtual bool _equals(const StructType*) const;
+  virtual bool _equals(const SubprogramType*) const;
+
+  virtual bool isPrimitive() const;
+  virtual Type* numPromotionWith(Type*);
+  virtual Type* litPromotionWith(Type*);
+
+  virtual bool isLValueFor(Type*);
+  virtual bool isRValueFor(PrimitiveType*);
+  virtual bool isRValueFor(MatrixType*);
+  virtual bool isRValueFor(StructType*);
+  virtual bool isRValueFor(SubprogramType*);
 private:
   int         _id;
   std::string _name;
@@ -51,13 +90,29 @@
 public:
   MatrixType(Type* ofType, int dimensions);
 
-  const Type*         ofType();
-  int                 dimensions();
+  const Type*         ofType() const;
+  int                 dimensions() const;
 
   virtual std::string name() const;
 
+  virtual bool equals(const Type*) const;
+  virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
-  virtual bool equals(int id) const;
+
+  virtual bool _equals(const PrimitiveType*) const;
+  virtual bool _equals(const MatrixType*) const;
+  virtual bool _equals(const StructType*) const;
+  virtual bool _equals(const SubprogramType*) const;
+
+  virtual bool isPrimitive() const;
+  virtual Type* numPromotionWith(Type*);
+  virtual Type* litPromotionWith(Type*);
+
+  virtual bool isLValueFor(Type*);
+  virtual bool isRValueFor(PrimitiveType*);
+  virtual bool isRValueFor(MatrixType*);
+  virtual bool isRValueFor(StructType*);
+  virtual bool isRValueFor(SubprogramType*);
 private:
   Type          *_ofType;
   int           _dimensions;
@@ -78,13 +133,32 @@
   StructType(const std::string& name, const std::list<Field>& fields,
              const std::string& unit, int line);
 
-  const std::list<Field>& fields();
+  StructType(const std::list<Field>& fields);
 
+  const std::list<Field>& fields() const;
+
+  bool equivalent(Type*);
+
   virtual std::string name() const;
 
+  virtual bool equals(const Type*) const;
+  virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
-  virtual bool equals(int id) const;
+  //virtual bool equals(list<Field> fields)
+  virtual bool _equals(const PrimitiveType*) const;
+  virtual bool _equals(const MatrixType*) const;
+  virtual bool _equals(const StructType*) const;
+  virtual bool _equals(const SubprogramType*) const;
 
+  virtual bool isPrimitive() const;
+  virtual Type* numPromotionWith(Type*);
+  virtual Type* litPromotionWith(Type*);
+
+  virtual bool isLValueFor(Type*);
+  virtual bool isRValueFor(PrimitiveType*);
+  virtual bool isRValueFor(MatrixType*);
+  virtual bool isRValueFor(StructType*);
+  virtual bool isRValueFor(SubprogramType*);
 private:
   std::string      _name;
   std::list<Field> _fields;
@@ -99,10 +173,24 @@
 
   virtual std::string name() const;
 
-
+  virtual bool equals(const Type*) const;
+  virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
-  virtual bool equals(int id) const;
 
+  virtual bool _equals(const PrimitiveType*) const;
+  virtual bool _equals(const MatrixType*) const;
+  virtual bool _equals(const StructType*) const;
+  virtual bool _equals(const SubprogramType*) const;
+
+  virtual bool isPrimitive() const;
+  virtual Type* numPromotionWith(Type*);
+  virtual Type* litPromotionWith(Type*);
+
+  virtual bool isLValueFor(Type*);
+  virtual bool isRValueFor(PrimitiveType*);
+  virtual bool isRValueFor(MatrixType*);
+  virtual bool isRValueFor(StructType*);
+  virtual bool isRValueFor(SubprogramType*);
 private:
   TypeList         _paramTypes;
   Type*            _returnType;



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:50:34 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:50:34 +0100
Subject: [gpt-commit] r391 - trunk/gpt2/gptc/src
Message-ID: <200711261250.lAQCoY5E007981@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:50:34 +0100 (Mon, 26 Nov 2007)
New Revision: 391

Modified:
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
Log:
DEVNULL:-Pequena limpeza de codigo

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-11-26 12:49:24 UTC (rev 390)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-11-26 12:50:34 UTC (rev 391)
@@ -32,14 +32,13 @@
   if (_type) {
     ret += _type->name();
   }
-  ret += " {";
+  ret += " - ";
   if (_isConst) {
     ret += "c";
   }
   if (_isRef) {
     ret += "r";
   }
-  ret += "}";
   return ret;
 }
 
@@ -48,7 +47,7 @@
 
 
 SymbolList::const_iterator SymbolList::duplicated() const {
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     if (count((*it).lexeme()) > 1) {
       return it;
     }
@@ -59,7 +58,7 @@
 std::list<StructType::Field> SymbolList::toStructFieldList() const {
   std::list<StructType::Field> fields;
 
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     fields.push_back(StructType::Field((*it).lexeme(), (*it).type()));
   }
   return fields;
@@ -68,7 +67,7 @@
 TypeList SymbolList::toTypeList() const {
   TypeList list;
 
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     list.push_back((*it).type());
   }
   return list;
@@ -76,7 +75,7 @@
 
 int SymbolList::count(const std::string& lexeme) const {
   int ret = 0;
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     if ((*it).lexeme() == lexeme) {
       ret++;
     }
@@ -84,8 +83,8 @@
   return ret;
 }
 
-SymbolList::const_iterator SymbolList::find(const std::string& lexeme) const {
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+SymbolList::iterator SymbolList::find(const std::string& lexeme) {
+  for (iterator it = begin(); it != end(); ++it) {
     if ((*it).lexeme() == lexeme) {
       return it;
     }
@@ -95,9 +94,8 @@
 
 std::string SymbolList::toString() const {
   std::string ret = "";
-  for (SymbolList::const_iterator it = begin(); it != end(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     ret += (*it).toString() + "\n";
   }
   return ret;
 }
-

Modified: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-11-26 12:49:24 UTC (rev 390)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-11-26 12:50:34 UTC (rev 391)
@@ -45,7 +45,7 @@
 
   int count(const std::string& lexeme) const;
 
-  const_iterator find(const std::string& lexeme) const;
+  iterator find(const std::string& lexeme);
 
   std::string toString() const;
 };



From gpt-commit-noreply at mail.berlios.de  Mon Nov 26 13:50:51 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Mon, 26 Nov 2007 13:50:51 +0100
Subject: [gpt-commit] r392 - trunk/gpt2/gptc/src
Message-ID: <200711261250.lAQCopKT008011@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-26 13:50:51 +0100 (Mon, 26 Nov 2007)
New Revision: 392

Modified:
   trunk/gpt2/gptc/src/teste.cpp
Log:
nomsg

Modified: trunk/gpt2/gptc/src/teste.cpp
===================================================================
--- trunk/gpt2/gptc/src/teste.cpp	2007-11-26 12:50:34 UTC (rev 391)
+++ trunk/gpt2/gptc/src/teste.cpp	2007-11-26 12:50:51 UTC (rev 392)
@@ -52,6 +52,7 @@
   }
 
   if (should_dump) {
+    std::cerr << "parser.g AST:\n";
     std::cerr << cast->toStringList() << std::endl << std::endl;
   }
   return cast;
@@ -68,6 +69,9 @@
   semantic.programa(ast);
 
   symtable->dump();
+
+  std::cerr << "semantic.g AST:\n";
+  std::cerr << ast->toStringList() << std::endl << std::endl;
 }
 
 int main(int argc, char** argv) {



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 04:05:16 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 04:05:16 +0100
Subject: [gpt-commit] r393 - trunk/gpt2/gptc/src
Message-ID: <200711270305.lAR35GVR001841@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-27 04:05:16 +0100 (Tue, 27 Nov 2007)
New Revision: 393

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
Log:
-Aperfeicoamento na deteccao de matrizes com tipos heterogeneos
-Checando se os tipos sao primitivos em diversas operacoes

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-26 12:50:51 UTC (rev 392)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-27 03:05:16 UTC (rev 393)
@@ -106,28 +106,31 @@
   //TODO
   //-proibicao de consts como lvalues em expressoes
 
-void BaseSemanticWalker::evalAttribution(Type* ltype, Type* rtype) {
+Type* BaseSemanticWalker::evalAttribution(Type* ltype, Type* rtype) {
   if (!ltype->isLValueFor(rtype)) {
     std::cerr << "ilegal: "
               << ltype->name() << " := " << rtype->name() << endl;
   }
+  return rtype;
 }
 
-void BaseSemanticWalker::evalAttribution(Type* ltype, const InitMatrixList& mtx) {
+Type* BaseSemanticWalker::evalAttribution(Type* ltype, const InitMatrixList& mtx) {
   Type* rtype = evalHomogeneity(mtx);
   if (!ltype->isLValueFor(rtype)) {
     std::cerr << "ilegal: "
               << ltype->name() << " := " << rtype->name() << endl;
   }
+  return ltype;
 }
 
-void BaseSemanticWalker::evalAttribution(Type* ltype, const InitStructList& stc) {
+Type* BaseSemanticWalker::evalAttribution(Type* ltype, const InitStructList& stc) {
   StructType* rtype = createAnonymousStructFor(stc);
 
   if (!ltype->isLValueFor(rtype)) {
     std::cerr << "ilegal: "
               << ltype->name() << " := " << rtype->name() << endl;
   }
+  return ltype;
 }
 
 StructType* BaseSemanticWalker::createAnonymousStructFor(const InitStructList& stc) {
@@ -142,25 +145,28 @@
 
 Type* BaseSemanticWalker::evalHomogeneity(const InitMatrixList& mtx) {
   InitMatrixList::const_iterator it;
+
+  Type *rtype = 0;
+  Type *tmptype = 0;
   int dim = 0;
-  Type* type = 0;
+
   for (it = mtx.begin(); it != mtx.end(); ++it) {
     if (dim == 0) {
       dim = it->first;
     } else if (dim != it->first) {
-      std::cerr << "err: Numero variavel de dimensoes na matriz!\n";
+      std::cerr << "ilegal: Numero variavel de dimensoes na matriz!\n";
     }
 
-    if (type == 0) {
-      type = it->second;
-    } else if (!type->equals(it->second)) {
-      std::cerr << "err: Numero variavel de tipos na matriz!\n";
+    if (rtype == 0) {
+      rtype = it->second;
+    } else if (!rtype->compatible(it->second)) {
+      std::cerr << "ilegal: Matriz heterogenea\n";
     }
   }
-  return _symtable->retrieveMatrixType(type, dim);
+
+  return _symtable->retrieveMatrixType(rtype, dim);
 }
 
-
 Type*
 BaseSemanticWalker::evalExpr_OU(Type* left, Type* right) {
   return _symtable->getType(PortugolTokenTypes::T_LOGICO);
@@ -316,6 +322,12 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MAIS(Type* left, Type* right) {
+  if (!left->isPrimitive() || !right->isPrimitive()) {
+    std::cerr << "ilegal: "
+              << left->name() << " + " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+
   Type* ret;
   if (ret = left->numPromotionWith(right)) {
     return ret;
@@ -331,6 +343,12 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MENOS(Type* left, Type* right) {
+  if (!left->isPrimitive() || !right->isPrimitive()) {
+    std::cerr << "ilegal: "
+              << left->name() << " + " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+
   Type* ret;
   if (ret = left->numPromotionWith(right)) {
     return ret;
@@ -344,6 +362,12 @@
 
 Type*
 BaseSemanticWalker::evalExpr_DIV(Type* left, Type* right) {
+  if (!left->isPrimitive() || !right->isPrimitive()) {
+    std::cerr << "ilegal: "
+              << left->name() << " + " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+
   Type* ret;
   if (ret = left->numPromotionWith(right)) {
     return ret;
@@ -357,6 +381,12 @@
 
 Type*
 BaseSemanticWalker::evalExpr_MULTIP(Type* left, Type* right) {
+  if (!left->isPrimitive() || !right->isPrimitive()) {
+    std::cerr << "ilegal: "
+              << left->name() << " + " << right->name() << std::endl;
+    return _symtable->getType(PortugolTokenTypes::T_NULO);
+  }
+
   Type* ret;
   if (ret = left->numPromotionWith(right)) {
     return ret;

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-26 12:50:51 UTC (rev 392)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-27 03:05:16 UTC (rev 393)
@@ -38,48 +38,6 @@
 typedef std::list<std::pair<std::string,Type*> > InitStructList;
 typedef std::list<std::pair<int,Type*> >         InitMatrixList;
 
-/*struct InitValue {
-  enum { PRIMITIVE, MATRIX, STRUCT };
-  int id;
-  Type* primtype;
-  std::list<InitValue> mvalues;
-  std::list<pair<std::string, InitValue> > svalues;
-*/
-//   Type* calculatedType(const SymbolTable& symtable) {
-//     std::list<InitValue>::iterator it;
-//     Type *type = 0;
-//
-//     switch (id) {
-//       case PRIMITIVE:
-//         return primtype;
-//       case MATRIX:
-//         for (it = list.begin(); it != list.end(); ++it) {
-//           if (!type) {
-//             type = (*it).calculatedType(symtable);
-//           } else {
-//             type = type;
-//           }
-//         }
-//     }
-//
-//     TypeList types;
-//     Type *ret;
-//     std::list<InitValue>::iterator it;
-//     for (it = list.begin(); it != list.end(); ++it) {
-//       switch ((*it).id) {
-//         case PRIMITIVE:
-//           types.push_back((*it).primtype);
-//           break;
-//         case MATRIX:
-//           types.push_back(
-//       }
-//     }
-//   }
-// };
-
-
-
-
 class BaseSemanticWalker : public antlr::TreeParser {
 
 public:
@@ -105,13 +63,13 @@
 
   void evalMatrixSubscript(Type*);
 
-  void evalAttribution(Type*, Type*);
-  void evalAttribution(Type*, const InitMatrixList&);
-  void evalAttribution(Type*, const InitStructList&);
+  Type* evalAttribution(Type*, Type*);
+  Type* evalAttribution(Type*, const InitMatrixList&);
+  Type* evalAttribution(Type*, const InitStructList&);
 
   StructType* createAnonymousStructFor(const InitStructList&);
 
-  Type* evalHomogeneity(const InitMatrixList&);
+  Type* evalHomogeneity(const InitMatrixList& mtx);
 
   Type* evalExpr_OU(Type* left, Type* right);
   Type* evalExpr_E(Type* left, Type* right);



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 04:05:35 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 04:05:35 +0100
Subject: [gpt-commit] r394 - trunk/gpt2/gptc/src
Message-ID: <200711270305.lAR35ZWg001873@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-27 04:05:35 +0100 (Tue, 27 Nov 2007)
New Revision: 394

Modified:
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
Log:
-Atualizacao de nomes de tipos, de acordo com modificacoes em Types.hpp

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-11-27 03:05:16 UTC (rev 393)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-11-27 03:05:35 UTC (rev 394)
@@ -55,8 +55,8 @@
   return end();
 }
 
-std::list<StructType::Field> SymbolList::toStructFieldList() const {
-  std::list<StructType::Field> fields;
+StructType::FieldList SymbolList::toStructFieldList() const {
+  StructType::FieldList fields;
 
   for (const_iterator it = begin(); it != end(); ++it) {
     fields.push_back(StructType::Field((*it).lexeme(), (*it).type()));

Modified: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-11-27 03:05:16 UTC (rev 393)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-11-27 03:05:35 UTC (rev 394)
@@ -39,7 +39,7 @@
 public:
   const_iterator duplicated() const;
 
-  std::list<StructType::Field> toStructFieldList() const;
+  StructType::FieldList toStructFieldList() const;
 
   TypeList toTypeList() const;
 



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 04:06:13 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 04:06:13 +0100
Subject: [gpt-commit] r395 - trunk/gpt2/gptc/src
Message-ID: <200711270306.lAR36D4i001924@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-27 04:06:10 +0100 (Tue, 27 Nov 2007)
New Revision: 395

Modified:
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
Log:
-Adicao dos metodos compatible para checar a interoperabilidade entre tipos em uma atribuicao (especialmente util em casos que misturam os tipos inteiro e real).
-Permitindo valores nulos como rvalues para tipos compostos.
-Fix em MatrixType::equals (comparacao de ofType's)
-Correcao do MatrixType::_isRValueFor(MatrixType*), levando em consideracao promocoes de tipo.
-Permitindo criacao de estruturas anonymas para ajudar na analise semantica
-Adicao do tipo FieldList para StructType

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-11-27 03:05:35 UTC (rev 394)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-11-27 03:06:10 UTC (rev 395)
@@ -66,6 +66,27 @@
   return _name;
 }
 
+bool PrimitiveType::compatible(Type* other) {
+  other->_compatible(this);
+}
+
+bool PrimitiveType::_compatible(PrimitiveType* other) {
+  return _equals(other) || numPromotionWith(other);
+}
+
+bool PrimitiveType::_compatible(MatrixType*) {
+  return false;
+}
+
+bool PrimitiveType::_compatible(StructType*) {
+  return false;
+}
+
+bool PrimitiveType::_compatible(SubprogramType*) {
+  return false;
+}
+
+
 bool PrimitiveType::equals(const Type* other) const {
   other->_equals(this);
 }
@@ -131,10 +152,10 @@
 }
 
 bool PrimitiveType::isLValueFor(Type* rtype) {
-  rtype->isRValueFor(this);
+  rtype->_isRValueFor(this);
 }
 
-bool PrimitiveType::isRValueFor(PrimitiveType* lvalue) {
+bool PrimitiveType::_isRValueFor(PrimitiveType* lvalue) {
   if (lvalue->equals(this)) {
     return true;
   }
@@ -146,15 +167,21 @@
   return false;
 }
 
-bool PrimitiveType::isRValueFor(MatrixType*) {
+bool PrimitiveType::_isRValueFor(MatrixType*) {
+  if (_id == PortugolTokenTypes::T_NULO) {
+    return true;
+  }
   return false;
 }
 
-bool PrimitiveType::isRValueFor(StructType*) {
+bool PrimitiveType::_isRValueFor(StructType*) {
+  if (_id == PortugolTokenTypes::T_NULO) {
+    return true;
+  }
   return false;
 }
 
-bool PrimitiveType::isRValueFor(SubprogramType*) {
+bool PrimitiveType::_isRValueFor(SubprogramType*) {
   return false;
 }
 
@@ -183,6 +210,27 @@
   return _dimensions;
 }
 
+bool MatrixType::compatible(Type* other) {
+  other->_compatible(this);
+}
+
+bool MatrixType::_compatible(PrimitiveType*) {
+  return false;
+}
+
+bool MatrixType::_compatible(MatrixType* other) {
+  return _dimensions == other->_dimensions &&
+         _ofType->compatible(other->_ofType);
+}
+
+bool MatrixType::_compatible(StructType*) {
+  return false;
+}
+
+bool MatrixType::_compatible(SubprogramType*) {
+  return false;
+}
+
 bool MatrixType::equals(const Type* other) const {
   other->_equals(this);
 }
@@ -200,7 +248,7 @@
 }
 
 bool MatrixType::_equals(const MatrixType* other) const {
-  return (other->_ofType == _ofType) && (other->_dimensions == _dimensions);
+  return (other->_ofType->equals(_ofType)) && (other->_dimensions == _dimensions);
 }
 
 bool MatrixType::_equals(const StructType*) const {
@@ -224,49 +272,44 @@
 }
 
 bool MatrixType::isLValueFor(Type* rtype) {
-  rtype->isRValueFor(this);
+  rtype->_isRValueFor(this);
 }
 
-bool MatrixType::isRValueFor(PrimitiveType*) {
+bool MatrixType::_isRValueFor(PrimitiveType*) {
   return false;
 }
 
-bool MatrixType::isRValueFor(MatrixType* lvalue) {
-  if (_equals(lvalue)) {
+bool MatrixType::_isRValueFor(MatrixType* lvalue) {
+  if ((lvalue->_dimensions == _dimensions) &&
+      lvalue->_ofType->isLValueFor(_ofType)) {
     return true;
   }
 
-  if ((lvalue->dimensions() == dimensions()) &&
-      lvalue->ofType()->equals(PortugolTokenTypes::T_REAL) &&
-      _ofType->equals(PortugolTokenTypes::T_INTEIRO)) {
-    return true;
-  }
-
   return false;
 }
 
-bool MatrixType::isRValueFor(StructType*) {
+bool MatrixType::_isRValueFor(StructType*) {
   return false;
 }
 
-bool MatrixType::isRValueFor(SubprogramType*) {
+bool MatrixType::_isRValueFor(SubprogramType*) {
   return false;
 }
 
 //------------------------------------------------------------------
 
 
-StructType::StructType(const std::string& name, const std::list<Field>& fields,
+StructType::StructType(const std::string& name, const FieldList& fields,
                        const std::string& unit, int line)
-  : _name(name), _fields(fields), _unit(unit), _line(line) {
+  : _anonymous(false), _name(name), _fields(fields), _unit(unit), _line(line) {
 }
 
 
-StructType::StructType(const std::list<Field>& fields)
-  : _name("<anonymous>"), _fields(fields), _unit("<intern>"), _line(-1) {
+StructType::StructType(const FieldList& fields)
+  : _anonymous(true), _name("<anonymous>"), _fields(fields), _unit("<intern>"), _line(-1) {
 }
 
-const std::list<StructType::Field>& StructType::fields() const {
+const StructType::FieldList& StructType::fields() const {
   return _fields;
 }
 
@@ -274,10 +317,26 @@
   return _name;
 }
 
-bool StructType::equivalent(Type* other) {
+bool StructType::compatible(Type* other) {
+  other->_compatible(this);
+}
 
+bool StructType::_compatible(PrimitiveType*) {
+  return false;
 }
 
+bool StructType::_compatible(MatrixType*) {
+  return false;
+}
+
+bool StructType::_compatible(StructType* other) {
+  return _fields.compatible(other->_fields);
+}
+
+bool StructType::_compatible(SubprogramType*) {
+  return false;
+}
+
 bool StructType::equals(const Type* other) const {
   other->_equals(this);
 }
@@ -299,7 +358,14 @@
 }
 
 bool StructType::_equals(const StructType* other) const {
-  return _name == other->_name;
+  if ((_anonymous  && other->_anonymous) ||
+      (!_anonymous && !other->_anonymous)) {
+    //comparacao estrutural
+    return _fields == other->_fields;
+  } else {
+    //comparacao nominal
+    return _name == other->_name;
+  }
 }
 
 bool StructType::_equals(const SubprogramType*) const {
@@ -319,22 +385,27 @@
 }
 
 bool StructType::isLValueFor(Type* rtype) {
-  rtype->isRValueFor(this);
+  rtype->_isRValueFor(this);
 }
 
-bool StructType::isRValueFor(PrimitiveType*) {
+bool StructType::_isRValueFor(PrimitiveType*) {
   return false;
 }
 
-bool StructType::isRValueFor(MatrixType*) {
+bool StructType::_isRValueFor(MatrixType*) {
   return false;
 }
 
-bool StructType::isRValueFor(StructType* other) {
-  return _equals(other);
+bool StructType::_isRValueFor(StructType* ltype) {
+  if (_anonymous || ltype->_anonymous) {
+    return ltype->_fields.isLValueFor(_fields);
+  } else {
+    //comparacao nominal
+    return _equals(ltype);
+  }
 }
 
-bool StructType::isRValueFor(SubprogramType*) {
+bool StructType::_isRValueFor(SubprogramType*) {
   return false;
 }
 
@@ -359,6 +430,28 @@
   return ret;
 }
 
+
+bool SubprogramType::compatible(Type* other) {
+  other->_compatible(this);
+}
+
+bool SubprogramType::_compatible(PrimitiveType*) {
+  return false;
+}
+
+bool SubprogramType::_compatible(MatrixType*) {
+  return false;
+}
+
+bool SubprogramType::_compatible(StructType*) {
+  return false;
+}
+
+bool SubprogramType::_compatible(SubprogramType*) {
+  return false;
+}
+
+
 bool SubprogramType::equals(const Type* other) const {
   other->_equals(this);
 }
@@ -404,18 +497,18 @@
   return false;
 }
 
-bool SubprogramType::isRValueFor(PrimitiveType*) {
+bool SubprogramType::_isRValueFor(PrimitiveType*) {
   return false;
 }
 
-bool SubprogramType::isRValueFor(MatrixType*) {
+bool SubprogramType::_isRValueFor(MatrixType*) {
   return false;
 }
 
-bool SubprogramType::isRValueFor(StructType*) {
+bool SubprogramType::_isRValueFor(StructType*) {
   return false;
 }
 
-bool SubprogramType::isRValueFor(SubprogramType*) {
+bool SubprogramType::_isRValueFor(SubprogramType*) {
   return false;
 }

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-11-27 03:05:35 UTC (rev 394)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-11-27 03:06:10 UTC (rev 395)
@@ -15,6 +15,12 @@
   virtual ~Type();
   virtual std::string name() const = 0;
 
+  virtual bool compatible(Type*) = 0;
+  virtual bool _compatible(PrimitiveType*) = 0;
+  virtual bool _compatible(MatrixType*) = 0;
+  virtual bool _compatible(StructType*) = 0;
+  virtual bool _compatible(SubprogramType*) = 0;
+
   virtual bool equals(const Type*) const = 0;
   virtual bool equals(int id) const = 0;
   virtual bool equals(Type* ofType, int dimensions) const = 0;
@@ -31,10 +37,10 @@
 
   virtual bool isLValueFor(Type*) = 0;
 
-  virtual bool isRValueFor(PrimitiveType*) = 0;
-  virtual bool isRValueFor(MatrixType*) = 0;
-  virtual bool isRValueFor(StructType*) = 0;
-  virtual bool isRValueFor(SubprogramType*) = 0;
+  virtual bool _isRValueFor(PrimitiveType*) = 0;
+  virtual bool _isRValueFor(MatrixType*) = 0;
+  virtual bool _isRValueFor(StructType*) = 0;
+  virtual bool _isRValueFor(SubprogramType*) = 0;
 };
 
 
@@ -60,6 +66,12 @@
   int id();
   virtual std::string name() const;
 
+  virtual bool compatible(Type*);
+  virtual bool _compatible(PrimitiveType*);
+  virtual bool _compatible(MatrixType*);
+  virtual bool _compatible(StructType*);
+  virtual bool _compatible(SubprogramType*);
+
   virtual bool equals(const Type*) const;
   virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
@@ -74,10 +86,10 @@
   virtual Type* litPromotionWith(Type*);
 
   virtual bool isLValueFor(Type*);
-  virtual bool isRValueFor(PrimitiveType*);
-  virtual bool isRValueFor(MatrixType*);
-  virtual bool isRValueFor(StructType*);
-  virtual bool isRValueFor(SubprogramType*);
+  virtual bool _isRValueFor(PrimitiveType*);
+  virtual bool _isRValueFor(MatrixType*);
+  virtual bool _isRValueFor(StructType*);
+  virtual bool _isRValueFor(SubprogramType*);
 private:
   int         _id;
   std::string _name;
@@ -95,6 +107,12 @@
 
   virtual std::string name() const;
 
+  virtual bool compatible(Type*);
+  virtual bool _compatible(PrimitiveType*);
+  virtual bool _compatible(MatrixType*);
+  virtual bool _compatible(StructType*);
+  virtual bool _compatible(SubprogramType*);
+
   virtual bool equals(const Type*) const;
   virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
@@ -109,16 +127,15 @@
   virtual Type* litPromotionWith(Type*);
 
   virtual bool isLValueFor(Type*);
-  virtual bool isRValueFor(PrimitiveType*);
-  virtual bool isRValueFor(MatrixType*);
-  virtual bool isRValueFor(StructType*);
-  virtual bool isRValueFor(SubprogramType*);
+  virtual bool _isRValueFor(PrimitiveType*);
+  virtual bool _isRValueFor(MatrixType*);
+  virtual bool _isRValueFor(StructType*);
+  virtual bool _isRValueFor(SubprogramType*);
 private:
   Type          *_ofType;
   int           _dimensions;
 };
 
-
 class StructType : public Type {
 public:
   class Field {
@@ -126,21 +143,101 @@
     Field(const std::string& n, Type* t)
       : name(n), type(t) {}
 
+    bool isLValueFor(const Field& other) const {
+      return name == other.name && type->isLValueFor(other.type);
+    }
+
+    bool compatible(const Field& other) const {
+      return name == other.name && type->compatible(other.type);
+    }
+
+    bool operator==(const Field& other) const {
+      return name == other.name && type->equals(other.type);
+    }
+
     std::string name;
     Type* type;
   };
 
-  StructType(const std::string& name, const std::list<Field>& fields,
+  class FieldList : public std::list<Field> {
+    public:
+
+    bool compatible(const FieldList& other) const {
+      if (size() != other.size()) {
+        return false;
+      }
+      const_iterator it, jt;
+      bool found;
+      for (it = begin(); it != end(); ++it) {
+        found = false;
+        for (jt = other.begin(); jt != other.end(); ++jt) {
+          if ((*it).compatible(*jt)) {
+            found = true;
+          }
+        }
+        if (!found) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    bool isLValueFor(const FieldList& other) const {
+      if (size() != other.size()) {
+        return false;
+      }
+      const_iterator it, jt;
+      bool found;
+      for (it = begin(); it != end(); ++it) {
+        found = false;
+        for (jt = other.begin(); jt != other.end(); ++jt) {
+          if ((*it).isLValueFor(*jt)) {
+            found = true;
+          }
+        }
+        if (!found) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    bool operator==(const FieldList& other) const {
+      if (size() != other.size()) {
+        return false;
+      }
+      const_iterator it, jt;
+      bool found;
+      for (it = begin(); it != end(); ++it) {
+        found = false;
+        for (jt = other.begin(); jt != other.end(); ++jt) {
+          if ((*it) == (*jt)) {
+            found = true;
+          }
+        }
+        if (!found) {
+          return false;
+        }
+      }
+      return true;
+    }
+  };
+
+  StructType(const std::string& name, const FieldList& fields,
              const std::string& unit, int line);
 
-  StructType(const std::list<Field>& fields);
+  StructType(const FieldList& fields);
 
-  const std::list<Field>& fields() const;
+  const FieldList& fields() const;
 
-  bool equivalent(Type*);
-
   virtual std::string name() const;
 
+  virtual bool compatible(Type*);
+  virtual bool _compatible(PrimitiveType*);
+  virtual bool _compatible(MatrixType*);
+  virtual bool _compatible(StructType*);
+  virtual bool _compatible(SubprogramType*);
+
   virtual bool equals(const Type*) const;
   virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
@@ -155,13 +252,14 @@
   virtual Type* litPromotionWith(Type*);
 
   virtual bool isLValueFor(Type*);
-  virtual bool isRValueFor(PrimitiveType*);
-  virtual bool isRValueFor(MatrixType*);
-  virtual bool isRValueFor(StructType*);
-  virtual bool isRValueFor(SubprogramType*);
+  virtual bool _isRValueFor(PrimitiveType*);
+  virtual bool _isRValueFor(MatrixType*);
+  virtual bool _isRValueFor(StructType*);
+  virtual bool _isRValueFor(SubprogramType*);
 private:
+  bool             _anonymous;
   std::string      _name;
-  std::list<Field> _fields;
+  FieldList        _fields;
   std::string      _unit;
   int              _line;
 };
@@ -173,6 +271,12 @@
 
   virtual std::string name() const;
 
+  virtual bool compatible(Type*);
+  virtual bool _compatible(PrimitiveType*);
+  virtual bool _compatible(MatrixType*);
+  virtual bool _compatible(StructType*);
+  virtual bool _compatible(SubprogramType*);
+
   virtual bool equals(const Type*) const;
   virtual bool equals(int id) const;
   virtual bool equals(Type* ofType, int dimensions) const;
@@ -187,10 +291,10 @@
   virtual Type* litPromotionWith(Type*);
 
   virtual bool isLValueFor(Type*);
-  virtual bool isRValueFor(PrimitiveType*);
-  virtual bool isRValueFor(MatrixType*);
-  virtual bool isRValueFor(StructType*);
-  virtual bool isRValueFor(SubprogramType*);
+  virtual bool _isRValueFor(PrimitiveType*);
+  virtual bool _isRValueFor(MatrixType*);
+  virtual bool _isRValueFor(StructType*);
+  virtual bool _isRValueFor(SubprogramType*);
 private:
   TypeList         _paramTypes;
   Type*            _returnType;



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 04:06:31 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 04:06:31 +0100
Subject: [gpt-commit] r396 - trunk/gpt2/gptc/src
Message-ID: <200711270306.lAR36VLi001986@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-27 04:06:30 +0100 (Tue, 27 Nov 2007)
New Revision: 396

Modified:
   trunk/gpt2/gptc/src/semantic.g
Log:
-Adicionando informacao de tipo aos nodes da lista de inicializacao

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-11-27 03:06:10 UTC (rev 395)
+++ trunk/gpt2/gptc/src/semantic.g	2007-11-27 03:06:30 UTC (rev 396)
@@ -146,32 +146,33 @@
 valor_inicialiacao[Type* ltype]
 
                           {
+                            Type* rtype;
                             _analisingInitializationList = true;
                           }
 
-  : #(T_VALOR valor[ltype])
+  : #(v:T_VALOR rtype=valor[ltype])
 
                           {
+                            v->setEvalType(rtype);
                             _analisingInitializationList = false;
                           }
   ;
 
-valor[Type *ltype]
+valor[Type *ltype] returns [Type* rtype]
                           {
-                            Type *rtype;
                             InitMatrixList         mtx;
                             InitStructList         stc;
                           }
 
-  : rtype=expressao       {evalAttribution(ltype, rtype);}
+  : rtype=expressao       {rtype = evalAttribution(ltype, rtype);}
 
   | #(T_VAL_MATRIZ  (valor_matriz[1,mtx])+)
 
-                          {evalAttribution(ltype, mtx);}
+                          {rtype = evalAttribution(ltype, mtx);}
 
   | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)
 
-                          {evalAttribution(ltype, stc);}
+                          {rtype = evalAttribution(ltype, stc);}
   ;
 
 valor_matriz [int dimension, InitMatrixList& mtx]
@@ -191,17 +192,24 @@
                             createAnonymousStructFor(stc)));}
   ;
 
-valor_estrutura [const string& field, InitStructList& stc]
+valor_estrutura [const std::string& field, InitStructList& stc]
                               {
                                 Type *type;
                                 InitMatrixList mtx;
                               }
-  : type=expressao     {stc.push_back(std::pair<std::string,Type*>(field, type));}
+  : type=expressao
+                              {
+                                stc.push_back(
+                                  std::pair<std::string,Type*>(
+                                    field, type));
+                              }
 
   | #(T_VAL_MATRIZ (valor_matriz[1, mtx])+)
                               {
                                 type = evalHomogeneity(mtx);
-                                stc.push_back(std::pair<std::string,Type*>(field,type));
+                                stc.push_back(
+                                  std::pair<std::string,Type*>(
+                                    field,type));
                               }
 
   | #(T_VAL_ESTRUTURA (id:T_IDENTIFICADOR valor_estrutura[id->getText(),stc])+)



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 17:01:18 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 17:01:18 +0100
Subject: [gpt-commit] r397 - trunk/gpt2/gptc/src
Message-ID: <200711271601.lARG1Iiw026225@sheep.berlios.de>

Author: thiago_silva
Date: 2007-11-27 17:01:16 +0100 (Tue, 27 Nov 2007)
New Revision: 397

Modified:
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
   trunk/gpt2/gptc/src/semantic.g
Log:
-Fusao da hierarquia de tipos em uma classe apenas (Type), para simplificar e nao depender do circo de voodoo polimorfico.
-Restringindo promocao de tipos na lista de inicializacao de matrizes, ate ter um codigo que funcione.

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -13,7 +13,6 @@
 
 void BaseSemanticWalker::useLib(const  std::string& lib) {
   //TODO: sanitize lib: "bla\ bla" -> "bla bla"
-
   std::cerr << "Using lib:" << lib << std::endl;
 }
 
@@ -50,17 +49,17 @@
                                      int line,
                                      Type* ret) {
 
-  SubprogramType* type = new SubprogramType(
-        params.toTypeList(),
-        (ret == 0) ? _symtable->getType(PortugolTokenTypes::T_NULO) : ret);
+  //TODO: Levar em consideracao o registro de funcoes polimorficas
+//   Type* type = _symtable->getType(params.toTypeList(),
+//           (ret == 0) ? _symtable->getType(PortugolTokenTypes::T_NULO) : ret);
 
-  try {
-    _symtable->declare(_symtable->newSymbol(name, type,line));
-    _symtable->declare(params, name);
-  } catch (RedeclarationException e) {
-    cerr << "catched! Redeclaration: " << e.symbol().toString() << std::endl;
-    delete type;
-  }
+//   try {
+//     _symtable->declare(_symtable->newSymbol(name, type,line));
+//     _symtable->declare(params, name);
+//   } catch (RedeclarationException e) {
+//     cerr << "catched! Redeclaration: " << e.symbol().toString() << std::endl;
+//     delete type;
+//   }
 }
 
 Type* BaseSemanticWalker::getType(const std::string& name) {
@@ -124,7 +123,7 @@
 }
 
 Type* BaseSemanticWalker::evalAttribution(Type* ltype, const InitStructList& stc) {
-  StructType* rtype = createAnonymousStructFor(stc);
+  Type* rtype = createAnonymousStructFor(stc);
 
   if (!ltype->isLValueFor(rtype)) {
     std::cerr << "ilegal: "
@@ -133,7 +132,7 @@
   return ltype;
 }
 
-StructType* BaseSemanticWalker::createAnonymousStructFor(const InitStructList& stc) {
+Type* BaseSemanticWalker::createAnonymousStructFor(const InitStructList& stc) {
   SymbolList slist;
   InitStructList::const_iterator it;
   for (it = stc.begin(); it != stc.end(); ++it) {
@@ -159,12 +158,12 @@
 
     if (rtype == 0) {
       rtype = it->second;
-    } else if (!rtype->compatible(it->second)) {
+    } else if (!rtype->equals(it->second)) {
       std::cerr << "ilegal: Matriz heterogenea\n";
     }
   }
 
-  return _symtable->retrieveMatrixType(rtype, dim);
+  return _symtable->getType(rtype, dim);
 }
 
 Type*

Modified: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -31,7 +31,6 @@
 class SymbolList;
 class Type;
 class TypeList;
-class StructType;
 
 typedef std::list<RefPortugolAST> IDList;
 
@@ -67,7 +66,7 @@
   Type* evalAttribution(Type*, const InitMatrixList&);
   Type* evalAttribution(Type*, const InitStructList&);
 
-  StructType* createAnonymousStructFor(const InitStructList&);
+  Type* createAnonymousStructFor(const InitStructList&);
 
   Type* evalHomogeneity(const InitMatrixList& mtx);
 

Modified: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -55,11 +55,11 @@
   return end();
 }
 
-StructType::FieldList SymbolList::toStructFieldList() const {
-  StructType::FieldList fields;
+Type::StructFieldList SymbolList::toStructFieldList() const {
+  Type::StructFieldList fields;
 
   for (const_iterator it = begin(); it != end(); ++it) {
-    fields.push_back(StructType::Field((*it).lexeme(), (*it).type()));
+    fields.push_back(Type::StructField((*it).lexeme(), (*it).type()));
   }
   return fields;
 }

Modified: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -39,7 +39,7 @@
 public:
   const_iterator duplicated() const;
 
-  StructType::FieldList toStructFieldList() const;
+  Type::StructFieldList toStructFieldList() const;
 
   TypeList toTypeList() const;
 

Modified: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -35,11 +35,11 @@
   return *ret;
 }
 
-Type* SymbolTable::retrieveMatrixType(Type *ofType, int dimensions) {
+Type* SymbolTable::getType(Type *ofType, int dimensions) {
   TypeList::iterator it = _types.find(ofType, dimensions);
   Type* type;
   if (it == _types.end()) {
-    type = new MatrixType(ofType, dimensions);
+    type = new Type(ofType, dimensions);
     _types.push_back(type);
   } else {
     type = *it;
@@ -47,6 +47,14 @@
   return type;
 }
 
+// Type* SymbolTable::getType(const TypeList& paramTypes, Type* returnType) {
+  //TODO
+  //Levar em consideracao o registro de funcoes polimorficas
+  //Type *type = new Type(paramTypes, returnType);
+//   throw;
+// }
+
+
 Symbol SymbolTable::newSymbol(const std::string& name, Type* type,
                 const std::string& scope, int line,
                 bool isConst, bool isRef) {
@@ -69,12 +77,12 @@
   if (_types.find(name) != _types.end()) {
     throw RedefinedTypeException(name);
   }
-  _types.push_back(new StructType(name,
+  _types.push_back(new Type(name,
       symbolList.toStructFieldList(), _unit, line));
 }
 
-StructType* SymbolTable::createAnonymousStruct(const SymbolList& symbolList) {
-  StructType* ret = new StructType(symbolList.toStructFieldList());
+Type* SymbolTable::createAnonymousStruct(const SymbolList& symbolList) {
+  Type* ret = new Type(symbolList.toStructFieldList());
   _types.push_back(ret);
   return ret;
 }
@@ -143,12 +151,12 @@
 }
 
 void SymbolTable::initialize() {
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_INTEIRO,"inteiro"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_REAL,"real"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_CARACTERE,"caractere"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_LITERAL,"literal"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_LOGICO,"l?gico"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_NULO,"nulo"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_CORINGA,"coringa"));
-  _types.push_back(new PrimitiveType(PortugolTokenTypes::T_RETICENCIAS,"retic?ncias"));
+  _types.push_back(new Type(PortugolTokenTypes::T_INTEIRO,"inteiro"));
+  _types.push_back(new Type(PortugolTokenTypes::T_REAL,"real"));
+  _types.push_back(new Type(PortugolTokenTypes::T_CARACTERE,"caractere"));
+  _types.push_back(new Type(PortugolTokenTypes::T_LITERAL,"literal"));
+  _types.push_back(new Type(PortugolTokenTypes::T_LOGICO,"l?gico"));
+  _types.push_back(new Type(PortugolTokenTypes::T_NULO,"nulo"));
+  _types.push_back(new Type(PortugolTokenTypes::T_CORINGA,"coringa"));
+  _types.push_back(new Type(PortugolTokenTypes::T_RETICENCIAS,"retic?ncias"));
 }

Modified: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -18,12 +18,12 @@
   void setScope(const std::string& scope);
   void setGlobalScope();
 
+  //
   Type* getType(const std::string& name);
-
   Type* getType(int id);
+  Type* getType(Type *ofType, int dimensions);
+//   Type* getType(const TypeList& paramTypes, Type* returnType);
 
-  Type* retrieveMatrixType(Type *ofType, int dimensions);
-
   Symbol newSymbol(const std::string& name, Type* type,
                    const std::string& scope, int line = -1,
                    bool isConst = false, bool isRef = false);
@@ -35,7 +35,7 @@
                    const SymbolList& symbolList,
                    int line);
 
-  StructType* createAnonymousStruct(const SymbolList& symbolList);
+  Type* createAnonymousStruct(const SymbolList& symbolList);
 
   bool declared(const Symbol& s);
 

Modified: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -1,363 +1,344 @@
 #include "Types.hpp"
-#include "PortugolTokenTypes.hpp"
 
-Type::~Type() {}
 
-//------------------------------------------------------------------
+Type::StructField::StructField(const std::string& n, Type* t)
+      : name(n), type(t) {}
 
+bool
+Type::StructField::isLValueFor(const Type::StructField& other) const {
+  return name == other.name && type->isLValueFor(other.type);
+}
 
-TypeList::iterator TypeList::find(const std::string& lexeme) {
-  iterator it;
+// bool
+// Type::StructField::compatible(const Type::StructField& other) const {
+//   return name == other.name && type->compatible(other.type);
+// }
 
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)->name() == lexeme) {
-      return it;
-    }
-  }
-  return end();
+bool
+Type::StructField::operator==(const Type::StructField& other) const {
+  return name == other.name && type->equals(other.type);
 }
 
-TypeList::iterator TypeList::find(Type* ofType, int dimensions) {
-  iterator it;
+// bool
+// Type::StructFieldList::compatible(const Type::StructFieldList& other) const {
+//   if (size() != other.size()) {
+//     return false;
+//   }
+//   const_iterator it, jt;
+//   bool found;
+//   for (it = begin(); it != end(); ++it) {
+//     found = false;
+//     for (jt = other.begin(); jt != other.end(); ++jt) {
+//       if ((*it).compatible(*jt)) {
+//         found = true;
+//       }
+//     }
+//     if (!found) {
+//       return false;
+//     }
+//   }
+//   return true;
+// }
 
+bool
+Type::StructFieldList::isLValueFor(const Type::StructFieldList& other) const {
+  if (size() != other.size()) {
+    return false;
+  }
+  const_iterator it, jt;
+  bool found;
   for (it = begin(); it != end(); ++it) {
-    if ((*it)->equals(ofType, dimensions)) {
-      return it;
+    found = false;
+    for (jt = other.begin(); jt != other.end(); ++jt) {
+      if ((*it).isLValueFor(*jt)) {
+        found = true;
+      }
     }
+    if (!found) {
+      return false;
+    }
   }
-  return end();
+  return true;
 }
 
-TypeList::iterator TypeList::find(int id) {
-  iterator it;
-
+bool
+Type::StructFieldList::operator==(const Type::StructFieldList& other) const {
+  if (size() != other.size()) {
+    return false;
+  }
+  const_iterator it, jt;
+  bool found;
   for (it = begin(); it != end(); ++it) {
-    if ((*it)->equals(id)) {
-      return it;
+    found = false;
+    for (jt = other.begin(); jt != other.end(); ++jt) {
+      if ((*it) == (*jt)) {
+        found = true;
+      }
     }
+    if (!found) {
+      return false;
+    }
   }
-  return end();
+  return true;
 }
 
-// void TypeList::push_back(const TypeList& other) {
-//   for (iterator it = other.begin(); it != other.end(); ++it) {
-//     push_back(*it);
-//   }
-// }
 
-std::string TypeList::toString() const {
-  std::string ret = "";
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    ret += (*it)->name() + ",";
-  }
-  return ret;
-}
 
+//************* GENERAL *********************************/
 
-//------------------------------------------------------------------
-
-
-PrimitiveType::PrimitiveType(int id, const std::string& name)
-  : _id(id), _name(name) {
+bool Type::isPrimitive() const {
+  return _typeId == PRIMITIVE;
 }
 
-std::string PrimitiveType::name() const {
-  return _name;
+bool Type::isMatrix() const {
+  return _typeId == MATRIX;
 }
 
-bool PrimitiveType::compatible(Type* other) {
-  other->_compatible(this);
+bool Type::isStruct() const {
+  return _typeId == STRUCT;
 }
 
-bool PrimitiveType::_compatible(PrimitiveType* other) {
-  return _equals(other) || numPromotionWith(other);
+bool Type::isSubprogram() const {
+  return _typeId == SUBPROGRAM;
 }
 
-bool PrimitiveType::_compatible(MatrixType*) {
-  return false;
+const std::string Type::name() const {
+  return _name;
 }
 
-bool PrimitiveType::_compatible(StructType*) {
-  return false;
+bool Type::equals(int id) const {
+  return isPrimitive() && (_id == id);
 }
 
-bool PrimitiveType::_compatible(SubprogramType*) {
-  return false;
+bool Type::equals(Type* ofType, int dimensions) const {
+  return isMatrix() && (dimensions == _dimensions) &&
+          _ofType->equals(ofType);
 }
 
+/************* VIRTUAL *********************************/
 
-bool PrimitiveType::equals(const Type* other) const {
-  other->_equals(this);
-}
+// bool Type::compatible(Type* other) {
+//   switch (_typeId) {
+//     case PRIMITIVE:
+//       return primitive_compatible(other);
+//     case MATRIX:
+//       return matrix_compatible(other);
+//     case STRUCT:
+//       return struct_compatible(other);
+//     case SUBPROGRAM:
+//       return subprogram_compatible(other);
+//     default:
+//       throw;
+//   }
+// }
 
-bool PrimitiveType::equals(int id) const {
-  return _id == id;
+bool Type::equals(const Type* other) const {
+  switch (_typeId) {
+    case PRIMITIVE:
+      return primitive_equals(other);
+    case MATRIX:
+      return matrix_equals(other);
+    case STRUCT:
+      return struct_equals(other);
+    case SUBPROGRAM:
+      return subprogram_equals(other);
+    default:
+      throw;
+  }
 }
 
-bool PrimitiveType::equals(Type* ofType, int dimensions) const {
-  return false;
+Type* Type::numPromotionWith(Type* other) {
+  switch (_typeId) {
+    case PRIMITIVE:
+      return primitive_numPromotionWith(other);
+    case MATRIX:
+      return NULL;
+    case STRUCT:
+      return NULL;
+    case SUBPROGRAM:
+      return NULL;
+    default:
+      throw;
+  }
 }
 
-bool PrimitiveType::_equals(const PrimitiveType* other) const {
-  return other->_id == _id;
+Type* Type::litPromotionWith(Type* other) {
+  switch (_typeId) {
+    case PRIMITIVE:
+      return primitive_litPromotionWith(other);
+    case MATRIX:
+      return NULL;
+    case STRUCT:
+      return NULL;
+    case SUBPROGRAM:
+      return NULL;
+    default:
+      throw;
+  }
 }
 
-bool PrimitiveType::_equals(const MatrixType*) const {
-  return false;
+
+bool Type::isLValueFor(Type* rtype) {
+  switch (_typeId) {
+    case PRIMITIVE:
+      return primitive_isLValueFor(rtype);
+    case MATRIX:
+      return matrix_isLValueFor(rtype);
+    case STRUCT:
+      return struct_isLValueFor(rtype);
+    case SUBPROGRAM:
+      return false;
+    default:
+      throw;
+  }
 }
 
-bool PrimitiveType::_equals(const StructType*) const {
-  return false;
+//************* PRIMITIVE *********************************/
+
+
+
+Type::Type(int id, const std::string& name)
+  : _typeId(PRIMITIVE), _name(name), _id(id) {
 }
 
-bool PrimitiveType::_equals(const SubprogramType*) const {
-  return false;
+int Type::primitiveType() const {
+  return _id;
 }
 
-bool PrimitiveType::isPrimitive() const {
-  return true;
+// bool Type::primitive_compatible(Type* other) {
+//   if (other->isPrimitive()) {
+//     return equals(other) || numPromotionWith(other);
+//   } else {
+//     return false;
+//   }
+// }
+
+bool Type::primitive_equals(const Type* other) const {
+  return other->isPrimitive() && (other->_id == _id);
 }
 
-Type* PrimitiveType::numPromotionWith(Type* other) {
-  if ((_id == PortugolTokenTypes::T_INTEIRO)
+Type* Type::primitive_numPromotionWith(Type* other) {
+  if ((_id == T_INTEIRO)
        &&
-      (other->equals(PortugolTokenTypes::T_INTEIRO) ||
-       other->equals(PortugolTokenTypes::T_REAL))) {
+      (other->equals(T_INTEIRO) ||
+       other->equals(T_REAL))) {
     return other;
-  } else if ((_id == PortugolTokenTypes::T_REAL)
+  } else if ((_id == T_REAL)
               &&
-             (other->equals(PortugolTokenTypes::T_INTEIRO) ||
-              other->equals(PortugolTokenTypes::T_REAL))) {
+             (other->equals(T_INTEIRO) ||
+              other->equals(T_REAL))) {
     return this;
   }
 
   return NULL;
 }
 
-Type* PrimitiveType::litPromotionWith(Type* other) {
-  if ((_id == PortugolTokenTypes::T_LITERAL)
+Type* Type::primitive_litPromotionWith(Type* other) {
+  if ((_id == T_LITERAL)
        &&
-      (other->equals(PortugolTokenTypes::T_LITERAL) ||
-       other->equals(PortugolTokenTypes::T_CARACTERE))) {
+      (other->equals(T_LITERAL) ||
+       other->equals(T_CARACTERE))) {
     return this;
-  } else if (other->equals(PortugolTokenTypes::T_LITERAL)
+  } else if (other->equals(T_LITERAL)
               &&
-             ((_id == PortugolTokenTypes::T_CARACTERE) ||
-              (_id == PortugolTokenTypes::T_LITERAL))) {
+             ((_id == T_CARACTERE) ||
+              (_id == T_LITERAL))) {
     return other;
   }
 
   return NULL;
 }
 
-bool PrimitiveType::isLValueFor(Type* rtype) {
-  rtype->_isRValueFor(this);
-}
-
-bool PrimitiveType::_isRValueFor(PrimitiveType* lvalue) {
-  if (lvalue->equals(this)) {
+bool Type::primitive_isLValueFor(Type* rvalue) {
+  if (equals(rvalue)) {
     return true;
   }
 
-  if (lvalue->equals(PortugolTokenTypes::T_REAL) &&
-      _id == PortugolTokenTypes::T_INTEIRO) {
+  if ((_id == T_REAL) &&
+      rvalue->equals(T_INTEIRO)) {
     return true;
   }
   return false;
 }
 
-bool PrimitiveType::_isRValueFor(MatrixType*) {
-  if (_id == PortugolTokenTypes::T_NULO) {
-    return true;
-  }
-  return false;
-}
+/************* MATRIX *********************************/
 
-bool PrimitiveType::_isRValueFor(StructType*) {
-  if (_id == PortugolTokenTypes::T_NULO) {
-    return true;
-  }
-  return false;
-}
+Type::Type(Type* type, int dimensions)
+  : _typeId(MATRIX), _ofType(type), _dimensions(dimensions) {
 
-bool PrimitiveType::_isRValueFor(SubprogramType*) {
-  return false;
-}
-
-//------------------------------------------------------------------
-
-
-MatrixType::MatrixType(Type* type, int dimensions)
-  : _ofType(type), _dimensions(dimensions) {
-}
-
-std::string MatrixType::name() const {
-  std::string ret;
-  ret = "matriz";
+  _name = "matriz";
   for (int i = 0; i < _dimensions; i++) {
-    ret += "[]";
+    _name += "[]";
   }
-  ret += " do tipo " + _ofType->name();
-  return ret;
+  _name += " do tipo " + _ofType->name();
 }
 
-const Type* MatrixType::ofType() const {
+const Type* Type::ofType() const {
   return _ofType;
 }
 
-int MatrixType::dimensions() const {
+int Type::dimensions() const {
   return _dimensions;
 }
 
-bool MatrixType::compatible(Type* other) {
-  other->_compatible(this);
-}
+// bool Type::matrix_compatible(Type* other) {
+//   if (other->isMatrix()) {
+//     return _dimensions == other->_dimensions &&
+//           _ofType->compatible(other->_ofType);
+//   } else {
+//     return false;
+//   }
+// }
 
-bool MatrixType::_compatible(PrimitiveType*) {
-  return false;
+bool Type::matrix_equals(const Type* other) const {
+  return other->isMatrix() && equals(other->_ofType, other->_dimensions);
 }
 
-bool MatrixType::_compatible(MatrixType* other) {
-  return _dimensions == other->_dimensions &&
-         _ofType->compatible(other->_ofType);
-}
+bool Type::matrix_isLValueFor(Type* rvalue) {
+  if (rvalue->isMatrix() &&
+      (rvalue->_dimensions == _dimensions) &&
+      rvalue->_ofType->isLValueFor(_ofType)) {
+    return true;
+  }
 
-bool MatrixType::_compatible(StructType*) {
-  return false;
-}
-
-bool MatrixType::_compatible(SubprogramType*) {
-  return false;
-}
-
-bool MatrixType::equals(const Type* other) const {
-  other->_equals(this);
-}
-
-bool MatrixType::equals(int id) const {
-  return false;
-}
-
-bool MatrixType::equals(Type* ofType, int dimensions) const {
-  return (ofType == _ofType) && (dimensions == _dimensions);
-}
-
-bool MatrixType::_equals(const PrimitiveType*) const {
-  return false;
-}
-
-bool MatrixType::_equals(const MatrixType* other) const {
-  return (other->_ofType->equals(_ofType)) && (other->_dimensions == _dimensions);
-}
-
-bool MatrixType::_equals(const StructType*) const {
-  return false;
-}
-
-bool MatrixType::_equals(const SubprogramType*) const {
-  return false;
-}
-
-bool MatrixType::isPrimitive() const {
-  return false;
-}
-
-Type* MatrixType::numPromotionWith(Type*) {
-  return NULL;
-}
-
-Type* MatrixType::litPromotionWith(Type*) {
-  return NULL;
-}
-
-bool MatrixType::isLValueFor(Type* rtype) {
-  rtype->_isRValueFor(this);
-}
-
-bool MatrixType::_isRValueFor(PrimitiveType*) {
-  return false;
-}
-
-bool MatrixType::_isRValueFor(MatrixType* lvalue) {
-  if ((lvalue->_dimensions == _dimensions) &&
-      lvalue->_ofType->isLValueFor(_ofType)) {
+  if (rvalue->isPrimitive() && rvalue->equals(T_NULO)) {
     return true;
   }
 
   return false;
 }
 
-bool MatrixType::_isRValueFor(StructType*) {
-  return false;
-}
 
-bool MatrixType::_isRValueFor(SubprogramType*) {
-  return false;
-}
 
-//------------------------------------------------------------------
+/******************** STRUCT *********************************/
 
 
-StructType::StructType(const std::string& name, const FieldList& fields,
-                       const std::string& unit, int line)
-  : _anonymous(false), _name(name), _fields(fields), _unit(unit), _line(line) {
+Type::Type(const std::string& name, const StructFieldList& fields,
+           const std::string& unit, int line)
+  : _typeId(STRUCT), _name(name), _anonymous(false), _fields(fields),
+    _unit(unit), _line(line) {
 }
 
 
-StructType::StructType(const FieldList& fields)
-  : _anonymous(true), _name("<anonymous>"), _fields(fields), _unit("<intern>"), _line(-1) {
+Type::Type(const StructFieldList& fields)
+  : _typeId(STRUCT), _name("<estrutura an?nima>"), _anonymous(true),
+    _fields(fields), _unit("<interno>"), _line(-1) {
 }
 
-const StructType::FieldList& StructType::fields() const {
+const Type::StructFieldList& Type::fields() const {
   return _fields;
 }
 
-std::string StructType::name() const {
-  return _name;
-}
 
-bool StructType::compatible(Type* other) {
-  other->_compatible(this);
-}
+// bool Type::struct_compatible(Type* other) {
+//   return other->isStruct() && _fields.compatible(other->_fields);
+// }
 
-bool StructType::_compatible(PrimitiveType*) {
-  return false;
-}
+bool Type::struct_equals(const Type* other) const {
+  if (!other->isStruct()) {
+    return false;
+  }
 
-bool StructType::_compatible(MatrixType*) {
-  return false;
-}
-
-bool StructType::_compatible(StructType* other) {
-  return _fields.compatible(other->_fields);
-}
-
-bool StructType::_compatible(SubprogramType*) {
-  return false;
-}
-
-bool StructType::equals(const Type* other) const {
-  other->_equals(this);
-}
-
-bool StructType::equals(int id) const {
-  return false;
-}
-
-bool StructType::equals(Type* ofType, int dimensions) const {
-  return false;
-}
-
-bool StructType::_equals(const PrimitiveType*) const {
-  return false;
-}
-
-bool StructType::_equals(const MatrixType*) const {
-  return false;
-}
-
-bool StructType::_equals(const StructType* other) const {
   if ((_anonymous  && other->_anonymous) ||
       (!_anonymous && !other->_anonymous)) {
     //comparacao estrutural
@@ -368,147 +349,102 @@
   }
 }
 
-bool StructType::_equals(const SubprogramType*) const {
-  return false;
-}
 
-bool StructType::isPrimitive() const {
-  return false;
-}
+bool Type::struct_isLValueFor(Type* rtype) {
+  if (rtype->isPrimitive()) {
+    return rtype->equals(T_NULO);
+  }
 
-Type* StructType::numPromotionWith(Type*) {
-  return NULL;
-}
+  if (!rtype->isStruct()) {
+    return false;
+  }
 
-Type* StructType::litPromotionWith(Type*) {
-  return NULL;
-}
-
-bool StructType::isLValueFor(Type* rtype) {
-  rtype->_isRValueFor(this);
-}
-
-bool StructType::_isRValueFor(PrimitiveType*) {
-  return false;
-}
-
-bool StructType::_isRValueFor(MatrixType*) {
-  return false;
-}
-
-bool StructType::_isRValueFor(StructType* ltype) {
-  if (_anonymous || ltype->_anonymous) {
-    return ltype->_fields.isLValueFor(_fields);
+  if (_anonymous || rtype->_anonymous) {
+    return _fields.isLValueFor(rtype->_fields);
   } else {
     //comparacao nominal
-    return _equals(ltype);
+    return equals(rtype);
   }
 }
 
-bool StructType::_isRValueFor(SubprogramType*) {
-  return false;
-}
 
-//------------------------------------------------------------------
 
+/******************** SUBPROGRAM *********************************/
 
-SubprogramType::SubprogramType(const TypeList& paramTypes,
-                               Type* returnType)
-  : _paramTypes(paramTypes), _returnType(returnType) {
-}
+Type::Type(const TypeList& paramTypes,
+           Type* returnType)
+  : _typeId(SUBPROGRAM), _paramTypes(paramTypes), _returnType(returnType) {
 
-std::string SubprogramType::name() const {
-  std::string ret;
-  if (_returnType->equals(PortugolTokenTypes::T_NULO)) {
-    ret = "proc(";
+  if (_returnType->equals(T_NULO)) {
+    _name = "proc(";
   } else {
-    ret = "func(";
+    _name = "func(";
   }
-  ret += _paramTypes.toString();
-  ret += ")";
-  ret += " : " + _returnType->name();
-  return ret;
+  _name += _paramTypes.toString();
+  _name += ")";
+  _name += " : " + _returnType->name();
 }
 
 
-bool SubprogramType::compatible(Type* other) {
-  other->_compatible(this);
-}
+// bool Type::subprogram_compatible(Type* other) {
+//   return equals(other);
+// }
 
-bool SubprogramType::_compatible(PrimitiveType*) {
-  return false;
-}
 
-bool SubprogramType::_compatible(MatrixType*) {
-  return false;
+bool Type::subprogram_equals(const Type* other) const {
+  return other->isSubprogram() &&
+         (_paramTypes == other->_paramTypes) &&
+         (_returnType->equals(other->_returnType));
 }
 
-bool SubprogramType::_compatible(StructType*) {
-  return false;
-}
 
-bool SubprogramType::_compatible(SubprogramType*) {
-  return false;
-}
 
 
-bool SubprogramType::equals(const Type* other) const {
-  other->_equals(this);
-}
+/******************** TYPELIST *********************************/
 
-bool SubprogramType::equals(int id) const {
-  return false;
-}
 
-bool SubprogramType::equals(Type*, int) const {
-  return false;
-}
 
-bool SubprogramType::_equals(const PrimitiveType*) const {
-  return false;
-}
 
-bool SubprogramType::_equals(const MatrixType*) const {
-  return false;
-}
 
-bool SubprogramType::_equals(const StructType*) const {
-  return false;
-}
+TypeList::iterator TypeList::find(const std::string& lexeme) {
+  iterator it;
 
-bool SubprogramType::_equals(const SubprogramType* other) const {
-  return (_paramTypes == other->_paramTypes) &&
-         (_returnType == other->_returnType);
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->name() == lexeme) {
+      return it;
+    }
+  }
+  return end();
 }
 
-bool SubprogramType::isPrimitive() const {
-  return false;
-}
+TypeList::iterator TypeList::find(Type* ofType, int dimensions) {
+  iterator it;
 
-Type* SubprogramType::numPromotionWith(Type*) {
-  return NULL;
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->equals(ofType, dimensions)) {
+      return it;
+    }
+  }
+  return end();
 }
 
-Type* SubprogramType::litPromotionWith(Type*) {
-  return NULL;
-}
+TypeList::iterator TypeList::find(int id) {
+  iterator it;
 
-bool SubprogramType::isLValueFor(Type*) {
-  return false;
+  for (it = begin(); it != end(); ++it) {
+    if ((*it)->equals(id)) {
+      return it;
+    }
+  }
+  return end();
 }
 
-bool SubprogramType::_isRValueFor(PrimitiveType*) {
-  return false;
+std::string TypeList::toString() const {
+  std::string ret = "";
+  const_iterator it;
+  for (it = begin(); it != end(); ++it) {
+    ret += (*it)->name() + ",";
+  }
+  return ret;
 }
 
-bool SubprogramType::_isRValueFor(MatrixType*) {
-  return false;
-}
-
-bool SubprogramType::_isRValueFor(StructType*) {
-  return false;
-}
-
-bool SubprogramType::_isRValueFor(SubprogramType*) {
-  return false;
-}

Modified: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-11-27 16:01:16 UTC (rev 397)
@@ -4,46 +4,10 @@
 #include <string>
 #include <list>
 
-class PrimitiveType;
-class MatrixType;
-class StructType;
-class SubprogramType;
+#include "PortugolTokenTypes.hpp"
 
+class Type;
 
-class Type {
-public:
-  virtual ~Type();
-  virtual std::string name() const = 0;
-
-  virtual bool compatible(Type*) = 0;
-  virtual bool _compatible(PrimitiveType*) = 0;
-  virtual bool _compatible(MatrixType*) = 0;
-  virtual bool _compatible(StructType*) = 0;
-  virtual bool _compatible(SubprogramType*) = 0;
-
-  virtual bool equals(const Type*) const = 0;
-  virtual bool equals(int id) const = 0;
-  virtual bool equals(Type* ofType, int dimensions) const = 0;
-
-  virtual bool _equals(const PrimitiveType*) const = 0;
-  virtual bool _equals(const MatrixType*) const = 0;
-  virtual bool _equals(const StructType*) const = 0;
-  virtual bool _equals(const SubprogramType*) const = 0;
-
-  virtual bool  isPrimitive() const = 0;
-
-  virtual Type* numPromotionWith(Type*) = 0;
-  virtual Type* litPromotionWith(Type*) = 0;
-
-  virtual bool isLValueFor(Type*) = 0;
-
-  virtual bool _isRValueFor(PrimitiveType*) = 0;
-  virtual bool _isRValueFor(MatrixType*) = 0;
-  virtual bool _isRValueFor(StructType*) = 0;
-  virtual bool _isRValueFor(SubprogramType*) = 0;
-};
-
-
 class TypeList : public std::list<Type*> {
 public:
 
@@ -59,246 +23,116 @@
 };
 
 
-class PrimitiveType : public Type {
+class Type : private PortugolTokenTypes {
 public:
-  PrimitiveType(int id, const std::string& name);
+  enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM };
 
-  int id();
-  virtual std::string name() const;
+  class StructField {
+  public:
+    StructField(const std::string& n, Type* t);
+    bool isLValueFor(const StructField& other) const;
 
-  virtual bool compatible(Type*);
-  virtual bool _compatible(PrimitiveType*);
-  virtual bool _compatible(MatrixType*);
-  virtual bool _compatible(StructType*);
-  virtual bool _compatible(SubprogramType*);
+//     bool compatible(const StructField& other) const;
 
-  virtual bool equals(const Type*) const;
-  virtual bool equals(int id) const;
-  virtual bool equals(Type* ofType, int dimensions) const;
+    bool operator==(const StructField& other) const;
 
-  virtual bool _equals(const PrimitiveType*) const;
-  virtual bool _equals(const MatrixType*) const;
-  virtual bool _equals(const StructType*) const;
-  virtual bool _equals(const SubprogramType*) const;
+  private:
+    std::string name;
+    Type* type;
+  };
 
-  virtual bool isPrimitive() const;
-  virtual Type* numPromotionWith(Type*);
-  virtual Type* litPromotionWith(Type*);
+  class StructFieldList : public std::list<StructField> {
+  public:
+//     bool compatible(const StructFieldList& other) const;
+    bool isLValueFor(const StructFieldList& other) const;
+    bool operator==(const StructFieldList& other) const;
+  };
 
-  virtual bool isLValueFor(Type*);
-  virtual bool _isRValueFor(PrimitiveType*);
-  virtual bool _isRValueFor(MatrixType*);
-  virtual bool _isRValueFor(StructType*);
-  virtual bool _isRValueFor(SubprogramType*);
-private:
-  int         _id;
-  std::string _name;
-};
 
+  /* Constructors */
 
+  //Primitive
+  Type(int id, const std::string& name);
+  int primitiveType() const;
 
-
-class MatrixType : public Type {
-public:
-  MatrixType(Type* ofType, int dimensions);
-
+  //Matrix
+  Type(Type* ofType, int dimensions);
   const Type*         ofType() const;
   int                 dimensions() const;
 
-  virtual std::string name() const;
+  //Struct
+  Type(const std::string& name, const StructFieldList& fields,
+             const std::string& unit, int line);
+  Type(const StructFieldList& fields);
+  const StructFieldList& fields() const;
 
-  virtual bool compatible(Type*);
-  virtual bool _compatible(PrimitiveType*);
-  virtual bool _compatible(MatrixType*);
-  virtual bool _compatible(StructType*);
-  virtual bool _compatible(SubprogramType*);
+  //Subprogram
+  Type(const TypeList& paramTypes, Type* returnType);
 
-  virtual bool equals(const Type*) const;
-  virtual bool equals(int id) const;
-  virtual bool equals(Type* ofType, int dimensions) const;
+  /* General Methods */
 
-  virtual bool _equals(const PrimitiveType*) const;
-  virtual bool _equals(const MatrixType*) const;
-  virtual bool _equals(const StructType*) const;
-  virtual bool _equals(const SubprogramType*) const;
+  bool isPrimitive() const;
+  bool isMatrix() const;
+  bool isStruct() const;
+  bool isSubprogram() const;
 
-  virtual bool isPrimitive() const;
-  virtual Type* numPromotionWith(Type*);
-  virtual Type* litPromotionWith(Type*);
+  const std::string name() const;
 
-  virtual bool isLValueFor(Type*);
-  virtual bool _isRValueFor(PrimitiveType*);
-  virtual bool _isRValueFor(MatrixType*);
-  virtual bool _isRValueFor(StructType*);
-  virtual bool _isRValueFor(SubprogramType*);
-private:
-  Type          *_ofType;
-  int           _dimensions;
-};
+  bool equals(int id) const;
+  bool equals(Type* ofType, int dimensions) const;
 
-class StructType : public Type {
-public:
-  class Field {
-    public:
-    Field(const std::string& n, Type* t)
-      : name(n), type(t) {}
 
-    bool isLValueFor(const Field& other) const {
-      return name == other.name && type->isLValueFor(other.type);
-    }
 
-    bool compatible(const Field& other) const {
-      return name == other.name && type->compatible(other.type);
-    }
+  //virtual
+//   bool  compatible(Type* other);
+  bool  equals(const Type* other) const;
+  Type* numPromotionWith(Type* other);
+  Type* litPromotionWith(Type* other);
+  bool  isLValueFor(Type* rtype);
 
-    bool operator==(const Field& other) const {
-      return name == other.name && type->equals(other.type);
-    }
 
-    std::string name;
-    Type* type;
-  };
+  //impl primitive
+//   bool  primitive_compatible(Type* other);
+  bool  primitive_equals(const Type* other) const;
+  Type* primitive_numPromotionWith(Type* other);
+  Type* primitive_litPromotionWith(Type* other);
+  bool  primitive_isLValueFor(Type* rvalue);
 
-  class FieldList : public std::list<Field> {
-    public:
+  //impl matrix
+//   bool matrix_compatible(Type* other);
+  bool matrix_equals(const Type* other) const;
+  bool matrix_isLValueFor(Type* rvalue);
 
-    bool compatible(const FieldList& other) const {
-      if (size() != other.size()) {
-        return false;
-      }
-      const_iterator it, jt;
-      bool found;
-      for (it = begin(); it != end(); ++it) {
-        found = false;
-        for (jt = other.begin(); jt != other.end(); ++jt) {
-          if ((*it).compatible(*jt)) {
-            found = true;
-          }
-        }
-        if (!found) {
-          return false;
-        }
-      }
-      return true;
-    }
+  //impl struct
+//   bool struct_compatible(Type* other);
+  bool struct_equals(const Type* other) const;
+  bool struct_isLValueFor(Type* rtype);
 
-    bool isLValueFor(const FieldList& other) const {
-      if (size() != other.size()) {
-        return false;
-      }
-      const_iterator it, jt;
-      bool found;
-      for (it = begin(); it != end(); ++it) {
-        found = false;
-        for (jt = other.begin(); jt != other.end(); ++jt) {
-          if ((*it).isLValueFor(*jt)) {
-            found = true;
-          }
-        }
-        if (!found) {
-          return false;
-        }
-      }
-      return true;
-    }
+  //impl subprogram
+//   bool subprogram_compatible(Type* other);
+  bool subprogram_equals(const Type* other) const;
 
-    bool operator==(const FieldList& other) const {
-      if (size() != other.size()) {
-        return false;
-      }
-      const_iterator it, jt;
-      bool found;
-      for (it = begin(); it != end(); ++it) {
-        found = false;
-        for (jt = other.begin(); jt != other.end(); ++jt) {
-          if ((*it) == (*jt)) {
-            found = true;
-          }
-        }
-        if (!found) {
-          return false;
-        }
-      }
-      return true;
-    }
-  };
+private:
+  int         _typeId;
 
-  StructType(const std::string& name, const FieldList& fields,
-             const std::string& unit, int line);
+  std::string _name;
 
-  StructType(const FieldList& fields);
+  //Primitive
+  int         _id;
 
-  const FieldList& fields() const;
+  //matrix
+  Type          *_ofType;
+  int           _dimensions;
 
-  virtual std::string name() const;
-
-  virtual bool compatible(Type*);
-  virtual bool _compatible(PrimitiveType*);
-  virtual bool _compatible(MatrixType*);
-  virtual bool _compatible(StructType*);
-  virtual bool _compatible(SubprogramType*);
-
-  virtual bool equals(const Type*) const;
-  virtual bool equals(int id) const;
-  virtual bool equals(Type* ofType, int dimensions) const;
-  //virtual bool equals(list<Field> fields)
-  virtual bool _equals(const PrimitiveType*) const;
-  virtual bool _equals(const MatrixType*) const;
-  virtual bool _equals(const StructType*) const;
-  virtual bool _equals(const SubprogramType*) const;
-
-  virtual bool isPrimitive() const;
-  virtual Type* numPromotionWith(Type*);
-  virtual Type* litPromotionWith(Type*);
-
-  virtual bool isLValueFor(Type*);
-  virtual bool _isRValueFor(PrimitiveType*);
-  virtual bool _isRValueFor(MatrixType*);
-  virtual bool _isRValueFor(StructType*);
-  virtual bool _isRValueFor(SubprogramType*);
-private:
+  //struct
   bool             _anonymous;
-  std::string      _name;
-  FieldList        _fields;
+  StructFieldList  _fields;
   std::string      _unit;
   int              _line;
-};
 
-
-class SubprogramType : public Type {
-public:
-  SubprogramType(const TypeList& paramTypes, Type* returnType);
-
-  virtual std::string name() const;
-
-  virtual bool compatible(Type*);
-  virtual bool _compatible(PrimitiveType*);
-  virtual bool _compatible(MatrixType*);
-  virtual bool _compatible(StructType*);
-  virtual bool _compatible(SubprogramType*);
-
-  virtual bool equals(const Type*) const;
-  virtual bool equals(int id) const;
-  virtual bool equals(Type* ofType, int dimensions) const;
-
-  virtual bool _equals(const PrimitiveType*) const;
-  virtual bool _equals(const MatrixType*) const;
-  virtual bool _equals(const StructType*) const;
-  virtual bool _equals(const SubprogramType*) const;
-
-  virtual bool isPrimitive() const;
-  virtual Type* numPromotionWith(Type*);
-  virtual Type* litPromotionWith(Type*);
-
-  virtual bool isLValueFor(Type*);
-  virtual bool _isRValueFor(PrimitiveType*);
-  virtual bool _isRValueFor(MatrixType*);
-  virtual bool _isRValueFor(StructType*);
-  virtual bool _isRValueFor(SubprogramType*);
-private:
+  //Subprogram
   TypeList         _paramTypes;
   Type*            _returnType;
 };
 
-
 #endif

Modified: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-11-27 03:06:30 UTC (rev 396)
+++ trunk/gpt2/gptc/src/semantic.g	2007-11-27 16:01:16 UTC (rev 397)
@@ -240,7 +240,7 @@
 
   : #(T_MATRIZ ofType=tipo (dimensao {d++;})*)
 
-                            {type = _symtable->retrieveMatrixType(ofType,d);}
+                            {type = _symtable->getType(ofType,d);}
   ;
 
 dimensao



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 19:59:33 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 19:59:33 +0100
Subject: [gpt-commit] r398 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src
Message-ID: <200711271859.lARIxXxO023964@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-27 19:59:29 +0100 (Tue, 27 Nov 2007)
New Revision: 398

Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/CSymbol.cpp
   trunk/gpt2/common/src/CSymbol.hpp
   trunk/gpt2/common/src/CSymbolTable.cpp
   trunk/gpt2/common/src/CSymbolTable.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CCode.cpp
   trunk/gpt2/gptasm/src/CCode.hpp
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/CData.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/Makefile
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptvm/src/CBytecode.cpp
   trunk/gpt2/gptvm/src/CBytecode.hpp
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CExecutionStack.cpp
   trunk/gpt2/gptvm/src/CExecutionStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
   trunk/gpt2/gptvm/src/main.cpp
Log:
DEVNULL:
* Procedimentos definidos pelo usuario funcionando parcialmente
  - Chamada a procedimentos, com ou sem parametros
  - Variaveis locais ou globais
  - Parametros
* Reorganizacao parcial do codigo
* Limpeza de codigo nao mais utilizado


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -2,20 +2,7 @@
 
 #include "CBinString.hpp"
 
-// TODO: versoes BEM mais otimizadas :-)
-//int CData::getInt(const int &address)
-//{
-//   int *ret = (int*)&(_data[address]);
-//   return *ret;
-//}
-//void CData::setInt(const int &address, const int &value)
-//{
-//   int *targetAddress = (int*)&(_data[address]);
-//
-//   *targetAddress = value;
-//}
 
-
 void CBinString::writeInt(const int &value)
 {
    char *byte = (char*)&value;
@@ -59,14 +46,8 @@
 
 void CBinString::readInt(int &value)
 {
-   int result = 0;
-   char *byte = (char*)&result;
-
-   for( size_t i = 0; i < sizeof(int); i++) {
-      *byte = (*this)[0]; // TODO
-      byte++;
-      erase(0,1);
-   }
+   int result = *((int*)data());
+   erase(0,sizeof(int));
    value = result;
 //   std::cout << "readInt:" << value << std::endl;
 }
@@ -92,12 +73,7 @@
 
 int CBinString::getInt(int pos)
 {
-   int result = 0;
-   char *byte = (char*)&result;
-
-   for( size_t i = 0; i < sizeof(int); i++) {
-      *byte++ = (*this)[pos++];
-   }
+   int result = *((int*)(data()+pos));
    return result;
 }
 
@@ -135,17 +111,66 @@
 
 void CBinString::setInt(int pos, const int &value)
 {
-   char *byte = (char*)&value;
+   int *address = (int*)(data()+pos);
+   *address = value;
+}
 
-   for( size_t i = 0; i < sizeof(int); i++) {
-      (*this)[pos++] = *byte++;
+
+void CBinString::setCString(int pos, const std::string &value)
+{
+   replace(pos, value.length()+1, value + '\0');
+}
+
+
+void CBinString::pushInt(const int &value)
+{
+   writeInt(value);
+}
+
+
+int CBinString::popInt()
+{
+   int pos = size()-sizeof(int);
+   int result = *((int*)(data()+pos));
+
+   erase(pos,sizeof(int));
+
+   return result;
+//   std::cout << "readInt:" << value << std::endl;
+}
+
+
+int CBinString::getLastInt() const
+{
+   int pos = size()-sizeof(int);
+   int result = *((int*)(data()+pos));
+
+   return result;
+}
+
+
+void CBinString::pushCString(const std::string &value)
+{
+   (*this) += value;
+   (*this) += '\0';
+}
+
+
+void CBinString::pushBytes(const int &number)
+{
+   for (int i = 0; i < number; i++) {
+      writeByte(0);
    }
-   // TODO: BEM mais eficiente...
-   // int *targetAddress = (int*)&(_data[address]);
-   //*targetAddress = value;
 }
 
 
+void CBinString::popBytes(const int &number)
+{
+   int pos = size()-number;
+   erase(pos,number);
+}
+
+
 bool CBinString::removeIfEqual(const int &value)
 {
    // TODO: nao ta correto pq sempre retira...

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -20,6 +20,14 @@
    std::string readString();
    void readBool(bool &value);
    void setInt(int pos, const int &value);
+   void setCString(int pos, const std::string &value);
+   void pushInt(const int &value);
+   int popInt();
+   int getLastInt() const;
+   void pushCString(const std::string &value);
+   std::string popCString();
+   void pushBytes(const int &number);
+   void popBytes(const int &number);
    bool removeIfEqual(const int &value);
    bool removeIfEqual(const char &value);
    bool removeIfEqual(const std::string &value);

Modified: trunk/gpt2/common/src/CSymbol.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CSymbol.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -9,8 +9,9 @@
 }
 
 
-CSymbol::CSymbol (const std::string &name, const char &type, const char &category, const int &address)
-   : _name(name)
+CSymbol::CSymbol (const int &scope, const std::string &name, const char &type, const char &category, const int &address)
+   : _scope(scope)
+   , _name(name)
    , _type(type)
    , _category(category)
    , _address(address)
@@ -22,9 +23,10 @@
                   const int &address, const bool &hasVarArguments, 
                   const int &staticParameters, 
                   std::vector<CSymbol> parameters)
-   : _name(name)
+   : _scope(GLOBAL)
+   , _name(name)
    , _type(type)
-   , _category(CSymbol::PROC)
+   , _category(PROC)
    , _address(address)
    , _hasVarArguments(hasVarArguments)
    , _staticParameters(staticParameters)
@@ -57,6 +59,7 @@
 
 bool CSymbol::readFromBinary(CBinString &bin)
 {
+   _scope = GLOBAL;
    bin.readInt(_address);
    bin.readByte(_category);
 

Modified: trunk/gpt2/common/src/CSymbol.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CSymbol.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -9,29 +9,37 @@
 class CSymbol
 {
 public:
+   enum EScope {
+      GLOBAL = 'G',
+      LOCAL  = 'L'
+   };
    enum ECategory {
-      PROC = 'P',
+      PROC  = 'P',
       CONST = 'C',
-      VAR = 'V',
+      VAR   = 'V',
       PARAM = 'P'
    };
    enum EType {
       NO_TYPE = 'N',
-      STRING = 'S',
-      INT = 'I',
-      CHAR = 'C',
-      BOOL = 'B',
-      REAL = 'R',
-      MATRIX = 'M',
+      STRING  = 'S',
+      INT     = 'I',
+      CHAR    = 'C',
+      BOOL    = 'B',
+      REAL    = 'R',
+      MATRIX  = 'M',
       POINTER = 'P'
    };
    CSymbol ();
-   CSymbol (const std::string &name, const char &type, const char &category,
-            const int &address);
+   CSymbol (const int &scope, const std::string &name, const char &type, 
+            const char &category, const int &address);
    CSymbol (const std::string &name, const char &type, const int &address,
             const bool &hasVarArguments, const int &staticParameters,
             std::vector<CSymbol> parameters);
    virtual ~CSymbol();
+   int getScope() const
+   {
+      return _scope;
+   }
    std::string getName() const
    {
       return _name;
@@ -63,6 +71,7 @@
       return _parameters;
    }
 private:
+   int                  _scope;
    std::string          _name;
    char                 _type;
    char                 _category;

Modified: trunk/gpt2/common/src/CSymbolTable.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -34,7 +34,7 @@
 
 CSymbol* CSymbolTable::addParameter (const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol( name, type, CSymbol::PARAM, address);
+   CSymbol *symbol = new CSymbol(CSymbol::LOCAL, name, type, CSymbol::PARAM, address | 0x80000000);
 
    _symbols.push_back(symbol);
 
@@ -46,7 +46,7 @@
 
 CSymbol* CSymbolTable::addConstant (const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol( name, type, CSymbol::CONST, address);
+   CSymbol *symbol = new CSymbol(CSymbol::GLOBAL, name, type, CSymbol::CONST, address);
 
    _symbols.push_back(symbol);
 
@@ -61,18 +61,26 @@
 }
 
 
-CSymbol* CSymbolTable::addVariable (const std::string &name, const int &type, const int &address)
+CSymbol* CSymbolTable::addVariable (const int &scope, const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol( name, type, CSymbol::VAR, address);
+   CSymbol *symbol = NULL;
 
+   if (scope == CSymbol::GLOBAL) {
+      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address);
+   } else {
+      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address | 0x80000000 );
+   }
+
    _symbols.push_back(symbol);
 
-   // Endere?o 0000 (data), variavel, string, 8 bytes ???, nome "v1"
-   // 0000: 0000 V S 8??? 2 "v1"
-   writeInt( address );
-   writeByte( CSymbol::VAR ); // categoria: variavel
-   writeByte( type );         // tipo
-   writeString( name );       // nome da variavel
+   if (scope == CSymbol::GLOBAL) {
+      // Endere?o 0000 (data), variavel, string, 8 bytes ???, nome "v1"
+      // 0000: 0000 V S 8??? 2 "v1"
+      writeInt( address );
+      writeByte( CSymbol::VAR ); // categoria: variavel
+      writeByte( type );         // tipo
+      writeString( name );       // nome da variavel
+   }
 
    return symbol;
 }
@@ -98,3 +106,14 @@
    return true;
 }
 
+
+void CSymbolTable::clearLocalSymbols()
+{
+   for(size_t pos = 0; pos < _symbols.size(); pos++) {
+      if (_symbols[pos]->getScope() == CSymbol::LOCAL) {
+         _symbols.erase(_symbols.begin() + pos);
+         pos--;
+      }
+   }
+}
+

Modified: trunk/gpt2/common/src/CSymbolTable.hpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/CSymbolTable.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -16,9 +16,10 @@
    CSymbol* addProcedure (const std::string &name, const int &type, const int &address, const bool &hasVarArguments, const int &staticParameters, std::vector<CSymbol> parameters);
    CSymbol* addParameter (const std::string &name, const int &type, const int &address);
    CSymbol* addConstant (const std::string &name, const int &type, const int &address);
-   CSymbol* addVariable (const std::string &name, const int &type, const int &address);
+   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, const int &address);
    CSymbol* add(CSymbol *symbol);
    bool readFromBinary(CBinString &bin);
+   void clearLocalSymbols();
 };
 
 #endif

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -35,14 +35,14 @@
    OP_IEQ         = 30,
    OP_SEQ         = 31,
    OP_REQ         = 32,
-   OP_OR = 33,
+   OP_OR          = 33,
    OP_AND         = 34,
    OP_XOR         = 35,
-   OP_INEG = 36,
-   OP_RNEG = 37,
+   OP_INEG        = 36,
+   OP_RNEG        = 37,
    OP_NOT         = 38,
-   OP_IINC = 39,
-   OP_IDEC = 40,
+   OP_IINC        = 39,
+   OP_IDEC        = 40,
    OP_I2C         = 41,
    OP_R2C         = 42,
    OP_S2C         = 43,
@@ -64,53 +64,59 @@
    OP_R2I         = 59,
    OP_S2I         = 60,
    OP_B2I         = 61,
-   OP_ISET = 62,
-   OP_SSET = 63,
-   OP_RSET = 64,
-   OP_GETA = 65,
-   OP_IGETV = 66,
-   OP_SGETV = 67,
-   OP_RGETV = 68,
-   OP_ISETV = 69,
-   OP_SSETV = 70,
-   OP_RSETV = 71,
+   OP_ISET        = 62,
+   OP_SSET        = 63,
+   OP_RSET        = 64,
+   OP_GETA        = 65,
+   OP_IGETV       = 66,
+   OP_SGETV       = 67,
+   OP_RGETV       = 68,
+   OP_ISETV       = 69,
+   OP_SSETV       = 70,
+   OP_RSETV       = 71,
    OP_JMP         = 72,
-   OP_IF = 73,
-   OP_IFNOT = 74,
-   OP_PUSH = 75,
+   OP_IF          = 73,
+   OP_IFNOT       = 74,
+//   OP_PUSH = 75,
    OP_POP         = 76,
-   OP_INCSP = 77,
-   OP_DECSP = 78,
-   OP_PUSH_INT = 79,
+   OP_INCSP       = 77,
+   OP_DECSP       = 78,
+   OP_PUSH_INT    = 79,
    OP_PUSH_STRING = 80,
-   OP_PUSH_REAL = 81,
-   OP_PUSH_CHAR = 82,
-   OP_PUSH_BOOL = 83,
+   OP_PUSH_REAL   = 81,
+   OP_PUSH_CHAR   = 82,
+   OP_PUSH_BOOL   = 83,
    OP_PUSH_MATRIX = 84,
-   OP_PUSH_SREG = 85,
-   OP_POP_SREG = 86,
-   OP_INCSP_4 = 87,
-   OP_INCSP_8 = 88,
-   OP_DECSP_4 = 89,
-   OP_DECSP_8 = 90,
-   OP_PCALL = 91,
+   OP_PUSH_SREG   = 85,
+   OP_POP_SREG    = 86,
+   OP_INCSP_4     = 87,
+   OP_INCSP_8     = 88,
+   OP_DECSP_4     = 89,
+   OP_DECSP_8     = 90,
+   OP_PCALL       = 91,
    OP_RET         = 92,
-   OP_LIBCALL = 93,
-   OP_SALLOC = 94,
-   OP_SFREE = 95,
-   OP_SSETC = 96,
-   OP_SGETC = 97,
-   OP_M1ALLOC = 98,
-   OP_M2ALLOC = 99,
-   OP_MFREE = 100,
-   OP_M1SET = 101,
-   OP_M1GET = 102,
-   OP_M2SET = 103,
-   OP_M2GET = 104,
-   OP_MCOPY = 105,
-   OP_MGETSIZE1 = 106,
-   OP_MGETSIZE2 = 107,
-   OPCODE_NUMBER  = 108
+   OP_LIBCALL     = 93,
+   OP_SALLOC      = 94,
+   OP_SFREE       = 95,
+   OP_SSETC       = 96,
+   OP_SGETC       = 97,
+   OP_M1ALLOC     = 98,
+   OP_M2ALLOC     = 99,
+   OP_MFREE       = 100,
+   OP_M1SET       = 101,
+   OP_M1GET       = 102,
+   OP_M2SET       = 103,
+   OP_M2GET       = 104,
+   OP_MCOPY       = 105,
+   OP_MGETSIZE1   = 106,
+   OP_MGETSIZE2   = 107,
+   OP_PUSH_ITYPE  = 108,
+   OP_PUSH_STYPE  = 109,
+   OP_PUSH_RTYPE  = 110,
+   OP_PUSH_CTYPE  = 111,
+   OP_PUSH_BTYPE  = 112,
+   OP_PUSH_MTYPE  = 113,
+   OPCODE_NUMBER  = 113
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CCode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CCode.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CCode.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,2 +0,0 @@
-#include "CCode.hpp"
-

Modified: trunk/gpt2/gptasm/src/CCode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CCode.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CCode.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,17 +0,0 @@
-#ifndef GPT_CODE_H
-#define GPT_CODE_H
-
-
-#include <string>
-
-#include "CBinString.hpp"
-
-
-class CCode : public CBinString
-{
-public:
-private:
-};
-
-#endif
-

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -19,9 +19,9 @@
 }
 
 
-CSymbol* CData::addVariable (const std::string &name, const int &type, const int &address)
+CSymbol* CData::addVariable (const int &scope, const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol (name, type, CSymbol::VAR, address);
+   CSymbol *symbol = new CSymbol (scope, name, type, CSymbol::VAR, address);
 
    _symbols.push_back(symbol);
 
@@ -37,7 +37,7 @@
 
 CSymbol* CData::addConstant (const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol (name, type, CSymbol::CONST, address);
+   CSymbol *symbol = new CSymbol (CSymbol::GLOBAL, name, type, CSymbol::CONST, address);
 
    _symbols.push_back(symbol);
 

Modified: trunk/gpt2/gptasm/src/CData.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CData.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -13,7 +13,7 @@
    CData();
    ~CData();
    CSymbol* add(CSymbol *symbol);
-   CSymbol* addVariable (const std::string &name, const int &type, const int &address);
+   CSymbol* addVariable (const int &scope, const std::string &name, const int &type, const int &address);
    CSymbol* addConstant (const std::string &name, const int &type, const int &address);
 };
 

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -5,6 +5,7 @@
 
 
 #include "Common.hpp"
+#include "Tools.hpp"
 
 
 CGenBytecode::CGenBytecode()
@@ -82,7 +83,7 @@
    _opcodes[ "jmp"         ] = OP_JMP;
    _opcodes[ "if"          ] = OP_IF;
    _opcodes[ "ifnot"       ] = OP_IFNOT;
-   _opcodes[ "push"        ] = OP_PUSH;
+//   _opcodes[ "push"        ] = OP_PUSH;
    _opcodes[ "pop"         ] = OP_POP;
    _opcodes[ "incsp"       ] = OP_INCSP;
    _opcodes[ "decsp"       ] = OP_DECSP;
@@ -98,6 +99,12 @@
    _opcodes[ "push_char"   ] = OP_PUSH_CHAR;
    _opcodes[ "push_bool"   ] = OP_PUSH_BOOL;
    _opcodes[ "push_matrix" ] = OP_PUSH_MATRIX;
+   _opcodes[ "push_itype"  ] = OP_PUSH_ITYPE;
+   _opcodes[ "push_stype"  ] = OP_PUSH_STYPE;
+   _opcodes[ "push_rtype"  ] = OP_PUSH_RTYPE;
+   _opcodes[ "push_ctype"  ] = OP_PUSH_CTYPE;
+   _opcodes[ "push_btype"  ] = OP_PUSH_BTYPE;
+   _opcodes[ "push_mtype"  ] = OP_PUSH_MTYPE;
    _opcodes[ "push_sreg"   ] = OP_PUSH_SREG;
    _opcodes[ "pop_sreg"    ] = OP_POP_SREG;
    _opcodes[ "incsp_4"     ] = OP_INCSP_4;
@@ -141,32 +148,42 @@
    _symbolTable.addProcedure (procedureName, CSymbol::NO_TYPE, _code.size(), hasVarArguments, staticParameters, parameters);
    _currentProcedure = procedureName;
    _currentSP = 0;
-//   _unsolvedLabels.clear();
-//   _solvedLabels.clear();
     registryLabel(procedureName);
 }
 
 
 void CGenBytecode::finishProcedure()
 {
-//   translateLabelsToAddress();
    _currentProcedure.clear();
+   _currentSP = 0;
+   _symbolTable.clearLocalSymbols();
    // TODO: delete na procedure ???
 }
 
 
 void CGenBytecode::makeVarDefinition(const std::string &lexeme, const int &type)
 {
-   if (_currentProcedure.empty()) { // assumindo que sao dados globais...
-      _symbolTable.addVariable (lexeme, type, _data.getDataSize());
+   if (_currentProcedure.empty()) {
+      // variavel global
+      _symbolTable.addVariable (CSymbol::GLOBAL, lexeme, type, _data.getDataSize());
+      std::cout << "var global " << lexeme << " address " << _data.getDataSize() << std::endl;
+      _data.addVariable (CSymbol::GLOBAL, lexeme, type, _data.getDataSize());
+   } else {
+      // variavel local
+      CSymbol *symbol = _symbolTable.addVariable (CSymbol::LOCAL, lexeme, type, _currentSP);
+      std::cout << "var local " << lexeme << " address " << _currentSP << std::endl;
+      _currentSP += symbol->getTypeSize();
+      // gera incsp XXX
+      _code.writeByte(OP_INCSP);
+      addAddress(itoa(symbol->getTypeSize()), CSymbol::CONST, CSymbol::INT);
    }
-   _data.addVariable (lexeme, type, _data.getDataSize());
 }
 
 
 void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
 {
    CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
+   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
    _currentSP += symbol->getTypeSize();
 }
 
@@ -192,12 +209,11 @@
 
 void CGenBytecode::addAddress(const std::string &id, const int &category, const int &type)
 {
-   int ref = _data.getAddress(id);
-   if (ref == -1) {
-      //ref = _data.add((new CSymbol())->setAsConstantData( id, type, _data.getDataSize()))->getAddress();
-      ref = _data.addConstant (id, type, _data.getDataSize())->getAddress();
+   int address = _symbolTable.getAddress(id);
+   if (address == -1) {
+      address = _data.addConstant (id, type, _data.getDataSize())->getAddress();
    }
-   _code.writeInt(ref);
+   _code.writeInt(address);
 }
 
 
@@ -207,15 +223,12 @@
 
    ret += _header.getBinary();
 
-//   std::cout << "symbolTable.getSymbolsCount()=" << _symbolTable.getSymbolsCount() << std::endl;
    ret.writeInt(_symbolTable.getSymbolsCount());
    ret += _symbolTable;
 
-//   std::cout << "data.size()=" << _data.getDataSize() << std::endl;
    ret.writeInt(_data.getDataSize());
    ret += _data;
 
-//   std::cout << "code.size()=" << _code.size() << std::endl;
    ret.writeInt(_code.size());
    ret += _code;
 

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -8,7 +8,6 @@
 #include "CHeader.hpp"
 #include "CSymbolTable.hpp"
 #include "CData.hpp"
-#include "CCode.hpp"
 #include "CBinString.hpp"
 
 class CGenBytecode
@@ -31,7 +30,7 @@
    CHeader                    _header;
    CSymbolTable               _symbolTable;
    CData                      _data;
-   CCode                      _code;
+   CBinString                 _code;
    std::map<std::string,char> _opcodes;
    std::string                _currentProcedure;
    int                        _currentSP;

Modified: trunk/gpt2/gptasm/src/Makefile
===================================================================
--- trunk/gpt2/gptasm/src/Makefile	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/Makefile	2007-11-27 18:59:29 UTC (rev 398)
@@ -5,8 +5,8 @@
 CCFLAGS=-g -Wall
 
 objects = GptAssemblyLexer.o GptAssemblyParser.o main.o CGptAsm.o CGenBytecode.o \
-	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o CCode.o $(COMMON_DIR)CHeader.o \
-        CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o
+	$(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o $(COMMON_DIR)CHeader.o \
+        CData.o $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o $(COMMON_DIR)Tools.o
 
 all: $(objects)
 	g++ -o gptasm $(objects) /usr/local/lib/libantlr.a

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,12 +1,6 @@
 header {
    #include <string>
-  #include <sstream>
-//  #include <iostream>
-//  #include <ctype.h>
-//  #include <antlr/TokenStreamSelector.hpp>
-//
-//  using namespace antlr;
-//  using namespace std;
+   #include <sstream>
 }
 
 
@@ -117,7 +111,6 @@
    T_KW_JMP="jmp";
    T_KW_IF="if";
    T_KW_IFNOT="ifnot";
-   T_KW_PUSH="push";
    T_KW_POP="pop";
    T_KW_INCSP="incsp";
    T_KW_DECSP="decsp";
@@ -133,6 +126,12 @@
    T_KW_PUSH_CHAR="push_char";
    T_KW_PUSH_BOOL="push_bool";
    T_KW_PUSH_MATRIX="push_matrix";
+   T_KW_PUSH_ITYPE="push_itype";
+   T_KW_PUSH_STYPE="push_stype";
+   T_KW_PUSH_RTYPE="push_rtype";
+   T_KW_PUSH_CTYPE="push_ctype";
+   T_KW_PUSH_BTYPE="push_btype";
+   T_KW_PUSH_MTYPE="push_mtype";
    T_KW_PUSH_SP="push_sreg";
    T_KW_POP_SP="pop_sreg";
    T_KW_INCSP_4="incsp_4";
@@ -169,19 +168,8 @@
 
 {
 public:  
-//  void setNextFilename(string str) {
-//    nextFilename = str;
-//  }
 
-//  string getNextFilename( )
-//  {
-//    return nextFilename;
-//  }
-
 private:
-//  string nextFilename;
-//  TokenStreamSelector* selector;  
-//  bool hasLatim;
 }
 
 

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-27 18:59:29 UTC (rev 398)
@@ -108,13 +108,10 @@
 //---------------------
   procedure_declaration
 //---------------------
-{
-   std::vector<CSymbol> parameters;
-}
   : "proc" 
    tk_id:T_ID
     { bytecode.initProcedure(tk_id->getText(), false, 0, std::vector<CSymbol>()); }
-    (parameter_declaration[parameters])*
+    (parameter_declaration)*
     (var_declaration)*
     code_block
     { bytecode.finishProcedure(); }
@@ -122,14 +119,13 @@
   ;
 
 //---------------------
-  parameter_declaration [std::vector<CSymbol> &parameters]
+  parameter_declaration
 //---------------------
 {
   int tk_type;
 }
   : "param" ("ref")? tk_id:T_ID tk_type=primitive_type
     { declareParameter( tk_id->getText(), tk_type ); }
-    { parameters.push_back(CSymbol(tk_id->getText(), tk_type, CSymbol::PARAM, 0)); } // TODO: nao eh zero...
   ;
 
 //#####################
@@ -249,9 +245,11 @@
 //--------------------
   mn_chamada_subrotina
 //--------------------
-   :  "push"
+   :  ("push_int"|"push_string"|"push_real"|"push_char"|"push_bool"|"push_matrix")
       {bytecode.addOpcode(getLastTokenText());}
       element
+   |  ("push_itype"|"push_stype"|"push_rtype"|"push_ctype"|"push_btype"|"push_mtype")
+      {bytecode.addOpcode(getLastTokenText());}
    |  "pop"
       {bytecode.addOpcode(getLastTokenText());}
       identifier
@@ -261,8 +259,6 @@
       { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
 //   |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
 //      {bytecode.addOpcode(getLastTokenText());}
-   |  ("push_int"|"push_string"|"push_real"|"push_char"|"push_bool"|"push_matrix")
-      {bytecode.addOpcode(getLastTokenText());}
    |  ("push_sreg"|"pop_sreg")
       {bytecode.addOpcode(getLastTokenText());}
    |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
@@ -378,11 +374,10 @@
 //    )?
 //  ; 
 
-//---------------------------------
-  element //returns [std::string ret]
-//---------------------------------
+//-------
+  element
+//-------
   : identifier //{ bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::STRING); }
-//  | ret=literal
   | literal
   ;
 

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -25,9 +25,9 @@
 
     // imprima( x );
     push_sreg
-    push x
-    push_int
-    push 1
+    push_int x
+    push_itype
+    push_int 1
     libcall imprima
     pop_sreg
 

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -14,9 +14,9 @@
 
     // imprima( x );
     push_sreg
-    push x
-    push_int
-    push 1
+    push_int x
+    push_itype
+    push_int 1
     libcall imprima
     pop_sreg
 

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -8,11 +8,11 @@
     push_sreg
     imul t1, 5, 3
     isum t2, 2, t1
-    push t2
-    push_int
-    push "2+5*3="
-    push_string
-    push 2
+    push_int t2
+    push_itype
+    push_string "2+5*3="
+    push_stype
+    push_int 2
     libcall imprima
     pop_sreg
 

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -2,9 +2,9 @@
 
 proc main
     push_sreg
-    push "Ol? mundo !!!"
-    push_string
-    push 1
+    push_string "Ol? mundo !!!"
+    push_stype
+    push_int 1
     libcall imprima
     pop_sreg
 

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -2,12 +2,12 @@
 
 proc main
     // soma( 2, 7 );
-    push_sp
-    push 7
-    push 2
+    push_sreg
+    push_int 2
+    push_int 7
     pcall soma
-    pop_sp
-	
+    pop_sreg
+
     exit 0
 endproc
 
@@ -17,20 +17,20 @@
 
     var t1 int
 
-    push_sp
-    push "A soma ?: "
-    push_string
-    push 1
-    pcall imprima
-    pop_sp
+//    push_sreg
+//    push_string "A soma ?: "
+//    push_stype
+//    push_int 1
+//    libcall imprima
+//    pop_sreg
 
-    push_sp
     isum t1, x, y
-    push t1
-    push_int
-    push 1
-    pcall imprima
-    pop_sp
+//    push_sreg
+    push_int t1
+    push_itype
+    push_int 1
+    libcall imprima
+//    pop_sreg
 
     ret	
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -6,9 +6,9 @@
    pop_sreg
 
    push_sreg
-   push "Finalizando..."
-   push_string
-   push 1
+   push_string "Finalizando..."
+   push_stype
+   push_int 1
    libcall imprima
    pop_sreg
 
@@ -21,9 +21,9 @@
    isum temp, 2, 4
 
    push_sreg
-   push temp
-   push_int
-   push 1
+   push_int temp
+   push_itype
+   push_int 1
    libcall imprima
    pop_sreg
 
@@ -31,3 +31,4 @@
 endproc
    
 endprogram
+

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-27 18:59:29 UTC (rev 398)
@@ -3,6 +3,9 @@
 var x int
 var y int
 
+//    var t1 int
+//    var t2 int
+
 proc main
     var t1 int
     var t2 int
@@ -17,11 +20,11 @@
     push_sreg
     imul t1, x, y
     isum t2, t1, 4
-    push t2
-    push_int
-    push "x*y+4="
-    push_string
-    push 2
+    push_int t2
+    push_itype
+    push_string "x*y+4="
+    push_stype
+    push_int 2
     libcall imprima
     pop_sreg
 	

Modified: trunk/gpt2/gptvm/src/CBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CBytecode.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,18 +1,24 @@
 #include "CBytecode.hpp"
 
+#include <iostream>
+
 CBytecode::CBytecode()
    : _IP(0)
 {
 }
 
 
-CBytecode::~CBytecode()
-{
-}
+//CBytecode::~CBytecode()
+//{
+//}
 
 
 char CBytecode::fetchByte()
 {
+   if (_IP >= size()) {
+      std::cout << "Erro limite em fetchByte()" << std::endl;
+      abort();
+   }
    char result = getByte(_IP);
    _IP += sizeof(char);
    return result;

Modified: trunk/gpt2/gptvm/src/CBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CBytecode.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -9,7 +9,7 @@
 {
 public:
    CBytecode();
-  ~CBytecode();
+//  ~CBytecode();
    char fetchByte();
    int  fetchInt();
    void setIP(const int &IP);

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,7 +1,12 @@
 #include "CDataStack.hpp"
 
 
+#include <iostream>
+
+
 CDataStack::CDataStack()
+   : _BS(0)
+   , _SP(0)
 {
 }
 
@@ -10,3 +15,81 @@
 {
 }
 
+
+void CDataStack::setInt(const int &address, const int &value)
+{
+//   std::cout << "setInt ";
+   if (address & 0x80000000) {
+//      std::cout << "local address sem bit ligado: " << (address & 0x7FFFFFFF) << std::endl;
+      CBinString::setInt(_BS + (address & 0x7FFFFFFF), value);
+   } else {
+      std::cout << "ERRO !!! Invocando setInt com global address: " << address << std::endl;
+   }
+}
+
+
+int CDataStack::getInt(const int &address)
+{
+//   std::cout << "getInt ";
+   if (address & 0x80000000) {
+//      std::cout << "local address sem bit ligado: " << (address & 0x7FFFFFFF) << std::endl;
+      return CBinString::getInt(_BS + (address & 0x7FFFFFFF));
+   } else {
+      std::cout << "ERRO !!! Invocando getInt com global address: " << address << std::endl;
+      return -1;
+   }
+}
+
+
+void CDataStack::pushInt(const int &value)
+{
+   CBinString::pushInt(value);
+   _SP+=sizeof(int);
+}
+
+
+int CDataStack::popInt()
+{
+   int result = CBinString::popInt();
+   _SP-=sizeof(int);
+   return result;
+}
+
+
+void CDataStack::pushBytes(const int &number)
+{
+   CBinString::pushBytes(number);
+   _SP += number;
+}
+
+
+void CDataStack::popBytes(const int &number)
+{
+   CBinString::popBytes(number);
+   _SP -= number;
+}
+
+
+void CDataStack::setBS(const int &value)
+{
+   _BS = value;
+}
+
+
+void CDataStack::setSP(const int &value)
+{
+   _SP = value;
+}
+
+
+int CDataStack::getBS() const
+{
+   return _BS;
+}
+
+
+int CDataStack::getSP() const
+{
+   return _SP;
+}
+

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -2,15 +2,27 @@
 #define GPT_DATA_STACK_H
 
 
-#include <stack>
+#include "CBinString.hpp"
 
 
-class CDataStack : public std::stack<void*>
+class CDataStack : public CBinString
 {
 public:
    CDataStack();
    ~CDataStack();
+   void setInt(const int &address, const int &value);
+   int getInt(const int &address);
+   void pushInt(const int &value);
+   int popInt();
+   void pushBytes(const int &number);
+   void popBytes(const int &number);
+   void setBS(const int &value);
+   void setSP(const int &value);
+   int getBS() const;
+   int getSP() const;
 private:
+   int _BS;
+   int _SP; // TODO: SP eh equivalente a size() ???
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/CExecutionStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CExecutionStack.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CExecutionStack.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,27 +0,0 @@
-#include "CExecutionStack.hpp"
-
-
-CExecutionStack::CExecutionStack()
-   : _BP(0)
-   , _SP(0)
-{
-}
-
-
-void CExecutionStack::pushStackRegs()
-{
-   push(_BP);
-   push(_SP);
-   _BP = _SP;
-}
-
-
-void CExecutionStack::popStackRegs()
-{
-   _SP = top();
-   pop();
-
-   _BP = top();
-   pop();
-}
-

Modified: trunk/gpt2/gptvm/src/CExecutionStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CExecutionStack.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CExecutionStack.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -1,19 +0,0 @@
-#ifndef GPT_EXECUTION_STACK_HPP
-#define GPT_EXECUTION_STACK_HPP
-
-#include <stack>
-
-
-class CExecutionStack : public std::stack<int>
-{
-public:
-   CExecutionStack();
-   void pushStackRegs();
-   void popStackRegs();
-private:
-   int _BP;
-   int _SP;
-};
-
-#endif
-

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -25,7 +25,7 @@
    _header.readFromBinary(bin) &&
          _symbolTable.readFromBinary(bin);
 
-   bin.readString(_data);
+   bin.readString(_globalData);
 
    _code.assign(bin.readString());
 
@@ -41,7 +41,7 @@
    _opcodePointer[OP_NOP        ] = &CRunBytecode::nopOpcode;
    _opcodePointer[OP_PUSH_SREG  ] = &CRunBytecode::pushSregOpcode;
    _opcodePointer[OP_POP_SREG   ] = &CRunBytecode::popSregOpcode;
-   _opcodePointer[OP_PUSH       ] = &CRunBytecode::pushOpcode;
+//   _opcodePointer[OP_PUSH       ] = &CRunBytecode::pushOpcode;
    _opcodePointer[OP_PUSH_STRING] = &CRunBytecode::pushStringOpcode;
 //   _opcodePointer[OP_PUSH_1     ] = &CRunBytecode::push1Opcode;
    _opcodePointer[OP_PCALL      ] = &CRunBytecode::pcallOpcode;
@@ -140,9 +140,16 @@
    _opcodePointer[OP_PUSH_BOOL  ] = &CRunBytecode::pushBoolOpcode;
    _opcodePointer[OP_PUSH_MATRIX] = &CRunBytecode::pushMatrixOpcode;
 
-//   OP_INCSP_4,
+   _opcodePointer[OP_PUSH_STYPE ] = &CRunBytecode::pushSTypeOpcode;
+   _opcodePointer[OP_PUSH_ITYPE ] = &CRunBytecode::pushITypeOpcode;
+   _opcodePointer[OP_PUSH_RTYPE ] = &CRunBytecode::pushRTypeOpcode;
+   _opcodePointer[OP_PUSH_CTYPE ] = &CRunBytecode::pushCTypeOpcode;
+   _opcodePointer[OP_PUSH_BTYPE ] = &CRunBytecode::pushBTypeOpcode;
+   _opcodePointer[OP_PUSH_MTYPE ] = &CRunBytecode::pushMTypeOpcode;
+
+   _opcodePointer[OP_INCSP_4    ] = &CRunBytecode::incsp4Opcode;
 //   OP_INCSP_8,
-//   OP_DECSP_4,
+   _opcodePointer[OP_DECSP_4    ] = &CRunBytecode::decsp4Opcode;
 //   OP_DECSP_8,
 
    _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
@@ -165,7 +172,8 @@
 
 int CRunBytecode::run()
 {
-//   std::cout << "Code lido: [" << _code.getBinary() << "]" << " size=" << _code.getBinary().size() << std::endl;
+   //std::cout << "Code lido: [" << _code.getBinary() << "]" << " size=" << _code.getBinary().size() << std::endl;
+//   std::cout << "Code size=" << _code.size() << std::endl;
 
    initOpcodePointer();
    _code.setIP(0); // TODO: pegar o endereco de main
@@ -204,28 +212,24 @@
 
 void CRunBytecode::procImprima()
 {
-   int argNumber = _data.getInt((int)_dataStack.top());
-   _dataStack.pop();
+   int argNumber = _dataStack.popInt();
 
    for (int arg=0; arg < argNumber; arg++) {
-      int type = (int)_dataStack.top();
-      _dataStack.pop();
-      int address = (int)_dataStack.top();
-      _dataStack.pop();
-      int value;
+      int type = _dataStack.popInt();
+      int boolValue;
       switch (type) {
          case CSymbol::STRING:
-            std::cout << _data.getCString(address);
+            std::cout << getStringData(_dataStack.popInt());
             break;
          case CSymbol::INT:
-            std::cout << _data.getInt(address);
+            std::cout << _dataStack.popInt();
             break;
          case CSymbol::CHAR:
-            std::cout << (char)_data.getInt(address);
+            std::cout << (char)_dataStack.popInt();
             break;
          case CSymbol::BOOL:
-            value = _data.getInt(address);
-            if (value == 0) {
+            boolValue = _dataStack.popInt();
+            if (boolValue == 0) {
                std::cout << "false";
             } else {
                std::cout << "true";
@@ -234,7 +238,7 @@
          case CSymbol::REAL:
          case CSymbol::MATRIX:
          default:
-            std::cout << "Tipo nao suportado !!!" << std::endl;
+            std::cout << "Tipo ainda nao suportado !!!" << std::endl;
             abort();
       }
    }
@@ -261,29 +265,36 @@
 {
    trace ("push_sreg opcode");
 
-   _executionStack.pushStackRegs();
+   _executionStack.push(_dataStack.getBS());
+   _executionStack.push(_dataStack.getSP());
 }
 
 void CRunBytecode::popSregOpcode()
 {
    trace ("pop_sreg opcode");
 
-   _executionStack.popStackRegs();
+   _dataStack.setSP(_executionStack.top());
+   _executionStack.pop();
+
+   _dataStack.setBS(_executionStack.top());
+   _executionStack.pop();
 }
 
-void CRunBytecode::pushOpcode()
+
+void CRunBytecode::pushStringOpcode()
 {
-   trace ("push opcode");
+   trace ("push_string opcode");
 
    int address = _code.fetchInt();
-   _dataStack.push((void*)address);
+
+   _dataStack.pushInt(address);
 }
 
-void CRunBytecode::pushStringOpcode()
+void CRunBytecode::pushSTypeOpcode()
 {
-   trace ("push_string opcode");
+   trace ("push_stype opcode");
 
-   _dataStack.push((void*)CSymbol::STRING);
+   _dataStack.pushInt(CSymbol::STRING);
 }
 
 
@@ -291,6 +302,8 @@
 {
    trace ("pcall opcode");
 
+   _dataStack.setBS(_executionStack.top()); // TODO: verificar melhor isso...
+
    int address = _code.fetchInt();
 
    _executionStack.push(_code.getIP());
@@ -304,7 +317,7 @@
 
    int address = _code.fetchInt();
 
-   if (_data.getCString(address) == "imprima") {
+   if (_globalData.getCString(address) == "imprima") {
       procImprima();
    } else {
       error("libcall invocando subrotina desconhecida !!!");
@@ -316,7 +329,7 @@
 {
    trace ("exit opcode");
 
-   _returnCode = _code.fetchInt();
+   _returnCode = getIntData(_code.fetchInt());
 
    _stop = true;
 }
@@ -337,7 +350,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) + _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) + getIntData(val2Address));
 }
 
 void CRunBytecode::ssumOpcode()
@@ -358,7 +371,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) - _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) - getIntData(val2Address));
 }
 
 void CRunBytecode::ssubOpcode()
@@ -379,7 +392,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) * _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) * getIntData(val2Address));
 }
 
 void CRunBytecode::rmulOpcode()
@@ -395,7 +408,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) / _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) / getIntData(val2Address));
 }
 
 void CRunBytecode::rdivOpcode()
@@ -411,7 +424,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) % _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) % getIntData(val2Address));
 }
 
 void CRunBytecode::rmodOpcode()
@@ -427,7 +440,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) >= _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) >= getIntData(val2Address));
 }
 
 void CRunBytecode::sgeOpcode()
@@ -448,7 +461,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) <= _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) <= getIntData(val2Address));
 }
 
 void CRunBytecode::sleOpcode()
@@ -469,7 +482,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) != _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) != getIntData(val2Address));
 }
 
 void CRunBytecode::sneOpcode()
@@ -490,7 +503,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) > _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) > getIntData(val2Address));
 }
 
 void CRunBytecode::sgtOpcode()
@@ -511,7 +524,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) < _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) < getIntData(val2Address));
 }
 
 void CRunBytecode::sltOpcode()
@@ -532,7 +545,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) == _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) == getIntData(val2Address));
 }
 
 void CRunBytecode::seqOpcode()
@@ -553,7 +566,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) || _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) || getIntData(val2Address));
 }
 
 void CRunBytecode::andOpcode()
@@ -564,7 +577,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(val1Address) && _data.getInt(val2Address));
+   setIntData(varAddress, getIntData(val1Address) && getIntData(val2Address));
 }
 
 void CRunBytecode::xorOpcode()
@@ -594,7 +607,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(varAddress) + _data.getInt(valAddress));
+   setIntData(varAddress, getIntData(varAddress) + getIntData(valAddress));
 }
 
 void CRunBytecode::idecOpcode()
@@ -604,7 +617,7 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(varAddress) - _data.getInt(valAddress));
+   setIntData(varAddress, getIntData(varAddress) - getIntData(valAddress));
 }
 
 void CRunBytecode::i2cOpcode()
@@ -719,9 +732,54 @@
    int varAddress = _code.fetchInt();
    int valAddress = _code.fetchInt();
 
-   _data.setInt(varAddress, _data.getInt(valAddress));
+   setIntData(varAddress, getIntData(valAddress));
 }
 
+
+void CRunBytecode::setIntData(const int &address, const int &value)
+{
+   if (address & 0x80000000) {
+      _dataStack.setInt(address, value);
+   } else {
+//      std::cout << "setIntData global address: " << address << std::endl;
+      _globalData.setInt(address, value); // TODO: _globalData ou _globalData ???
+   }
+}
+
+
+int CRunBytecode::getIntData(const int &address)
+{
+   if (address & 0x80000000) {
+      return _dataStack.getInt(address);
+   } else {
+//      std::cout << "global address: " << address << std::endl;
+      return _globalData.getInt(address);
+   }
+}
+
+
+void CRunBytecode::setStringData(const int &address, const std::string &value)
+{
+   if (address & 0x80000000) {
+      _dataStack.setCString(address, value);
+   } else {
+//      std::cout << "setCStringData global address: " << address << std::endl;
+      _globalData.setCString(address, value);
+   }
+}
+
+
+std::string CRunBytecode::getStringData(const int &address)
+{
+   if (address & 0x80000000) {
+      return _dataStack.getCString(address);
+   } else {
+//      std::cout << "global address: " << address << std::endl;
+      return _globalData.getCString(address);
+   }
+}
+
+
 void CRunBytecode::ssetOpcode()
 {
    invalidOpcode(__FUNCTION__);
@@ -783,7 +841,7 @@
    int varAddress = _code.fetchInt();
    int labelAddress = _code.fetchInt();
 
-   if (_data.getInt(varAddress)) {
+   if (getIntData(varAddress)) {
       _code.setIP(labelAddress);
    }
 }
@@ -795,7 +853,7 @@
    int varAddress = _code.fetchInt();
    int labelAddress = _code.fetchInt();
 
-   if (!_data.getInt(varAddress)) {
+   if (!getIntData(varAddress)) {
       _code.setIP(labelAddress);
    }
 }
@@ -807,12 +865,21 @@
 
 void CRunBytecode::incspOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("incsp opcode");
+
+   int valAddress = _code.fetchInt();
+   int size = getIntData(valAddress);
+
+   _dataStack.pushBytes(size);
 }
 
 void CRunBytecode::decspOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("decsp opcode");
+
+   int size = getIntData(_code.fetchInt());
+
+   _dataStack.popBytes(size);
 }
 
 
@@ -826,28 +893,30 @@
 {
    trace ("push_int opcode");
 
-   _dataStack.push((void*)CSymbol::INT);
+   int address = _code.fetchInt();
+
+   _dataStack.pushInt(getIntData(address));
 }
 
 void CRunBytecode::pushRealOpcode()
 {
    trace ("push_real opcode");
 
-   _dataStack.push((void*)CSymbol::REAL);
+   invalidOpcode(__FUNCTION__);
 }
 
 void CRunBytecode::pushCharOpcode()
 {
    trace ("push_char opcode");
 
-   _dataStack.push((void*)CSymbol::CHAR);
+   invalidOpcode(__FUNCTION__);
 }
 
 void CRunBytecode::pushBoolOpcode()
 {
    trace ("push_bool opcode");
 
-   _dataStack.push((void*)CSymbol::BOOL);
+   invalidOpcode(__FUNCTION__);
 }
 
 void CRunBytecode::pushMatrixOpcode()
@@ -855,10 +924,56 @@
    invalidOpcode(__FUNCTION__);
 }
 
+void CRunBytecode::pushITypeOpcode()
+{
+   trace ("push_itype opcode");
 
-//   OP_INCSP_4,
+   _dataStack.pushInt(CSymbol::INT);
+}
+
+void CRunBytecode::pushRTypeOpcode()
+{
+   trace ("push_rtype opcode");
+
+   _dataStack.pushInt(CSymbol::REAL);
+}
+
+void CRunBytecode::pushCTypeOpcode()
+{
+   trace ("push_ctype opcode");
+
+   _dataStack.pushInt(CSymbol::CHAR);
+}
+
+void CRunBytecode::pushBTypeOpcode()
+{
+   trace ("push_btype opcode");
+
+   _dataStack.pushInt(CSymbol::BOOL);
+}
+
+void CRunBytecode::pushMTypeOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+
+void CRunBytecode::incsp4Opcode()
+{
+   trace ("incsp_4 opcode");
+
+   _dataStack.pushInt(0);
+}
+
 //   OP_INCSP_8,
-//   OP_DECSP_4,
+
+void CRunBytecode::decsp4Opcode()
+{
+   trace ("decsp_4 opcode");
+
+   _dataStack.popInt();
+}
+
 //   OP_DECSP_8,
 
 void CRunBytecode::retOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -12,7 +12,6 @@
 #include "CBytecode.hpp"
 #include "Common.hpp"
 #include "CDataStack.hpp"
-#include "CExecutionStack.hpp"
 
 class CRunBytecode;
 
@@ -32,13 +31,17 @@
    void initOpcodePointer();
    void step();
    void procImprima();
+   void setIntData(const int &address, const int &value);
+   int  getIntData(const int &address);
+   void setStringData(const int &address, const std::string &value);
+   std::string getStringData(const int &address);
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
    void pushSregOpcode();
    void popSregOpcode();
-   void pushOpcode();
    void pushStringOpcode();
+   void pushSTypeOpcode();
 //   void push1Opcode();
    void pcallOpcode();
    void libcallOpcode();
@@ -136,9 +139,15 @@
    void pushBoolOpcode();
    void pushMatrixOpcode();
 
-//   OP_INCSP_4,
+   void pushITypeOpcode();
+   void pushRTypeOpcode();
+   void pushCTypeOpcode();
+   void pushBTypeOpcode();
+   void pushMTypeOpcode();
+
+   void incsp4Opcode();
 //   OP_INCSP_8,
-//   OP_DECSP_4,
+   void decsp4Opcode();
 //   OP_DECSP_8,
 
    void retOpcode();
@@ -160,14 +169,13 @@
 
    CHeader       _header;
    CSymbolTable  _symbolTable;
-   CBinString    _data;
-//   CData         _data;
+   CBinString    _globalData;
    CBytecode     _code;
    OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
    bool          _stop;
    int           _returnCode;
    CDataStack    _dataStack;
-   CExecutionStack _executionStack;
+   std::stack<int>   _executionStack;
 };
 
 #endif

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-27 18:59:29 UTC (rev 398)
@@ -6,13 +6,11 @@
 
 GPTASM=../gptasm/
 
-objects = main.o CGptVm.o CRunBytecode.o CDataStack.o CBytecode.o \
-          CExecutionStack.o \
+objects = main.o CGptVm.o CRunBytecode.o CBytecode.o CDataStack.o \
           $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
           $(COMMON_DIR)CHeader.o \
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
           
-
 all: $(objects)
 	g++ -o gptvm $(objects)
 

Modified: trunk/gpt2/gptvm/src/main.cpp
===================================================================
--- trunk/gpt2/gptvm/src/main.cpp	2007-11-27 16:01:16 UTC (rev 397)
+++ trunk/gpt2/gptvm/src/main.cpp	2007-11-27 18:59:29 UTC (rev 398)
@@ -42,7 +42,9 @@
 
    CGptVm gptvm( &options );
 
-   return gptvm.run();
+   int result = gptvm.run();
+
+   return result;
 }
 
 



From gpt-commit-noreply at mail.berlios.de  Tue Nov 27 20:01:46 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Tue, 27 Nov 2007 20:01:46 +0100
Subject: [gpt-commit] r399 - in trunk/gpt2: gptasm/src gptvm/src
Message-ID: <200711271901.lARJ1k0G024187@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-27 20:01:45 +0100 (Tue, 27 Nov 2007)
New Revision: 399

Removed:
   trunk/gpt2/gptasm/src/CCode.cpp
   trunk/gpt2/gptasm/src/CCode.hpp
   trunk/gpt2/gptvm/src/CExecutionStack.cpp
   trunk/gpt2/gptvm/src/CExecutionStack.hpp
Log:
DEVNULL:
* Removendo arquivos nao mais utilizados


Deleted: trunk/gpt2/gptasm/src/CCode.cpp
===================================================================

Deleted: trunk/gpt2/gptasm/src/CCode.hpp
===================================================================

Deleted: trunk/gpt2/gptvm/src/CExecutionStack.cpp
===================================================================

Deleted: trunk/gpt2/gptvm/src/CExecutionStack.hpp
===================================================================



From gpt-commit-noreply at mail.berlios.de  Thu Nov 29 12:53:04 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 29 Nov 2007 12:53:04 +0100
Subject: [gpt-commit] r400 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test
	gptvm/test/gerados_pelo_gptasm
Message-ID: <200711291153.lATBr48A007032@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-29 12:53:00 +0100 (Thu, 29 Nov 2007)
New Revision: 400

Modified:
   trunk/gpt2/common/src/CSymbol.cpp
   trunk/gpt2/common/src/CSymbolTable.cpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.hpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/src/Makefile
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
   trunk/gpt2/gptvm/test/run.sh
Log:
DEVNULL:
* Tratamento mais efetivo para enderecamento
  - bit indicando se eh local ou global
  - bit indicando se eh endereco positivo ou negativo
* Mnemonicos/opcodes
  - retirado pop, push, push_int, push_string, push_real, push_char, push_bool,
    push_matrix, push_sreg, pop_sreg, incsp_4, incsp_8, decsp_4, decsp_8
  - incluido pushiv, pushsv, pushrv, pushmv, pushit, pushst, pushrt, pushct,
    pushbt, pushmt, popiv, poprv, popsv, popmv, push0, push1, push2, push3,
    push4, push5, exit0, exit1
* Ajuste nos exemplos em GptAssembly
* Reformulacao na metodologia para passagem de parametros e ajustes de BP e SP


Modified: trunk/gpt2/common/src/CSymbol.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbol.cpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/common/src/CSymbol.cpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -2,6 +2,7 @@
 
 
 #include "CSymbol.hpp"
+#include "Tools.hpp"
 
 
 CSymbol::CSymbol()
@@ -42,18 +43,7 @@
 
 int CSymbol::getTypeSize() const
 {
-   switch(_type) {
-   case INT:
-   case CHAR:
-   case BOOL:
-      return sizeof(int);
-   case REAL:
-      return sizeof(double);
-   case STRING:
-   case MATRIX:
-      return sizeof(void*);
-   }
-   return 0;
+   return ::getTypeSize(_type);
 }
 
 

Modified: trunk/gpt2/common/src/CSymbolTable.cpp
===================================================================
--- trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/common/src/CSymbolTable.cpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,6 +1,10 @@
 #include "CSymbolTable.hpp"
 
+#include "Common.hpp"
 
+#include "Tools.hpp"
+
+
 CSymbolTable::CSymbolTable()
 {
 }
@@ -34,7 +38,7 @@
 
 CSymbol* CSymbolTable::addParameter (const std::string &name, const int &type, const int &address)
 {
-   CSymbol *symbol = new CSymbol(CSymbol::LOCAL, name, type, CSymbol::PARAM, address | 0x80000000);
+   CSymbol *symbol = new CSymbol(CSymbol::LOCAL, name, type, CSymbol::PARAM, address|SET_LOCAL_BIT|SET_NEG_BIT);
 
    _symbols.push_back(symbol);
 
@@ -68,7 +72,7 @@
    if (scope == CSymbol::GLOBAL) {
       symbol = new CSymbol(scope, name, type, CSymbol::VAR, address);
    } else {
-      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address | 0x80000000 );
+      symbol = new CSymbol(scope, name, type, CSymbol::VAR, address | SET_LOCAL_BIT);
    }
 
    _symbols.push_back(symbol);

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,6 +1,29 @@
-#ifndef GPT_COMMON
-#define GPT_COMMON
+#ifndef GPT_COMMON_HPP
+#define GPT_COMMON_HPP
 
+/*
+Mapa de bits para o endereco:
+31: Nao utilizado :-)
+30: Ligado indica endereco local, desligado indica endereco global
+29: Ligado indica endereco negativo, desligado indica endereco positivo
+28..0: valor do endereco
+*/
+
+//const int SET_LOCAL_BIT   = 0x80000000;
+//const int UNSET_LOCAL_BIT = 0x3FFFFFFF;
+
+const int SET_LOCAL_BIT   = 0x40000000; // 01000000 (binario)
+const int UNSET_LOCAL_BIT = 0xBFFFFFFF; // 10111111 (binario)
+
+const int SET_NEG_BIT     = 0x20000000; // 00100000 (binario)
+const int UNSET_NEG_BIT   = 0xDFFFFFFF; // 11011111 (binario)
+
+#define IS_LOCAL_ADDRESS(address) \
+   (address) & SET_LOCAL_BIT
+
+#define IS_NEG_ADDRESS(address) \
+   (address) & SET_NEG_BIT
+
 enum opcode {
    OP_NOP         = 0,
    OP_HLT         = 1,
@@ -77,22 +100,18 @@
    OP_JMP         = 72,
    OP_IF          = 73,
    OP_IFNOT       = 74,
-//   OP_PUSH = 75,
-   OP_POP         = 76,
    OP_INCSP       = 77,
    OP_DECSP       = 78,
-   OP_PUSH_INT    = 79,
-   OP_PUSH_STRING = 80,
-   OP_PUSH_REAL   = 81,
-   OP_PUSH_CHAR   = 82,
-   OP_PUSH_BOOL   = 83,
-   OP_PUSH_MATRIX = 84,
-   OP_PUSH_SREG   = 85,
-   OP_POP_SREG    = 86,
-   OP_INCSP_4     = 87,
-   OP_INCSP_8     = 88,
-   OP_DECSP_4     = 89,
-   OP_DECSP_8     = 90,
+   OP_PUSHIV      = 79,
+   OP_PUSHSV      = 80,
+   OP_PUSHRV      = 81,
+   OP_PUSHMV      = 84,
+   OP_PUSHSREG    = 85,
+   OP_POPSREG     = 86,
+   OP_INCSP4      = 87,
+   OP_INCSP8      = 88,
+   OP_DECSP4      = 89,
+   OP_DECSP8      = 90,
    OP_PCALL       = 91,
    OP_RET         = 92,
    OP_LIBCALL     = 93,
@@ -110,13 +129,25 @@
    OP_MCOPY       = 105,
    OP_MGETSIZE1   = 106,
    OP_MGETSIZE2   = 107,
-   OP_PUSH_ITYPE  = 108,
-   OP_PUSH_STYPE  = 109,
-   OP_PUSH_RTYPE  = 110,
-   OP_PUSH_CTYPE  = 111,
-   OP_PUSH_BTYPE  = 112,
-   OP_PUSH_MTYPE  = 113,
-   OPCODE_NUMBER  = 113
+   OP_PUSHIT      = 108,
+   OP_PUSHST      = 109,
+   OP_PUSHRT      = 110,
+   OP_PUSHCT      = 111,
+   OP_PUSHBT      = 112,
+   OP_PUSHMT      = 113,
+   OP_POPIV       = 114,
+   OP_POPRV       = 115,
+   OP_POPSV       = 116,
+   OP_POPMV       = 117,
+   OP_PUSH0       = 118,
+   OP_PUSH1       = 119,
+   OP_PUSH2       = 120,
+   OP_PUSH3       = 121,
+   OP_PUSH4       = 122,
+   OP_PUSH5       = 123,
+   OP_EXIT0       = 124,
+   OP_EXIT1       = 125,
+   OPCODE_NUMBER  = 125
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -10,6 +10,7 @@
 
 CGenBytecode::CGenBytecode()
    : _currentSP(0)
+//   , _parametersSize(0)
 {
    _opcodes[ "isum"        ] = OP_ISUM;
    _opcodes[ "ssum"        ] = OP_SSUM;
@@ -84,33 +85,33 @@
    _opcodes[ "if"          ] = OP_IF;
    _opcodes[ "ifnot"       ] = OP_IFNOT;
 //   _opcodes[ "push"        ] = OP_PUSH;
-   _opcodes[ "pop"         ] = OP_POP;
+   _opcodes[ "popiv"         ] = OP_POPIV;
+   _opcodes[ "poprv"         ] = OP_POPRV;
+   _opcodes[ "popmv"         ] = OP_POPMV;
    _opcodes[ "incsp"       ] = OP_INCSP;
    _opcodes[ "decsp"       ] = OP_DECSP;
-//   _opcodes[ "push_0"      ] = OP_PUSH_0;
-//   _opcodes[ "push_1"      ] = OP_PUSH_1;
-//   _opcodes[ "push_2"      ] = OP_PUSH_2;
-//   _opcodes[ "push_3"      ] = OP_PUSH_3;
-//   _opcodes[ "push_4"      ] = OP_PUSH_4;
-//   _opcodes[ "push_5"      ] = OP_PUSH_5;
-   _opcodes[ "push_int"    ] = OP_PUSH_INT;
-   _opcodes[ "push_string" ] = OP_PUSH_STRING;
-   _opcodes[ "push_real"   ] = OP_PUSH_REAL;
-   _opcodes[ "push_char"   ] = OP_PUSH_CHAR;
-   _opcodes[ "push_bool"   ] = OP_PUSH_BOOL;
-   _opcodes[ "push_matrix" ] = OP_PUSH_MATRIX;
-   _opcodes[ "push_itype"  ] = OP_PUSH_ITYPE;
-   _opcodes[ "push_stype"  ] = OP_PUSH_STYPE;
-   _opcodes[ "push_rtype"  ] = OP_PUSH_RTYPE;
-   _opcodes[ "push_ctype"  ] = OP_PUSH_CTYPE;
-   _opcodes[ "push_btype"  ] = OP_PUSH_BTYPE;
-   _opcodes[ "push_mtype"  ] = OP_PUSH_MTYPE;
-   _opcodes[ "push_sreg"   ] = OP_PUSH_SREG;
-   _opcodes[ "pop_sreg"    ] = OP_POP_SREG;
-   _opcodes[ "incsp_4"     ] = OP_INCSP_4;
-   _opcodes[ "incsp_8"     ] = OP_INCSP_8;
-   _opcodes[ "decsp_4"     ] = OP_DECSP_4;
-   _opcodes[ "decsp_8"     ] = OP_DECSP_8;
+   _opcodes[ "push0"       ] = OP_PUSH0;
+   _opcodes[ "push1"       ] = OP_PUSH1;
+   _opcodes[ "push2"       ] = OP_PUSH2;
+   _opcodes[ "push3"       ] = OP_PUSH3;
+   _opcodes[ "push4"       ] = OP_PUSH4;
+   _opcodes[ "push5"       ] = OP_PUSH5;
+   _opcodes[ "pushiv"      ] = OP_PUSHIV;
+   _opcodes[ "pushsv"      ] = OP_PUSHSV;
+   _opcodes[ "pushrv"      ] = OP_PUSHRV;
+   _opcodes[ "pushmv"      ] = OP_PUSHMV;
+   _opcodes[ "pushit"      ] = OP_PUSHIT;
+   _opcodes[ "pushst"      ] = OP_PUSHST;
+   _opcodes[ "pushrt"      ] = OP_PUSHRT;
+   _opcodes[ "pushct"      ] = OP_PUSHCT;
+   _opcodes[ "pushbt"      ] = OP_PUSHBT;
+   _opcodes[ "pushmt"      ] = OP_PUSHMT;
+   _opcodes[ "pushsreg"    ] = OP_PUSHSREG;
+   _opcodes[ "popsreg"     ] = OP_POPSREG;
+   _opcodes[ "incsp4"      ] = OP_INCSP4;
+   _opcodes[ "incsp8"      ] = OP_INCSP8;
+   _opcodes[ "decsp4"      ] = OP_DECSP4;
+   _opcodes[ "decsp8"      ] = OP_DECSP8;
    _opcodes[ "pcall"       ] = OP_PCALL;
    _opcodes[ "ret"         ] = OP_RET;
    _opcodes[ "libcall"     ] = OP_LIBCALL;
@@ -129,8 +130,8 @@
    _opcodes[ "mgetsize1"   ] = OP_MGETSIZE1;
    _opcodes[ "mgetsize2"   ] = OP_MGETSIZE2;
    _opcodes[ "nop"         ] = OP_NOP;
-//   _opcodes[ "exit_0"      ] = OP_EXIT_0;
-//   _opcodes[ "exit_1"      ] = OP_EXIT_1;
+   _opcodes[ "exit0"       ] = OP_EXIT0;
+   _opcodes[ "exit1"       ] = OP_EXIT1;
    _opcodes[ "hlt"         ] = OP_HLT;
    _opcodes[ "exit"        ] = OP_EXIT;
 }
@@ -149,6 +150,8 @@
    _currentProcedure = procedureName;
    _currentSP = 0;
     registryLabel(procedureName);
+   _parameters.clear();
+//   _parametersSize = 0;
 }
 
 
@@ -156,6 +159,7 @@
 {
    _currentProcedure.clear();
    _currentSP = 0;
+//   _parametersSize = 0;
    _symbolTable.clearLocalSymbols();
    // TODO: delete na procedure ???
 }
@@ -182,12 +186,43 @@
 
 void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
 {
-   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
-   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
-   _currentSP += symbol->getTypeSize();
+   _parameters.push_back(std::pair<std::string,int>(lexeme, type));
+//   _parametersSize += getTypeSize(type);
+//   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
+//   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
+//   _currentSP += symbol->getTypeSize();
 }
 
 
+void CGenBytecode::finishParDefinition()
+{
+   _currentSP = 0;
+   for (std::list<std::pair<std::string,int> >::reverse_iterator par = _parameters.rbegin();
+         par != _parameters.rend(); par++) {
+      _currentSP -= getTypeSize(par->second);
+      CSymbol *symbol = _symbolTable.addParameter(par->first, par->second, abs(_currentSP));
+//      std::cout << "par " << par->first << " address " << _currentSP << std::endl;
+      std::cout << "param=" << symbol->getName() << " address=" << symbol->getAddress() << std::endl;
+      std::cout << "\t" << realAddressString(symbol->getAddress()) << std::endl;
+   }
+
+   _currentSP = 0;
+
+//   if (_parametersSize != 0) {
+//      std::cout << "_parametersSize != 0 !!!" << std::endl;
+//      abort();
+//   }
+}
+
+
+//void CGenBytecode::makeParDefinition(const std::string &lexeme, const int &type)
+//{
+//   CSymbol *symbol = _symbolTable.addParameter(lexeme, type, _currentSP);
+//   std::cout << "par " << lexeme << " address " << _currentSP << std::endl;
+//   _currentSP += symbol->getTypeSize();
+//}
+
+
 void CGenBytecode::registryLabel(const std::string &labelName)
 {
    // TODO

Modified: trunk/gpt2/gptasm/src/CGenBytecode.hpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/src/CGenBytecode.hpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -19,6 +19,7 @@
    void finishProcedure();
    void makeVarDefinition(const std::string &lexeme, const int &type);
    void makeParDefinition(const std::string &lexeme, const int &type);
+   void finishParDefinition();
    void registryLabel(const std::string &labelName);
    void addOpcode(const std::string &mn);
    void addAddress(const std::string &id, const int &category, const int &type);
@@ -34,8 +35,10 @@
    std::map<std::string,char> _opcodes;
    std::string                _currentProcedure;
    int                        _currentSP;
+//   int                        _parametersSize;
    std::list<std::pair<std::string, int> > _unsolvedLabels;
    std::map<std::string, int> _solvedLabels;
+   std::list<std::pair<std::string, int> > _parameters;
 };
 
 #endif

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-29 11:53:00 UTC (rev 400)
@@ -111,33 +111,34 @@
    T_KW_JMP="jmp";
    T_KW_IF="if";
    T_KW_IFNOT="ifnot";
-   T_KW_POP="pop";
+   T_KW_POPIV="popiv";
+   T_KW_POPSV="popsv";
+   T_KW_POPRV="poprv";
+   T_KW_POPMV="popmv";
    T_KW_INCSP="incsp";
    T_KW_DECSP="decsp";
-//   T_KW_PUSH_0="push_0";
-//   T_KW_PUSH_1="push_1";
-//   T_KW_PUSH_2="push_2";
-//   T_KW_PUSH_3="push_3";
-//   T_KW_PUSH_4="push_4";
-//   T_KW_PUSH_5="push_5";
-   T_KW_PUSH_INT="push_int";
-   T_KW_PUSH_STRING="push_string";
-   T_KW_PUSH_REAL="push_real";
-   T_KW_PUSH_CHAR="push_char";
-   T_KW_PUSH_BOOL="push_bool";
-   T_KW_PUSH_MATRIX="push_matrix";
-   T_KW_PUSH_ITYPE="push_itype";
-   T_KW_PUSH_STYPE="push_stype";
-   T_KW_PUSH_RTYPE="push_rtype";
-   T_KW_PUSH_CTYPE="push_ctype";
-   T_KW_PUSH_BTYPE="push_btype";
-   T_KW_PUSH_MTYPE="push_mtype";
-   T_KW_PUSH_SP="push_sreg";
-   T_KW_POP_SP="pop_sreg";
-   T_KW_INCSP_4="incsp_4";
-   T_KW_INCSP_8="incsp_8";
-   T_KW_DECSP_4="decsp_4";
-   T_KW_DECSP_8="decsp_8";
+   T_KW_PUSH0="push0";
+   T_KW_PUSH1="push1";
+   T_KW_PUSH2="push2";
+   T_KW_PUSH3="push3";
+   T_KW_PUSH4="push4";
+   T_KW_PUSH5="push5";
+   T_KW_PUSHIV="pushiv";
+   T_KW_PUSHSV="pushsv";
+   T_KW_PUSHRV="pushrv";
+   T_KW_PUSHMV="pushmv";
+   T_KW_PUSHIT="pushit";
+   T_KW_PUSHST="pushst";
+   T_KW_PUSHRT="pushrt";
+   T_KW_PUSHCT="pushct";
+   T_KW_PUSHBT="pushbt";
+   T_KW_PUSHMT="pushmt";
+//   T_KW_PUSHSREG="pushsreg";
+//   T_KW_POPSREG="popsreg";
+   T_KW_INCSP4="incsp4";
+   T_KW_INCSP8="incsp8";
+   T_KW_DECSP4="decsp4";
+   T_KW_DECSP8="decsp8";
    T_KW_PCALL="pcall";
    T_KW_LIBCALL="libcall";
    T_KW_RET="ret";
@@ -156,8 +157,8 @@
    T_KW_MGETSIZE1="mgetsize1";
    T_KW_MGETSIZE2="mgetsize2";
    T_KW_NOP="nop";
-//   T_KW_EXIT_0="exit_0";
-//   T_KW_EXIT_1="exit_1";
+   T_KW_EXIT0="exit0";
+   T_KW_EXIT1="exit1";
    T_KW_HLT="hlt";
    T_KW_EXIT="exit";
    T_KW_TRUE="true";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-29 11:53:00 UTC (rev 400)
@@ -27,14 +27,6 @@
 {  
    public:
       CGenBytecode bytecode;
-      void declareVar(const std::string& lexeme, int type)
-      {
-         bytecode.makeVarDefinition( lexeme, type );
-      }
-      void declareParameter(const std::string& lexeme, int type)
-      {
-         bytecode.makeParDefinition( lexeme, type );
-      }
       antlr::RefToken getLastToken()
       {
          return LT(0);
@@ -86,7 +78,7 @@
   char tk_type;
 }
   : "var" tk_id:T_ID tk_type=primitive_type
-    { declareVar(tk_id->getText(), tk_type); }
+    { bytecode.makeVarDefinition(tk_id->getText(), tk_type); }
   ;
 
 //--------------------------------
@@ -112,6 +104,7 @@
    tk_id:T_ID
     { bytecode.initProcedure(tk_id->getText(), false, 0, std::vector<CSymbol>()); }
     (parameter_declaration)*
+    { bytecode.finishParDefinition(); }
     (var_declaration)*
     code_block
     { bytecode.finishProcedure(); }
@@ -125,7 +118,7 @@
   int tk_type;
 }
   : "param" ("ref")? tk_id:T_ID tk_type=primitive_type
-    { declareParameter( tk_id->getText(), tk_type ); }
+    { bytecode.makeParDefinition(tk_id->getText(), tk_type); }
   ;
 
 //#####################
@@ -245,24 +238,25 @@
 //--------------------
   mn_chamada_subrotina
 //--------------------
-   :  ("push_int"|"push_string"|"push_real"|"push_char"|"push_bool"|"push_matrix")
+   :  ("pushiv"|"pushsv"|"pushrv"|"pushmv")
       {bytecode.addOpcode(getLastTokenText());}
       element
-   |  ("push_itype"|"push_stype"|"push_rtype"|"push_ctype"|"push_btype"|"push_mtype")
+   |  ("pushit"|"pushst"|"pushrt"|"pushct"|"pushbt"|"pushmt")
       {bytecode.addOpcode(getLastTokenText());}
-   |  "pop"
+//   |  "pop"
+   |  ("popiv"|"popsv"|"poprv"|"popmv")
       {bytecode.addOpcode(getLastTokenText());}
       identifier
    |  ("incsp"|"decsp")
       {bytecode.addOpcode(getLastTokenText());}
       T_INT_VALUE
       { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
-//   |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
+   |  ("push0"|"push1"|"push2"|"push3"|"push4"|"push5")
+      {bytecode.addOpcode(getLastTokenText());}
+//   |  ("pushsreg"|"popsreg")
 //      {bytecode.addOpcode(getLastTokenText());}
-   |  ("push_sreg"|"pop_sreg")
+   |  ("incsp4"|"incsp8"|"decsp4"|"decsp8")
       {bytecode.addOpcode(getLastTokenText());}
-   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
-      {bytecode.addOpcode(getLastTokenText());}
    |  "pcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
@@ -337,8 +331,7 @@
 //-----------
   mn_execucao
 //-----------
-//   :   ("nop"|"exit_0"|"exit_1"|"hlt")
-   :   ("nop"|"hlt")
+   :   ("nop"|"hlt"|"exit0"|"exit1")
       {bytecode.addOpcode(getLastTokenText());}
    |   "exit"
       {bytecode.addOpcode(getLastTokenText());}

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -12,28 +12,24 @@
     isetv c:4, 20 // *(c + 4 ) := 20
 
     // imprima( "c.x=", c.x );
-    push_sp
     igetv t1, c:0 // t1 := *( c + 0)
-    push t1
-    push_int
-    push "c.x="
-    push_string
-    push_2
-    pcall imprima
-    pop_sp
+    pushiv t1
+    pushit
+    pushsv "c.x="
+    pushst
+    pushiv 2
+    libcall imprima
 
     // imprima( "c.y=", c.y );
-    push_sp
     igetv t1, c:4 // t1 := *(c + 4)
-    push t1
-    push_int
-    push "c.y="
-    push_string
-    push_2
-    pcall imprima
-    pop_sp
+    pushiv t1
+    pushit
+    pushsv "c.y="
+    pushst
+    pushiv 2
+    libcall imprima
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -24,14 +24,12 @@
     proximo:
 
     // imprima( x );
-    push_sreg
-    push_int x
-    push_itype
-    push_int 1
+    pushiv x
+    pushit
+    push1
     libcall imprima
-    pop_sreg
 
-    exit 0
+    exit0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,10 +1,9 @@
 program exemplo
 
 var x int
-var t1 int
 
 proc main
-//    var t1 int
+    var t1 int
 
     // para x de 1 at? 10 fa?a
     iset x, 1
@@ -13,12 +12,10 @@
     ifnot t1, proximo
 
     // imprima( x );
-    push_sreg
-    push_int x
-    push_itype
-    push_int 1
+    pushiv x
+    pushit
+    push1
     libcall imprima
-    pop_sreg
 
     // fim-para
     iinc x, 1
@@ -26,7 +23,7 @@
 
     proximo:
 
-    exit 0
+    exit0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -5,16 +5,14 @@
     var t2 int
 
     // imprima( "2+5*3=", 2+5*3 );
-    push_sreg
     imul t1, 5, 3
     isum t2, 2, t1
-    push_int t2
-    push_itype
-    push_string "2+5*3="
-    push_stype
-    push_int 2
+    pushiv t2
+    pushit
+    pushsv "2+5*3="
+    pushst
+    pushiv 2
     libcall imprima
-    pop_sreg
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,20 +1,21 @@
 program exemplo
 
 proc main
+    var t1 int
     // imprima( "A soma ?: ", soma( 2, 7 ) );
-    push_sp
-    push_0 // resultado da fun??o
-    push 7 // empilha 7
-    push 2 // empilha 2
+    pushiv 0 // resultado da fun??o
+    pushiv 2 // empilha 2
+    pushiv 7 // empilha 7
     pcall soma
-    push_int
-    push "A soma ?: "
-    push_string
-    push_2
-    pcall imprima
-    pop_sp
-	
-    exit_0
+    popiv t1
+    pushiv t1
+    pushit
+    pushsv "A soma ?: "
+    pushst
+    pushiv 2
+    libcall imprima
+
+    exit 0
 endproc
 
 proc soma
@@ -24,6 +25,7 @@
 
     isum __result, x, y
 
+    decsp 8 // tamanho dos parametros + variaveis locais - retorno da funcao
     ret
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,12 +1,10 @@
 program exemplo
 
 proc main
-    push_sreg
-    push_string "Ol? mundo !!!"
-    push_stype
-    push_int 1
+    pushsv "Ol? mundo !!!"
+    pushst
+    pushiv 1
     libcall imprima
-    pop_sreg
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -4,29 +4,23 @@
 
 proc main
     // imprima( "Digite um n?mero: " );
-    push_sp
-    push "Digite um n?mero: "
-    push_string
-    push_1
-    pcall imprima
-    pop_sp
+    pushsv "Digite um n?mero: "
+    pushst
+    pushiv 1
+    libcall imprima
     // x := leia( );
-    push_0 // resultado da fun??o
-    push_sp
-    pcall leia
-    pop_sp
-    pop x
+    pushit
+    libcall leia
+    popiv x
     // imprima( "O n?mero digitado foi ", x );
-    push_sp
-    push x
-    push_int
-    push "O n?mero digitado foi "
-    push_string
-    push_2
-    pcall imprima
-    pop_sp
+    pushiv x
+    pushit
+    pushsv "O n?mero digitado foi "
+    pushst
+    pushiv 2
+    libcall imprima
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -2,12 +2,14 @@
 
 proc main
     // soma( 2, 7 );
-    push_sreg
-    push_int 2
-    push_int 7
+    pushiv 2
+    pushiv 7
     pcall soma
-    pop_sreg
 
+    pushiv 10
+    pushiv 20
+    pcall soma
+
     exit 0
 endproc
 
@@ -17,21 +19,18 @@
 
     var t1 int
 
-//    push_sreg
-//    push_string "A soma ?: "
-//    push_stype
-//    push_int 1
-//    libcall imprima
-//    pop_sreg
+    pushsv "A soma ?: "
+    pushst
+    pushiv 1
+    libcall imprima
 
     isum t1, x, y
-//    push_sreg
-    push_int t1
-    push_itype
-    push_int 1
+    pushiv t1
+    pushit
+    pushiv 1
     libcall imprima
-//    pop_sreg
 
+    decsp 12
     ret	
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -4,33 +4,31 @@
 
 proc main
     // soma( s, 2, 7 );
-    push_sp
-    push 7
-    push 2
-    push s
+    pushiv s
+    pushiv 2
+    pushiv 7
     pcall soma
-    pop_sp
 	
     // imprima( s );
-    push_sp
-    push s
-    push_int
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv s
+    pushit
+    pushiv 1
+    libcall imprima
 	
-    exit_0
+    exit 0
 endproc
 
 proc soma
     param r int
     param v1 int
     param v2 int
+    var t1 int
 
     // r := v1 + v2;
     isum t1, v1, v2
     isetv r:0, t1
 
+    decsp 16
     ret	
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,16 +1,12 @@
 program exemplo
 
 proc main
-   push_sreg
    pcall soma
-   pop_sreg
 
-   push_sreg
-   push_string "Finalizando..."
-   push_stype
-   push_int 1
+   pushsv "Finalizando..."
+   pushst
+   pushiv 1
    libcall imprima
-   pop_sreg
 
    exit 0
 endproc
@@ -20,13 +16,12 @@
 
    isum temp, 2, 4
 
-   push_sreg
-   push_int temp
-   push_itype
-   push_int 1
+   pushiv temp
+   pushit
+   pushiv 1
    libcall imprima
-   pop_sreg
 
+   decsp 4
    ret
 endproc
    

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -3,9 +3,6 @@
 var x int
 var y int
 
-//    var t1 int
-//    var t2 int
-
 proc main
     var t1 int
     var t2 int
@@ -17,16 +14,14 @@
     iset y, 20
 	
     // imprima( "x*y+4=", x*y+4 );
-    push_sreg
     imul t1, x, y
     isum t2, t1, 4
-    push_int t2
-    push_itype
-    push_string "x*y+4="
-    push_stype
-    push_int 2
+    pushiv t2
+    pushit
+    pushsv "x*y+4="
+    pushst
+    pushiv 2
     libcall imprima
-    pop_sreg
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -10,21 +10,17 @@
     isum v, v, 10
     isum v, 10, v
 
-    push_sp
-    push v
-    push_int
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv v
+    pushit
+    pushiv 1
+    libcall imprima
 	
-    push_sp
-    push 10
-    push_int
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv 10
+    pushit
+    pushiv 1
+    libcall imprima
 	
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -10,21 +10,17 @@
     rsum v, v, 10.0
     rsum v, 10.0, v
 
-    push_sp
-    push v
-    push_real
-    push_1
-    pcall imprima
-    pop_sp
+    pushrv v
+    pushrt
+    pushrv 1
+    libcall imprima
 
-    push_sp
-    push 10.0
-    push_real
-    push_1
-    pcall imprima
-    pop_sp
+    pushrv 10.0
+    pushrt
+    pushrv 1
+    libcall imprima
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -12,23 +12,19 @@
     ssum v, v, "10"
     ssum v, "10", v
 
-    push_sp
-    push v
-    push_string
-    push_1
-    pcall imprima
-    pop_sp
+    pushsv v
+    pushst
+    pushiv 1
+    libcall imprima
 	
-    push_sp
-    push "10"
-    push_string
-    push_1
-    pcall imprima
-    pop_sp
+    pushsv "10"
+    pushst
+    pushiv 1
+    libcall imprima
 	
     sfree v
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -10,21 +10,17 @@
     isum v, v, 'a'
     isum v, 'b', v
 
-    push_sp
-    push v
-    push_char
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv v
+    pushct
+    pushiv 1
+    libcall imprima
 
-    push_sp
-    push 'a'
-    push_char
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv 'a'
+    pushct
+    pushiv 1
+    libcall imprima
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-29 11:53:00 UTC (rev 400)
@@ -7,28 +7,22 @@
     iset v, false
     iset v, v
 
-    push_sp
-    push true
-    push_bool
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv true
+    pushbt
+    pushiv 1
+    libcall imprima
 
-    push_sp
-    push false
-    push_bool
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv false
+    pushbt
+    pushiv 1
+    libcall imprima
 
-    push_sp
-    push v
-    push_bool
-    push_1
-    pcall imprima
-    pop_sp
+    pushiv v
+    pushbt
+    pushiv 1
+    libcall imprima
 
-    exit_0
+    exit 0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,6 +1,11 @@
 #include "CDataStack.hpp"
 
+#include "Common.hpp"
 
+#include "Tools.hpp"
+
+
+
 #include <iostream>
 
 
@@ -15,13 +20,12 @@
 {
 }
 
-
 void CDataStack::setInt(const int &address, const int &value)
 {
 //   std::cout << "setInt ";
-   if (address & 0x80000000) {
-//      std::cout << "local address sem bit ligado: " << (address & 0x7FFFFFFF) << std::endl;
-      CBinString::setInt(_BS + (address & 0x7FFFFFFF), value);
+   if (IS_LOCAL_ADDRESS(address)) {
+//      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
+      CBinString::setInt(_BS + realAddress(address), value);
    } else {
       std::cout << "ERRO !!! Invocando setInt com global address: " << address << std::endl;
    }
@@ -31,9 +35,9 @@
 int CDataStack::getInt(const int &address)
 {
 //   std::cout << "getInt ";
-   if (address & 0x80000000) {
-//      std::cout << "local address sem bit ligado: " << (address & 0x7FFFFFFF) << std::endl;
-      return CBinString::getInt(_BS + (address & 0x7FFFFFFF));
+   if (IS_LOCAL_ADDRESS(address)) {
+//      std::cout << "local address sem bit ligado: " << ((unsigned int)address & UNSET_BIT_LOCAL) << std::endl;
+      return CBinString::getInt(_BS + realAddress(address));
    } else {
       std::cout << "ERRO !!! Invocando getInt com global address: " << address << std::endl;
       return -1;

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -39,17 +39,14 @@
    }
 
    _opcodePointer[OP_NOP        ] = &CRunBytecode::nopOpcode;
-   _opcodePointer[OP_PUSH_SREG  ] = &CRunBytecode::pushSregOpcode;
-   _opcodePointer[OP_POP_SREG   ] = &CRunBytecode::popSregOpcode;
-//   _opcodePointer[OP_PUSH       ] = &CRunBytecode::pushOpcode;
-   _opcodePointer[OP_PUSH_STRING] = &CRunBytecode::pushStringOpcode;
-//   _opcodePointer[OP_PUSH_1     ] = &CRunBytecode::push1Opcode;
+//   _opcodePointer[OP_PUSHSREG   ] = &CRunBytecode::pushsregOpcode;
+//   _opcodePointer[OP_POPSREG    ] = &CRunBytecode::popsregOpcode;
    _opcodePointer[OP_PCALL      ] = &CRunBytecode::pcallOpcode;
    _opcodePointer[OP_LIBCALL    ] = &CRunBytecode::libcallOpcode;
-//   _opcodePointer[OP_EXIT_0     ] = &CRunBytecode::exit0Opcode;
    _opcodePointer[OP_EXIT       ] = &CRunBytecode::exitOpcode;
+   _opcodePointer[OP_EXIT0      ] = &CRunBytecode::exit0Opcode;
+   _opcodePointer[OP_EXIT1      ] = &CRunBytecode::exit1Opcode;
 
-//   OP_EXIT_1,
    _opcodePointer[OP_HLT        ] = &CRunBytecode::hltOpcode;
 
    _opcodePointer[OP_ISUM       ] = &CRunBytecode::isumOpcode;
@@ -124,34 +121,35 @@
    _opcodePointer[OP_JMP        ] = &CRunBytecode::jmpOpcode;
    _opcodePointer[OP_IF         ] = &CRunBytecode::ifOpcode;
    _opcodePointer[OP_IFNOT      ] = &CRunBytecode::ifnotOpcode;
-   _opcodePointer[OP_POP        ] = &CRunBytecode::popOpcode;
+   _opcodePointer[OP_POPSV      ] = &CRunBytecode::popsvOpcode;
+   _opcodePointer[OP_POPIV      ] = &CRunBytecode::popivOpcode;
+   _opcodePointer[OP_POPRV      ] = &CRunBytecode::poprvOpcode;
+   _opcodePointer[OP_POPMV      ] = &CRunBytecode::popmvOpcode;
    _opcodePointer[OP_INCSP      ] = &CRunBytecode::incspOpcode;
    _opcodePointer[OP_DECSP      ] = &CRunBytecode::decspOpcode;
+   _opcodePointer[OP_PUSH0      ] = &CRunBytecode::push0Opcode;
+   _opcodePointer[OP_PUSH1      ] = &CRunBytecode::push1Opcode;
+   _opcodePointer[OP_PUSH2      ] = &CRunBytecode::push2Opcode;
+   _opcodePointer[OP_PUSH3      ] = &CRunBytecode::push3Opcode;
+   _opcodePointer[OP_PUSH4      ] = &CRunBytecode::push4Opcode;
+   _opcodePointer[OP_PUSH5      ] = &CRunBytecode::push5Opcode;
+   _opcodePointer[OP_PUSHSV     ] = &CRunBytecode::pushsvOpcode;
+   _opcodePointer[OP_PUSHIV     ] = &CRunBytecode::pushivOpcode;
+   _opcodePointer[OP_PUSHRV     ] = &CRunBytecode::pushrvOpcode;
+   _opcodePointer[OP_PUSHMV     ] = &CRunBytecode::pushmvOpcode;
 
-//   OP_PUSH_0,
-//   OP_PUSH_2,
-//   OP_PUSH_3,
-//   OP_PUSH_4,
-//   OP_PUSH_5,
+   _opcodePointer[OP_PUSHST     ] = &CRunBytecode::pushstOpcode;
+   _opcodePointer[OP_PUSHIT     ] = &CRunBytecode::pushitOpcode;
+   _opcodePointer[OP_PUSHRT     ] = &CRunBytecode::pushrtOpcode;
+   _opcodePointer[OP_PUSHCT     ] = &CRunBytecode::pushctOpcode;
+   _opcodePointer[OP_PUSHBT     ] = &CRunBytecode::pushbtOpcode;
+   _opcodePointer[OP_PUSHMT     ] = &CRunBytecode::pushmtOpcode;
 
-   _opcodePointer[OP_PUSH_INT   ] = &CRunBytecode::pushIntOpcode;
-   _opcodePointer[OP_PUSH_REAL  ] = &CRunBytecode::pushRealOpcode;
-   _opcodePointer[OP_PUSH_CHAR  ] = &CRunBytecode::pushCharOpcode;
-   _opcodePointer[OP_PUSH_BOOL  ] = &CRunBytecode::pushBoolOpcode;
-   _opcodePointer[OP_PUSH_MATRIX] = &CRunBytecode::pushMatrixOpcode;
+   _opcodePointer[OP_INCSP4     ] = &CRunBytecode::incsp4Opcode;
+   _opcodePointer[OP_INCSP8     ] = &CRunBytecode::incsp8Opcode;
+   _opcodePointer[OP_DECSP4     ] = &CRunBytecode::decsp4Opcode;
+   _opcodePointer[OP_DECSP8     ] = &CRunBytecode::decsp8Opcode;
 
-   _opcodePointer[OP_PUSH_STYPE ] = &CRunBytecode::pushSTypeOpcode;
-   _opcodePointer[OP_PUSH_ITYPE ] = &CRunBytecode::pushITypeOpcode;
-   _opcodePointer[OP_PUSH_RTYPE ] = &CRunBytecode::pushRTypeOpcode;
-   _opcodePointer[OP_PUSH_CTYPE ] = &CRunBytecode::pushCTypeOpcode;
-   _opcodePointer[OP_PUSH_BTYPE ] = &CRunBytecode::pushBTypeOpcode;
-   _opcodePointer[OP_PUSH_MTYPE ] = &CRunBytecode::pushMTypeOpcode;
-
-   _opcodePointer[OP_INCSP_4    ] = &CRunBytecode::incsp4Opcode;
-//   OP_INCSP_8,
-   _opcodePointer[OP_DECSP_4    ] = &CRunBytecode::decsp4Opcode;
-//   OP_DECSP_8,
-
    _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
    _opcodePointer[OP_SALLOC     ] = &CRunBytecode::sallocOpcode;
    _opcodePointer[OP_SFREE      ] = &CRunBytecode::sfreeOpcode;
@@ -225,7 +223,8 @@
             std::cout << _dataStack.popInt();
             break;
          case CSymbol::CHAR:
-            std::cout << (char)_dataStack.popInt();
+//            std::cout << (char)_dataStack.popInt();
+            std::cout << "char [" << (int)_dataStack.popInt() << "]";
             break;
          case CSymbol::BOOL:
             boolValue = _dataStack.popInt();
@@ -245,6 +244,39 @@
    std::cout << std::endl;
 }
 
+
+void CRunBytecode::procLeia()
+{
+   int type = _dataStack.popInt();
+   int iValue = 0;
+   switch (type) {
+//      case CSymbol::STRING:
+//         _dataStack.pushString(std::cin);
+//         break;
+      case CSymbol::INT:
+         std::cin >> iValue;
+         _dataStack.pushInt(iValue);
+         break;
+//      case CSymbol::CHAR:
+//         std::cout << (char)_dataStack.popInt();
+//         break;
+//      case CSymbol::BOOL:
+//         boolValue = _dataStack.popInt();
+//         if (boolValue == 0) {
+//            std::cout << "false";
+//         } else {
+//            std::cout << "true";
+//         }
+//         break;
+      case CSymbol::REAL:
+      case CSymbol::MATRIX:
+      default:
+         std::cout << "Tipo ainda nao suportado !!!" << std::endl;
+         abort();
+   }
+   std::cout << std::endl;
+}
+
 /////////////
 // opcodes //
 /////////////
@@ -261,49 +293,40 @@
    // nothing to do
 }
 
-void CRunBytecode::pushSregOpcode()
-{
-   trace ("push_sreg opcode");
+//void CRunBytecode::pushsregOpcode()
+//{
+//   invalidOpcode(__FUNCTION__);
+//   trace ("pushsreg opcode");
+//
+//   _executionStack.push(_dataStack.getBS());
+//   _executionStack.push(_dataStack.getSP());
+//}
 
-   _executionStack.push(_dataStack.getBS());
-   _executionStack.push(_dataStack.getSP());
-}
+//void CRunBytecode::popsregOpcode()
+//{
+//   invalidOpcode(__FUNCTION__);
+//   trace ("popsreg opcode");
+//
+//   _dataStack.setSP(_executionStack.top());
+//   _executionStack.pop();
+//
+//   _dataStack.setBS(_executionStack.top());
+//   _executionStack.pop();
+//
+//   // Ajusta o tamanho correto de _dataStack
+//   _dataStack.resize(_dataStack.getSP());
+//}
 
-void CRunBytecode::popSregOpcode()
-{
-   trace ("pop_sreg opcode");
 
-   _dataStack.setSP(_executionStack.top());
-   _executionStack.pop();
-
-   _dataStack.setBS(_executionStack.top());
-   _executionStack.pop();
-}
-
-
-void CRunBytecode::pushStringOpcode()
-{
-   trace ("push_string opcode");
-
-   int address = _code.fetchInt();
-
-   _dataStack.pushInt(address);
-}
-
-void CRunBytecode::pushSTypeOpcode()
-{
-   trace ("push_stype opcode");
-
-   _dataStack.pushInt(CSymbol::STRING);
-}
-
-
 void CRunBytecode::pcallOpcode()
 {
    trace ("pcall opcode");
 
-   _dataStack.setBS(_executionStack.top()); // TODO: verificar melhor isso...
+   _executionStack.push(_dataStack.getBS());
+//   _executionStack.push(_dataStack.getSP());
 
+   _dataStack.setBS(_dataStack.getSP());
+
    int address = _code.fetchInt();
 
    _executionStack.push(_code.getIP());
@@ -319,6 +342,8 @@
 
    if (_globalData.getCString(address) == "imprima") {
       procImprima();
+   } else if (_globalData.getCString(address) == "leia") {
+      procLeia();
    } else {
       error("libcall invocando subrotina desconhecida !!!");
    }
@@ -335,6 +360,26 @@
 }
 
 
+void CRunBytecode::exit0Opcode()
+{
+   trace ("exit0 opcode");
+
+   _returnCode = 0;
+
+   _stop = true;
+}
+
+
+void CRunBytecode::exit1Opcode()
+{
+   trace ("exit1 opcode");
+
+   _returnCode = 1;
+
+   _stop = true;
+}
+
+
 void CRunBytecode::hltOpcode()
 {
    trace ("hlt opcode");
@@ -738,7 +783,7 @@
 
 void CRunBytecode::setIntData(const int &address, const int &value)
 {
-   if (address & 0x80000000) {
+   if (IS_LOCAL_ADDRESS(address)) {
       _dataStack.setInt(address, value);
    } else {
 //      std::cout << "setIntData global address: " << address << std::endl;
@@ -749,7 +794,7 @@
 
 int CRunBytecode::getIntData(const int &address)
 {
-   if (address & 0x80000000) {
+   if (IS_LOCAL_ADDRESS(address)) {
       return _dataStack.getInt(address);
    } else {
 //      std::cout << "global address: " << address << std::endl;
@@ -760,7 +805,7 @@
 
 void CRunBytecode::setStringData(const int &address, const std::string &value)
 {
-   if (address & 0x80000000) {
+   if (IS_LOCAL_ADDRESS(address)) {
       _dataStack.setCString(address, value);
    } else {
 //      std::cout << "setCStringData global address: " << address << std::endl;
@@ -771,7 +816,7 @@
 
 std::string CRunBytecode::getStringData(const int &address)
 {
-   if (address & 0x80000000) {
+   if (IS_LOCAL_ADDRESS(address)) {
       return _dataStack.getCString(address);
    } else {
 //      std::cout << "global address: " << address << std::endl;
@@ -858,11 +903,30 @@
    }
 }
 
-void CRunBytecode::popOpcode()
+void CRunBytecode::popsvOpcode()
 {
    invalidOpcode(__FUNCTION__);
 }
 
+void CRunBytecode::popivOpcode()
+{
+   trace ("popiv opcode");
+
+   int address = _code.fetchInt();
+
+   setIntData(address, _dataStack.popInt());
+}
+
+void CRunBytecode::poprvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
+void CRunBytecode::popmvOpcode()
+{
+   invalidOpcode(__FUNCTION__);
+}
+
 void CRunBytecode::incspOpcode()
 {
    trace ("incsp opcode");
@@ -883,76 +947,121 @@
 }
 
 
-//   OP_PUSH_0,
-//   OP_PUSH_2,
-//   OP_PUSH_3,
-//   OP_PUSH_4,
-//   OP_PUSH_5,
+void CRunBytecode::push0Opcode()
+{
+   trace ("push0 opcode");
 
-void CRunBytecode::pushIntOpcode()
+   _dataStack.pushInt(0);
+}
+
+
+void CRunBytecode::push1Opcode()
 {
-   trace ("push_int opcode");
+   trace ("push1 opcode");
 
-   int address = _code.fetchInt();
+   _dataStack.pushInt(1);
+}
 
-   _dataStack.pushInt(getIntData(address));
+
+void CRunBytecode::push2Opcode()
+{
+   trace ("push2 opcode");
+
+   _dataStack.pushInt(2);
 }
 
-void CRunBytecode::pushRealOpcode()
+
+void CRunBytecode::push3Opcode()
 {
-   trace ("push_real opcode");
+   trace ("push3 opcode");
 
-   invalidOpcode(__FUNCTION__);
+   _dataStack.pushInt(3);
 }
 
-void CRunBytecode::pushCharOpcode()
+
+void CRunBytecode::push4Opcode()
 {
-   trace ("push_char opcode");
+   trace ("push4 opcode");
 
-   invalidOpcode(__FUNCTION__);
+   _dataStack.pushInt(4);
 }
 
-void CRunBytecode::pushBoolOpcode()
+
+void CRunBytecode::push5Opcode()
 {
-   trace ("push_bool opcode");
+   trace ("push5 opcode");
 
+   _dataStack.pushInt(5);
+}
+
+
+void CRunBytecode::pushsvOpcode()
+{
+   trace ("pushsv opcode");
+
+   int address = _code.fetchInt();
+
+   _dataStack.pushInt(address);
+}
+
+
+void CRunBytecode::pushivOpcode()
+{
+   trace ("pushiv opcode");
+
+   int address = _code.fetchInt();
+
+   _dataStack.pushInt(getIntData(address));
+}
+
+void CRunBytecode::pushrvOpcode()
+{
+   trace ("pushrv opcode");
+
    invalidOpcode(__FUNCTION__);
 }
 
-void CRunBytecode::pushMatrixOpcode()
+void CRunBytecode::pushmvOpcode()
 {
    invalidOpcode(__FUNCTION__);
 }
 
-void CRunBytecode::pushITypeOpcode()
+void CRunBytecode::pushstOpcode()
 {
-   trace ("push_itype opcode");
+   trace ("pushst opcode");
 
+   _dataStack.pushInt(CSymbol::STRING);
+}
+
+void CRunBytecode::pushitOpcode()
+{
+   trace ("pushit opcode");
+
    _dataStack.pushInt(CSymbol::INT);
 }
 
-void CRunBytecode::pushRTypeOpcode()
+void CRunBytecode::pushrtOpcode()
 {
-   trace ("push_rtype opcode");
+   trace ("pushrt opcode");
 
    _dataStack.pushInt(CSymbol::REAL);
 }
 
-void CRunBytecode::pushCTypeOpcode()
+void CRunBytecode::pushctOpcode()
 {
-   trace ("push_ctype opcode");
+   trace ("pushct opcode");
 
    _dataStack.pushInt(CSymbol::CHAR);
 }
 
-void CRunBytecode::pushBTypeOpcode()
+void CRunBytecode::pushbtOpcode()
 {
-   trace ("push_btype opcode");
+   trace ("pushbt opcode");
 
    _dataStack.pushInt(CSymbol::BOOL);
 }
 
-void CRunBytecode::pushMTypeOpcode()
+void CRunBytecode::pushmtOpcode()
 {
    invalidOpcode(__FUNCTION__);
 }
@@ -960,28 +1069,49 @@
 
 void CRunBytecode::incsp4Opcode()
 {
-   trace ("incsp_4 opcode");
+   trace ("incsp4 opcode");
 
    _dataStack.pushInt(0);
 }
 
-//   OP_INCSP_8,
+void CRunBytecode::incsp8Opcode()
+{
+   trace ("incsp8 opcode");
 
+   _dataStack.pushInt(0);
+   _dataStack.pushInt(0);
+}
+
 void CRunBytecode::decsp4Opcode()
 {
-   trace ("decsp_4 opcode");
+   trace ("decsp4 opcode");
 
    _dataStack.popInt();
 }
 
-//   OP_DECSP_8,
+void CRunBytecode::decsp8Opcode()
+{
+   trace ("decsp8 opcode");
 
+   _dataStack.popInt();
+   _dataStack.popInt();
+}
+
 void CRunBytecode::retOpcode()
 {
    trace ("ret opcode");
 
    _code.setIP(_executionStack.top());
    _executionStack.pop();
+
+//   _dataStack.setSP(_executionStack.top());
+//   _executionStack.pop();
+
+   _dataStack.setBS(_executionStack.top());
+   _executionStack.pop();
+
+//   // Ajusta o tamanho correto de _dataStack
+//   _dataStack.resize(_dataStack.getSP());
 }
 
 void CRunBytecode::sallocOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-29 11:53:00 UTC (rev 400)
@@ -31,6 +31,7 @@
    void initOpcodePointer();
    void step();
    void procImprima();
+   void procLeia();
    void setIntData(const int &address, const int &value);
    int  getIntData(const int &address);
    void setStringData(const int &address, const std::string &value);
@@ -38,17 +39,15 @@
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
-   void pushSregOpcode();
-   void popSregOpcode();
-   void pushStringOpcode();
-   void pushSTypeOpcode();
+//   void pushsregOpcode();
+//   void popsregOpcode();
 //   void push1Opcode();
    void pcallOpcode();
    void libcallOpcode();
 //   void exit0Opcode();
    void exitOpcode();
-
-//   OP_EXIT_1,
+   void exit0Opcode();
+   void exit1Opcode();
    void hltOpcode();
 
    void isumOpcode();
@@ -123,32 +122,34 @@
    void jmpOpcode();
    void ifOpcode();
    void ifnotOpcode();
-   void popOpcode();
+   void popsvOpcode();
+   void popivOpcode();
+   void poprvOpcode();
+   void popmvOpcode();
    void incspOpcode();
    void decspOpcode();
+   void push0Opcode();
+   void push1Opcode();
+   void push2Opcode();
+   void push3Opcode();
+   void push4Opcode();
+   void push5Opcode();
+   void pushsvOpcode();
+   void pushivOpcode();
+   void pushrvOpcode();
+   void pushmvOpcode();
 
-//   OP_PUSH_0,
-//   OP_PUSH_2,
-//   OP_PUSH_3,
-//   OP_PUSH_4,
-//   OP_PUSH_5,
+   void pushstOpcode();
+   void pushitOpcode();
+   void pushrtOpcode();
+   void pushctOpcode();
+   void pushbtOpcode();
+   void pushmtOpcode();
 
-   void pushIntOpcode();
-   void pushRealOpcode();
-   void pushCharOpcode();
-   void pushBoolOpcode();
-   void pushMatrixOpcode();
-
-   void pushITypeOpcode();
-   void pushRTypeOpcode();
-   void pushCTypeOpcode();
-   void pushBTypeOpcode();
-   void pushMTypeOpcode();
-
    void incsp4Opcode();
-//   OP_INCSP_8,
+   void incsp8Opcode();
    void decsp4Opcode();
-//   OP_DECSP_8,
+   void decsp8Opcode();
 
    void retOpcode();
    void sallocOpcode();
@@ -171,7 +172,7 @@
    CSymbolTable  _symbolTable;
    CBinString    _globalData;
    CBytecode     _code;
-   OpcodePointer _opcodePointer[ OPCODE_NUMBER ];
+   OpcodePointer _opcodePointer[OPCODE_NUMBER];
    bool          _stop;
    int           _returnCode;
    CDataStack    _dataStack;

Modified: trunk/gpt2/gptvm/src/Makefile
===================================================================
--- trunk/gpt2/gptvm/src/Makefile	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptvm/src/Makefile	2007-11-29 11:53:00 UTC (rev 400)
@@ -8,7 +8,7 @@
 
 objects = main.o CGptVm.o CRunBytecode.o CBytecode.o CDataStack.o \
           $(COMMON_DIR)CSymbol.o $(COMMON_DIR)CSymbolTable.o \
-          $(COMMON_DIR)CHeader.o \
+          $(COMMON_DIR)CHeader.o $(COMMON_DIR)Tools.o\
           $(COMMON_DIR)CBinString.o $(COMMON_DIR)CSymbolList.o 
           
 all: $(objects)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/run.sh
===================================================================
--- trunk/gpt2/gptvm/test/run.sh	2007-11-27 19:01:45 UTC (rev 399)
+++ trunk/gpt2/gptvm/test/run.sh	2007-11-29 11:53:00 UTC (rev 400)
@@ -1,6 +1,6 @@
 rm $1.stdout 1>/dev/null 2>&1
 
-../../gptvm $1 > $1.stdout
+../../src/gptvm $1 > $1.stdout
 if [ $? -ne 0 ]
 then
 	echo "Erro: nao foi possivel executar $1.gvm"



From gpt-commit-noreply at mail.berlios.de  Thu Nov 29 13:23:04 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Thu, 29 Nov 2007 13:23:04 +0100
Subject: [gpt-commit] r401 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200711291223.lATCN4gm021563@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-29 13:23:01 +0100 (Thu, 29 Nov 2007)
New Revision: 401

Modified:
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
   trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
   trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
   trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
   trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
Log:
DEVNULL:
* Mais alguns mnemonicos/opcodes renomeados


Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-29 12:23:01 UTC (rev 401)
@@ -106,15 +106,13 @@
    OP_PUSHSV      = 80,
    OP_PUSHRV      = 81,
    OP_PUSHMV      = 84,
-   OP_PUSHSREG    = 85,
-   OP_POPSREG     = 86,
-   OP_INCSP4      = 87,
-   OP_INCSP8      = 88,
-   OP_DECSP4      = 89,
-   OP_DECSP8      = 90,
+   OP_INCSP_4     = 87,
+   OP_INCSP_8     = 88,
+   OP_DECSP_4     = 89,
+   OP_DECSP_8     = 90,
    OP_PCALL       = 91,
    OP_RET         = 92,
-   OP_LIBCALL     = 93,
+   OP_LCALL       = 93,
    OP_SALLOC      = 94,
    OP_SFREE       = 95,
    OP_SSETC       = 96,
@@ -139,14 +137,14 @@
    OP_POPRV       = 115,
    OP_POPSV       = 116,
    OP_POPMV       = 117,
-   OP_PUSH0       = 118,
-   OP_PUSH1       = 119,
-   OP_PUSH2       = 120,
-   OP_PUSH3       = 121,
-   OP_PUSH4       = 122,
-   OP_PUSH5       = 123,
-   OP_EXIT0       = 124,
-   OP_EXIT1       = 125,
+   OP_PUSH_0      = 118,
+   OP_PUSH_1      = 119,
+   OP_PUSH_2      = 120,
+   OP_PUSH_3      = 121,
+   OP_PUSH_4      = 122,
+   OP_PUSH_5      = 123,
+   OP_EXIT_0      = 124,
+   OP_EXIT_1      = 125,
    OPCODE_NUMBER  = 125
 };
 

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-29 12:23:01 UTC (rev 401)
@@ -84,18 +84,17 @@
    _opcodes[ "jmp"         ] = OP_JMP;
    _opcodes[ "if"          ] = OP_IF;
    _opcodes[ "ifnot"       ] = OP_IFNOT;
-//   _opcodes[ "push"        ] = OP_PUSH;
-   _opcodes[ "popiv"         ] = OP_POPIV;
-   _opcodes[ "poprv"         ] = OP_POPRV;
-   _opcodes[ "popmv"         ] = OP_POPMV;
+   _opcodes[ "popiv"       ] = OP_POPIV;
+   _opcodes[ "poprv"       ] = OP_POPRV;
+   _opcodes[ "popmv"       ] = OP_POPMV;
    _opcodes[ "incsp"       ] = OP_INCSP;
    _opcodes[ "decsp"       ] = OP_DECSP;
-   _opcodes[ "push0"       ] = OP_PUSH0;
-   _opcodes[ "push1"       ] = OP_PUSH1;
-   _opcodes[ "push2"       ] = OP_PUSH2;
-   _opcodes[ "push3"       ] = OP_PUSH3;
-   _opcodes[ "push4"       ] = OP_PUSH4;
-   _opcodes[ "push5"       ] = OP_PUSH5;
+   _opcodes[ "push_0"      ] = OP_PUSH_0;
+   _opcodes[ "push_1"      ] = OP_PUSH_1;
+   _opcodes[ "push_2"      ] = OP_PUSH_2;
+   _opcodes[ "push_3"      ] = OP_PUSH_3;
+   _opcodes[ "push_4"      ] = OP_PUSH_4;
+   _opcodes[ "push_5"      ] = OP_PUSH_5;
    _opcodes[ "pushiv"      ] = OP_PUSHIV;
    _opcodes[ "pushsv"      ] = OP_PUSHSV;
    _opcodes[ "pushrv"      ] = OP_PUSHRV;
@@ -106,15 +105,13 @@
    _opcodes[ "pushct"      ] = OP_PUSHCT;
    _opcodes[ "pushbt"      ] = OP_PUSHBT;
    _opcodes[ "pushmt"      ] = OP_PUSHMT;
-   _opcodes[ "pushsreg"    ] = OP_PUSHSREG;
-   _opcodes[ "popsreg"     ] = OP_POPSREG;
-   _opcodes[ "incsp4"      ] = OP_INCSP4;
-   _opcodes[ "incsp8"      ] = OP_INCSP8;
-   _opcodes[ "decsp4"      ] = OP_DECSP4;
-   _opcodes[ "decsp8"      ] = OP_DECSP8;
+   _opcodes[ "incsp_4"     ] = OP_INCSP_4;
+   _opcodes[ "incsp_8"     ] = OP_INCSP_8;
+   _opcodes[ "decsp_4"     ] = OP_DECSP_4;
+   _opcodes[ "decsp_8"     ] = OP_DECSP_8;
    _opcodes[ "pcall"       ] = OP_PCALL;
    _opcodes[ "ret"         ] = OP_RET;
-   _opcodes[ "libcall"     ] = OP_LIBCALL;
+   _opcodes[ "lcall"       ] = OP_LCALL;
    _opcodes[ "salloc"      ] = OP_SALLOC;
    _opcodes[ "sfree"       ] = OP_SFREE;
    _opcodes[ "ssetc"       ] = OP_SSETC;
@@ -130,8 +127,8 @@
    _opcodes[ "mgetsize1"   ] = OP_MGETSIZE1;
    _opcodes[ "mgetsize2"   ] = OP_MGETSIZE2;
    _opcodes[ "nop"         ] = OP_NOP;
-   _opcodes[ "exit0"       ] = OP_EXIT0;
-   _opcodes[ "exit1"       ] = OP_EXIT1;
+   _opcodes[ "exit_0"      ] = OP_EXIT_0;
+   _opcodes[ "exit_1"      ] = OP_EXIT_1;
    _opcodes[ "hlt"         ] = OP_HLT;
    _opcodes[ "exit"        ] = OP_EXIT;
 }

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-29 12:23:01 UTC (rev 401)
@@ -117,12 +117,12 @@
    T_KW_POPMV="popmv";
    T_KW_INCSP="incsp";
    T_KW_DECSP="decsp";
-   T_KW_PUSH0="push0";
-   T_KW_PUSH1="push1";
-   T_KW_PUSH2="push2";
-   T_KW_PUSH3="push3";
-   T_KW_PUSH4="push4";
-   T_KW_PUSH5="push5";
+   T_KW_PUSH_0="push_0";
+   T_KW_PUSH_1="push_1";
+   T_KW_PUSH_2="push_2";
+   T_KW_PUSH_3="push_3";
+   T_KW_PUSH_4="push_4";
+   T_KW_PUSH_5="push_5";
    T_KW_PUSHIV="pushiv";
    T_KW_PUSHSV="pushsv";
    T_KW_PUSHRV="pushrv";
@@ -133,14 +133,12 @@
    T_KW_PUSHCT="pushct";
    T_KW_PUSHBT="pushbt";
    T_KW_PUSHMT="pushmt";
-//   T_KW_PUSHSREG="pushsreg";
-//   T_KW_POPSREG="popsreg";
-   T_KW_INCSP4="incsp4";
-   T_KW_INCSP8="incsp8";
-   T_KW_DECSP4="decsp4";
-   T_KW_DECSP8="decsp8";
+   T_KW_INCSP_4="incsp_4";
+   T_KW_INCSP_8="incsp_8";
+   T_KW_DECSP_4="decsp_4";
+   T_KW_DECSP_8="decsp_8";
    T_KW_PCALL="pcall";
-   T_KW_LIBCALL="libcall";
+   T_KW_LCALL="lcall";
    T_KW_RET="ret";
    T_KW_SALLOC="salloc";
    T_KW_SFREE="sfree";
@@ -157,8 +155,8 @@
    T_KW_MGETSIZE1="mgetsize1";
    T_KW_MGETSIZE2="mgetsize2";
    T_KW_NOP="nop";
-   T_KW_EXIT0="exit0";
-   T_KW_EXIT1="exit1";
+   T_KW_EXIT_0="exit_0";
+   T_KW_EXIT_1="exit_1";
    T_KW_HLT="hlt";
    T_KW_EXIT="exit";
    T_KW_TRUE="true";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-29 12:23:01 UTC (rev 401)
@@ -251,17 +251,15 @@
       {bytecode.addOpcode(getLastTokenText());}
       T_INT_VALUE
       { bytecode.addAddress(getLastTokenText(), CSymbol::CONST, CSymbol::INT); }
-   |  ("push0"|"push1"|"push2"|"push3"|"push4"|"push5")
+   |  ("push_0"|"push_1"|"push_2"|"push_3"|"push_4"|"push_5")
       {bytecode.addOpcode(getLastTokenText());}
-//   |  ("pushsreg"|"popsreg")
-//      {bytecode.addOpcode(getLastTokenText());}
-   |  ("incsp4"|"incsp8"|"decsp4"|"decsp8")
+   |  ("incsp_4"|"incsp_8"|"decsp_4"|"decsp_8")
       {bytecode.addOpcode(getLastTokenText());}
    |  "pcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
       { bytecode.unsolvedLabel(getLastTokenText());}
-   |  "libcall"
+   |  "lcall"
       {bytecode.addOpcode(getLastTokenText());}
       T_ID
       { bytecode.addAddress(getLastTokenText(),CSymbol::CONST, CSymbol::STRING); }
@@ -331,7 +329,7 @@
 //-----------
   mn_execucao
 //-----------
-   :   ("nop"|"hlt"|"exit0"|"exit1")
+   :   ("nop"|"hlt"|"exit_0"|"exit_1")
       {bytecode.addOpcode(getLastTokenText());}
    |   "exit"
       {bytecode.addOpcode(getLastTokenText());}

Modified: trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/enderecamento_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -17,8 +17,8 @@
     pushit
     pushsv "c.x="
     pushst
-    pushiv 2
-    libcall imprima
+    push_2
+    lcall imprima
 
     // imprima( "c.y=", c.y );
     igetv t1, c:4 // t1 := *(c + 4)
@@ -26,10 +26,10 @@
     pushit
     pushsv "c.y="
     pushst
-    pushiv 2
-    libcall imprima
+    push_2
+    lcall imprima
 
-    exit 0
+    exit_0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_condicionais_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -26,10 +26,10 @@
     // imprima( x );
     pushiv x
     pushit
-    push1
-    libcall imprima
+    push_1
+    lcall imprima
 
-    exit0
+    exit_0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/estruturas_repeticao_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -14,8 +14,8 @@
     // imprima( x );
     pushiv x
     pushit
-    push1
-    libcall imprima
+    push_1
+    lcall imprima
 
     // fim-para
     iinc x, 1
@@ -23,7 +23,7 @@
 
     proximo:
 
-    exit0
+    exit_0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/expressoes_matematicas_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -12,9 +12,9 @@
     pushsv "2+5*3="
     pushst
     pushiv 2
-    libcall imprima
+    lcall imprima
 
-    exit 0
+    exit_0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -3,7 +3,7 @@
 proc main
     var t1 int
     // imprima( "A soma ?: ", soma( 2, 7 ) );
-    pushiv 0 // resultado da fun??o
+    push_0 // resultado da fun??o
     pushiv 2 // empilha 2
     pushiv 7 // empilha 7
     pcall soma
@@ -12,10 +12,10 @@
     pushit
     pushsv "A soma ?: "
     pushst
-    pushiv 2
-    libcall imprima
+    push_2
+    lcall imprima
 
-    exit 0
+    exit_0
 endproc
 
 proc soma
@@ -25,7 +25,7 @@
 
     isum __result, x, y
 
-    decsp 8 // tamanho dos parametros + variaveis locais - retorno da funcao
+    decsp_8 // tamanho dos parametros + variaveis locais - retorno da funcao
     ret
 endproc
 

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -4,7 +4,7 @@
     pushsv "Ol? mundo !!!"
     pushst
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/invocando_subrotinas_linguagem_2.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -6,21 +6,21 @@
     // imprima( "Digite um n?mero: " );
     pushsv "Digite um n?mero: "
     pushst
-    pushiv 1
-    libcall imprima
+    push_1
+    lcall imprima
     // x := leia( );
     pushit
-    libcall leia
+    lcall leia
     popiv x
     // imprima( "O n?mero digitado foi ", x );
     pushiv x
     pushit
     pushsv "O n?mero digitado foi "
     pushst
-    pushiv 2
-    libcall imprima
+    push_2
+    lcall imprima
 
-    exit 0
+    exit_0
 endproc
 
 endprogram

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -10,7 +10,7 @@
     pushiv 20
     pcall soma
 
-    exit 0
+    exit_0
 endproc
 
 proc soma
@@ -21,14 +21,14 @@
 
     pushsv "A soma ?: "
     pushst
-    pushiv 1
-    libcall imprima
+    push_1
+    lcall imprima
 
     isum t1, x, y
     pushiv t1
     pushit
-    pushiv 1
-    libcall imprima
+    push_1
+    lcall imprima
 
     decsp 12
     ret	

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -12,10 +12,10 @@
     // imprima( s );
     pushiv s
     pushit
-    pushiv 1
-    libcall imprima
+    push_1
+    lcall imprima
 	
-    exit 0
+    exit_0
 endproc
 
 proc soma

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_3.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -6,7 +6,7 @@
    pushsv "Finalizando..."
    pushst
    pushiv 1
-   libcall imprima
+   lcall imprima
 
    exit 0
 endproc
@@ -19,7 +19,7 @@
    pushiv temp
    pushit
    pushiv 1
-   libcall imprima
+   lcall imprima
 
    decsp 4
    ret

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -21,7 +21,7 @@
     pushsv "x*y+4="
     pushst
     pushiv 2
-    libcall imprima
+    lcall imprima
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_2.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -13,12 +13,12 @@
     pushiv v
     pushit
     pushiv 1
-    libcall imprima
+    lcall imprima
 	
     pushiv 10
     pushit
     pushiv 1
-    libcall imprima
+    lcall imprima
 	
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -13,12 +13,12 @@
     pushrv v
     pushrt
     pushrv 1
-    libcall imprima
+    lcall imprima
 
     pushrv 10.0
     pushrt
     pushrv 1
-    libcall imprima
+    lcall imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -15,12 +15,12 @@
     pushsv v
     pushst
     pushiv 1
-    libcall imprima
+    lcall imprima
 	
     pushsv "10"
     pushst
     pushiv 1
-    libcall imprima
+    lcall imprima
 	
     sfree v
 

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_5.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -13,12 +13,12 @@
     pushiv v
     pushct
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     pushiv 'a'
     pushct
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_6.gasm	2007-11-29 12:23:01 UTC (rev 401)
@@ -10,17 +10,17 @@
     pushiv true
     pushbt
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     pushiv false
     pushbt
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     pushiv v
     pushbt
     pushiv 1
-    libcall imprima
+    lcall imprima
 
     exit 0
 endproc

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-29 12:23:01 UTC (rev 401)
@@ -39,13 +39,11 @@
    }
 
    _opcodePointer[OP_NOP        ] = &CRunBytecode::nopOpcode;
-//   _opcodePointer[OP_PUSHSREG   ] = &CRunBytecode::pushsregOpcode;
-//   _opcodePointer[OP_POPSREG    ] = &CRunBytecode::popsregOpcode;
    _opcodePointer[OP_PCALL      ] = &CRunBytecode::pcallOpcode;
-   _opcodePointer[OP_LIBCALL    ] = &CRunBytecode::libcallOpcode;
+   _opcodePointer[OP_LCALL      ] = &CRunBytecode::lcallOpcode;
    _opcodePointer[OP_EXIT       ] = &CRunBytecode::exitOpcode;
-   _opcodePointer[OP_EXIT0      ] = &CRunBytecode::exit0Opcode;
-   _opcodePointer[OP_EXIT1      ] = &CRunBytecode::exit1Opcode;
+   _opcodePointer[OP_EXIT_0     ] = &CRunBytecode::exit_0Opcode;
+   _opcodePointer[OP_EXIT_1     ] = &CRunBytecode::exit_1Opcode;
 
    _opcodePointer[OP_HLT        ] = &CRunBytecode::hltOpcode;
 
@@ -127,12 +125,12 @@
    _opcodePointer[OP_POPMV      ] = &CRunBytecode::popmvOpcode;
    _opcodePointer[OP_INCSP      ] = &CRunBytecode::incspOpcode;
    _opcodePointer[OP_DECSP      ] = &CRunBytecode::decspOpcode;
-   _opcodePointer[OP_PUSH0      ] = &CRunBytecode::push0Opcode;
-   _opcodePointer[OP_PUSH1      ] = &CRunBytecode::push1Opcode;
-   _opcodePointer[OP_PUSH2      ] = &CRunBytecode::push2Opcode;
-   _opcodePointer[OP_PUSH3      ] = &CRunBytecode::push3Opcode;
-   _opcodePointer[OP_PUSH4      ] = &CRunBytecode::push4Opcode;
-   _opcodePointer[OP_PUSH5      ] = &CRunBytecode::push5Opcode;
+   _opcodePointer[OP_PUSH_0     ] = &CRunBytecode::push_0Opcode;
+   _opcodePointer[OP_PUSH_1     ] = &CRunBytecode::push_1Opcode;
+   _opcodePointer[OP_PUSH_2     ] = &CRunBytecode::push_2Opcode;
+   _opcodePointer[OP_PUSH_3     ] = &CRunBytecode::push_3Opcode;
+   _opcodePointer[OP_PUSH_4     ] = &CRunBytecode::push_4Opcode;
+   _opcodePointer[OP_PUSH_5     ] = &CRunBytecode::push_5Opcode;
    _opcodePointer[OP_PUSHSV     ] = &CRunBytecode::pushsvOpcode;
    _opcodePointer[OP_PUSHIV     ] = &CRunBytecode::pushivOpcode;
    _opcodePointer[OP_PUSHRV     ] = &CRunBytecode::pushrvOpcode;
@@ -145,10 +143,10 @@
    _opcodePointer[OP_PUSHBT     ] = &CRunBytecode::pushbtOpcode;
    _opcodePointer[OP_PUSHMT     ] = &CRunBytecode::pushmtOpcode;
 
-   _opcodePointer[OP_INCSP4     ] = &CRunBytecode::incsp4Opcode;
-   _opcodePointer[OP_INCSP8     ] = &CRunBytecode::incsp8Opcode;
-   _opcodePointer[OP_DECSP4     ] = &CRunBytecode::decsp4Opcode;
-   _opcodePointer[OP_DECSP8     ] = &CRunBytecode::decsp8Opcode;
+   _opcodePointer[OP_INCSP_4     ] = &CRunBytecode::incsp_4Opcode;
+   _opcodePointer[OP_INCSP_8     ] = &CRunBytecode::incsp_8Opcode;
+   _opcodePointer[OP_DECSP_4     ] = &CRunBytecode::decsp_4Opcode;
+   _opcodePointer[OP_DECSP_8     ] = &CRunBytecode::decsp_8Opcode;
 
    _opcodePointer[OP_RET        ] = &CRunBytecode::retOpcode;
    _opcodePointer[OP_SALLOC     ] = &CRunBytecode::sallocOpcode;
@@ -334,7 +332,7 @@
 }
 
 
-void CRunBytecode::libcallOpcode()
+void CRunBytecode::lcallOpcode()
 {
    trace ("libcall opcode");
 
@@ -360,7 +358,7 @@
 }
 
 
-void CRunBytecode::exit0Opcode()
+void CRunBytecode::exit_0Opcode()
 {
    trace ("exit0 opcode");
 
@@ -370,7 +368,7 @@
 }
 
 
-void CRunBytecode::exit1Opcode()
+void CRunBytecode::exit_1Opcode()
 {
    trace ("exit1 opcode");
 
@@ -947,49 +945,49 @@
 }
 
 
-void CRunBytecode::push0Opcode()
+void CRunBytecode::push_0Opcode()
 {
-   trace ("push0 opcode");
+   trace ("pus_h0 opcode");
 
    _dataStack.pushInt(0);
 }
 
 
-void CRunBytecode::push1Opcode()
+void CRunBytecode::push_1Opcode()
 {
-   trace ("push1 opcode");
+   trace ("push_1 opcode");
 
    _dataStack.pushInt(1);
 }
 
 
-void CRunBytecode::push2Opcode()
+void CRunBytecode::push_2Opcode()
 {
-   trace ("push2 opcode");
+   trace ("push_2 opcode");
 
    _dataStack.pushInt(2);
 }
 
 
-void CRunBytecode::push3Opcode()
+void CRunBytecode::push_3Opcode()
 {
-   trace ("push3 opcode");
+   trace ("push_3 opcode");
 
    _dataStack.pushInt(3);
 }
 
 
-void CRunBytecode::push4Opcode()
+void CRunBytecode::push_4Opcode()
 {
-   trace ("push4 opcode");
+   trace ("push_4 opcode");
 
    _dataStack.pushInt(4);
 }
 
 
-void CRunBytecode::push5Opcode()
+void CRunBytecode::push_5Opcode()
 {
-   trace ("push5 opcode");
+   trace ("push_5 opcode");
 
    _dataStack.pushInt(5);
 }
@@ -1067,31 +1065,31 @@
 }
 
 
-void CRunBytecode::incsp4Opcode()
+void CRunBytecode::incsp_4Opcode()
 {
-   trace ("incsp4 opcode");
+   trace ("incsp_4 opcode");
 
    _dataStack.pushInt(0);
 }
 
-void CRunBytecode::incsp8Opcode()
+void CRunBytecode::incsp_8Opcode()
 {
-   trace ("incsp8 opcode");
+   trace ("incsp_8 opcode");
 
    _dataStack.pushInt(0);
    _dataStack.pushInt(0);
 }
 
-void CRunBytecode::decsp4Opcode()
+void CRunBytecode::decsp_4Opcode()
 {
-   trace ("decsp4 opcode");
+   trace ("decsp_4 opcode");
 
    _dataStack.popInt();
 }
 
-void CRunBytecode::decsp8Opcode()
+void CRunBytecode::decsp_8Opcode()
 {
-   trace ("decsp8 opcode");
+   trace ("decsp_8 opcode");
 
    _dataStack.popInt();
    _dataStack.popInt();

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-29 11:53:00 UTC (rev 400)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-29 12:23:01 UTC (rev 401)
@@ -39,15 +39,11 @@
    // opcodes
    void invalidOpcode(const std::string &opcode="");
    void nopOpcode();
-//   void pushsregOpcode();
-//   void popsregOpcode();
-//   void push1Opcode();
    void pcallOpcode();
-   void libcallOpcode();
-//   void exit0Opcode();
+   void lcallOpcode();
    void exitOpcode();
-   void exit0Opcode();
-   void exit1Opcode();
+   void exit_0Opcode();
+   void exit_1Opcode();
    void hltOpcode();
 
    void isumOpcode();
@@ -128,12 +124,12 @@
    void popmvOpcode();
    void incspOpcode();
    void decspOpcode();
-   void push0Opcode();
-   void push1Opcode();
-   void push2Opcode();
-   void push3Opcode();
-   void push4Opcode();
-   void push5Opcode();
+   void push_0Opcode();
+   void push_1Opcode();
+   void push_2Opcode();
+   void push_3Opcode();
+   void push_4Opcode();
+   void push_5Opcode();
    void pushsvOpcode();
    void pushivOpcode();
    void pushrvOpcode();
@@ -146,10 +142,10 @@
    void pushbtOpcode();
    void pushmtOpcode();
 
-   void incsp4Opcode();
-   void incsp8Opcode();
-   void decsp4Opcode();
-   void decsp8Opcode();
+   void incsp_4Opcode();
+   void incsp_8Opcode();
+   void decsp_4Opcode();
+   void decsp_8Opcode();
 
    void retOpcode();
    void sallocOpcode();

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Nov 30 14:30:10 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 30 Nov 2007 14:30:10 +0100
Subject: [gpt-commit] r402 - in trunk/gpt2: common/src gptasm/test/wikki
	gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200711301330.lAUDUA5F015212@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-30 14:30:08 +0100 (Fri, 30 Nov 2007)
New Revision: 402

Added:
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/common/src/Tools.hpp
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
Modified:
   trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
   trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
Log:
DEVNULL:
* Procedimentos com ou sem passagem de parametros funcionando
* Funcoes com ou sem passagem de parametros funcionando
* Funcoes recursivas funcionando


Added: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/common/src/Tools.cpp	2007-11-30 13:30:08 UTC (rev 402)
@@ -0,0 +1,344 @@
+//#include "PortugolParserTokenTypes.hpp"
+
+#include "Tools.hpp"
+#include "CSymbol.hpp" // TODO: nao ta legal...
+#include "Common.hpp"
+
+
+int hexToInt(const char* _value) {
+    int result = 0;
+    char *position;
+    char conversionTable[] = "0123456789ABCDEF";
+
+    while (*_value) {
+        position = strchr(conversionTable, *_value);
+        if (position == NULL)
+            return 0;
+
+        result <<= 4;
+        result = result | (position - conversionTable);
+        _value++;
+    }
+
+    return result;
+}
+
+string pad(string _text, unsigned int _size) {
+    if (_size > _text.length())
+        _text.append(_size - _text.length(), ' ');
+
+    return _text;
+}
+
+string lpad(string _text, unsigned int _size) {
+    if (_size > _text.length())
+        _text = string(_size - _text.length(), ' ') + _text;
+
+    return _text;
+}
+
+string intToHex(unsigned int _value, int _size) {
+    string codHex = "0123456789ABCDEF";
+    string result;
+    int nible;
+
+    while (_value > 0) {
+        nible = _value & 0xF;
+        _value >>= 4;
+        result = codHex[nible] + result;
+    }
+
+    if ( _size == -1 )
+        _size = 1;
+
+    return strZero(result, _size);
+    // if (_size == -1)
+    //     return( result );
+    // else
+    //     return( strZero( result, _size ) );
+    //
+}
+
+string strZero(string _value, unsigned int _size) {
+    while (_value.length() < _size) {
+        _value = '0' + _value;
+    }
+
+    return _value;
+}
+
+string strZero(int _value, unsigned int _size) {
+    string result = itoa(_value);
+
+    while (result.length() < _size) {
+        result = '0' + result;
+    }
+
+    return result;
+}
+
+string dataToHex(char _code[], unsigned int _length) {
+    string result;
+    unsigned int count;
+
+    for (count = 0; count < _length; count++)
+        result += intToHex(_code[count], 2);
+
+    return result;
+}
+
+string dataToHex(char _code[], unsigned int _start, unsigned int _length) {
+    string result;
+    unsigned int count;
+
+    for (count = _start; count - _start < _length; count++)
+        result += intToHex(_code[count], 2);
+
+    return result;
+}
+
+int binToInt(const char* _binValue) {
+    int intValue = 0;
+    int length = strlen(_binValue) - 1;
+    int countBit;
+
+    for (countBit = length; countBit >= 0; countBit--) {
+        if (_binValue[countBit] == '1')
+            intValue += int(pow(2.0, length - countBit));
+    }
+
+    return intValue;
+}
+
+string itoa(int _number) {
+    stringstream s;
+
+    s << _number;
+    return s.str();
+}
+
+string ftos(double _value) {
+    stringstream s;
+
+    s <<  setiosflags(ios::fixed) << _value;
+    
+    return s.str();
+}
+
+string itobool(int _number) {
+    if (_number == 0)
+        return "false";
+    else
+        return "true";
+}
+
+string strtoupper(string str) {
+    unsigned int count;
+
+    for (count = 0; count < str.size(); count++)
+        str[count] = toupper(str[count]);
+
+    return str;
+}
+
+string strToUpperWithEscapeControls(string str) {
+    unsigned int count;
+
+    for (count = 0; count < str.size(); count++) {
+        if (str[count] == '\\')
+            count += 2;
+        else
+            str[count] = toupper(str[count]);
+    }
+
+    return str;
+}
+
+string alltrim(string str) {
+    // crap version...  :-)
+    // precisamos usar `find', `rfind'! --felipek
+    while (str[0] == ' ')
+        str.erase(0, 1);
+
+    while (str[str.length() - 1] == ' ')
+        str.erase(str.length() - 1, 1);
+
+    return str;
+}
+
+string wo_ctrl_chrs(string str, char chr_to_put) {
+    unsigned int chr_number;
+
+    for (chr_number = 0; chr_number < str.size(); chr_number++) {
+        if (str[chr_number] < 32)
+            str[chr_number] = chr_to_put;
+    }
+
+    return str;
+}
+
+/* CRAP!  --felipek
+string& getStringWithTab(string _data, string _tab) {
+	cout << "begin getStringWithTab" << endl;
+	cout << "tab=\"" << _tab << "\"" << endl;
+	cout << "begin datae" << endl;
+	cout << _data << endl;
+	cout << "end datae" << endl;
+	int pos = -1;
+ 
+	// test too another new line sequences
+	while( ( pos = _data.find( "\n", pos + 1 ) ) != -1 ) {
+		_data.insert( pos + 1, _tab );
+	}
+ 
+	cout << "begin datas" << endl;
+	cout << _data << endl;
+	cout << "end datas" << endl;
+	return( _data );
+}
+*/
+
+bool streamtoken(istringstream& stream, string& key, string& val) {
+     /* FIXME: leak, --felipek */
+     char buffer[8192];
+     unsigned int delim;
+     string entry;
+//     bool ret;
+
+     /* FIXME: ret type, -- felipek */
+     stream.getline(buffer, 8192 - 1);
+     entry = string(buffer);
+     delim = entry.find(' ', 0);
+
+     if (delim != entry.npos) {
+         key = entry.substr(0, delim);
+         val = entry.substr(delim + 1);
+     }
+
+     return !stream.eof();
+}
+
+
+/*const string typeToText(const int &type)
+{
+   if (type == PortugolParserTokenTypes::T_INT_LIT) {
+      return "int";
+   } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
+      return "char";
+   } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
+      return "string";
+   } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
+      return "real";
+   } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
+      return "id";
+   }
+
+   return "ERRO !!!";
+}
+
+const string typeInAsm( const int &type )
+{
+   if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
+      return "int";
+   } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
+      return "string";
+   } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
+      return "char";
+   } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
+      return "bool";
+   } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
+      return "real";
+   } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
+      return "pointer ???";
+   } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
+      return "matrix";
+   }
+
+   return "ERRO !!!";
+}
+
+
+const int typeToLiteral( const int &type )
+{
+   switch (type) {
+      case PortugolParserTokenTypes::T_KW_INTEIRO:
+         return PortugolParserTokenTypes::T_INT_LIT;
+      case PortugolParserTokenTypes::T_KW_LITERAL:
+         return PortugolParserTokenTypes::T_STRING_LIT;
+      case PortugolParserTokenTypes::T_KW_CARACTERE:
+         return PortugolParserTokenTypes::T_CARAC_LIT;
+      case PortugolParserTokenTypes::T_KW_LOGICO:
+         return PortugolParserTokenTypes::T_INT_LIT;
+//      case PortugolParserTokenTypes::T_KW_CORINGA:
+//         return "pointer ???";
+//      case PortugolParserTokenTypes::T_KW_MATRIZ:
+//          return PortugolParserTokenTypes::T_MATRIZ;
+      default:
+          return 0;
+          // trow exception ???
+   }
+}
+*/
+
+int getTypeSize(const int &type)
+{
+   switch(type) {
+   case CSymbol::INT:
+   case CSymbol::CHAR:
+   case CSymbol::BOOL:
+      return sizeof(int);
+   case CSymbol::REAL:
+      return sizeof(double);
+   case CSymbol::STRING:
+   case CSymbol::MATRIX:
+      return sizeof(void*);
+   }
+   return 0;
+}
+
+//struct SBits {
+//   int signal : 1;
+//   int localbit : 1;
+//   int others : 30;
+//}
+
+//int setLocalBit(const int &value, const bool &state)
+//{
+//   SBits result;
+//   memcpy(result, value, sizeof(int));
+//  result.localbit = state;
+//
+//   return (int) result;
+//}
+
+int realAddress(int address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      address = address & UNSET_LOCAL_BIT;
+   }
+   if (IS_NEG_ADDRESS(address)) {
+      address = address & UNSET_NEG_BIT;
+      address *= -1;
+   }
+   return address;
+}
+
+std::string realAddressString(int address)
+{
+   std::string result;
+
+   if (IS_LOCAL_ADDRESS(address)) {
+      address = address & UNSET_LOCAL_BIT;
+      result += "LOCAL ";
+   }
+   if (IS_NEG_ADDRESS(address)) {
+      address = address & UNSET_NEG_BIT;
+      address *= -1;
+      result += "NEG ";
+   }
+   result += "value ";
+   result += itoa(address);
+
+   return result;
+}
+


Property changes on: trunk/gpt2/common/src/Tools.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gpt2/common/src/Tools.hpp
===================================================================
--- trunk/gpt2/common/src/Tools.hpp	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/common/src/Tools.hpp	2007-11-30 13:30:08 UTC (rev 402)
@@ -0,0 +1,42 @@
+#ifndef GPT_TOOLS_H
+#define GPT_TOOLS_H
+
+#include <iomanip>
+
+#include <iostream>
+#include <string>
+#include <cstdlib>
+#include <cstring>
+#include <cmath>
+#include <cstdio>
+#include <sstream>
+using namespace std;
+
+
+int hexToInt(const char *);
+string pad(string, unsigned int);
+string lpad(string, unsigned int);
+string intToHex(unsigned int, int = -1);
+string strZero(string, unsigned int);
+string strZero(int, unsigned int);
+string dataToHex(char *, unsigned int);
+string dataToHex( char *, unsigned int, unsigned int);
+int binToInt(const char *);
+int octToInt(const char *);
+string itoa(int);
+string itobool(int);
+string ftos(double);
+string strtoupper(string);
+string strToUpperWithEscapeControls(string);
+string alltrim(string);
+string wo_ctrl_chrs(string str, char = ' ');
+bool streamtoken(istringstream&, string&, string&);
+// string& getStringWithTab(string, string);
+const string typeToText(const int &type);
+const string typeInAsm( const int &type );
+const int typeToLiteral( const int &type );
+int getTypeSize(const int &type);
+int realAddress(int address);
+std::string realAddressString(int address);
+
+#endif


Property changes on: trunk/gpt2/common/src/Tools.hpp
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_1.gasm	2007-11-30 13:30:08 UTC (rev 402)
@@ -4,8 +4,8 @@
     var t1 int
     // imprima( "A soma ?: ", soma( 2, 7 ) );
     push_0 // resultado da fun??o
+    pushiv 7 // empilha 7
     pushiv 2 // empilha 2
-    pushiv 7 // empilha 7
     pcall soma
     popiv t1
     pushiv t1

Added: trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/gptasm/test/wikki/funcoes_definidas_usuario_2.gasm	2007-11-30 13:30:08 UTC (rev 402)
@@ -0,0 +1,69 @@
+program exemplo
+
+var x int
+
+proc main
+    // imprima( "Digite o n?mero para calcular o fatorial:" );
+    pushsv "Digite o n?mero para calcular o fatorial:"
+    pushst
+    push_1
+    lcall imprima
+
+    // x := leia( );
+    pushit
+    lcall leia
+    popiv x
+
+    // imprima( "Fatorial de ", x, " ? ", fatorial( x ) );
+    push_0 // retorno da fun??o
+    pushiv x
+    pcall fatorial
+    pushit
+    pushsv " ? "
+    pushst
+    pushiv x
+    pushit
+    pushsv "Fatorial de "
+    pushst
+    push_4
+    lcall imprima
+
+    exit_0
+endproc
+
+proc fatorial
+    param __result int
+    param z int
+	
+    var t1 int
+    var t2 int
+
+//    se z = 1 ent?o
+    ieq t1, z, 1
+    ifnot t1, senao
+        // retorne 1;
+        iset __result, 1
+        decsp 12
+        ret
+        jmp proximo
+    // sen?o
+    senao:
+        // retorne z * fatorial( z - 1 );
+        isub t1, z, 1
+        push_0 // retorno da fun??o
+        pushiv t1
+        pcall fatorial
+        popiv t1
+        imul t2, z, t1
+        iset __result, t2
+        decsp 12
+        ret
+    // fim-se
+    proximo:
+
+    decsp 12
+    ret
+endproc
+
+endprogram
+

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_1.gasm	2007-11-30 13:30:08 UTC (rev 402)
@@ -2,12 +2,12 @@
 
 proc main
     // soma( 2, 7 );
-    pushiv 2
     pushiv 7
+    pushiv 2
     pcall soma
 
-    pushiv 10
     pushiv 20
+    pushiv 10
     pcall soma
 
     exit_0
@@ -19,15 +19,12 @@
 
     var t1 int
 
-    pushsv "A soma ?: "
-    pushst
-    push_1
-    lcall imprima
-
     isum t1, x, y
     pushiv t1
     pushit
-    push_1
+    pushsv "A soma ?: "
+    pushst
+    push_2
     lcall imprima
 
     decsp 12

Modified: trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/gptasm/test/wikki/procedimentos_definidos_usuario_2.gasm	2007-11-30 13:30:08 UTC (rev 402)
@@ -4,9 +4,9 @@
 
 proc main
     // soma( s, 2, 7 );
+    pushiv 7
+    pushiv 2
     pushiv s
-    pushiv 2
-    pushiv 7
     pcall soma
 	
     // imprima( s );

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-29 12:23:01 UTC (rev 401)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 13:30:08 UTC (rev 402)
@@ -208,24 +208,30 @@
 
 void CRunBytecode::procImprima()
 {
-   int argNumber = _dataStack.popInt();
+   int address = sizeof(int);
+   int argNumber = _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
 
    for (int arg=0; arg < argNumber; arg++) {
-      int type = _dataStack.popInt();
+      address += sizeof(int);
+      int type = _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
       int boolValue;
       switch (type) {
          case CSymbol::STRING:
-            std::cout << getStringData(_dataStack.popInt());
+            address += sizeof(int);
+            std::cout << getStringData(_dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT));
             break;
          case CSymbol::INT:
-            std::cout << _dataStack.popInt();
+            address += sizeof(int);
+            std::cout << _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
             break;
          case CSymbol::CHAR:
 //            std::cout << (char)_dataStack.popInt();
-            std::cout << "char [" << (int)_dataStack.popInt() << "]";
+            address += sizeof(int);
+            std::cout << "char [" << (int)_dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT) << "]";
             break;
          case CSymbol::BOOL:
-            boolValue = _dataStack.popInt();
+            address += sizeof(int);
+            boolValue = _dataStack.getInt(address|SET_LOCAL_BIT|SET_NEG_BIT);
             if (boolValue == 0) {
                std::cout << "false";
             } else {
@@ -240,9 +246,47 @@
       }
    }
    std::cout << std::endl;
+   _dataStack.popBytes(address);
 }
 
 
+//void CRunBytecode::procImprima()
+//{
+//   int argNumber = _dataStack.popInt();
+//
+//   for (int arg=0; arg < argNumber; arg++) {
+//      int type = _dataStack.popInt();
+//      int boolValue;
+//      switch (type) {
+//         case CSymbol::STRING:
+//            std::cout << getStringData(_dataStack.popInt());
+//            break;
+//         case CSymbol::INT:
+//            std::cout << _dataStack.popInt();
+//            break;
+//         case CSymbol::CHAR:
+////            std::cout << (char)_dataStack.popInt();
+//            std::cout << "char [" << (int)_dataStack.popInt() << "]";
+//            break;
+//         case CSymbol::BOOL:
+//            boolValue = _dataStack.popInt();
+//            if (boolValue == 0) {
+//               std::cout << "false";
+//            } else {
+//               std::cout << "true";
+//            }
+//            break;
+//         case CSymbol::REAL:
+//         case CSymbol::MATRIX:
+//         default:
+//            std::cout << "Tipo ainda nao suportado !!!" << std::endl;
+//            abort();
+//      }
+//   }
+//   std::cout << std::endl;
+//}
+
+
 void CRunBytecode::procLeia()
 {
    int type = _dataStack.popInt();
@@ -334,8 +378,11 @@
 
 void CRunBytecode::lcallOpcode()
 {
-   trace ("libcall opcode");
+   trace ("lcall opcode");
 
+   _executionStack.push(_dataStack.getBS());
+   _dataStack.setBS(_dataStack.getSP());
+
    int address = _code.fetchInt();
 
    if (_globalData.getCString(address) == "imprima") {
@@ -343,8 +390,11 @@
    } else if (_globalData.getCString(address) == "leia") {
       procLeia();
    } else {
-      error("libcall invocando subrotina desconhecida !!!");
+      error("lcall invocando subrotina desconhecida !!!");
    }
+
+   _dataStack.setBS(_executionStack.top());
+   _executionStack.pop();
 }
 
 
@@ -947,7 +997,7 @@
 
 void CRunBytecode::push_0Opcode()
 {
-   trace ("pus_h0 opcode");
+   trace ("push_0 opcode");
 
    _dataStack.pushInt(0);
 }

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Nov 30 16:09:12 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 30 Nov 2007 16:09:12 +0100
Subject: [gpt-commit] r403 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200711301509.lAUF9C3X027112@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-30 16:09:05 +0100 (Fri, 30 Nov 2007)
New Revision: 403

Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
   trunk/gpt2/common/src/Common.hpp
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/src/CGenBytecode.cpp
   trunk/gpt2/gptasm/src/lexer.g
   trunk/gpt2/gptasm/src/parser.g
   trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
   trunk/gpt2/gptvm/src/CDataStack.cpp
   trunk/gpt2/gptvm/src/CDataStack.hpp
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/src/CRunBytecode.hpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
Log:
DEVNULL:
* Implementado suporte ao tipo real


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -44,6 +44,18 @@
 }
 
 
+void CBinString::writeReal(const double &value)
+{
+   char *byte = (char*)&value;
+
+   for( size_t i = 0; i < sizeof(double); i++) {
+      push_back(*byte);
+      byte++;
+   }
+}
+
+
+
 void CBinString::readInt(int &value)
 {
    int result = *((int*)data());
@@ -61,6 +73,14 @@
 }
 
 
+void CBinString::readReal(double &value)
+{
+   double result = *((double*)data());
+   erase(0,sizeof(double));
+   value = result;
+}
+
+
 char CBinString::getByte(const int &pos)
 {
    return (*this)[pos];
@@ -78,6 +98,13 @@
 }
 
 
+double CBinString::getReal(int pos)
+{
+   double result = *((double*)(data()+pos));
+   return result;
+}
+
+
 void CBinString::readString(std::string &value)
 {
    int size;
@@ -122,6 +149,13 @@
 }
 
 
+void CBinString::setReal(int pos, const double &value)
+{
+   double *address = (double*)(data()+pos);
+   *address = value;
+}
+
+
 void CBinString::pushInt(const int &value)
 {
    writeInt(value);
@@ -140,6 +174,23 @@
 }
 
 
+void CBinString::pushReal(const double &value)
+{
+   writeReal(value);
+}
+
+
+double CBinString::popReal()
+{
+   int pos = size()-sizeof(double);
+   double result = *((double*)(data()+pos));
+
+   erase(pos,sizeof(double));
+
+   return result;
+}
+
+
 int CBinString::getLastInt() const
 {
    int pos = size()-sizeof(int);
@@ -149,6 +200,15 @@
 }
 
 
+double CBinString::getLastReal() const
+{
+   int pos = size()-sizeof(double);
+   double result = *((double*)(data()+pos));
+
+   return result;
+}
+
+
 void CBinString::pushCString(const std::string &value)
 {
    (*this) += value;

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -3,6 +3,7 @@
 
 #include <string>
 
+// TODO: muitos desses metodos poderiam ser implementados ou como templates ou entao com um metodo generico que receba aonde ler/gravar a informacao e o tamanho do dado (sizeof(tipo))
 
 class CBinString : public std::string
 {
@@ -11,19 +12,26 @@
    void writeByte(const char &value);
    void writeString(const std::string &value, const bool &writeSize=true);
    void writeBool(const bool &value);
+   void writeReal(const double &value);
    void readInt(int &value);
    void readByte(char &value);
+   void readReal(double &value);
    char getByte(const int &pos);
    void getByte(const int &pos, char &value);
    int getInt(int pos);
+   double getReal(int pos);
    void readString(std::string &value);
    std::string readString();
    void readBool(bool &value);
    void setInt(int pos, const int &value);
    void setCString(int pos, const std::string &value);
+   void setReal(int pos, const double &value);
    void pushInt(const int &value);
    int popInt();
+   void pushReal(const double &value);
+   double popReal();
    int getLastInt() const;
+   double getLastReal() const;
    void pushCString(const std::string &value);
    std::string popCString();
    void pushBytes(const int &number);

Modified: trunk/gpt2/common/src/Common.hpp
===================================================================
--- trunk/gpt2/common/src/Common.hpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/common/src/Common.hpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -39,7 +39,6 @@
    OP_IDIV        = 11,
    OP_RDIV        = 12,
    OP_IMOD        = 13,
-   OP_RMOD        = 14,
    OP_IGE         = 15,
    OP_SGE         = 16,
    OP_RGE         = 17,

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -46,10 +46,10 @@
       writeString(name, false);
    } else if (type == CSymbol::INT) {
       writeInt(atoi(name.c_str()));
+   } else if (type == CSymbol::REAL) {
+      writeReal(atof(name.c_str()));
    }
 
    return symbol;
 }
 
-
-

Modified: trunk/gpt2/gptasm/src/CGenBytecode.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptasm/src/CGenBytecode.cpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -23,7 +23,6 @@
    _opcodes[ "idiv"        ] = OP_IDIV;
    _opcodes[ "rdiv"        ] = OP_RDIV;
    _opcodes[ "imod"        ] = OP_IMOD;
-   _opcodes[ "rmod"        ] = OP_RMOD;
    _opcodes[ "ige"         ] = OP_IGE;
    _opcodes[ "sge"         ] = OP_SGE;
    _opcodes[ "rge"         ] = OP_RGE;

Modified: trunk/gpt2/gptasm/src/lexer.g
===================================================================
--- trunk/gpt2/gptasm/src/lexer.g	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptasm/src/lexer.g	2007-11-30 15:09:05 UTC (rev 403)
@@ -50,7 +50,6 @@
    T_KW_IDIV="idiv";
    T_KW_RDIV="rdiv";
    T_KW_IMOD="imod";
-   T_KW_RMOD="rmod";
    T_KW_IGE="ige";
    T_KW_SGE="sge";
    T_KW_RGE="rge";

Modified: trunk/gpt2/gptasm/src/parser.g
===================================================================
--- trunk/gpt2/gptasm/src/parser.g	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptasm/src/parser.g	2007-11-30 15:09:05 UTC (rev 403)
@@ -167,7 +167,7 @@
    :  ( "isum"|"ssum"|"rsum"
       | "isub"|"ssub"|"rsub"
       | "imul"|"rmul"|"idiv"|"rdiv"
-      | "imod"|"rmod"
+      | "imod"
       | "ige" |"sge" |"rge" |"ile"|"sle"|"rle"
       | "ine" |"sne" |"rne"
       | "igt" |"sgt" |"rgt"

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_3.gasm	2007-11-30 15:09:05 UTC (rev 403)
@@ -5,19 +5,19 @@
 proc main
     rset v, 0.0
     rset v, v
-    rsum v, 10.0, 10.0
+    rsum v, 10.2, 10.2
     rsum v, v, v
-    rsum v, v, 10.0
-    rsum v, 10.0, v
+    rsum v, v, 10.2
+    rsum v, 10.2, v
 
     pushrv v
     pushrt
-    pushrv 1
+    push_1
     lcall imprima
 
-    pushrv 10.0
+    pushrv 10.8
     pushrt
-    pushrv 1
+    push_1
     lcall imprima
 
     exit 0

Modified: trunk/gpt2/gptvm/src/CDataStack.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptvm/src/CDataStack.cpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -60,6 +60,42 @@
 }
 
 
+void CDataStack::setReal(const int &address, const double &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      CBinString::setReal(_BS + realAddress(address), value);
+   } else {
+      std::cout << "ERRO !!! Invocando setReal com global address: " << address << std::endl;
+   }
+}
+
+
+double CDataStack::getReal(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return CBinString::getReal(_BS + realAddress(address));
+   } else {
+      std::cout << "ERRO !!! Invocando getReal com global address: " << address << std::endl;
+      return -1;
+   }
+}
+
+
+void CDataStack::pushReal(const double &value)
+{
+   CBinString::pushReal(value);
+   _SP+=sizeof(double);
+}
+
+
+double CDataStack::popReal()
+{
+   double result = CBinString::popReal();
+   _SP-=sizeof(double);
+   return result;
+}
+
+
 void CDataStack::pushBytes(const int &number)
 {
    CBinString::pushBytes(number);

Modified: trunk/gpt2/gptvm/src/CDataStack.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptvm/src/CDataStack.hpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -14,6 +14,10 @@
    int getInt(const int &address);
    void pushInt(const int &value);
    int popInt();
+   void setReal(const int &address, const double &value);
+   double getReal(const int &address);
+   void pushReal(const double &value);
+   double popReal();
    void pushBytes(const int &number);
    void popBytes(const int &number);
    void setBS(const int &value);

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -58,7 +58,6 @@
    _opcodePointer[OP_IDIV       ] = &CRunBytecode::idivOpcode;
    _opcodePointer[OP_RDIV       ] = &CRunBytecode::rdivOpcode;
    _opcodePointer[OP_IMOD       ] = &CRunBytecode::imodOpcode;
-   _opcodePointer[OP_RMOD       ] = &CRunBytecode::rmodOpcode;
    _opcodePointer[OP_IGE        ] = &CRunBytecode::igeOpcode;
    _opcodePointer[OP_SGE        ] = &CRunBytecode::sgeOpcode;
    _opcodePointer[OP_RGE        ] = &CRunBytecode::rgeOpcode;
@@ -239,6 +238,9 @@
             }
             break;
          case CSymbol::REAL:
+            address += sizeof(double);
+            std::cout << _dataStack.getReal(address|SET_LOCAL_BIT|SET_NEG_BIT);
+            break;
          case CSymbol::MATRIX:
          default:
             std::cout << "Tipo ainda nao suportado !!!" << std::endl;
@@ -291,6 +293,7 @@
 {
    int type = _dataStack.popInt();
    int iValue = 0;
+   double dValue = 0.0;
    switch (type) {
 //      case CSymbol::STRING:
 //         _dataStack.pushString(std::cin);
@@ -311,6 +314,9 @@
 //         }
 //         break;
       case CSymbol::REAL:
+         std::cin >> dValue;
+         _dataStack.pushReal(dValue);
+         break;
       case CSymbol::MATRIX:
       default:
          std::cout << "Tipo ainda nao suportado !!!" << std::endl;
@@ -319,6 +325,71 @@
    std::cout << std::endl;
 }
 
+
+void CRunBytecode::setIntData(const int &address, const int &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      _dataStack.setInt(address, value);
+   } else {
+//      std::cout << "setIntData global address: " << address << std::endl;
+      _globalData.setInt(address, value);
+   }
+}
+
+
+int CRunBytecode::getIntData(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return _dataStack.getInt(address);
+   } else {
+//      std::cout << "global address: " << address << std::endl;
+      return _globalData.getInt(address);
+   }
+}
+
+
+void CRunBytecode::setRealData(const int &address, const double &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      _dataStack.setReal(address, value);
+   } else {
+      _globalData.setReal(address, value);
+   }
+}
+
+
+double CRunBytecode::getRealData(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return _dataStack.getReal(address);
+   } else {
+      return _globalData.getReal(address);
+   }
+}
+
+
+void CRunBytecode::setStringData(const int &address, const std::string &value)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      _dataStack.setCString(address, value);
+   } else {
+//      std::cout << "setCStringData global address: " << address << std::endl;
+      _globalData.setCString(address, value);
+   }
+}
+
+
+std::string CRunBytecode::getStringData(const int &address)
+{
+   if (IS_LOCAL_ADDRESS(address)) {
+      return _dataStack.getCString(address);
+   } else {
+//      std::cout << "global address: " << address << std::endl;
+      return _globalData.getCString(address);
+   }
+}
+
+
 /////////////
 // opcodes //
 /////////////
@@ -335,31 +406,7 @@
    // nothing to do
 }
 
-//void CRunBytecode::pushsregOpcode()
-//{
-//   invalidOpcode(__FUNCTION__);
-//   trace ("pushsreg opcode");
-//
-//   _executionStack.push(_dataStack.getBS());
-//   _executionStack.push(_dataStack.getSP());
-//}
 
-//void CRunBytecode::popsregOpcode()
-//{
-//   invalidOpcode(__FUNCTION__);
-//   trace ("popsreg opcode");
-//
-//   _dataStack.setSP(_executionStack.top());
-//   _executionStack.pop();
-//
-//   _dataStack.setBS(_executionStack.top());
-//   _executionStack.pop();
-//
-//   // Ajusta o tamanho correto de _dataStack
-//   _dataStack.resize(_dataStack.getSP());
-//}
-
-
 void CRunBytecode::pcallOpcode()
 {
    trace ("pcall opcode");
@@ -403,28 +450,25 @@
    trace ("exit opcode");
 
    _returnCode = getIntData(_code.fetchInt());
-
-   _stop = true;
+   _stop       = true;
 }
 
 
 void CRunBytecode::exit_0Opcode()
 {
-   trace ("exit0 opcode");
+   trace ("exit_0 opcode");
 
    _returnCode = 0;
-
-   _stop = true;
+   _stop       = true;
 }
 
 
 void CRunBytecode::exit_1Opcode()
 {
-   trace ("exit1 opcode");
+   trace ("exit_1 opcode");
 
    _returnCode = 1;
-
-   _stop = true;
+   _stop       = true;
 }
 
 
@@ -453,7 +497,13 @@
 
 void CRunBytecode::rsumOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rsum opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) + getRealData(val2Address));
 }
 
 void CRunBytecode::isubOpcode()
@@ -474,7 +524,13 @@
 
 void CRunBytecode::rsubOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rsub opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) - getRealData(val2Address));
 }
 
 void CRunBytecode::imulOpcode()
@@ -490,7 +546,13 @@
 
 void CRunBytecode::rmulOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rmul opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) * getRealData(val2Address));
 }
 
 void CRunBytecode::idivOpcode()
@@ -506,7 +568,13 @@
 
 void CRunBytecode::rdivOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rdiv opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) / getRealData(val2Address));
 }
 
 void CRunBytecode::imodOpcode()
@@ -520,10 +588,6 @@
    setIntData(varAddress, getIntData(val1Address) % getIntData(val2Address));
 }
 
-void CRunBytecode::rmodOpcode()
-{
-   invalidOpcode(__FUNCTION__);
-}
 
 void CRunBytecode::igeOpcode()
 {
@@ -543,7 +607,13 @@
 
 void CRunBytecode::rgeOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rge opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) >= getRealData(val2Address));
 }
 
 void CRunBytecode::ileOpcode()
@@ -564,7 +634,13 @@
 
 void CRunBytecode::rleOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rle opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) <= getRealData(val2Address));
 }
 
 void CRunBytecode::ineOpcode()
@@ -585,7 +661,13 @@
 
 void CRunBytecode::rneOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rne opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) != getRealData(val2Address));
 }
 
 void CRunBytecode::igtOpcode()
@@ -606,7 +688,13 @@
 
 void CRunBytecode::rgtOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rgt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) > getRealData(val2Address));
 }
 
 void CRunBytecode::iltOpcode()
@@ -627,7 +715,13 @@
 
 void CRunBytecode::rltOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rlt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) < getRealData(val2Address));
 }
 
 void CRunBytecode::ieqOpcode()
@@ -648,7 +742,13 @@
 
 void CRunBytecode::reqOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("req opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(val1Address) == getRealData(val2Address));
 }
 
 void CRunBytecode::orOpcode()
@@ -735,7 +835,12 @@
 
 void CRunBytecode::i2rOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("i2r opcode");
+
+   int var1Address = _code.fetchInt();
+   int var2Address = _code.fetchInt();
+
+   setRealData(var1Address, (double)getIntData(var2Address));
 }
 
 void CRunBytecode::c2rOpcode()
@@ -805,7 +910,12 @@
 
 void CRunBytecode::r2iOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("r2i opcode");
+
+   int var1Address = _code.fetchInt();
+   int var2Address = _code.fetchInt();
+
+   setIntData(var1Address, (int)getRealData(var2Address));
 }
 
 void CRunBytecode::s2iOpcode()
@@ -829,50 +939,6 @@
 }
 
 
-void CRunBytecode::setIntData(const int &address, const int &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      _dataStack.setInt(address, value);
-   } else {
-//      std::cout << "setIntData global address: " << address << std::endl;
-      _globalData.setInt(address, value); // TODO: _globalData ou _globalData ???
-   }
-}
-
-
-int CRunBytecode::getIntData(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return _dataStack.getInt(address);
-   } else {
-//      std::cout << "global address: " << address << std::endl;
-      return _globalData.getInt(address);
-   }
-}
-
-
-void CRunBytecode::setStringData(const int &address, const std::string &value)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      _dataStack.setCString(address, value);
-   } else {
-//      std::cout << "setCStringData global address: " << address << std::endl;
-      _globalData.setCString(address, value);
-   }
-}
-
-
-std::string CRunBytecode::getStringData(const int &address)
-{
-   if (IS_LOCAL_ADDRESS(address)) {
-      return _dataStack.getCString(address);
-   } else {
-//      std::cout << "global address: " << address << std::endl;
-      return _globalData.getCString(address);
-   }
-}
-
-
 void CRunBytecode::ssetOpcode()
 {
    invalidOpcode(__FUNCTION__);
@@ -880,7 +946,12 @@
 
 void CRunBytecode::rsetOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("rset opcode");
+
+   int varAddress = _code.fetchInt();
+   int valAddress = _code.fetchInt();
+
+   setRealData(varAddress, getRealData(valAddress));
 }
 
 void CRunBytecode::getaOpcode()
@@ -967,7 +1038,11 @@
 
 void CRunBytecode::poprvOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("poprv opcode");
+
+   int address = _code.fetchInt();
+
+   setRealData(address, _dataStack.popReal());
 }
 
 void CRunBytecode::popmvOpcode()
@@ -1066,7 +1141,9 @@
 {
    trace ("pushrv opcode");
 
-   invalidOpcode(__FUNCTION__);
+   int address = _code.fetchInt();
+
+   _dataStack.pushReal(getRealData(address));
 }
 
 void CRunBytecode::pushmvOpcode()

Modified: trunk/gpt2/gptvm/src/CRunBytecode.hpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-30 13:30:08 UTC (rev 402)
+++ trunk/gpt2/gptvm/src/CRunBytecode.hpp	2007-11-30 15:09:05 UTC (rev 403)
@@ -34,6 +34,8 @@
    void procLeia();
    void setIntData(const int &address, const int &value);
    int  getIntData(const int &address);
+   void setRealData(const int &address, const double &value);
+   double getRealData(const int &address);
    void setStringData(const int &address, const std::string &value);
    std::string getStringData(const int &address);
    // opcodes
@@ -57,7 +59,6 @@
    void idivOpcode();
    void rdivOpcode();
    void imodOpcode();
-   void rmodOpcode();
    void igeOpcode();
    void sgeOpcode();
    void rgeOpcode();

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)



From gpt-commit-noreply at mail.berlios.de  Fri Nov 30 17:04:37 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 30 Nov 2007 17:04:37 +0100
Subject: [gpt-commit] r404 - trunk/gpt2/common/src
Message-ID: <200711301604.lAUG4bew030509@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-30 17:04:36 +0100 (Fri, 30 Nov 2007)
New Revision: 404

Modified:
   trunk/gpt2/common/src/CBinString.cpp
   trunk/gpt2/common/src/CBinString.hpp
Log:
DEVNULL:
* Algumas otimizacoes na classe que le e grava dados binarios


Modified: trunk/gpt2/common/src/CBinString.cpp
===================================================================
--- trunk/gpt2/common/src/CBinString.cpp	2007-11-30 15:09:05 UTC (rev 403)
+++ trunk/gpt2/common/src/CBinString.cpp	2007-11-30 16:04:36 UTC (rev 404)
@@ -5,20 +5,15 @@
 
 void CBinString::writeInt(const int &value)
 {
-   char *byte = (char*)&value;
-
-   for( size_t i = 0; i < sizeof(int); i++) {
-      push_back(*byte);
-      byte++;
-   }
-//   std::cout << "writeInt:" << value << std::endl;
+   resize(size()+sizeof(int));
+   int *result = ((int*)(data()+size()))-1;
+   *result = value;
 }
 
 
 void CBinString::writeByte(const char &value)
 {
-   (*this) += value;
-//   std::cout << "writeByte:" << value << "(" << (int)value << ")" << std::endl;
+   push_back(value);
 }
 
 
@@ -37,29 +32,22 @@
 
 void CBinString::writeBool(const bool &value)
 {
-   char byte = (char)value;
-
-   (*this) += byte;
-//   std::cout << "writeBool:" << value << std::endl;
+   push_back(value);
 }
 
 
 void CBinString::writeReal(const double &value)
 {
-   char *byte = (char*)&value;
-
-   for( size_t i = 0; i < sizeof(double); i++) {
-      push_back(*byte);
-      byte++;
-   }
+   resize(size()+sizeof(double));
+   double *result = ((double*)(data()+size()))-1;
+   *result = value;
 }
 
 
-
 void CBinString::readInt(int &value)
 {
    int result = *((int*)data());
-   erase(0,sizeof(int));
+   erase(0, sizeof(int));
    value = result;
 //   std::cout << "readInt:" << value << std::endl;
 }
@@ -76,7 +64,7 @@
 void CBinString::readReal(double &value)
 {
    double result = *((double*)data());
-   erase(0,sizeof(double));
+   erase(0, sizeof(double));
    value = result;
 }
 
@@ -271,3 +259,14 @@
    return substr(address, pos - address);
 }
 
+
+void CBinString::writeData(const void *value, const size_t &size)
+{
+   const char *byte = (const char*)value;
+
+   for( size_t i = 0; i < size; i++) {
+      push_back(*byte);
+      byte++;
+   }
+}
+

Modified: trunk/gpt2/common/src/CBinString.hpp
===================================================================
--- trunk/gpt2/common/src/CBinString.hpp	2007-11-30 15:09:05 UTC (rev 403)
+++ trunk/gpt2/common/src/CBinString.hpp	2007-11-30 16:04:36 UTC (rev 404)
@@ -41,6 +41,8 @@
    bool removeIfEqual(const std::string &value);
    std::string getCString(const int &address);
    std::string::find;
+private:
+   void writeData(const void *value, const size_t &size);
 };
 
 #endif



From gpt-commit-noreply at mail.berlios.de  Fri Nov 30 19:58:49 2007
From: gpt-commit-noreply at mail.berlios.de (gpt-commit-noreply at mail.berlios.de)
Date: Fri, 30 Nov 2007 19:58:49 +0100
Subject: [gpt-commit] r405 - in trunk/gpt2: common/src gptasm/src
	gptasm/test/wikki gptvm/src gptvm/test/gerados_pelo_gptasm
Message-ID: <200711301858.lAUIwnLO001476@sheep.berlios.de>

Author: alexgarzao
Date: 2007-11-30 19:58:48 +0100 (Fri, 30 Nov 2007)
New Revision: 405

Modified:
   trunk/gpt2/common/src/Tools.cpp
   trunk/gpt2/gptasm/src/CData.cpp
   trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
   trunk/gpt2/gptvm/src/CRunBytecode.cpp
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
   trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
Log:
DEVNULL:
* Suporte a variaveis do tipo string


Modified: trunk/gpt2/common/src/Tools.cpp
===================================================================
--- trunk/gpt2/common/src/Tools.cpp	2007-11-30 16:04:36 UTC (rev 404)
+++ trunk/gpt2/common/src/Tools.cpp	2007-11-30 18:58:48 UTC (rev 405)
@@ -290,6 +290,7 @@
    case CSymbol::REAL:
       return sizeof(double);
    case CSymbol::STRING:
+      return sizeof(char)+sizeof(void*);
    case CSymbol::MATRIX:
       return sizeof(void*);
    }

Modified: trunk/gpt2/gptasm/src/CData.cpp
===================================================================
--- trunk/gpt2/gptasm/src/CData.cpp	2007-11-30 16:04:36 UTC (rev 404)
+++ trunk/gpt2/gptasm/src/CData.cpp	2007-11-30 18:58:48 UTC (rev 405)
@@ -25,6 +25,11 @@
 
    _symbols.push_back(symbol);
 
+   if (type == CSymbol::STRING) {
+      // Para strings constantes e variaveis eh necessario indicar a categoria
+      writeByte(CSymbol::VAR);
+   }
+
    //_data += symbol->getBinary();
    for (int i=0; i < symbol->getTypeSize(); i++) {
       // TODO: horrivel :-)
@@ -43,6 +48,9 @@
 
    //_data += symbol->getBinary();
    if (type == CSymbol::STRING) {
+      // Para strings constantes e variaveis eh necessario indicar a categoria
+      std::cout << "String constante [" << name << "] indicado o tipo..." << std::endl;
+      writeByte(CSymbol::CONST);
       writeString(name, false);
    } else if (type == CSymbol::INT) {
       writeInt(atoi(name.c_str()));

Modified: trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm
===================================================================
--- trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-30 16:04:36 UTC (rev 404)
+++ trunk/gpt2/gptasm/test/wikki/variaveis_4.gasm	2007-11-30 18:58:48 UTC (rev 405)
@@ -6,12 +6,36 @@
     salloc v
 
     sset v, "0"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
     sset v, v
-    ssum v, "10", "10"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
+    ssum v, "12", "34"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
     ssum v, v, v
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
     ssum v, v, "10"
+    pushsv v
+    pushst
+    pushiv 1
+    lcall imprima
+
     ssum v, "10", v
-
     pushsv v
     pushst
     pushiv 1

Modified: trunk/gpt2/gptvm/src/CRunBytecode.cpp
===================================================================
--- trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 16:04:36 UTC (rev 404)
+++ trunk/gpt2/gptvm/src/CRunBytecode.cpp	2007-11-30 18:58:48 UTC (rev 405)
@@ -371,10 +371,21 @@
 void CRunBytecode::setStringData(const int &address, const std::string &value)
 {
    if (IS_LOCAL_ADDRESS(address)) {
-      _dataStack.setCString(address, value);
+      char type = _dataStack.getByte(address);
+
+      if (type == CSymbol::CONST) {
+         _dataStack.setCString(address+1, value);
+      } else {
+         *((std::string*)_dataStack.getInt(address+1)) = value;
+      }
    } else {
-//      std::cout << "setCStringData global address: " << address << std::endl;
-      _globalData.setCString(address, value);
+      char type = _globalData.getByte(address);
+
+      if (type == CSymbol::CONST) {
+         _globalData.setCString(address+1, value);
+      } else {
+         *((std::string*)_globalData.getInt(address+1)) = value;
+      }
    }
 }
 
@@ -382,14 +393,35 @@
 std::string CRunBytecode::getStringData(const int &address)
 {
    if (IS_LOCAL_ADDRESS(address)) {
-      return _dataStack.getCString(address);
+      char type = _dataStack.getByte(address);
+
+      if (type == CSymbol::CONST) {
+         return _dataStack.getCString(address+1);
+      } else {
+         return *((std::string*)_dataStack.getInt(address+1));
+      }
    } else {
-//      std::cout << "global address: " << address << std::endl;
-      return _globalData.getCString(address);
+      char type = _globalData.getByte(address);
+
+      if (type == CSymbol::CONST) {
+         return _globalData.getCString(address+1);
+      } else {
+         return *((std::string*)_globalData.getInt(address+1));
+      }
    }
 }
 
+//std::string CRunBytecode::getStringData(const int &address)
+//{
+//   if (IS_LOCAL_ADDRESS(address)) {
+//      return _dataStack.getCString(address);
+//   } else {
+////      std::cout << "global address: " << address << std::endl;
+//      return _globalData.getCString(address);
+//   }
+//}
 
+
 /////////////
 // opcodes //
 /////////////
@@ -432,6 +464,12 @@
 
    int address = _code.fetchInt();
 
+   if (_globalData[address] != CSymbol::CONST) {
+      error( "Endereco para lcall deve conter uma string constante !!!" );
+   }
+
+   address++;
+
    if (_globalData.getCString(address) == "imprima") {
       procImprima();
    } else if (_globalData.getCString(address) == "leia") {
@@ -492,7 +530,13 @@
 
 void CRunBytecode::ssumOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ssum opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setStringData(varAddress, getStringData(val1Address) + getStringData(val2Address));
 }
 
 void CRunBytecode::rsumOpcode()
@@ -602,7 +646,13 @@
 
 void CRunBytecode::sgeOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sge opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) >= getStringData(val2Address));
 }
 
 void CRunBytecode::rgeOpcode()
@@ -613,7 +663,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) >= getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) >= getRealData(val2Address));
 }
 
 void CRunBytecode::ileOpcode()
@@ -629,7 +679,13 @@
 
 void CRunBytecode::sleOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("ile opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) <= getStringData(val2Address));
 }
 
 void CRunBytecode::rleOpcode()
@@ -640,7 +696,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) <= getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) <= getRealData(val2Address));
 }
 
 void CRunBytecode::ineOpcode()
@@ -656,7 +712,13 @@
 
 void CRunBytecode::sneOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sne opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) != getStringData(val2Address));
 }
 
 void CRunBytecode::rneOpcode()
@@ -667,7 +729,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) != getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) != getRealData(val2Address));
 }
 
 void CRunBytecode::igtOpcode()
@@ -683,7 +745,13 @@
 
 void CRunBytecode::sgtOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sgt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) > getStringData(val2Address));
 }
 
 void CRunBytecode::rgtOpcode()
@@ -694,7 +762,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) > getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) > getRealData(val2Address));
 }
 
 void CRunBytecode::iltOpcode()
@@ -710,7 +778,13 @@
 
 void CRunBytecode::sltOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("slt opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) < getStringData(val2Address));
 }
 
 void CRunBytecode::rltOpcode()
@@ -721,7 +795,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) < getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) < getRealData(val2Address));
 }
 
 void CRunBytecode::ieqOpcode()
@@ -737,7 +811,13 @@
 
 void CRunBytecode::seqOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("seq opcode");
+
+   int varAddress  = _code.fetchInt();
+   int val1Address = _code.fetchInt();
+   int val2Address = _code.fetchInt();
+
+   setIntData(varAddress, getStringData(val1Address) == getStringData(val2Address));
 }
 
 void CRunBytecode::reqOpcode()
@@ -748,7 +828,7 @@
    int val1Address = _code.fetchInt();
    int val2Address = _code.fetchInt();
 
-   setRealData(varAddress, getRealData(val1Address) == getRealData(val2Address));
+   setIntData(varAddress, getRealData(val1Address) == getRealData(val2Address));
 }
 
 void CRunBytecode::orOpcode()
@@ -941,7 +1021,12 @@
 
 void CRunBytecode::ssetOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sset opcode");
+
+   int varAddress = _code.fetchInt();
+   int valAddress = _code.fetchInt();
+
+   setStringData(varAddress, getStringData(valAddress));
 }
 
 void CRunBytecode::rsetOpcode()
@@ -1239,14 +1324,80 @@
 //   _dataStack.resize(_dataStack.getSP());
 }
 
+// TODO: ao inves de termos global e local, quem sabe as globais nao poderiam estar no inicio do que hj sao as locais ?
+// Isso simplificaria e muito a implementacao...
+
 void CRunBytecode::sallocOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("salloc opcode");
+
+   int address = _code.fetchInt();
+
+   if (IS_LOCAL_ADDRESS(address)) {
+      char type = _dataStack.getByte(address);
+
+      if (type != CSymbol::VAR) {
+         error( "salloc apenas com variaveis !!!" );
+      }
+
+//      std::string *vvv = new std::string();
+      std::string *value = new std::string();
+      _dataStack.setInt(address+1, (int)value);
+
+
+//      (std::string*)(_dataStack.data()+address+1) = "aaa";
+//      (std::string*)(_dataStack.data()+address+1) = new std::string;
+//      value =  (std::string*)_dataStack.data()+address+1;
+//      *value = "aaa";
+//      *value = new std::string;
+//
+//
+//      std::string *v = new std::string;
+
+//      int x = 1;
+//      (std::string*)x = v;
+//      *(std::string*)(_dataStack.getInt(address+1)) = v;
+//      *((std::string*)_dataStack.getInt(address+1)) = new std::string("");
+   } else {
+      char type = _globalData.getByte(address);
+
+      if (type != CSymbol::VAR) {
+         error( "salloc apenas com variaveis !!!" );
+      }
+
+      std::string *value = new std::string();
+      _globalData.setInt(address+1, (int)value);
+      //*((std::string*)_globalData.getInt(address+1)) = new std::string("");
+   }
 }
 
 void CRunBytecode::sfreeOpcode()
 {
-   invalidOpcode(__FUNCTION__);
+   trace ("sfree opcode");
+
+   int address = _code.fetchInt();
+
+   if (IS_LOCAL_ADDRESS(address)) {
+      char type = _dataStack.getByte(address);
+
+      if (type != CSymbol::VAR) {
+         error( "sfree apenas com variaveis !!!" );
+      }
+
+      std::string *value = (std::string*)_dataStack.getInt(address+1);
+      delete value;
+      _dataStack.setInt(address+1, 0);
+   } else {
+      char type = _globalData.getByte(address);
+
+      if (type != CSymbol::VAR) {
+         error( "sfree apenas com variaveis !!!" );
+      }
+
+      std::string *value = (std::string*)_globalData.getInt(address+1);
+      delete value;
+      _globalData.setInt(address+1, 0);
+   }
 }
 
 void CRunBytecode::ssetcOpcode()

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_condicionais_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/estruturas_repeticao_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/expressoes_matematicas_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/funcoes_definidas_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/invocando_subrotinas_linguagem_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/procedimentos_definidos_usuario_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_1.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_2.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_3.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_4.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_5.gvm
===================================================================
(Binary files differ)

Modified: trunk/gpt2/gptvm/test/gerados_pelo_gptasm/variaveis_6.gvm
===================================================================
(Binary files differ)



