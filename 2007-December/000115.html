<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-commit] r441 - in trunk/gpt2/gptc: . src src/common	src/gptasm_target src/parser src/semantic src/symboltable test tmp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-commit/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r441%20-%20in%20trunk/gpt2/gptc%3A%20.%20src%20src/common%0A%09src/gptasm_target%20src/parser%20src/semantic%20src/symboltable%20test%20tmp&In-Reply-To=%3C200712190208.lBJ28jFT029671%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000114.html">
   <LINK REL="Next"  HREF="000116.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-commit] r441 - in trunk/gpt2/gptc: . src src/common	src/gptasm_target src/parser src/semantic src/symboltable test tmp</H1>
    <B>gpt-commit-noreply at mail.berlios.de</B> 
    <A HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r441%20-%20in%20trunk/gpt2/gptc%3A%20.%20src%20src/common%0A%09src/gptasm_target%20src/parser%20src/semantic%20src/symboltable%20test%20tmp&In-Reply-To=%3C200712190208.lBJ28jFT029671%40sheep.berlios.de%3E"
       TITLE="[gpt-commit] r441 - in trunk/gpt2/gptc: . src src/common	src/gptasm_target src/parser src/semantic src/symboltable test tmp">gpt-commit-noreply at mail.berlios.de
       </A><BR>
    <I>Wed Dec 19 03:08:45 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000114.html">[gpt-commit] r440 - trunk/gpt2/gptc/test
</A></li>
        <LI>Next message: <A HREF="000116.html">[gpt-commit] r442 - trunk/gpt2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#115">[ date ]</a>
              <a href="thread.html#115">[ thread ]</a>
              <a href="subject.html#115">[ subject ]</a>
              <a href="author.html#115">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: thiago_silva
Date: 2007-12-19 03:08:43 +0100 (Wed, 19 Dec 2007)
New Revision: 441

Added:
   trunk/gpt2/gptc/src/common/
   trunk/gpt2/gptc/src/common/CompilerError.cpp
   trunk/gpt2/gptc/src/common/CompilerError.hpp
   trunk/gpt2/gptc/src/common/Makefile.am
   trunk/gpt2/gptc/src/common/PortugolAST.cpp
   trunk/gpt2/gptc/src/common/PortugolAST.hpp
   trunk/gpt2/gptc/src/gptasm_target/
   trunk/gpt2/gptc/src/gptasm_target/Arguments.cpp
   trunk/gpt2/gptc/src/gptasm_target/Arguments.hpp
   trunk/gpt2/gptc/src/gptasm_target/AsmProgram.cpp
   trunk/gpt2/gptc/src/gptasm_target/AsmProgram.hpp
   trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/gptasm_target/Context.cpp
   trunk/gpt2/gptc/src/gptasm_target/Context.hpp
   trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.cpp
   trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/gptasm_target/Makefile.am
   trunk/gpt2/gptc/src/gptasm_target/Options.hpp
   trunk/gpt2/gptc/src/gptasm_target/Subroutine.cpp
   trunk/gpt2/gptc/src/gptasm_target/Subroutine.hpp
   trunk/gpt2/gptc/src/gptasm_target/TextFile.cpp
   trunk/gpt2/gptc/src/gptasm_target/TextFile.hpp
   trunk/gpt2/gptc/src/gptasm_target/Tools.cpp
   trunk/gpt2/gptc/src/gptasm_target/Tools.hpp
   trunk/gpt2/gptc/src/gptasm_target/gptasm.g
   trunk/gpt2/gptc/src/parser/
   trunk/gpt2/gptc/src/parser/Makefile.am
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/src/parser/lexer.g
   trunk/gpt2/gptc/src/parser/parser.g
   trunk/gpt2/gptc/src/semantic/
   trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/semantic/Makefile.am
   trunk/gpt2/gptc/src/semantic/semantic.g
   trunk/gpt2/gptc/src/symboltable/
   trunk/gpt2/gptc/src/symboltable/Makefile.am
   trunk/gpt2/gptc/src/symboltable/Symbol.cpp
   trunk/gpt2/gptc/src/symboltable/Symbol.hpp
   trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/symboltable/Types.cpp
   trunk/gpt2/gptc/src/symboltable/Types.hpp
Removed:
   trunk/gpt2/gptc/src/Arguments.cpp
   trunk/gpt2/gptc/src/Arguments.hpp
   trunk/gpt2/gptc/src/AsmProgram.cpp
   trunk/gpt2/gptc/src/AsmProgram.hpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
   trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
   trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
   trunk/gpt2/gptc/src/CompilerError.cpp
   trunk/gpt2/gptc/src/CompilerError.hpp
   trunk/gpt2/gptc/src/Context.cpp
   trunk/gpt2/gptc/src/Context.hpp
   trunk/gpt2/gptc/src/GptAsmExpression.cpp
   trunk/gpt2/gptc/src/GptAsmExpression.hpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp
   trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp
   trunk/gpt2/gptc/src/Options.hpp
   trunk/gpt2/gptc/src/PortugolAST.cpp
   trunk/gpt2/gptc/src/PortugolAST.hpp
   trunk/gpt2/gptc/src/Subroutine.cpp
   trunk/gpt2/gptc/src/Subroutine.hpp
   trunk/gpt2/gptc/src/Symbol.cpp
   trunk/gpt2/gptc/src/Symbol.hpp
   trunk/gpt2/gptc/src/SymbolTable.cpp
   trunk/gpt2/gptc/src/SymbolTable.hpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
   trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
   trunk/gpt2/gptc/src/TextFile.cpp
   trunk/gpt2/gptc/src/TextFile.hpp
   trunk/gpt2/gptc/src/Tools.cpp
   trunk/gpt2/gptc/src/Tools.hpp
   trunk/gpt2/gptc/src/Types.cpp
   trunk/gpt2/gptc/src/Types.hpp
   trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp
   trunk/gpt2/gptc/src/UnicodeCharScanner.hpp
   trunk/gpt2/gptc/src/gptasm.g
   trunk/gpt2/gptc/src/lexer.g
   trunk/gpt2/gptc/src/parser.g
   trunk/gpt2/gptc/src/semantic.g
Modified:
   trunk/gpt2/gptc/configure.ac
   trunk/gpt2/gptc/src/Makefile.am
   trunk/gpt2/gptc/test/Makefile.am
   trunk/gpt2/gptc/tmp/tree_teste.gpt
Log:
-Tentando organizar os modulos em diretorios distintos.

Modified: trunk/gpt2/gptc/configure.ac
===================================================================
--- trunk/gpt2/gptc/configure.ac	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/configure.ac	2007-12-19 02:08:43 UTC (rev 441)
@@ -63,8 +63,8 @@
 if test &quot;x${ANTLR_BIN}&quot; = &quot;x&quot;; then
   AC_MSG_ERROR(
   [
-    O programa &quot;antlr&quot; (ou runantlr) n&#195;&#163;o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers&#195;&#163;o &gt;= 2.6) instalado.
+    O programa &quot;antlr&quot; (ou runantlr) n&#195;&#131;&#194;&#163;o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers&#195;&#131;&#194;&#163;o &gt;= 2.6) instalado.
     Baixe em: <A HREF="http://www.antlr.org">http://www.antlr.org</A>
   ])
 fi
@@ -73,8 +73,8 @@
 if test &quot;x${ANTLR_CFG}&quot; = &quot;x&quot;; then
   AC_MSG_ERROR(
   [
-    O programa &quot;antlr-config&quot; n&#195;&#163;o foi encontrado no seu sistema (PATH).
-    GPT precisa do ANTLR (vers&#195;&#163;o &gt;= 2.6) instalado.
+    O programa &quot;antlr-config&quot; n&#195;&#131;&#194;&#163;o foi encontrado no seu sistema (PATH).
+    GPT precisa do ANTLR (vers&#195;&#131;&#194;&#163;o &gt;= 2.6) instalado.
     Baixe em: <A HREF="http://www.antlr.org">http://www.antlr.org</A>
   ])
 fi
@@ -89,5 +89,10 @@
 
 AC_CONFIG_FILES([Makefile
                  src/Makefile
+                 src/common/Makefile
+                 src/parser/Makefile
+                 src/semantic/Makefile
+                 src/symboltable/Makefile
+                 src/gptasm_target/Makefile
                  test/Makefile])
 AC_OUTPUT

Deleted: trunk/gpt2/gptc/src/Arguments.cpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Arguments.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,32 +0,0 @@
-#include &quot;Arguments.hpp&quot;
-
-#include &quot;Tools.hpp&quot;
-
-
-Arguments::Arguments( )
-{
-}
-
-void Arguments::init( Subroutine* subroutine, const string &amp;subroutineName )
-{
-	clear();
-	_subroutine     = subroutine;
-	_subroutineName = subroutineName;
-}
-
-void Arguments::emitMnsInSubroutineCall( )
-{
-	iterator argument;
-
-	bool varArgs = _subroutineName == &quot;imprima&quot;;
-
-	// se for &quot;imprima&quot; empilha o nro de argumentos e o tipo de cada um
-	// por enquanto imprima eh um caso especial, mas nas proximas versoes isso seria corrigido...
-	for( argument = end() - 1; argument &gt;= begin(); argument-- ) {
-		_subroutine-&gt;emitPUSHMn( *argument, varArgs );
-
-	}
-	if (varArgs) {
-		_subroutine-&gt;emit( &quot;push&quot;, itoa( size( ) ) );
-	}
-}

Deleted: trunk/gpt2/gptc/src/Arguments.hpp
===================================================================
--- trunk/gpt2/gptc/src/Arguments.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Arguments.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,24 +0,0 @@
-#ifndef ARGUMENTS_H
-#define ARGUMENTS_H
-
-#include &lt;vector&gt;
-using namespace std;
-
-#include &quot;Subroutine.hpp&quot;
-
-class Arguments : public vector&lt;string&gt; // usar list :-)
-{
-public:
-	Arguments( );
-	void init( Subroutine* subroutine, const string &amp;subroutineName );
-	void emitMnsInSubroutineCall( );
-	void setSubroutineName( const string &amp;_name ) {
-		_subroutineName = _name;
-	}
-private:
-	string _subroutineName;
-	Subroutine *_subroutine;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/AsmProgram.cpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/AsmProgram.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,85 +0,0 @@
-#include &quot;AsmProgram.hpp&quot;
-
-#include &quot;Tools.hpp&quot;
-
-
-AsmProgram::AsmProgram(Options *options)
-	: _options(options), _context(NULL)
-{
-}
-
-void AsmProgram::init()
-{
-	_asmPrg.writeln(&quot;// Programa gerado a partir de &quot; + _options-&gt;filename);
-	_asmPrg.writeln(&quot;program&quot;);
-	_asmPrg.writeln();
-}
-
-void AsmProgram::finish()
-{
-  _asmPrg.writeln();
-	_asmPrg.writeln(&quot;end-program&quot;);
-}
-
-AsmProgram::~AsmProgram()
-{
-}
-
-Subroutine *AsmProgram::initSubroutine(string name)
-{
-	Subroutine *action = new Subroutine(_options, /*_file,*/ name);
-	action-&gt;init();
-
-	return action;
-}
-
-
-void AsmProgram::finishSubroutine(Subroutine *action)
-{
-	action-&gt;finish();
-	_asmPrg.write(action-&gt;getCode());
-	delete action;
-}
-
-
-/*CContext *AsmProgram::addContext()
-{
-	CContext* context = new CContext();
-	_contexts.push(context);
-	_context = context;
-
-	return context;
-}
-
-
-CContext *AsmProgram::remContext()
-{
-	delete _contexts.top();
-	_contexts.pop();
-	if (_contexts.size() &gt; 0) {
-		_context = _contexts.top();
-		return _contexts.top();
-	} else {
-		_context = NULL;
-		return NULL;
-	}
-}
-
-
-CContext *AsmProgram::getContext()
-{
-	return _context;
-}
-*/
-
-void AsmProgram::emitVarDefinition(const string &amp;name, const string &amp;type)
-{
-	_asmPrg.writeln(&quot;var &quot; + name + &quot; &quot; + type);
-}
-
-
-string AsmProgram::getAsm() const
-{
-	return _asmPrg.getText();
-}
-

Deleted: trunk/gpt2/gptc/src/AsmProgram.hpp
===================================================================
--- trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/AsmProgram.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,33 +0,0 @@
-#ifndef ASM_PROGRAM_H
-#define ASM_PROGRAM_H
-
-#include &quot;Context.hpp&quot;
-#include &quot;Options.hpp&quot;
-
-#include &lt;string&gt;
-#include &lt;stack&gt;
-using namespace std;
-
-class AsmProgram
-{
-public:
-	AsmProgram(Options *options);
-	~AsmProgram();
-	void init();
-	void finish();
-	Subroutine *initSubroutine(string name);
-	void finishSubroutine(Subroutine *subroutine);
-	Context *addContext();
-	Context *remContext();
-	Context *getContext();
-	void emitVarDefinition(const string &amp;name, const string&amp; type);
-	string getAsm() const;
-private:
-	Options *_options;
-	Context *_context;
-	stack&lt;Context*&gt; _contexts;
-	TextFile _asmPrg;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,361 +0,0 @@
-#include &quot;BaseGptAsmWalker.hpp&quot;
-
-#include &quot;SymbolTable.hpp&quot;
-#include &quot;Symbol.hpp&quot;
-#include &quot;AsmProgram.hpp&quot;
-#include &quot;Types.hpp&quot;
-#include &quot;GptAsmExpression.hpp&quot;
-
-BaseGptAsmWalker::BaseGptAsmWalker(SymbolTable* symtable,
-                                   const std::string&amp; filepath)
-  : antlr::TreeParser(), _symtable(symtable), _filepath(filepath) {
-
-  _symtable-&gt;setGlobalScope();
-
-  _options.filename = _filepath;
-  _asmPrg = new AsmProgram(&amp;_options);
-
-  _subroutine = _asmPrg-&gt;initSubroutine(&quot;main&quot;);
-}
-
-
-void BaseGptAsmWalker::finishParser() {
-  delete _asmPrg;
-  _asmPrg = NULL;
-}
-
-void BaseGptAsmWalker::declareProgramVars(const std::list&lt;std::string&gt;&amp; ids) {
-  for (std::list&lt;std::string&gt;::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    Symbol symbol = _symtable-&gt;getSymbol(*it);
-    _asmPrg-&gt;emitVarDefinition(symbol.identifier(), symbol.type()-&gt;asmName(true));
-
-    if (symbol.type()-&gt;isMatrix()) {
-      addMatrixInitialization(symbol);
-    }
-  }
-}
-
-void BaseGptAsmWalker::addMatrixInitialization(const Symbol&amp; symbol) {
-  std::list&lt;int&gt; dims = symbol.type()-&gt;dimensions();
-
-  std::stringstream code;
-
-  if (dims.size() == 1) {
-    code &lt;&lt; &quot;m1alloc &quot; &lt;&lt; symbol.identifier()
-            &lt;&lt; &quot;, &quot; &lt;&lt; symbol.type()-&gt;ofType()-&gt;byteSize()
-            &lt;&lt; &quot;, &quot; &lt;&lt; dims.front();
-  } else if(dims.size() == 2) {
-    code &lt;&lt; &quot;m2alloc &quot; &lt;&lt; symbol.identifier()
-            &lt;&lt; &quot;, &quot; &lt;&lt; symbol.type()-&gt;ofType()-&gt;byteSize()
-            &lt;&lt; &quot;, &quot; &lt;&lt; dims.front()
-            &lt;&lt; &quot;, &quot; &lt;&lt; *(dims.rbegin());
-  }
-  _subroutine-&gt;emitAsmCode(code.str());
-}
-
-
-void BaseGptAsmWalker::declareSubroutineVars(const std::list&lt;std::string&gt;&amp; ids) {
-  for (std::list&lt;std::string&gt;::const_iterator it = ids.begin(); it != ids.end(); ++it) {
-    _subroutine-&gt;emitVarDefinition(
-      *it, _symtable-&gt;getSymbol(*it).type());
-  }
-}
-
-void BaseGptAsmWalker::declareParameter(const string&amp; lexeme) {
-  _subroutine-&gt;emitParDefinition(
-    lexeme, _symtable-&gt;getSymbol(lexeme).type());
-}
-
-int BaseGptAsmWalker::getSymbolType(const string&amp; lexeme) {
-  return _symtable-&gt;getSymbol(lexeme).type()-&gt;primitiveType();
-}
-
-// std::string BaseGptAsmWalker::expandOffset(const std::string&amp;, const std::list&lt;std::string&gt;&amp;) {
-  //??TODO
-// }
-
-
-void BaseGptAsmWalker::emitAttribution(const Symbol&amp; lv, const std::string&amp; tmp) {
-  switch (lv.type()-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      _subroutine-&gt;emit(&quot;rset&quot;, lv.identifier(), tmp);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      _subroutine-&gt;emit(&quot;sset&quot;, lv.identifier(), tmp);
-      break;
-    case PortugolTokenTypes::T_INTEIRO:
-    case PortugolTokenTypes::T_LOGICO:
-    case PortugolTokenTypes::T_CARACTERE:
-      _subroutine-&gt;emit(&quot;iset&quot;, lv.identifier(), tmp);
-      break;
-    default:
-      throw;
-  }
-}
-
-
-
-
-
-GptAsmExpression* BaseGptAsmWalker::expr_OU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, &quot;lor&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_E(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, &quot;land&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_OU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, &quot;bor&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_XOU(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, &quot;bxor&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_E(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, optype, &quot;band&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_IGUAL(Type *optype,
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  
-  //lh e rh tem o mesmo tipo
-  switch (left-&gt;restype()-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;req&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;seq&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;ieq&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_DIFERENTE(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  //lh e rh tem o mesmo tipo
-  switch (left-&gt;restype()-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;rne&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;sne&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, left-&gt;restype(), &quot;ine&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIOR(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype())) == NULL) {
-    promType = left-&gt;restype()-&gt;caracOrLit(right-&gt;restype());
-  }
-
-  switch (promType-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, &quot;rgt&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, &quot;sgt&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, promType, &quot;igt&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOR(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype())) == NULL) {
-    promType = left-&gt;restype()-&gt;caracOrLit(right-&gt;restype());
-  }
-
-  switch (promType-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, &quot;rlt&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, &quot;slt&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, promType, &quot;ilt&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIOR_EQ(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype())) == NULL) {
-    promType = left-&gt;restype()-&gt;caracOrLit(right-&gt;restype());
-  }
-
-  switch (promType-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, &quot;rge&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, &quot;sge&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, promType, &quot;ige&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOR_EQ(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  Type *promType;
-  if ((promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype())) == NULL) {
-    promType = left-&gt;restype()-&gt;caracOrLit(right-&gt;restype());
-  }
-
-  switch (promType-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, &quot;rle&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, &quot;sle&quot;, left, right);
-      break;
-    default: //inteiro, l&#243;gico, caractere
-      return new GptAsmExpression(optype, promType, &quot;ile&quot;, left, right);
-      break;
-  }
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_LEFT(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left-&gt;restype(), &quot;bshl&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_SHIFT_RIGHT(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left-&gt;restype(), &quot;bshr&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MAIS(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType;
-  if ((promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype())) == NULL) {
-    promType = left-&gt;restype()-&gt;caracOrLit(right-&gt;restype());
-  }
-
-  switch (optype-&gt;primitiveType()) {
-    case PortugolTokenTypes::T_INTEIRO:
-      return new GptAsmExpression(optype, promType, &quot;isum&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_REAL:
-      return new GptAsmExpression(optype, promType, &quot;rsum&quot;, left, right);
-      break;
-    case PortugolTokenTypes::T_LITERAL:
-      return new GptAsmExpression(optype, promType, &quot;ssum&quot;, left, right);
-      break;
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MENOS(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype());
-
-  if (optype-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, &quot;isub&quot;, left, right);
-  } else if (optype-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, &quot;rsub&quot;, left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_DIV(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype());
-
-  if (optype-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, &quot;idiv&quot;, left, right);
-  } else if (optype-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, &quot;rdiv&quot;, left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MULTIP(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-
-  Type *promType = left-&gt;restype()-&gt;intOrReal(right-&gt;restype());
-
-  if (optype-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, promType, &quot;imul&quot;, left, right);
-  } else if (optype-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, promType, &quot;rmul&quot;, left, right);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_MOD(Type *optype, 
-                                            GptAsmExpression* left, 
-                                            GptAsmExpression* right) {
-  return new GptAsmExpression(optype, left-&gt;restype(), &quot;imod&quot;, left, right);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_NEGATIVO(Type *optype, 
-                                            GptAsmExpression* term) {
-
-  if (optype-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return new GptAsmExpression(optype, term-&gt;restype(), &quot;inet&quot;, term);
-  } else if (optype-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return new GptAsmExpression(optype, term-&gt;restype(), &quot;rneg&quot;, term);
-  }
-  throw;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_POSITIVO(Type*,GptAsmExpression* term) {
-  return term;
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_UN_NAO(Type* optype,GptAsmExpression* term) {
-  return new GptAsmExpression(optype, term-&gt;restype(), &quot;not&quot;, term);
-}
-
-GptAsmExpression* BaseGptAsmWalker::expr_BIT_NAO(Type* optype,GptAsmExpression* term) {
-  return new GptAsmExpression(optype, term-&gt;restype(), &quot;bnot&quot;, term);
-}
-
-std::string BaseGptAsmWalker::getCode() {
-  return _asmPrg-&gt;getAsm();
-}
-

Deleted: trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,73 +0,0 @@
-#ifndef BASEGPTASMWALKER_HPP
-#define BASEGPTASMWALKER_HPP
-
-#include &lt;antlr/TreeParser.hpp&gt;
-#include &lt;string&gt;
-#include &lt;list&gt;
-
-#include &quot;Options.hpp&quot;
-
-class SymbolTable;
-class Symbol;
-class AsmProgram;
-class Subroutine;
-class GptAsmExpression;
-class Type;
-
-class BaseGptAsmWalker : public antlr::TreeParser {
-public:
-  BaseGptAsmWalker(SymbolTable*, const std::string&amp;);
-
-  std::string getCode();
-
-protected:
-  void finishParser();
-  void declareProgramVars(const std::list&lt;std::string&gt;&amp;);
-  void declareSubroutineVars(const std::list&lt;std::string&gt;&amp;);
-  void declareParameter(const string&amp;);
-  int getSymbolType(const string&amp;);
-
-  void addMatrixInitialization(const Symbol&amp; symbol);
-
-//   std::string expandOffset(const std::string&amp;, const std::list&lt;std::string&gt;&amp;);
-
-  void emitAttribution(const Symbol&amp;, const std::string&amp;);
-
-  GptAsmExpression* expr_OU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_E(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_OU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_XOU(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_E(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_IGUAL(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_DIFERENTE(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIOR(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOR(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOR_EQ(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_SHIFT_LEFT(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_BIT_SHIFT_RIGHT(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MAIS(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MENOS(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_DIV(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MULTIP(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_MOD(Type*, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression* expr_UN_NEGATIVO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_UN_POSITIVO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_UN_NAO(Type*,GptAsmExpression*);
-  GptAsmExpression* expr_BIT_NAO(Type*,GptAsmExpression*);
-
-//   void declareGlobals(const IDList&amp;);
-//   void addPrologue(code);
-//   void initStructMembers(const string&amp;, const IDList&amp;, code);
-
-//   std::string getAsmType(const std::string&amp;);
-
-  SymbolTable                 *_symtable;
-  std::string                  _filepath;
-
-  Options         _options;
-  AsmProgram      *_asmPrg;
-  Subroutine      *_subroutine;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/BaseSemanticWalker.cpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,1005 +0,0 @@
-
-#include &quot;BaseSemanticWalker.hpp&quot;
-#include &quot;PortugolTokenTypes.hpp&quot;
-#include &quot;SymbolTable.hpp&quot;
-#include &quot;Symbol.hpp&quot;
-#include &quot;Types.hpp&quot;
-#include &quot;SymbolTableExceptions.hpp&quot;
-
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-#include &lt;fstream&gt;
-
-bool InitMatrixList::hasUniformDimensions() const {
-  const_iterator it;
-  int d = -1;
-  for (it = begin(); it != end(); ++it) {
-    if (d == -1) {
-      d = (*it).first;
-    } else if (d != (*it).first) {
-      return false;
-    }
-  }
-  return true;
-}
-
-Type* InitMatrixList::elementsDivergeFrom(Type* from) const {
-  if (from-&gt;isError()) {
-    return NULL;
-  }
-
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    if (!(*it).second-&gt;isError() &amp;&amp; !from-&gt;attrPromotion((*it).second)) {
-      return (*it).second;
-    }
-  }
-  return NULL;
-}
-
-Type* InitMatrixList::evaluatedElementType(Type* from) const {
-  const_iterator it;
-  Type *ret = from;
-  for (it = begin(); it != end(); ++it) {
-    if (!(*it).second-&gt;isError()) {
-      ret = ret-&gt;attrPromotion((*it).second);
-    }
-  }
-  return ret;
-}
-
-int InitMatrixList::divergentDimensionFrom(int d) const {
-  const_iterator it;
-  for (it = begin(); it != end(); it++) {
-    if (d == (*it).first) {
-      return d;
-    }
-  }
-  return -1;
-}
-
-int InitMatrixList::dimensions() const {
-  return back().first;
-}
-
-/////////////////////////////////////////////////////////////////////
-
-
-
-BaseSemanticWalker::BaseSemanticWalker(SymbolTable* symtable,
-                                       const std::string&amp; filepath)
- : antlr::TreeParser(),
-  _symtable(symtable),
-  _typeBuilder(symtable-&gt;typeBuilder()),
-  _filepath(filepath) {
-
-  buildSourceLines();
-}
-
-void BaseSemanticWalker::buildSourceLines() {
-  std::ifstream fi(_filepath.c_str());
-  std::string line;
-  while (!fi.eof()) {
-    getline(fi, line);
-    _sourcelines.push_back(line);
-  }
-}
-
-void BaseSemanticWalker::useLib(const std::string&amp; lib) {
-  std::cerr &lt;&lt; &quot;Using &quot; &lt;&lt; lib &lt;&lt; std::endl;
-}
-
-Type* BaseSemanticWalker::getStructType(RefPortugolAST node) {
-  try {
-    return _symtable-&gt;getType(node-&gt;getText());
-  } catch (UndeclaredTypeException e) {
-    report(node-&gt;getLine(), node-&gt;getColumn(),
-           std::string(&quot;tipo indefinido: &quot;) + node-&gt;getText());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-Type* BaseSemanticWalker::getSymbolType(RefPortugolAST node) {
-  try {
-    return
-      _symtable-&gt;getSymbol(node-&gt;getText()).type();
-  } catch (UndeclaredSymbolException e) {
-    report(node-&gt;getLine(), node-&gt;getColumn(),
-           std::string(&quot;s&#237;mbolo n&#227;o declarado: &quot;) + node-&gt;getText());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-Type* BaseSemanticWalker::getSymbolType(RefPortugolAST parent,
-                                        Type* sttype, RefPortugolAST id) {
-  if (sttype-&gt;isError()) {
-    return sttype;
-  }
-
-  if (!sttype-&gt;isStruct()) {
-    report(id-&gt;getLine(), id-&gt;getColumn(), 
-      std::string(&quot;'&quot;) + parent-&gt;getText() + &quot;' n&#227;o &#233; uma estrutura&quot;);
-    return _typeBuilder-&gt;errorType();
-  }
-
-  SymbolList::const_iterator it =
-      sttype-&gt;fields().findFirstByLexeme(id-&gt;getText());
-
-  if (it == sttype-&gt;fields().end()) {
-    report(id-&gt;getLine(), id-&gt;getColumn(),
-        std::string(&quot;estrutura '&quot;)  + 
-        sttype-&gt;name() + &quot;' n&#227;o possui membro '&quot; + id-&gt;getText() + &quot;'&quot;);
-    return _typeBuilder-&gt;errorType();
-  }
-
-  return (*it).type();
-}
-
-
-void BaseSemanticWalker::setCurrentScope(RefPortugolAST id, 
-                                         const SymbolList&amp; params) {
-  _currentScopeSymbol = 
-      _symtable-&gt;getSymbol(id-&gt;getText(), params.typeList());
-
-  _symtable-&gt;setScope(_currentScopeSymbol);
-}
-
-void
-BaseSemanticWalker::checkMatrixDimensions(RefPortugolAST m, 
-                                          const std::list&lt;int&gt;&amp; dimensions) {
-  if (dimensions.size() &gt; 2) {
-    report(m-&gt;getLine(), m-&gt;getColumn(), 
-      &quot;matrizes com mais de 2 dimens&#245;es n&#227;o s&#227;o suportadas&quot;);
-  }
-
-  bool found_null = false;
-  std::list&lt;int&gt;::const_iterator it = dimensions.begin();
-  for (; it != dimensions.end(); ++it) {
-    if (*it == 0) {
-      found_null = true;
-    } else if (found_null) {
-      report(m-&gt;getLine(), m-&gt;getColumn(), 
-        &quot;somente as &#250;ltimas dimens&#245;es podem ter o tamanho omitido&quot;);
-    }
-  }
-}
-
-Type* BaseSemanticWalker::evalMatrixSubscript(RefPortugolAST id, Type* type,
-                                              int dimensions) {
-
-  if (type-&gt;isError()) {
-    return type;
-  }
-
-  if (type-&gt;isMatrix() &amp;&amp; (type-&gt;dimensions().size() &gt;= (unsigned int) dimensions)) {
-    return type-&gt;evalTypeFromSubscript(dimensions);
-  } else if (type-&gt;isMatrix()) {
-    std::stringstream s;
-    s &lt;&lt; id-&gt;getText() 
-    &lt;&lt; &quot; tem &quot; &lt;&lt; type-&gt;dimensions().size() 
-    &lt;&lt; &quot; dimens&#245;es&quot;; //dimens&#227;o / dimens&#245;es
-    report(id-&gt;getLine(), id-&gt;getColumn(), s.str());
-  } else {
-    report(id-&gt;getLine(), id-&gt;getColumn(), &quot;'&quot; + id-&gt;getText() + &quot;' n&#227;o &#233; uma matriz&quot;);
-  }
-  return _typeBuilder-&gt;errorType();
-}
-
-void  BaseSemanticWalker::evalMatrixSubscriptType(RefPortugolAST exp,Type* type) {
-  if (type-&gt;isError()) {
-    return;
-  }
-
-  if (!type-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    report(exp-&gt;getLine(), exp-&gt;getColumn(), 
-      &quot;subscrito da matriz deve ser do tipo inteiro. Encontrado tipo &quot; + type-&gt;name());
-  }
-}
-
-void BaseSemanticWalker::declare(const IDList&amp; ids, Type* type) {
-  IDList::const_iterator it;
-  for (it = ids.begin(); it != ids.end(); ++it) {
-    try {
-      _symtable-&gt;insertSymbol(
-        Symbol((*it)-&gt;getText(),
-              type,
-              _symtable-&gt;currentScope(),
-              _symtable-&gt;unit(),
-              (*it)-&gt;getLine(),
-              (*it)-&gt;getColumn()));
-    } catch (RedeclarationException e) {
-      report((*it)-&gt;getLine(), (*it)-&gt;getColumn(),
-            std::string(&quot;redeclara&#231;&#227;o: &quot;) + e.symbol().lexeme());
-    }
-  }
-}
-
-void BaseSemanticWalker::declareProc(RefPortugolAST id,
-                                     SymbolList&amp; params) {
-
-  Type *type = 
-    _typeBuilder-&gt;subprogramType(
-        params.typeList(), 
-        _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_NULO));
-
-  Symbol s(id-&gt;getText(),
-            type,
-            _symtable-&gt;globalScope(),
-            _symtable-&gt;unit(),
-            id-&gt;getLine(),
-            id-&gt;getColumn());
-
-  declareProc(s, params);
-}
-
-void BaseSemanticWalker::declareProc(RefPortugolAST id,
-                                     SymbolList&amp; params,
-                                     Type *rettype) {
-
-  Type *type = _typeBuilder-&gt;subprogramType(params.typeList(), rettype);
-
-  Symbol s(id-&gt;getText(),
-            type,
-            _symtable-&gt;globalScope(),
-            _symtable-&gt;unit(),
-            id-&gt;getLine(),
-            id-&gt;getColumn());
-
-  declareProc(s, params);
-
-}
-
-void BaseSemanticWalker::declareProc(const Symbol&amp; s, 
-                                     SymbolList&amp; params) {
-  try {
-    _symtable-&gt;insertSymbol(s);
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-           std::string(&quot;redeclara&#231;&#227;o: &quot;) + e.symbol().lexeme());
-    _symtable-&gt;setIgnoreScope();
-    return;
-  }  
-
-  _symtable-&gt;setScope(s);
-  params.setScope(s.identifier());
-
-  try {
-    _symtable-&gt;insertSymbols(params);
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-           std::string(&quot;redeclara&#231;&#227;o: &quot;) + e.symbol().lexeme());
-  }  
-}
-
-void BaseSemanticWalker::declareStruct(RefPortugolAST id,
-                                       const SymbolList&amp; fieldList) {
-
-  try {
-    _symtable-&gt;insertType(id-&gt;getText(), fieldList, id-&gt;getLine());
-  } catch (RedefinedTypeException e) {
-    report(id-&gt;getLine(), id-&gt;getColumn(), 
-        std::string(&quot;redefini&#231;&#227;o do tipo '&quot;) + e.typeName() + &quot;'&quot;);
-  } catch (RedeclarationException e) {
-    report(e.symbol().line(), e.symbol().column(),
-        std::string(&quot;redeclara&#231;&#227;o: &quot;) + e.symbol().lexeme());
-  }
-}
-
-Type* BaseSemanticWalker::evalInitStruct(const InitStructList&amp; stc) {
-  SymbolList flist;
-  InitStructList::const_iterator it;
-  for (it = stc.begin(); it != stc.end(); ++it) {
-    flist.push_back(Symbol(it-&gt;first-&gt;getText(), 
-                    it-&gt;second, 
-                    _symtable-&gt;globalScope(), 
-                    _symtable-&gt;unit(),
-                    it-&gt;first-&gt;getLine(),
-                    it-&gt;first-&gt;getColumn()));
-  }
-  return _typeBuilder-&gt;structType(flist);
-}
-
-Type* BaseSemanticWalker::evalInitMatrix(RefPortugolAST node, const InitMatrixList&amp; mtx) {
-  if (!mtx.hasUniformDimensions()) {
-    std::stringstream s;
-    s &lt;&lt; &quot;valores da matriz n&#227;o podem ter dimens&#245;es diferentes&quot;;
-
-    report(node-&gt;getLine(), node-&gt;getColumn(), s.str());
-    return _typeBuilder-&gt;errorType();
-  }
-
-
-  Type *ptype = mtx.front().second;
-  Type *dtype;
-  if (dtype = mtx.elementsDivergeFrom(ptype)) {
-    report(node-&gt;getLine(), node-&gt;getColumn(), 
-                 std::string(&quot;matriz heterogenea: &quot;)
-                 + ptype-&gt;name()
-                 + &quot; e &quot;
-                 + dtype-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-
-  Type *ret = _typeBuilder-&gt;matrixType(
-        mtx.evaluatedElementType(ptype), mtx.dimensions());
-
-  return ret;
-}
-
-
-
-void BaseSemanticWalker::evalAttribution(RefPortugolAST lastId,
-                                         Type* ltype, Type* rtype) {
-  if (ltype-&gt;isError() || rtype-&gt;isError()) {
-    return;
-  }
-
-  if (!ltype-&gt;isLValueFor(rtype)) {
-    report(lastId-&gt;getLine(), lastId-&gt;getColumn(),
-            string(&quot;vari&#225;vel do tipo '&quot;) + ltype-&gt;name()
-            + &quot;' n&#227;o pode receber valor do tipo '&quot; + rtype-&gt;name() + &quot;'&quot;);
-  }
-}
-
-void BaseSemanticWalker::evalAttribution(const ExpressionReturn&amp; l,
-                                         const ExpressionReturn&amp; r) {
-  if (l.second-&gt;isError() || r.second-&gt;isError()) {
-    return;
-  }
-
-  if (!l.second-&gt;isLValueFor(r.second)) {
-    report(r.first-&gt;getLine(), r.first-&gt;getColumn(),
-            &quot;vari&#225;vel do tipo '&quot; + l.second-&gt;name()
-            + &quot;' n&#227;o pode receber valor do tipo '&quot; + r.second-&gt;name() + &quot;'&quot;);
-  }
-}
-
-Type* BaseSemanticWalker::evalCall(RefPortugolAST id,
-                                   const TypeList&amp; paramTypes) {
-  //TODO
-  //-proibicao de consts passados para parametros &quot;ref&quot; sem constness
-
-// - Testar avaliacao de chamada de subprogramas (com e sem reticencias)
-//   -Avaliacao de qtd e tipos de parametros
-
-  if (paramTypes.hasErrorType()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  try {
-    return 
-      _symtable-&gt;getSymbol(id-&gt;getText(), paramTypes).type()-&gt;returnType();
-  } catch (UndeclaredSymbolException e) {
-    report(id-&gt;getLine(), id-&gt;getColumn(), 
-        &quot;fun&#231;&#227;o n&#227;o encontrada: '&quot; + id-&gt;getText() + &quot;'&quot;);
-    return _typeBuilder-&gt;errorType();
-  } catch (UnmatchedException e) {
-    report(id-&gt;getLine(), id-&gt;getColumn(),
-           &quot;Fun&#231;&#227;o compat&#237;vel com '&quot; + id-&gt;getText() 
-           + &quot;(&quot; + paramTypes.toString() + &quot;)' n&#227;o encontrada&quot;);
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-void BaseSemanticWalker::evalRetorne(RefPortugolAST ret,Type* type) {
-  if (type-&gt;isError()) {
-    return;
-  }
-
-  if (_symtable-&gt;isInGlobalScope()) {
-    report(ret-&gt;getLine(), ret-&gt;getColumn(), 
-        &quot;n&#227;o h&#225; retorno em escopo global&quot;);
-  } else if(!_currentScopeSymbol.type()-&gt;returnType()-&gt;isLValueFor(type)) {
-    report(ret-&gt;getLine(), ret-&gt;getColumn(), &quot;tipo de retorno (&quot; 
-           + type-&gt;name() + &quot;) incompat&#237;vel com tipo da fun&#231;&#227;o (&quot; 
-           + _currentScopeSymbol.type()-&gt;returnType()-&gt;name() +&quot;)&quot;);
-  }
-}
-
-
-void BaseSemanticWalker::evalCondicional(const ExpressionReturn&amp; ex) {
-  if (ex.second-&gt;isError()) {
-    return;
-  }
-
-  if (!ex.second-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-    report(ex.first-&gt;getLine(), ex.first-&gt;getColumn(),
-      &quot;enunciado exige express&#227;o l&#243;gica. Tipo '&quot; 
-      + ex.second-&gt;name() + &quot;' encontrado.&quot;);
-  }
-}
-
-/************************ EXPR ********************************************/
-
-  //TODO: refatorar os copy/pastes dos metodos evalExpr
-
-Type*
-BaseSemanticWalker::evalExpr_OU(RefPortugolAST op,Type* left, Type* right) {
-
-//l&#243;gico ou l&#243;gico --&gt; l&#243;gico
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(), 
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; ou &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-Type*
-BaseSemanticWalker::evalExpr_E(RefPortugolAST op,Type* left, Type* right) {
-
-//l&#243;gico e l&#243;gico --&gt; l&#243;gico
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(), 
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; e &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_OU(RefPortugolAST op,Type* left, Type* right) {
-
-//inteiro | inteiro --&gt; inteiro
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(), 
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; | &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_OUX(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro ^ inteiro --&gt; inteiro
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; ^ &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_E(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro &amp; inteiro --&gt; inteiro
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &amp; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_IGUAL(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro = inteiro --&gt; l&#243;gico
-    * real = real --&gt; l&#243;gico
-    * caractere = caractere --&gt; l&#243;gico
-    * literal = literal --&gt; l&#243;gico
-    * l&#243;gico = l&#243;gico --&gt; l&#243;gico 
-*/
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;isPrimitive() &amp;&amp; 
-      !left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-      left-&gt;equals(right)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; = &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_DIFERENTE(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro &lt;&gt; inteiro --&gt; l&#243;gico
-    * real &lt;&gt; real --&gt; l&#243;gico
-    * caractere &lt;&gt; caractere --&gt; l&#243;gico
-    * literal &lt;&gt; literal --&gt; l&#243;gico
-    * l&#243;gico &lt;&gt; l&#243;gico --&gt; l&#243;gico 
-*/
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;isPrimitive() &amp;&amp; 
-      !left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-      left-&gt;equals(right)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt;&gt; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIOR(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro &gt; inteiro --&gt; l&#243;gico
-    * real &gt; real --&gt; l&#243;gico
-    * caractere &gt; caractere --&gt; l&#243;gico 
-    * literal &gt; literal --&gt; l&#243;gico 
-
-    * inteiro &gt; real --&gt; l&#243;gico
-    * real &gt; inteiro --&gt; l&#243;gico 
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if ((left-&gt;isPrimitive() &amp;&amp; right-&gt;isPrimitive()) &amp;&amp;
-          (left-&gt;equals(right) || 
-           left-&gt;intOrReal(right) || 
-           left-&gt;caracOrLit(right))) {
-
-    if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt; &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-  
-    if (left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt; &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOR(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro &lt; inteiro --&gt; l&#243;gico
-    * real &lt; real --&gt; l&#243;gico
-    * caractere &lt; caractere --&gt; l&#243;gico 
-    * literal &lt; literal --&gt; l&#243;gico 
-
-    * inteiro &lt; real --&gt; l&#243;gico
-    * real &lt; inteiro --&gt; l&#243;gico 
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if ((left-&gt;isPrimitive() &amp;&amp; right-&gt;isPrimitive()) &amp;&amp;
-      (left-&gt;equals(right) || left-&gt;intOrReal(right))) {
-
-    if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt; &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-  
-    if (left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt; &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIOR_EQ(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro &gt;= inteiro --&gt; l&#243;gico
-    * real &gt;= real --&gt; l&#243;gico
-    * caractere &gt;= caractere --&gt; l&#243;gico 
-    * literal &gt;= literal --&gt; l&#243;gico 
-
-    * inteiro &gt;= real --&gt; l&#243;gico
-    * real &gt;= inteiro --&gt; l&#243;gico 
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if ((left-&gt;isPrimitive() &amp;&amp; right-&gt;isPrimitive()) &amp;&amp;
-      (left-&gt;equals(right) || left-&gt;intOrReal(right))) {
-
-    if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt;= &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-  
-    if (left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt;= &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt;= &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOR_EQ(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro &lt;= inteiro --&gt; l&#243;gico
-    * real &lt;= real --&gt; l&#243;gico
-    * caractere &lt;= caractere --&gt; l&#243;gico 
-    * literal &lt;= literal --&gt; l&#243;gico 
-
-    * inteiro &gt;= real --&gt; l&#243;gico
-    * real &gt;= inteiro --&gt; l&#243;gico 
-*/
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if ((left-&gt;isPrimitive() &amp;&amp; right-&gt;isPrimitive()) &amp;&amp;
-      (left-&gt;equals(right) || left-&gt;intOrReal(right))) {
-
-    if (left-&gt;equals(PortugolTokenTypes::T_LOGICO) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt;= &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-  
-    if (left-&gt;equals(PortugolTokenTypes::T_CORINGA) &amp;&amp; 
-        right-&gt;equals(PortugolTokenTypes::T_CORINGA)) {
-      report(op-&gt;getLine(), op-&gt;getColumn(),
-        std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt;= &quot; + right-&gt;name());
-      return _typeBuilder-&gt;errorType();
-    }
-
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt;= &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_LEFT(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro &lt;&lt; inteiro --&gt; inteiro
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &lt;&lt; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro &gt;&gt; inteiro --&gt; inteiro
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; &gt;&gt; &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MAIS(RefPortugolAST op, Type* left, Type* right) {
-
-/*
-    * inteiro + inteiro --&gt; inteiro
-    * real + real --&gt; real 
-
-    * inteiro + real --&gt; real
-    * real + inteiro --&gt; real
-
-
-    * literal + literal --&gt; literal
-    * caractere + caractere --&gt; literal
-    * literal + caractere --&gt; literal
-    * caractere + literal --&gt; literal 
-
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  Type* ret;
-  if (ret = left-&gt;intOrReal(right)) {
-    //int ou real
-    return ret; 
-  } else if (left-&gt;caracOrLit(right)) {
-    //sempre literal
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LITERAL);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; + &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MENOS(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro - inteiro --&gt; inteiro
-    * real - real --&gt; real 
-
-    * inteiro - real --&gt; real
-    * real - inteiro --&gt; real 
-*/
-
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  Type* ret;
-  if (ret = left-&gt;intOrReal(right)) {
-    return ret;
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; - &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_DIV(RefPortugolAST op, Type* left, Type* right) {
-/*
-    * inteiro / inteiro --&gt; inteiro
-    * real / real --&gt; real 
-
-    * inteiro / real --&gt; real
-    * real / inteiro --&gt; real 
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  Type* ret;
-  if (ret = left-&gt;intOrReal(right)) {
-    return ret;
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; / &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MULTIP(RefPortugolAST op, Type* left, Type* right) {
-
-/*
-    * inteiro * inteiro --&gt; inteiro
-    * real * real --&gt; real 
-
-    * inteiro * real --&gt; real
-    * real * inteiro --&gt; real 
-*/
-  if (left-&gt;isError() || right-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  Type* ret;
-  if (ret = left-&gt;intOrReal(right)) {
-    return ret;
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; * &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_MOD(RefPortugolAST op, Type* left, Type* right) {
-
-//inteiro % inteiro --&gt; inteiro
-
-  if (left-&gt;equals(PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      right-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + left-&gt;name() + &quot; % &quot; + right-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-
-Type*
-BaseSemanticWalker::evalExpr_UN_NEGATIVO(RefPortugolAST op, Type* term) {
-/*
-    * - inteiro --&gt; inteiro
-    * - real --&gt; real 
-*/
-  if (term-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (term-&gt;equals(PortugolTokenTypes::T_INTEIRO) ||
-      term-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder-&gt;primitiveType(term-&gt;primitiveType());
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + &quot; - &quot; + term-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_UN_POSITIVO(RefPortugolAST op, Type* term) {
-/*
-    * + inteiro --&gt; inteiro
-    * + real --&gt; real 
-*/
-  if (term-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (term-&gt;equals(PortugolTokenTypes::T_INTEIRO) ||
-      term-&gt;equals(PortugolTokenTypes::T_REAL)) {
-    return _typeBuilder-&gt;primitiveType(term-&gt;primitiveType());
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + &quot; + &quot; + term-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_NAO(RefPortugolAST op, Type* term) {
-
-//n&#227;o l&#243;gico --&gt; l&#243;gico
-
-  if (term-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (term-&gt;equals(PortugolTokenTypes::T_LOGICO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_LOGICO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(), 
-      std::string(&quot;ilegal: &quot;) + &quot; n&#227;o &quot; + term-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-Type*
-BaseSemanticWalker::evalExpr_BIT_NAO(RefPortugolAST op, Type* term) {
-
-//~ inteiro --&gt; inteiro
-
-  if (term-&gt;isError()) {
-    return _typeBuilder-&gt;errorType();
-  }
-
-  if (term-&gt;equals(PortugolTokenTypes::T_INTEIRO)) {
-    return _typeBuilder-&gt;primitiveType(PortugolTokenTypes::T_INTEIRO);
-  } else {
-    report(op-&gt;getLine(), op-&gt;getColumn(),
-      std::string(&quot;ilegal: &quot;) + &quot; ~ &quot; + term-&gt;name());
-    return _typeBuilder-&gt;errorType();
-  }
-}
-
-
-/********************************************************************/
-
-
-using std::cerr;
-using std::endl;
-
-void BaseSemanticWalker::report(int line, int col, const std::string&amp; msg) {
-  //&lt;file&gt;:&lt;line&gt;: &lt;message&gt;
-  //.............&lt;source code&gt;
-  //...................^
-
-  std::string space = &quot;                &quot;;
-  std::cerr &lt;&lt; _filepath &lt;&lt; &quot;:&quot; &lt;&lt; line &lt;&lt; &quot;: &quot; &lt;&lt; msg &lt;&lt; std::endl;
-  std::cerr &lt;&lt; space &lt;&lt; _sourcelines.at(line-1) &lt;&lt; std::endl;
-
-  for (unsigned int i = 1; i &lt; col + space.length(); i++) {
-    std::cerr &lt;&lt; &quot; &quot;;
-  }
-  std::cerr &lt;&lt; &quot;^&quot; &lt;&lt; std::endl;
-}
-
-void BaseSemanticWalker::report(int line, const std::string&amp; s) {
-  cerr &lt;&lt; &quot;linha &quot; &lt;&lt; line &lt;&lt; &quot; - &quot; &lt;&lt; s &lt;&lt; endl;
-}

Deleted: trunk/gpt2/gptc/src/BaseSemanticWalker.hpp
===================================================================
--- trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/BaseSemanticWalker.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,133 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef BASESEMANTICWALKER_H
-#define BASESEMANTICWALKER_H
-
-#include &lt;antlr/TreeParser.hpp&gt;
-#include &lt;list&gt;
-#include &lt;vector&gt;
-#include &lt;string&gt;
-
-#include &quot;PortugolAST.hpp&quot;
-#include &quot;Symbol.hpp&quot;
-
-class SymbolTable;
-class Type;
-class TypeList;
-class TypeBuilder;
-
-typedef std::list&lt;RefPortugolAST&gt;                IDList;
-
-//list&lt;pair&lt;field, type&gt;&gt;
-typedef std::list&lt;std::pair&lt;RefPortugolAST,Type*&gt; &gt; InitStructList;
-
-typedef std::pair&lt;RefPortugolAST,Type*&gt;  ExpressionReturn;
-
-//list&lt;pair&lt;dimsize,type&gt;&gt;
-class InitMatrixList : public std::list&lt;std::pair&lt;int,Type*&gt; &gt; {
-public:
-  bool              hasUniformDimensions() const;
-  Type*             elementsDivergeFrom(Type*) const;
-  Type*             evaluatedElementType(Type* from) const;
-  int               divergentDimensionFrom(int) const;
-  int               dimensions() const;
-};
-
-class BaseSemanticWalker : public antlr::TreeParser {
-
-public:
-  BaseSemanticWalker(SymbolTable*, const std::string&amp;);
-
-protected:
-  void useLib(const std::string&amp;);
-
-  Type* getStructType(RefPortugolAST);
-
-  Type* getSymbolType(RefPortugolAST);
-
-  Type* getSymbolType(RefPortugolAST,Type*, RefPortugolAST);
-
-  void setCurrentScope(RefPortugolAST id, const SymbolList&amp; params);
-
-  void declare(const IDList&amp;, Type*);
-
-  void declareProc(RefPortugolAST, SymbolList&amp;);
-  void declareProc(RefPortugolAST, SymbolList&amp;, Type*);
-  void declareProc(const Symbol&amp;,  SymbolList&amp;);
-
-//   void defineStruct(RefPortugolAST, const SymbolList&amp;);
-  void declareStruct(RefPortugolAST, const SymbolList&amp; );
-
-
-  void checkMatrixDimensions(RefPortugolAST, const std::list&lt;int&gt;&amp;);
-
-  Type* evalInitStruct(const InitStructList&amp; stc);
-  Type* evalInitMatrix(RefPortugolAST, const InitMatrixList&amp; mtx);
-  
-  Type* evalMatrixSubscript(RefPortugolAST, Type*, int);
-  void  evalMatrixSubscriptType(RefPortugolAST,Type*);
-
-  void evalAttribution(RefPortugolAST,Type*, Type*);
-  void evalAttribution(const ExpressionReturn&amp;, const ExpressionReturn&amp;);
-
-  Type* evalCall(RefPortugolAST id, const TypeList&amp; paramTypes);
-
-  void evalRetorne(RefPortugolAST,Type*);
-
-  void evalCondicional(const ExpressionReturn&amp;);
-
-  Type* evalExpr_OU(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_E(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_OU(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_OUX(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_E(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_IGUAL(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_DIFERENTE(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIOR(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOR(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIOR_EQ(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOR_EQ(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_LEFT(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_BIT_SHIFT_RIGHT(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MAIS(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MENOS(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_DIV(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MULTIP(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_MOD(RefPortugolAST,Type* left, Type* right);
-  Type* evalExpr_UN_NEGATIVO(RefPortugolAST,Type*);
-  Type* evalExpr_UN_POSITIVO(RefPortugolAST,Type*);
-  Type* evalExpr_NAO(RefPortugolAST,Type*);
-  Type* evalExpr_BIT_NAO(RefPortugolAST,Type*);
-
-  void buildSourceLines();
-
-  void report(int, int, const std::string&amp;);
-  void report(int, const std::string&amp;);
-  
-
-  SymbolTable*                 _symtable;
-  TypeBuilder*                 _typeBuilder;
-  std::string                  _filepath;
-  std::vector&lt;std::string&gt;     _sourcelines;
-  Symbol                       _currentScopeSymbol;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/CompilerError.cpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/CompilerError.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1 +0,0 @@
- 

Deleted: trunk/gpt2/gptc/src/CompilerError.hpp
===================================================================
--- trunk/gpt2/gptc/src/CompilerError.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/CompilerError.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,15 +0,0 @@
-
-/*
-  Cada gramatica deve ter sua ErrorList
-*/
-
-class ErrorList {
-
-};
-
-class CompilerError {
-  void addError(unit, line, errorCode, message);
-  //tips
-  //verbose, etc
-  std::string toString();
-};

Deleted: trunk/gpt2/gptc/src/Context.cpp
===================================================================
--- trunk/gpt2/gptc/src/Context.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Context.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,35 +0,0 @@
-#include &quot;Context.hpp&quot;
-
-Context::Context( ) : _arity(0), lastStoredVar(NULL)//, lastInvocationType(IT_QU)
-{
-}
-
-
-Context::~Context( )
-{
-}
-
-
-void Context::addArg( const char *name, const int &amp;type, const string &amp;indexVar )
-{
-	//arguments.push_back( new CArgument( name, type, indexVar ) );
-}
-
-
-void Context::initArity( const int &amp;value )
-{
-	_arity = value;
-}
-
-
-void Context::addArity( )
-{
-	_arity++;
-}
-
-
-int Context::getArity( )
-{
-	return _arity;
-}
-

Deleted: trunk/gpt2/gptc/src/Context.hpp
===================================================================
--- trunk/gpt2/gptc/src/Context.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Context.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,32 +0,0 @@
-#ifndef CONTEXT_H
-#define CONTEXT_H
-
-#include &lt;string&gt;
-using namespace std;
-
-#include &quot;Arguments.hpp&quot;
-
-class Context
-{
-private:
-	int _arity;
-public:
-	Context( );
-	~Context( );
-	void addArg( const char *name, const int &amp;type = 0, const string &amp;indexVar = &quot;&quot; );
-	void initArity( const int &amp;value = 0 );
-	void addArity( );
-	int getArity( );
-
-	char *lastStoredVar;
-	string label1;
-	string label2;
-	string tempVar1;
-	string tempVar2;
-//	CArguments arguments;
-//	int lastInvocationType;
-//	int blackboardType;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/GptAsmExpression.cpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/GptAsmExpression.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,128 +0,0 @@
-#include &quot;GptAsmExpression.hpp&quot;
-#include &quot;PortugolTokenTypes.hpp&quot;
-#include &quot;Types.hpp&quot;
-#include &quot;Subroutine.hpp&quot;
-
-#include &lt;sstream&gt;
-#include &lt;map&gt;
-
-GptAsmExpression::GptAsmExpression(Type* restype,
-                                   const std::string&amp; value) 
-  : _restype(restype), _exprtype(0), _mm(&quot;&quot;), _value(value), _op1(0), _op2(0) {
-}
-
-GptAsmExpression::GptAsmExpression(Type* restype, Type *exprtype,
-                                   std::string mm, GptAsmExpression* op1)
-  : _restype(restype), _exprtype(exprtype),
-    _mm(mm), _value(&quot;&quot;), _op1(op1), _op2(0) {
-}
-
-GptAsmExpression::GptAsmExpression(Type* restype,
-                   Type *exprtype,
-                   std::string mm,
-                   GptAsmExpression* op1,
-                   GptAsmExpression* op2) 
-  : _restype(restype), _exprtype(exprtype),
-    _mm(mm), _value(&quot;&quot;), _op1(op1), _op2(op2) {
-}
-
-
-GptAsmExpression::~GptAsmExpression() {
-  delete _op1;
-  delete _op2;
-}
-
-void GptAsmExpression::expand(const std::string lvalue, Subroutine* sub) {
-  if (isAtom()) {
-    return;
-  }
-
-  if (!_op2) {
-    if (_op1-&gt;isAtom()) {
-      sub-&gt;emit(_mm, lvalue, _op1-&gt;value());
-    } else {
-      std::string t1 = sub-&gt;declareTmp(_op1-&gt;restype());
-      _op1-&gt;expand(t1, sub);
-      sub-&gt;emit(_mm, lvalue, t1);
-    }
-  } else {
-    if (_op1-&gt;isAtom() &amp;&amp; _op2-&gt;isAtom()) {
-      std::string cp1 = expandCast(lvalue, _op1-&gt;value(), _op1-&gt;restype(), sub);
-      std::string cp2 = expandCast(lvalue, _op2-&gt;value(), _op2-&gt;restype(), sub);
-      sub-&gt;emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op1-&gt;isAtom()) {
-      std::string t2 = sub-&gt;declareTmp(_op2-&gt;restype());
-
-      _op2-&gt;expand(t2, sub);
-
-      std::string cp1 = expandCast(lvalue, _op1-&gt;value(), _op1-&gt;restype(), sub);
-      std::string cp2 = expandCast(lvalue, t2, _op2-&gt;restype(), sub);
-
-      sub-&gt;emit(_mm, lvalue, cp1, cp2);
-
-    } else if (_op2-&gt;isAtom()) {
-      std::string t1 = sub-&gt;declareTmp(_op1-&gt;restype());
-  
-      _op1-&gt;expand(t1, sub);
-  
-      std::string cp1 = expandCast(lvalue, t1, _op1-&gt;restype(), sub);
-      std::string cp2 = expandCast(lvalue, _op2-&gt;value(), _op2-&gt;restype(), sub);
-  
-      sub-&gt;emit(_mm, lvalue, cp1, cp2);
-  
-    } else {
-  
-      std::string t1 = sub-&gt;declareTmp(_op1-&gt;restype());
-      std::string t2 = sub-&gt;declareTmp(_op2-&gt;restype());
-  
-      _op1-&gt;expand(t1, sub);
-      _op2-&gt;expand(t2, sub);
-  
-      std::string cp1 = expandCast(lvalue, t1, _op1-&gt;restype(), sub);
-      std::string cp2 = expandCast(lvalue, t2, _op2-&gt;restype(), sub);
-  
-      sub-&gt;emit(_mm, lvalue, cp1, cp2);
-    }
-  }
-}
-
-bool GptAsmExpression::isAtom() {
-  return _value.length() &gt; 0;
-}
-
-const std::string&amp; GptAsmExpression::value() { 
-  return _value;
-}
-
-Type* GptAsmExpression::GptAsmExpression::restype() {
-  return _restype;
-}
-
-Type* GptAsmExpression::GptAsmExpression::exprtype() {
-  return _exprtype;
-}
-
-std::string GptAsmExpression::expandCast(const std::string &amp;lvalue,
-                                         const std::string&amp; op,
-                                         Type *optype,
-                                         Subroutine *sub) {
-  if (!optype-&gt;equals(_exprtype)) {
-    sub-&gt;emit(opcodeCast(optype, _exprtype), lvalue, op);
-    return lvalue;
-  }
-  return op;
-}
-
-std::string GptAsmExpression::opcodeCast(Type* from, Type* to) {
-  if ((from-&gt;primitiveType() == PortugolTokenTypes::T_INTEIRO) &amp;&amp;
-      (to-&gt;primitiveType() == PortugolTokenTypes::T_REAL)) {
-    return &quot;i2r&quot;;
-  }
-
-  if ((from-&gt;primitiveType() == PortugolTokenTypes::T_CARACTERE) &amp;&amp;
-      (to-&gt;primitiveType() == PortugolTokenTypes::T_LITERAL)) {
-    return &quot;c2s&quot;;
-  }
-  throw;
-}

Deleted: trunk/gpt2/gptc/src/GptAsmExpression.hpp
===================================================================
--- trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/GptAsmExpression.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,42 +0,0 @@
-#ifndef GPT_ASMEXPRESSION_HPP
-#define GPT_ASMEXPRESSION_HPP
-
-#include &lt;string&gt;
-
-
-class Type;
-class Subroutine;
-
-class GptAsmExpression {
-public:
-  GptAsmExpression(Type* restype, const std::string&amp; value);
-
-  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*, GptAsmExpression*);
-  GptAsmExpression(Type* restype, Type *exprtype, std::string, GptAsmExpression*);
-
-  ~GptAsmExpression();
-
-  void expand(const std::string lvalue, Subroutine* sub);
-
-  bool isAtom();
-
-  const std::string&amp; value();
-  Type*              exprtype();
-  Type*              restype();
-private:
-  std::string expandCast(const std::string&amp;,
-                         const std::string&amp;,
-                         Type*, Subroutine*);
-
-  std::string opcodeCast(Type* from, Type* to);
-
-
-  Type              *_restype;
-  Type              *_exprtype;
-  std::string       _mm;
-  std::string       _value;
-  GptAsmExpression  *_op1;
-  GptAsmExpression  *_op2;
-};
-
-#endif

Modified: trunk/gpt2/gptc/src/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,116 +1,13 @@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src
+SUBDIRS = parser common semantic symboltable gptasm_target
 
-noinst_LTLIBRARIES = libgptc.la
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/parser \
+	-I$(top_srcdir)/src/common -I$(top_srcdir)/src/semantic -I$(top_srcdir)/src/symboltable \
+	-I$(top_srcdir)/src/gptasm_target -I./parser -I./semantic -I./gptasm_target
 
 bin_PROGRAMS = gptc
 
 gptc_SOURCES = main.cpp
 
-gptc_LDADD = libgptc.la $(ANTLR_LIB)
-
-
-EXTRA_DIST = lexer.g parser.g semantic.g gptasm.g
-
-
-BUILT_SOURCES = PortugolLexer.hpp \
-                PortugolLexer.cpp \
-                PortugolParser.hpp \
-                PortugolParser.cpp \
-                SemanticWalker.hpp \
-                SemanticWalker.cpp \
-								GptAsmWalker.hpp \
-								GptAsmWalker.cpp \
-                TokenNames.hpp \
-                TokenLabels.hpp
-
-
-libgptc_la_SOURCES =  BaseSemanticWalker.hpp \
-											BaseSemanticWalker.cpp \
-											BaseGptAsmWalker.hpp \
-											BaseGptAsmWalker.cpp \
-											CompilerError.hpp \
-											CompilerError.cpp \
-											MismatchedUnicodeCharException.hpp \
-											MismatchedUnicodeCharException.cpp \
-											PortugolAST.hpp \
-											PortugolAST.cpp \
-											Symbol.hpp \
-											Symbol.cpp \
-											SymbolTable.hpp \
-											SymbolTable.cpp \
-											SymbolTableExceptions.hpp \
-											SymbolTableExceptions.cpp \
-											Types.hpp \
-											Types.cpp \
-											UnicodeCharBuffer.hpp \
-											UnicodeCharScanner.hpp \
-											GptAsmExpression.hpp GptAsmExpression.cpp \
-											Arguments.hpp \
-											Arguments.cpp \
-											AsmProgram.hpp AsmProgram.cpp \
-										  Context.hpp Context.cpp \
-										  Options.hpp \
-											Subroutine.hpp Subroutine.cpp \
-											TextFile.hpp TextFile.cpp \
-										  Tools.hpp Tools.cpp \
-											$(BUILT_SOURCES)
-
-
-CLEANFILES = PortugolLexer.cpp \
-             PortugolLexer.hpp \
-             PortugolTokenTypes.hpp \
-             PortugolTokenTypes.txt \
-             PortugolParser.cpp \
-						 PortugolParser.hpp  \
-             PortugolParserTokenTypes.hpp \
-             PortugolParserTokenTypes.txt \
-             SemanticWalker.hpp \
-             SemanticWalker.cpp \
-             SemanticWalkerTokenTypes.hpp \
-             SemanticWalkerTokenTypes.txt \
-             GptAsmWalkerTokenTypes.hpp \
-             GptAsmWalker.cpp \
-						 GptAsmWalker.hpp  \
-             GptAsmWalkerTokenTypes.txt \
-             TokenNames.hpp \
-             TokenLabels.hpp
-
-PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g Makefile
-	$(ANTLR_BIN) $(srcdir)/lexer.g
-
-PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g Makefile
-	$(ANTLR_BIN) $(srcdir)/parser.g
-
-SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g Makefile
-	$(ANTLR_BIN) $(srcdir)/semantic.g
-
-GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
-	$(ANTLR_BIN) $(srcdir)/gptasm.g
-
-TokenNames.hpp: Makefile
-	@echo &quot;#ifndef TOKENNAMES_H&quot; &gt; $@
-	@echo &quot;#define TOKENNAMES_H&quot;  &gt;&gt; $@
-	@echo &quot;static char* g_tokenNames[] = &quot; &gt;&gt; $@
-	@echo '{&quot;&quot;, &quot;EOF&quot;, &quot;&quot;, &quot;&quot;,'   &gt;&gt; $@
-	grep = PortugolTokenTypes.txt &gt;&gt; $@
-	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/&quot;\1&quot;,/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo -n &quot;static int g_tokenNamesSize = &quot; &gt;&gt; $@
-	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc &gt;&gt; $@
-	@echo &quot;;&quot; &gt;&gt; $@
-	@echo &quot;#endif&quot; &gt;&gt; $@
-
-TokenLabels.hpp: Makefile
-	@echo &quot;#ifndef TOKENLABELS_H&quot; &gt; $@
-	@echo &quot;#define TOKENLABELS_H&quot;  &gt;&gt; $@
-	@echo &quot;static char* g_tokenLabels[] = &quot; &gt;&gt; $@
-	@echo '{&quot;&quot;, &quot;EOF&quot;, &quot;&quot;, &quot;&quot;,'   &gt;&gt; $@
-	grep '&quot;' PortugolTokenTypes.txt &gt;&gt; $@
-	sed -i -e 's/^T.*\(&quot;[^&quot;]*&quot;\).*/\1,/' $@
-	sed -i -e '$$s/,/};/' $@
-	@echo &quot;static int g_tokenLabelsSize = &quot; &gt;&gt; $@
-	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc &gt;&gt; $@
-	@echo &quot;;&quot; &gt;&gt; $@
-	@echo &quot;#endif&quot; &gt;&gt; $@
-
-
+gptc_LDADD = $(top_builddir)/src/symboltable/libsymboltable.la \
+	$(top_builddir)/src/common/libcommon.la $(top_builddir)/src/gptasm_target/libgptasm.la \
+	$(top_builddir)/src/semantic/libsemantic.la $(top_builddir)/src/parser/libparser.la $(ANTLR_LIB)

Deleted: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp
===================================================================
--- trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,110 +0,0 @@
-
-#include &lt;iostream&gt;
-
-#include &lt;antlr/config.hpp&gt;
-#include &lt;antlr/RecognitionException.hpp&gt;
-#include &lt;antlr/BitSet.hpp&gt;
-#include &lt;antlr/String.hpp&gt;
-#include &quot;MismatchedUnicodeCharException.hpp&quot;
-#include &quot;UnicodeCharScanner.hpp&quot;
-
-
-MismatchedUnicodeCharException::MismatchedUnicodeCharException()
-: RecognitionException(&quot;Mismatched char&quot;)
-{
-}
-
-// Expected range / not range
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type lower,
-	char_type up,
-	bool matchNot,
-	UnicodeCharScanner* cs
-)
-: RecognitionException(&quot;Mismatched char&quot;,
-							  cs-&gt;getFilename(),
-							  cs-&gt;getLine(), cs-&gt;getColumn())
-, mismatchType(matchNot ? NOT_RANGE : RANGE)
-, foundChar(c)
-, expecting(lower)
-, upper(up)
-, scanner(cs)
-{
-}
-
-// Expected char / not char
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	char_type expect,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException(&quot;Mismatched char&quot;,
-                      cs-&gt;getFilename(),
-							 cs-&gt;getLine(), cs-&gt;getColumn())
-, mismatchType(matchNot ? NOT_CHAR : CHAR)
-, foundChar(c)
-, expecting(expect)
-, scanner(cs)
-{
-}
-
-// Expected BitSet / not BitSet
-MismatchedUnicodeCharException::MismatchedUnicodeCharException(
-	char_type c,
-	antlr::BitSet s,
-	bool matchNot,
-	UnicodeCharScanner* cs
-) : RecognitionException(&quot;Mismatched char&quot;,
-                      cs-&gt;getFilename(),
-							 cs-&gt;getLine(), cs-&gt;getColumn())
-, mismatchType(matchNot ? NOT_SET : SET)
-, foundChar(c)
-, set(s)
-, scanner(cs)
-{
-}
-
-MismatchedUnicodeCharException::~MismatchedUnicodeCharException() throw() {}
-
-/**
- * Returns a clean error message (no line number/column information)
- */
-std::string MismatchedUnicodeCharException::getMessage() const
-{
-	ANTLR_USE_NAMESPACE(std)string s;
-
-	switch (mismatchType) {
-	case CHAR :
-		s += &quot;expecting '&quot; + antlr::charName(expecting) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
-		break;
-	case NOT_CHAR :
-		s += &quot;expecting anything but '&quot; + antlr::charName(expecting) + &quot;'; got it anyway&quot;;
-		break;
-	case RANGE :
-		s += &quot;expecting token in range: '&quot; + antlr::charName(expecting) + &quot;'..'&quot; + antlr::charName(upper) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
-		break;
-	case NOT_RANGE :
-		s += &quot;expecting token NOT in range: &quot; + antlr::charName(expecting) + &quot;'..'&quot; + antlr::charName(upper) + &quot;', found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
-		break;
-	case SET :
-	case NOT_SET :
-		{
-			s += ANTLR_USE_NAMESPACE(std)string(&quot;expecting &quot;) + (mismatchType == NOT_SET ? &quot;NOT &quot; : &quot;&quot;) + &quot;one of (&quot;;
-			ANTLR_USE_NAMESPACE(std)vector&lt;unsigned int&gt; elems = set.toArray();
-			for ( unsigned int i = 0; i &lt; elems.size(); i++ )
-			{
-				s += &quot; '&quot;;
-				s += antlr::charName(elems[i]);
-				s += &quot;'&quot;;
-			}
-			s += &quot;), found '&quot; + antlr::charName(foundChar) + &quot;'&quot;;
-		}
-		break;
-	default :
-		s += RecognitionException::getMessage();
-		break;
-	}
-
-	return s;
-}

Deleted: trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp
===================================================================
--- trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,82 +0,0 @@
-#ifndef INC_MismatchedUnicodeCharException_hpp__
-#define INC_MismatchedUnicodeCharException_hpp__
-
-/* ANTLR Translator Generator
- * Project led by Terence Parr at <A HREF="http://www.jGuru.com">http://www.jGuru.com</A>
- * Software rights: <A HREF="http://www.antlr.org/license.html">http://www.antlr.org/license.html</A>
- *
- * $Id:$
- */
-
-#include &lt;antlr/config.hpp&gt;
-#include &lt;antlr/RecognitionException.hpp&gt;
-#include &lt;antlr/BitSet.hpp&gt;
-#include &lt;antlr/String.hpp&gt;
-
-class UnicodeCharScanner;
-
-class MismatchedUnicodeCharException : public antlr::RecognitionException {
-public:
-	typedef unsigned int char_type;
-	typedef enum {
-		CHAR = 1,
-		NOT_CHAR = 2,
-		RANGE = 3,
-		NOT_RANGE = 4,
-		SET = 5,
-		NOT_SET = 6
-	} MATCH_TYPE;
-
-	MismatchedUnicodeCharException();
-
-	// Expected range / not range
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type lower,
-		char_type up,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected char / not char
-	MismatchedUnicodeCharException(
-		char_type c,
-		char_type expect,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	// Expected BitSet / not BitSet
-	MismatchedUnicodeCharException(
-		char_type c,
-		antlr::BitSet s,
-		bool matchNot,
-		UnicodeCharScanner* cs
-	);
-
-	~MismatchedUnicodeCharException() throw();
-
-	/**
-	 * Returns a clean error message (no line number/column information)
-	 */
-	std::string getMessage() const;
-private:
-	// One of the above
-	MATCH_TYPE mismatchType;
-
-	// what was found on the input stream
-	char_type foundChar;
-
-	// For CHAR/NOT_CHAR and RANGE/NOT_RANGE
-	char_type expecting;
-
-	// For RANGE/NOT_RANGE (expecting is lower bound of range)
-	char_type upper;
-
-	// For SET/NOT_SET
-	antlr::BitSet set;
-	// who knows...they may want to ask scanner questions
-	UnicodeCharScanner* scanner;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/Options.hpp
===================================================================
--- trunk/gpt2/gptc/src/Options.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Options.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,21 +0,0 @@
-#ifndef OPTIONS
-#define OPTIONS
-
-#include &lt;string&gt;
-using namespace std;
-
-class Options {
-public:
-	Options( ) {
-		sentences = false;
-		sourceLine = NULL;
-	}
-	string filename;
-//	string sourcefile;
-//	string destfile;
-	bool sentences;
-	int *sourceLine;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/PortugolAST.cpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/PortugolAST.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,118 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  021110307, USA.             *
- ***************************************************************************/
-
-
-#include &quot;PortugolAST.hpp&quot;
-#include &quot;Types.hpp&quot;
-#include &lt;sstream&gt;
-
-const char* const PortugolAST::TYPE_NAME = &quot;PortugolAST&quot;;
-
-PortugolAST::PortugolAST()
-    : CommonAST(), line(0), column(0), type(0) {
-}
-
-PortugolAST::PortugolAST(RefToken t)
-    : CommonAST(t), line(t-&gt;getLine()), column(t-&gt;getColumn()), type(0) {
-}
-
-PortugolAST::PortugolAST( const CommonAST&amp; other )
-    : CommonAST(other), line(0), column(0), type(0) {
-}
-
-PortugolAST::PortugolAST( const PortugolAST&amp; other )
-    : CommonAST(other), line(other.line), column(other.column), type(0) {
-}
-
-PortugolAST::~PortugolAST() {
-}
-
-RefAST PortugolAST::clone( void ) const
-{
-  PortugolAST *ast = new PortugolAST( *this );
-  return RefAST(ast);
-}
-
-const char* PortugolAST::typeName( void ) const
-{
-  return PortugolAST::TYPE_NAME;
-}
-
-void PortugolAST::initialize(RefToken t)
-{
-  CommonAST::initialize(t);
-  setLine(t-&gt;getLine());
-  setColumn(t-&gt;getColumn());
-}
-
-void PortugolAST::setLine(int line_) {
-  line = line_;
-}
-
-int PortugolAST::getLine() const {
-    // most of the time the line number is not set if the node is a
-    // imaginary one. Usually this means it has a child. Refer to the
-    // child line number. Of course this could be extended a bit.
-    // based on an example by Peter Morling.
-    if ( line != 0 )
-        return line;
-    if( getFirstChild() )
-        return ( RefPortugolAST(getFirstChild())-&gt;getLine() );
-    return 0;
-}
-
-void PortugolAST::setColumn(int c) {
-  column = c;
-}
-
-int PortugolAST::getColumn() const {
-    // most of the time the line number is not set if the node is a
-    // imaginary one. Usually this means it has a child. Refer to the
-    // child line number. Of course this could be extended a bit.
-    // based on an example by Peter Morling.
-    if ( column != 0 )
-        return column;
-    if( getFirstChild() )
-        return ( RefPortugolAST(getFirstChild())-&gt;getColumn() );
-    return 0;
-}
-
-void PortugolAST::setEvalType(Type* t) {
-  type = t;
-}
-
-Type* PortugolAST::getEvalType() {
-  return type;
-}
-
-
-std::string PortugolAST::toString() const {
-  std::stringstream s;
-  s &lt;&lt; getText();
-//   s &lt;&lt; &quot;(&quot; &lt;&lt; getLine() &lt;&lt; &quot;:&quot; &lt;&lt; getColumn() &lt;&lt; &quot;)&quot; &lt;&lt; getText();
-  if (type) {
-    s &lt;&lt; &quot;:&quot; &lt;&lt; type-&gt;name();
-  }
-  return s.str();
-}
-
-RefAST PortugolAST::factory() {
-  return RefAST(new PortugolAST);
-}

Deleted: trunk/gpt2/gptc/src/PortugolAST.hpp
===================================================================
--- trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/PortugolAST.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,71 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef PORTUGOLAST_HPP
-#define PORTUGOLAST_HPP
-
-#include &lt;antlr/CommonAST.hpp&gt;
-#include &lt;string&gt;
-
-using namespace std;
-using namespace antlr;
-
-class Type;
-
-class PortugolAST : public CommonAST {
-public:
-  PortugolAST();
-  PortugolAST( RefToken t );
-  PortugolAST( const CommonAST&amp; other );
-  PortugolAST( const PortugolAST&amp; other );
-
-  ~PortugolAST();
-
-  void setLine(int line);
-  int getLine() const;
-
-  void setColumn(int);
-  int getColumn() const;
-
-  void setEvalType(Type*);
-  Type* getEvalType();
-
-  virtual RefAST clone( void ) const;
-
-  virtual void initialize( RefToken t );
-
-  virtual const char* typeName( void ) const;
-
-  virtual std::string toString() const;
-
-  static RefAST factory();
-  static const char* const TYPE_NAME;
-protected:
-  int   line;
-  int   column;
-  Type* type;
-  int endLine;
-  int eval_type; //evaluated type of expression
-  string filename;
-};
-
-typedef ASTRefCount&lt;PortugolAST&gt; RefPortugolAST;
-
-#endif

Deleted: trunk/gpt2/gptc/src/Subroutine.cpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Subroutine.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,183 +0,0 @@
-#include &quot;Subroutine.hpp&quot;
-
-#include &lt;iostream&gt;
-using namespace std;
-
-#include &quot;Tools.hpp&quot;
-#include &quot;Types.hpp&quot;
-
-#include &quot;PortugolTokenTypes.hpp&quot;
-
-
-Subroutine::Subroutine(Options *options, /*CGptAssemblyFile *file,*/ const string &amp;name)
-	: _options(options), _name(name), _tmpSuffix(1), _lastSourceLine(0)
-{
-	if (_options-&gt;sentences) {
-		//_sourceInfo = new SourceInfo();
-		//_sourceInfo-&gt;setFileName(_options-&gt;sourcefile);
-	}
-	_body.incTab();
-}
-
-
-Subroutine::~Subroutine()
-{
-	//if (_sourceInfo) {
-	//	delete _sourceInfo;
-	//}
-}
-
-
-void Subroutine::init()
-{
-  _header.writeln();
-	_header.writeln(string(&quot;// Procedure &quot;) + _name);
-	_header.writeln(&quot;proc &quot; + _name);
-	_header.incTab();
-//	_body.incTab();
-}
-
-
-void Subroutine::finish()
-{
-	if (_name == &quot;main&quot;) {
-		_body.writeln(&quot;exit_0&quot;);
-	}
-//	_body-&gt;decTab();
-	_footer.writeln(&quot;end-proc&quot;);
-
-	_footer.writeln(&quot;// Fim da procedure&quot;);
-	_footer.writeln();
-}
-
-
-void Subroutine::emitPUSHMn(const string &amp;symbol, const bool &amp;pushType)
-{
-//    SymbolType symbolType = _symbolTable-&gt;getSymbol(getName(), symbol, true).getType();
-// 
-//    _body.writeln(string(&quot;push &quot;)   + symbol);
-// 
-//    if (pushType) {
-//       _body.writeln(string(&quot;push_&quot;) + symbolType.toAsmType());
-//    }
-}
-
-
-void Subroutine::emit(const string &amp;mn, const string &amp;op1, const string &amp;op2, const string &amp;op3)
-{
-	_body.write(mn);
-	if (op1.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.write(&quot; &quot; + op1);
-	if (op2.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.write(&quot;, &quot; + op2);
-	if (op3.empty()) {
-		_body.writeln();
-		return;
-	}
-
-	_body.writeln(&quot;, &quot; + op3);
-}
-
-void Subroutine::emitMnWithPrefix(const string &amp;mn, const string &amp;var, const string &amp;op1, const string &amp;op2)
-{
-	emit(getMnWithPrefix(mn, var), var, op1, op2);
-}
-
-
-void Subroutine::emitLabel(const string &amp;label)
-{
-	_body.writeln(label + string(&quot;:&quot;));
-}
-
-
-void Subroutine::emitAsmCode(const string &amp;code)
-{
-	_body.writeln();
-	_body.writeln(code);
-	_body.writeln();
-}
-
-
-/*
-void Subroutine::write(string value)
-{
-//	if (_sourceInfo &amp;&amp; *_options-&gt;sourceLine &gt; _lastSourceLine) {
-//		string line = _sourceInfo-&gt;getLine(*_options-&gt;sourceLine);
-//		line = alltrim(wo_ctrl_chrs(line, ' '));
-//		_file-&gt;write(
-//				string(&quot;// LINE &quot;) + string(itoa(*_options-&gt;sourceLine)) + string(&quot; --&gt; &quot;) + line
-//				);
-//		_lastSourceLine = *_options-&gt;sourceLine;
-//	}
-
-	_body.write(value);
-}
-
-void Subroutine::writeln(string value)
-{
-//	if (_sourceInfo &amp;&amp; *_options-&gt;sourceLine &gt; _lastSourceLine) {
-//		string line = _sourceInfo-&gt;getLine(*_options-&gt;sourceLine);
-//		line = alltrim(wo_ctrl_chrs(line, ' '));
-//		_file-&gt;writeln(
-//				string(&quot;// LINE &quot;) + string(itoa(*_options-&gt;sourceLine)) + string(&quot; --&gt; &quot;) + line
-//				);
-//		_lastSourceLine = *_options-&gt;sourceLine;
-//	}
-
-	_body.writeln(value);
-}
-*/
-
-void Subroutine::emitVarDefinition(const string &amp;name, Type* type)
-{
-	_header.writeln(&quot;var &quot; + name + &quot; &quot; + type-&gt;asmName());
-
-  if (type-&gt;isPrimitive() &amp;&amp; type-&gt;equals(PortugolTokenTypes::T_LITERAL)) {
-    _prologue.writeln(&quot;salloc &quot; + name);
-  }
-}
-
-void Subroutine::emitParDefinition(const string &amp;name, Type* type)
-{
-	_header.writeln(&quot;par &quot; + name + &quot; &quot; + type-&gt;asmName());
-}
-
-string Subroutine::declareTmp(Type* type) {
-  std::stringstream s;
-  s &lt;&lt; &quot;tmp&quot; &lt;&lt; _tmpSuffix++;
- 
-  std::string name = s.str();
-  emitVarDefinition(name, type);
-  return name;
-}
-
-string Subroutine::getCode() const
-{
-	return _header.getText() + _prologue.getText() 
-         + _body.getText() + _footer.getText();
-}
-
-
-string Subroutine::getMnWithPrefix(const string &amp;mn, const string &amp;var) // TODO: serviria para simbolos tb ???
-{
-// 	int primitiveType = _symbolTable-&gt;getSymbol (getName(), var, true).getType().getPrimitiveType();
-
-// 	switch(primitiveType) {
-// 		case PortugolParserTokenTypes::T_KW_INTEIRO:    return &quot;i&quot; + mn;
-// 		case PortugolParserTokenTypes::T_KW_REAL:       return &quot;r&quot; + mn;
-// 		case PortugolParserTokenTypes::T_KW_CARACTERE:  return &quot;i&quot; + mn;
-// 		case PortugolParserTokenTypes::T_KW_LITERAL:    return &quot;s&quot; + mn;
-// 		case PortugolParserTokenTypes::T_KW_LOGICO:     return &quot;i&quot; + mn;
-// 		case PortugolParserTokenTypes::T_KW_MATRIZ:     return &quot;m&quot; + mn;
-// 		default:                                        return &quot;undefined_&quot; + mn;
-// 	}
-}
-

Deleted: trunk/gpt2/gptc/src/Subroutine.hpp
===================================================================
--- trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Subroutine.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,59 +0,0 @@
-#ifndef SUBROUTINE_H
-#define SUBROUTINE_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &quot;Options.hpp&quot;
-
-#include &lt;antlr/LLkParser.hpp&gt;
-#include &quot;PortugolParserTokenTypes.hpp&quot;
-
-#include &quot;TextFile.hpp&quot;
-
-using namespace std;
-
-class Type;
-
-class Subroutine
-{
-public:
-	Subroutine(Options *options, const string &amp;name);
-	~Subroutine();
-	void init();
-	void finish();
-	void emitPUSHMn(const string &amp;symbol, const bool &amp;pushType = false);
-	void emit(const string &amp;mn, const string &amp;op1 = &quot;&quot;, const string &amp;op2 = &quot;&quot;, const string &amp;op3 = &quot;&quot;);
-	void emitMnWithPrefix(const string &amp;mn, const string &amp;var, const string &amp;op1 = &quot;&quot;, const string &amp;op2 = &quot;&quot;);
-
-	void emitLabel(const string &amp;label);
-
-	void emitAsmCode(const string &amp;code);
-
-//	void write(string value);
-//	void writeln(string value = &quot;&quot;);
-
-	const string&amp; getName() const
-	{
-		return _name;
-	}
-	void emitVarDefinition(const string &amp;name, Type* type);
-	void emitParDefinition(const string &amp;name, Type* type);
-	string getCode() const;
-
-  string declareTmp(Type* type);
-private:
-	string getMnWithPrefix(const string &amp;mn, const string &amp;var);
-	Options *_options;
-	vector&lt;string&gt; _params;
-	int _lastSourceLine;
-	string _name;
-  int    _tmpSuffix;
-	TextFile _header;
-  TextFile _prologue;
-	TextFile _body;
-	TextFile _footer;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/Symbol.cpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Symbol.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,211 +0,0 @@
-#include &quot;Symbol.hpp&quot;
-#include &quot;Types.hpp&quot;
-
-#include &lt;sstream&gt;
-
-Symbol::Symbol()
-  : _type(0) {
-}
-
-Symbol::Symbol(const std::string&amp; lexeme,
-               Type* type,
-               const std::string&amp; scope,
-               const std::string&amp; unit,
-               int line,
-               int column)
-  :   _lexeme(lexeme),
-      _type(type),
-      _scope(scope),
-      _unit(unit),
-      _line(line),
-      _column(column) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-
-}
-
-Symbol::Symbol(const std::string&amp; lexeme,
-               Type* type,
-               const std::string&amp; unit,
-               int line,
-               int column)
-  :   _lexeme(lexeme),
-      _type(type),
-      _unit(unit),
-      _line(line),
-      _column(column) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-}
-
-
-
-Symbol::Symbol(const std::string&amp; lexeme, Type* type) 
-  : _lexeme(lexeme), _type(type), _scope(&quot;?&quot;), _unit(&quot;?&quot;), 
-    _line(0), _column(0) {
-
-  _identifier = buildIdentifier(lexeme, _type);
-}
-
-
-const std::string&amp; Symbol::lexeme() const {
-  return _lexeme;
-}
-
-Type* Symbol::type() const {
-  return _type;
-}
-
-void Symbol::setScope(const std::string&amp; scope) {
-  _scope = scope;
-}
-
-const std::string&amp; Symbol::scope() const {
-  return _scope;
-}
-
-const std::string&amp; Symbol::unit() const {
-  return _unit;
-}
-
-int Symbol::line() const {
-  return _line;
-}
-
-int Symbol::column() const {
-  return _column;
-}
-
-std::string Symbol::toString() const {
-  std::stringstream ret;
-  ret &lt;&lt; _unit &lt;&lt; &quot;:&quot; &lt;&lt; _line
-      &lt;&lt; &quot; (&quot; &lt;&lt; _scope &lt;&lt; &quot;) -&gt; &quot; &lt;&lt; lexeme();
-
-  ret &lt;&lt; &quot; : &quot; &lt;&lt; _type-&gt;name();
-
-  ret &lt;&lt; &quot; -- attributes: {&quot;;
-  if (_type-&gt;isConst()) {
-    ret &lt;&lt; &quot;c&quot;;
-  }
-
-  if (_type-&gt;isRef()) {
-    ret &lt;&lt; &quot;r&quot;;
-  }
-  ret &lt;&lt; &quot;}&quot;;
-
-  return ret.str();
-}
-
-std::string 
-Symbol::buildIdentifier(const std::string&amp; name, Type* type) {
-  if (!type-&gt;isSubprogram()) {
-    return name;
-  } else {
-    return buildIdentifier(name, type-&gt;paramTypes());
-  }
-}
-
-std::string 
-Symbol::buildIdentifier(const std::string&amp; name, const TypeList&amp; list) {
-  return name + &quot;_&quot; + list.toIdentifier();
-}
-
-std::string Symbol::identifier() const {
-  return &quot;_&quot; + _identifier;
-}
-
-
-bool Symbol::equivalent(const Symbol&amp; other) const {
-  return _lexeme == other._lexeme &amp;&amp;
-         _type-&gt;equals(other._type);
-}
-
-//-------------------------------------------------------
-
-
-SymbolList::const_iterator SymbolList::duplicated() const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if (count((*it).identifier()) &gt; 1) {
-      return it;
-    }
-  }
-  return end();
-}
-
-int SymbolList::count(const std::string&amp; identifier) const {
-  int c = 0;
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == identifier) {
-      c++;
-    }
-  }
-  return c;
-}
-
-TypeList SymbolList::typeList() const {
-  TypeList list;
-
-  for (const_iterator it = begin(); it != end(); ++it) {
-    list.push_back((*it).type());
-  }
-  return list;
-}
-
-SymbolList
-SymbolList::findAllByLexeme(const std::string&amp; lexeme) const {
-  SymbolList ret;
-  SymbolList::const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == lexeme) {
-      ret.push_back(*it);
-    }
-  }
-  return ret;
-}
-
-SymbolList::const_iterator 
-SymbolList::findFirstByLexeme(const std::string&amp; lexeme) const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).lexeme() == lexeme) {
-      return it;
-    }
-  }
-  return end();
-}
-
-SymbolList::const_iterator 
-SymbolList::findByIdentifier(const std::string&amp; identifier) const {
-  for (const_iterator it = begin(); it != end(); ++it) {
-    if ((*it).identifier() == identifier) {
-      return it;
-    }
-  }
-  return end();
-}
-
-void SymbolList::setScope(const std::string&amp; scope) {
-  for (iterator it = begin(); it != end(); ++it) {
-    (*it).setScope(scope);
-  }
-}
-
-std::string SymbolList::toString() const {
-  std::string ret = &quot;&quot;;
-  for (const_iterator it = begin(); it != end(); ++it) {
-    ret += (*it).toString() + &quot;\n&quot;;
-  }
-  return ret;
-}
-
-bool SymbolList::equivalent(const SymbolList&amp; other) const {
-  const_iterator it, jt;
-  for (it = begin(), jt = other.begin(); 
-       it != end() &amp;&amp; jt != other.end(); 
-       ++it, ++jt) {
-    if (!(*it).equivalent(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}

Deleted: trunk/gpt2/gptc/src/Symbol.hpp
===================================================================
--- trunk/gpt2/gptc/src/Symbol.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Symbol.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,82 +0,0 @@
-#ifndef SYMBOL_HPP
-#define SYMBOL_HPP
-
-#include &lt;string&gt;
-#include &lt;list&gt;
-
-class Type;
-class TypeList;
-
-class Symbol {
-public:
-  static std::string buildIdentifier(const std::string&amp;, Type*);
-  static std::string buildIdentifier(const std::string&amp;, const TypeList&amp;);
-
-  Symbol();
-
-  Symbol(const std::string&amp; lexeme,
-         Type* type,
-         const std::string&amp; scope,
-         const std::string&amp; unit,
-         int line,
-         int column);
-
-  Symbol(const std::string&amp; lexeme,
-         Type* type,
-         const std::string&amp; unit,
-         int line,
-         int column);
-
-  Symbol(const std::string&amp; lexeme,
-         Type* type);
-
-  const std::string&amp; lexeme() const;
-
-  Type* type() const;
-
-  void setScope(const std::string&amp;);
-  const std::string&amp; scope() const;
-
-  const std::string&amp; unit() const;
-
-  int line() const;
-  int column() const;
-
-  std::string toString() const;
-
-  std::string identifier() const;
-
-  bool equivalent(const Symbol&amp;) const;
-private:
-  std::string      _lexeme;
-  std::string      _identifier;
-  Type*            _type;
-  std::string      _scope;
-  std::string      _unit;
-  int              _line;
-  int              _column;
-};
-
-
-class SymbolList : public std::list&lt;Symbol&gt; {
-public:
-
-  const_iterator duplicated() const;
-
-  TypeList typeList() const;
-
-  SymbolList     findAllByLexeme(const std::string&amp;) const;
-  const_iterator findFirstByLexeme(const std::string&amp;) const;
-  const_iterator findByIdentifier(const std::string&amp;) const;
-  
-
-  int count(const std::string&amp;) const;
-
-  void setScope(const std::string&amp;);
-
-  std::string toString() const;
-
-  bool equivalent(const SymbolList&amp;) const;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/SymbolTable.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTable.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,211 +0,0 @@
-#include &quot;SymbolTable.hpp&quot;
-
-#include &quot;Types.hpp&quot;
-#include &quot;PortugolTokenTypes.hpp&quot;
-#include &quot;Symbol.hpp&quot;
-#include &quot;SymbolTableExceptions.hpp&quot;
-
-#include &lt;iostream&gt;
-
-SymbolTable::SymbolTable(const std::string&amp; unit)
-  : _unit(unit), _typeBuilder(new TypeBuilder) {
-
-  setGlobalScope();
-}
-
-void SymbolTable::setGlobalScope() {
-  _scope = globalScope();
-}
-
-bool SymbolTable::isInGlobalScope() {
-  return globalScope() == _scope;
-}
-
-void SymbolTable::setIgnoreScope() {
-  static char r = 1;
-  _scope = &quot;internal&quot; + (r++);
-}
-
-const std::string SymbolTable::globalScope() {
-  return &quot;@global&quot;;
-}
-
-void SymbolTable::setScope(const Symbol&amp; scopeSymbol) {  
-  _scope = scopeSymbol.identifier();
-}
-
-const std::string&amp; SymbolTable::currentScope() {
-  return _scope;
-}
-
-const std::string&amp; SymbolTable::unit() {
-  return _unit;
-}
-
-void SymbolTable::insertType(const std::string&amp; name,
-                             const SymbolList&amp; fields,
-                             int line) {
-  
-  //checando por campos duplicados na estrutura
-  SymbolList::const_iterator dup = fields.duplicated();
-  if (dup != fields.end()) {
-    throw RedeclarationException(*dup);
-  }
-
-  //checando por redefinicao da estrutura
-  if (_typeBuilder-&gt;typeList().find(name) != _typeBuilder-&gt;typeList().end()) {
-    throw RedefinedTypeException(name);
-  }
-
-  _typeBuilder-&gt;typeList().push_back(
-    new Type(_typeBuilder, name, fields, _unit, line));
-}
-
-
-// void SymbolTable::insertType(const std::string&amp; name,
-//                              const SymbolList&amp; symbolList,
-//                              int line) {
-// 
-//   //checando por campos duplicados na estrutura
-//   SymbolList::const_iterator dup = symbolList.duplicated();
-//   if (dup != symbolList.end()) {
-//     throw RedeclarationException(*dup);
-//   }
-// 
-//   //checando por redefinicao da estrutura
-//   if (_typeBuilder-&gt;typeList().find(name) != _typeBuilder-&gt;typeList().end()) {
-//     throw RedefinedTypeException(name);
-//   }
-// 
-//   _typeBuilder-&gt;typeList().push_back(
-//     new Type(_typeBuilder, name,
-//              symbolList.toStructFieldList(), _unit, line));
-// }
-
-Type* SymbolTable::getType(const std::string&amp; name) {
-  TypeList::iterator ret = _typeBuilder-&gt;typeList().find(name);
-
-  if (ret == _typeBuilder-&gt;typeList().end()) {
-    throw UndeclaredTypeException(name);
-  }
-
-  return *ret;
-}
-
-
-void SymbolTable::insertSymbol(const Symbol&amp; symbol) {
-  if (symbolExists(symbol)) {
-    throw RedeclarationException(symbol);
-  }
-  _table[symbol.scope()].push_back(symbol);
-}
-
-void SymbolTable::insertSymbols(const SymbolList&amp; symbols) {
-  for (SymbolList::const_iterator it = symbols.begin();
-       it != symbols.end();
-       ++it) {
-    insertSymbol(*it);
-  }
-}
-
-const Symbol&amp; SymbolTable::getSymbol(const std::string&amp; lexeme,
-                                     const std::string&amp; scope) {
-  SymbolList::const_iterator it = _table[scope].findFirstByLexeme(lexeme);
-  if (it == _table[scope].end()) {
-    throw UndeclaredSymbolException(lexeme);
-  }
-  return (*it);
-}
-
-const Symbol&amp; 
-SymbolTable::getSymbol(const std::string&amp; lexeme, const TypeList&amp; params) {
-  //deve considerar promocao de tipos
-  //    fun&#231;&#227;o f(a:real) ...
-  //    f(1);                //resolve para a fun&#231;&#227;o &quot;f_real&quot;
-
-
-  SymbolList list = _table[globalScope()].findAllByLexeme(lexeme);
-
-  if (list.size() == 0) {
-    throw UndeclaredSymbolException(lexeme);
-  }
-
-  //try exact version
-  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
-    if ((*it).type()-&gt;isSubprogram() &amp;&amp;
-        (*it).type()-&gt;paramTypes().equals(params)) {
-      return (*it);
-    }
-  }
-
-  //tentando promocoes...
-  for (SymbolList::iterator it = list.begin(); it != list.end(); ++it) {
-    if ((*it).type()-&gt;isSubprogram() &amp;&amp;
-        (*it).type()-&gt;paramTypes().isLValueFor(params)) {
-      return (*it);
-    }
-  }
-
-  throw UnmatchedException(lexeme);
-
-//   std::string id = Symbol::buildIdentifier(lexeme, params);
-//   SymbolList::const_iterator it = _table[globalScope()].findByIdentifier(id);
-//   if (it == _table[globalScope()].end()) {
-//     throw UndeclaredSymbolException(id);
-//   }
-//   return (*it);
-}
-
-const Symbol&amp; SymbolTable::getSymbol(const std::string&amp; lexeme) {
-  //buscar primeiro no escopo atual, depois no global
-
-  if (isInGlobalScope()) {
-    return getSymbol(lexeme, _scope);
-  } else {
-    try {
-      return getSymbol(lexeme, _scope);
-    } catch( ... ) {
-      return getSymbol(lexeme, globalScope());
-    }
-  }
-}
-
-bool SymbolTable::symbolExists(const Symbol&amp; s) {
-  SymbolList::const_iterator it = 
-    _table[s.scope()].findByIdentifier(s.identifier());
-
-  if (it == _table[s.scope()].end()) {
-    return false;
-  } else {
-    return true;
-  }
-}
-
-
-// bool SymbolTable::symbolExists(const std::string&amp; id) {
-//   return symbolExists(id, _scope);
-// }
-// 
-// bool SymbolTable::symbolExists(const std::string&amp; id,
-//                                const std::string&amp; scope) {
-// 
-//   return _table[scope].findByIdentifier(id) != _table[scope].end();
-// }
-
-
-void SymbolTable::dump() {
-
-  std::cerr &lt;&lt; &quot;=== SymbolTable ===\n&quot;;
-  std::cerr &lt;&lt; &quot;Identifiers ...\n&quot;;
-  std::map&lt;std::string, SymbolList&gt;::iterator it;
-  for (it = _table.begin(); it != _table.end(); ++it) {
-    std::cerr &lt;&lt; it-&gt;second.toString() &lt;&lt; std::endl;
-  }
-  std::cerr &lt;&lt; &quot;Types ... &quot; &lt;&lt; std::endl;
-  std::cerr &lt;&lt; _typeBuilder-&gt;typeList().toString() &lt;&lt; std::endl;
-  std::cerr &lt;&lt; &quot;=== End SymbolTable ===\n\n&quot;;
-}
-
-TypeBuilder* SymbolTable::typeBuilder() {
-  return _typeBuilder;
-}

Deleted: trunk/gpt2/gptc/src/SymbolTable.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTable.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,62 +0,0 @@
-#ifndef SYMBOLTABLE_HPP
-#define SYMBOLTABLE_HPP
-
-#include &lt;string&gt;
-#include &lt;list&gt;
-#include &lt;map&gt;
-
-#include &quot;Types.hpp&quot;
-
-class Symbol;
-class SymbolList;
-class TypeBuilder;
-
-class SymbolTable {
-public:
-  SymbolTable(const std::string&amp; unit);
-
-  void setGlobalScope();
-  bool isInGlobalScope();
-  void setIgnoreScope();
-  void setScope(const Symbol&amp;);
-  const std::string&amp; currentScope();
-  const std::string globalScope();
-
-  const std::string&amp; unit();
-
-  void insertType(const std::string&amp; name,
-                  const SymbolList&amp;,
-                  int line);
-
-  /* recuperar tipo por nome (ex. esruturas) */
-  Type* getType(const std::string&amp; name);
-
-  void insertSymbol(const Symbol&amp; symbol);
-  void insertSymbols(const SymbolList&amp; symbols);
-
-  //(lexeme, scope)
-  const Symbol&amp; getSymbol(const std::string&amp;, const std::string&amp;);
-
-  //(lexeme, params)
-  const Symbol&amp; getSymbol(const std::string&amp;, const TypeList&amp;);
-
-
-  //(lexeme) -&gt; todos os escopos, iniciando pelo atual
-  const Symbol&amp; getSymbol(const std::string&amp;);
-
-  void dump();
-
-  TypeBuilder* typeBuilder();
-private:
-/*  bool symbolExists(const std::string&amp;);
-  bool symbolExists(const std::string&amp;, const std::string&amp;);*/
-  bool symbolExists(const Symbol&amp; s);
-
-  std::string                        _unit;
-  std::string                        _scope;
-
-  TypeBuilder                        *_typeBuilder;
-  std::map&lt;std::string, SymbolList&gt;  _table;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/SymbolTableExceptions.cpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,63 +0,0 @@
-#include &quot;SymbolTableExceptions.hpp&quot;
-#include &quot;TokenNames.hpp&quot;
-
-UndeclaredTypeException::UndeclaredTypeException(const std::string&amp; name)
-  : _id(-1), _name(name) {
-}
-
-UndeclaredTypeException::UndeclaredTypeException(int id)
-  : _id(id) {
-}
-
-std::string UndeclaredTypeException::typeName() const {
-  if (_id == -1) {
-    return _name;
-  } else {
-    return g_tokenNames[_id];
-  }
-}
-
-//--------------------------------------------------------
-
-RedefinedTypeException::RedefinedTypeException(const std::string&amp; name)
-  : _name(name) {
-}
-
-const std::string&amp; RedefinedTypeException::typeName() const {
-  return _name;
-}
-
-
-//--------------------------------------------------------
-
-UndeclaredSymbolException::UndeclaredSymbolException(const std::string&amp; lexeme)
-  : _lexeme(lexeme) {
-}
-
-std::string UndeclaredSymbolException::lexeme() const {
-  return _lexeme;
-}
-
-
-//--------------------------------------------------------
-
-
-RedeclarationException::RedeclarationException(const Symbol&amp; s)
-  : _symbol(s) {
-}
-
-const Symbol&amp; RedeclarationException::symbol() const {
-  return _symbol;
-}
-
-//--------------------------------------------------------
-
-
-UnmatchedException::UnmatchedException(const std::string&amp; l)
-  : _lexeme(l) {
-
-}
-
-const std::string&amp; UnmatchedException::lexeme() {
-  return _lexeme;
-}

Deleted: trunk/gpt2/gptc/src/SymbolTableExceptions.hpp
===================================================================
--- trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/SymbolTableExceptions.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,59 +0,0 @@
-#ifndef SYMBOLTABLEEXCEPTIONS_HPP
-#define SYMBOLTABLEEXCEPTIONS_HPP
-
-#include &quot;Symbol.hpp&quot;
-#include &quot;Types.hpp&quot;
-
-#include &lt;string&gt;
-
-
-class UndeclaredTypeException {
-public:
-  UndeclaredTypeException(const std::string&amp; name);
-  UndeclaredTypeException(int id);
-
-  std::string typeName() const;
-
-private:
-  int _id;
-  std::string _name;
-};
-
-class RedefinedTypeException {
-public:
-  RedefinedTypeException(const std::string&amp; name);
-
-  const std::string&amp; typeName() const;
-private:
-  std::string _name;
-};
-
-class UndeclaredSymbolException {
-public:
-  UndeclaredSymbolException(const std::string&amp; lexeme);
-
-  std::string lexeme() const;
-
-private:
-  std::string _lexeme;
-};
-
-class RedeclarationException {
-public:
-  RedeclarationException(const Symbol&amp;);
-
-  const Symbol&amp; symbol() const;
-private:
-  Symbol _symbol;
-};
-
-class UnmatchedException {
-public:
-  UnmatchedException(const std::string&amp;);
-
-  const std::string&amp; lexeme();
-private:
-  std::string _lexeme;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/TextFile.cpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/TextFile.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,71 +0,0 @@
-#include &quot;TextFile.hpp&quot;
-
-
-TextFile::TextFile( const string &amp;chrTab )
-	: _chrTab( chrTab ), _emitTab( true )
-{
-}
-
-
-TextFile::~TextFile( )
-{
-}
-
-
-void TextFile::writeln( const string &amp;message )
-{
-	if ( _emitTab ) {
-		_txt &lt;&lt; _tabs;
-	}
-	_txt &lt;&lt; message &lt;&lt; endl;
-	_emitTab = true;
-}
-
-
-void TextFile::writeln( )
-{
-	_txt &lt;&lt; endl;
-	_emitTab = true;
-}
-
-
-void TextFile::write( const string &amp;message )
-{
-	if ( _emitTab ) {
-		_txt &lt;&lt; _tabs;
-	}
-	_txt &lt;&lt; message;
-	_emitTab = false;
-}
-
-
-void TextFile::incTab( )
-{
-    _tabs += _chrTab;
-}
-
-
-void TextFile::decTab( )
-{
-    _tabs.erase( _tabs.length( ) - _chrTab.length( ), _chrTab.length( ) );
-}
-
-
-string TextFile::getText( ) const
-{
-	return _txt.str( );
-}
-
-
-bool TextFile::writeToFile( const string &amp;filename )
-{
-	ofstream *_file;
-	_file = new ofstream( filename.c_str( ) );
-	if (_file) {
-		(*_file) &lt;&lt; _txt;
-		delete _file;
-		return true;
-	}
-	return false;
-}
-

Deleted: trunk/gpt2/gptc/src/TextFile.hpp
===================================================================
--- trunk/gpt2/gptc/src/TextFile.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/TextFile.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,30 +0,0 @@
-#ifndef GPT_TEXT_FILE_H
-#define GPT_TEXT_FILE_H
-
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;sstream&gt;
-
-using namespace std;
-
-class TextFile
-{
-public:
-	TextFile( const string &amp;chrTab = &quot;\t&quot; );
-	~TextFile( );
-	void writeln( const string &amp;message );
-	void writeln( );
-	void write( const string &amp;message );
-	void incTab( );
-	void decTab( );
-	string getText( ) const;
-	bool writeToFile( const string &amp;filename );
-private:
-	string _chrTab;
-	string _tabs;
-	bool _emitTab;
-	stringstream _txt;
-};
-
-#endif
-

Deleted: trunk/gpt2/gptc/src/Tools.cpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Tools.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,299 +0,0 @@
-/*
- * $Id: Tools.cpp,v 1.1.1.1 2005/08/15 15:19:52 asgarzao Exp $
- * MyLibrary version 0.1.0
- * Copyright (C) 2002 Alex Sandro Garz&#65533; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">alexgarzao at bol.com.br</A>&gt;
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-#include &quot;PortugolParserTokenTypes.hpp&quot;
-
-#include &quot;Tools.hpp&quot;
-
-
-int hexToInt(const char* _value) {
-    int result = 0;
-    char *position;
-    char conversionTable[] = &quot;0123456789ABCDEF&quot;;
-
-    while (*_value) {
-        position = strchr(conversionTable, *_value);
-        if (position == NULL)
-            return 0;
-
-        result &lt;&lt;= 4;
-        result = result | (position - conversionTable);
-        _value++;
-    }
-
-    return result;
-}
-
-string pad(string _text, unsigned int _size) {
-    if (_size &gt; _text.length())
-        _text.append(_size - _text.length(), ' ');
-
-    return _text;
-}
-
-string lpad(string _text, unsigned int _size) {
-    if (_size &gt; _text.length())
-        _text = string(_size - _text.length(), ' ') + _text;
-
-    return _text;
-}
-
-string intToHex(unsigned int _value, int _size) {
-    string codHex = &quot;0123456789ABCDEF&quot;;
-    string result;
-    int nible;
-
-    while (_value &gt; 0) {
-        nible = _value &amp; 0xF;
-        _value &gt;&gt;= 4;
-        result = codHex[nible] + result;
-    }
-
-    if ( _size == -1 )
-        _size = 1;
-
-    return strZero(result, _size);
-    // if (_size == -1)
-    //     return( result );
-    // else
-    //     return( strZero( result, _size ) );
-    //
-}
-
-string strZero(string _value, unsigned int _size) {
-    while (_value.length() &lt; _size) {
-        _value = '0' + _value;
-    }
-
-    return _value;
-}
-
-string strZero(int _value, unsigned int _size) {
-    string result = itoa(_value);
-
-    while (result.length() &lt; _size) {
-        result = '0' + result;
-    }
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = 0; count &lt; _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-string dataToHex(char _code[], unsigned int _start, unsigned int _length) {
-    string result;
-    unsigned int count;
-
-    for (count = _start; count - _start &lt; _length; count++)
-        result += intToHex(_code[count], 2);
-
-    return result;
-}
-
-int binToInt(const char* _binValue) {
-    int intValue = 0;
-    int length = strlen(_binValue) - 1;
-    int countBit;
-
-    for (countBit = length; countBit &gt;= 0; countBit--) {
-        if (_binValue[countBit] == '1')
-            intValue += int(pow(2.0, length - countBit));
-    }
-
-    return intValue;
-}
-
-string itoa(int _number) {
-    stringstream s;
-
-    s &lt;&lt; _number;
-    return s.str();
-}
-
-string ftos(double _value) {
-    stringstream s;
-
-    s &lt;&lt;  setiosflags(ios::fixed) &lt;&lt; _value;
-    
-    return s.str();
-}
-
-string itobool(int _number) {
-    if (_number == 0)
-        return &quot;false&quot;;
-    else
-        return &quot;true&quot;;
-}
-
-string strtoupper(string str) {
-    unsigned int count;
-
-    for (count = 0; count &lt; str.size(); count++)
-        str[count] = toupper(str[count]);
-
-    return str;
-}
-
-string strToUpperWithEscapeControls(string str) {
-    unsigned int count;
-
-    for (count = 0; count &lt; str.size(); count++) {
-        if (str[count] == '\\')
-            count += 2;
-        else
-            str[count] = toupper(str[count]);
-    }
-
-    return str;
-}
-
-string alltrim(string str) {
-    // crap version...  :-)
-    // precisamos usar `find', `rfind'! --felipek
-    while (str[0] == ' ')
-        str.erase(0, 1);
-
-    while (str[str.length() - 1] == ' ')
-        str.erase(str.length() - 1, 1);
-
-    return str;
-}
-
-string wo_ctrl_chrs(string str, char chr_to_put) {
-    unsigned int chr_number;
-
-    for (chr_number = 0; chr_number &lt; str.size(); chr_number++) {
-        if (str[chr_number] &lt; 32)
-            str[chr_number] = chr_to_put;
-    }
-
-    return str;
-}
-
-/* CRAP!  --felipek
-string&amp; getStringWithTab(string _data, string _tab) {
-	cout &lt;&lt; &quot;begin getStringWithTab&quot; &lt;&lt; endl;
-	cout &lt;&lt; &quot;tab=\&quot;&quot; &lt;&lt; _tab &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
-	cout &lt;&lt; &quot;begin datae&quot; &lt;&lt; endl;
-	cout &lt;&lt; _data &lt;&lt; endl;
-	cout &lt;&lt; &quot;end datae&quot; &lt;&lt; endl;
-	int pos = -1;
- 
-	// test too another new line sequences
-	while( ( pos = _data.find( &quot;\n&quot;, pos + 1 ) ) != -1 ) {
-		_data.insert( pos + 1, _tab );
-	}
- 
-	cout &lt;&lt; &quot;begin datas&quot; &lt;&lt; endl;
-	cout &lt;&lt; _data &lt;&lt; endl;
-	cout &lt;&lt; &quot;end datas&quot; &lt;&lt; endl;
-	return( _data );
-}
-*/
-
-bool streamtoken(istringstream&amp; stream, string&amp; key, string&amp; val) {
-     /* FIXME: leak, --felipek */
-     char buffer[8192];
-     unsigned int delim;
-     string entry;
-//     bool ret;
-
-     /* FIXME: ret type, -- felipek */
-     stream.getline(buffer, 8192 - 1);
-     entry = string(buffer);
-     delim = entry.find(' ', 0);
-
-     if (delim != entry.npos) {
-         key = entry.substr(0, delim);
-         val = entry.substr(delim + 1);
-     }
-
-     return !stream.eof();
-}
-
-
-const string typeToText(const int &amp;type)
-{
-//    if (type == PortugolParserTokenTypes::T_INT_LIT) {
-//       return &quot;int&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_CARAC_LIT) {
-//       return &quot;char&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_STRING_LIT) {
-//       return &quot;string&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_REAL_LIT) {
-//       return &quot;real&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_IDENTIFICADOR) {
-//       return &quot;id&quot;;
-//    }
-// 
-//    return &quot;ERRO !!!&quot;;
-}
-
-const string typeInAsm( const int &amp;type )
-{
-//    if (type == PortugolParserTokenTypes::T_KW_INTEIRO) {
-//       return &quot;int&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_LITERAL) {
-//       return &quot;string&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_CARACTERE) {
-//       return &quot;char&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_LOGICO) {
-//       return &quot;bool&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_REAL) {
-//       return &quot;real&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_CORINGA) {
-//       return &quot;pointer ???&quot;;
-//    } else if (type == PortugolParserTokenTypes::T_KW_MATRIZ) {
-//       return &quot;matrix&quot;;
-//    }
-
-   return &quot;ERRO !!!&quot;;
-}
-
-
-const int typeToLiteral( const int &amp;type )
-{
-//    switch (type) {
-//       case PortugolParserTokenTypes::T_KW_INTEIRO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-//       case PortugolParserTokenTypes::T_KW_LITERAL:
-//          return PortugolParserTokenTypes::T_STRING_LIT;
-//       case PortugolParserTokenTypes::T_KW_CARACTERE:
-//          return PortugolParserTokenTypes::T_CARAC_LIT;
-//       case PortugolParserTokenTypes::T_KW_LOGICO:
-//          return PortugolParserTokenTypes::T_INT_LIT;
-// //      case PortugolParserTokenTypes::T_KW_CORINGA:
-// //         return &quot;pointer ???&quot;;
-// //      case PortugolParserTokenTypes::T_KW_MATRIZ:
-// //          return PortugolParserTokenTypes::T_MATRIZ;
-//       default:
-//           return 0;
-//           // trow exception ???
-//    }
-}
-

Deleted: trunk/gpt2/gptc/src/Tools.hpp
===================================================================
--- trunk/gpt2/gptc/src/Tools.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Tools.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,39 +0,0 @@
-#ifndef GPT_TOOLS_H
-#define GPT_TOOLS_H
-
-#include &lt;iomanip&gt;
-
-#include &lt;iostream&gt;
-#include &lt;string&gt;
-#include &lt;cstdlib&gt;
-#include &lt;cstring&gt;
-#include &lt;cmath&gt;
-#include &lt;cstdio&gt;
-#include &lt;sstream&gt;
-using namespace std;
-
-
-int hexToInt(const char *);
-string pad(string, unsigned int);
-string lpad(string, unsigned int);
-string intToHex(unsigned int, int = -1);
-string strZero(string, unsigned int);
-string strZero(int, unsigned int);
-string dataToHex(char *, unsigned int);
-string dataToHex( char *, unsigned int, unsigned int);
-int binToInt(const char *);
-int octToInt(const char *);
-string itoa(int);
-string itobool(int);
-string ftos(double);
-string strtoupper(string);
-string strToUpperWithEscapeControls(string);
-string alltrim(string);
-string wo_ctrl_chrs(string str, char = ' ');
-bool streamtoken(istringstream&amp;, string&amp;, string&amp;);
-// string&amp; getStringWithTab(string, string);
-const string typeToText(const int &amp;type);
-const string typeInAsm( const int &amp;type );
-const int typeToLiteral( const int &amp;type );
-
-#endif

Deleted: trunk/gpt2/gptc/src/Types.cpp
===================================================================
--- trunk/gpt2/gptc/src/Types.cpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Types.cpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,726 +0,0 @@
-#include &quot;Types.hpp&quot;
-#include &quot;TokenLabels.hpp&quot;
-
-#include &lt;iostream&gt;
-#include &lt;sstream&gt;
-
-
-//************* GENERAL *********************************/
-
-void Type::setConst(bool c) {
-  _isConst = c;
-}
-
-void Type::setRef(bool c) {
-  _isRef = c;
-}
-
-bool Type::isConst() const {
-  return _isConst;
-}
-
-bool Type::isRef()   const {
-  return _isRef;
-}
-
-bool Type::isError() const {
-  if (_typeId == ERROR) {
-    return true;
-  }
-
-  if (isMatrix() &amp;&amp; _ofType-&gt;isError()) {
-    return true;
-  }
-
-  if (isStruct() &amp;&amp; _fields.typeList().hasErrorType()) {
-    return true;
-  }
-
-  if (isSubprogram() &amp;&amp;
-     (_returnType-&gt;isError() || _paramTypes.hasErrorType())) {
-    return true;
-  }
-  return false;
-}
-
-bool Type::isPrimitive() const {
-  return _typeId == PRIMITIVE;
-}
-
-bool Type::isMatrix() const {
-  return _typeId == MATRIX;
-}
-
-bool Type::isStruct() const {
-  return _typeId == STRUCT;
-}
-
-bool Type::isSubprogram() const {
-  return _typeId == SUBPROGRAM;
-}
-
-const std::string&amp; Type::name() const {
-  return _name;
-}
-
-std::string Type::asmName(bool complete) const {
-  std::stringstream stream;
-
-  switch (_typeId) {
-    case PRIMITIVE:
-      switch (_id) {
-        case T_INTEIRO:
-          return &quot;int&quot;;
-        case T_REAL:
-          return &quot;real&quot;;
-        case T_LITERAL:
-          return &quot;string&quot;;
-        case T_CARACTERE:
-          return &quot;char&quot;;
-        case T_LOGICO:
-          return &quot;bool&quot;;
-        case T_CORINGA:
-          return &quot;pointer&quot;;
-      }
-      throw;
-    case MATRIX:
-      return &quot;matrix&quot;;
-    case STRUCT:
-      if (!complete) {
-        return &quot;data&quot;;
-      } else {
-        stream &lt;&lt; &quot;data[&quot; &lt;&lt; byteSize() &lt;&lt; &quot;]&quot;;
-        return stream.str();
-      }
-    default:
-      throw;
-  }
-}
-
-const std::string&amp; Type::identifier() const {
-  return _identifier;
-}
-
-int Type::byteSize() const {
-  int ret = 0;
-  switch (_typeId) {
-    case PRIMITIVE:
-      switch(primitiveType()) {
-        case T_INTEIRO:    
-        case T_CARACTERE:
-        case T_LITERAL:
-        case T_LOGICO:
-        case T_CORINGA:
-          return sizeof(int);
-        case T_REAL:
-          return sizeof(double);
-        default:
-          throw;
-      }
-    case MATRIX:
-      return sizeof(void*);
-    case STRUCT:      
-      for (SymbolList::const_iterator it = _fields.begin(); it != _fields.end(); ++it) {
-        ret += (*it).type()-&gt;byteSize();
-      }
-      return ret;
-    case SUBPROGRAM:
-    default:
-      throw;
-  }
-}
-
-bool Type::equals(int id) const {
-  return isPrimitive() &amp;&amp; (_id == id);
-}
-
-bool Type::equals(Type* ofType, int dimensions) const {
-  return isMatrix() &amp;&amp; (dimensions == (int) _dimensions.size()) &amp;&amp;
-          _ofType-&gt;equals(ofType);
-}
-
-/************* VIRTUAL *********************************/
-
-Type* Type::attrPromotion(Type* other) {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_attrPromotion(other);
-    case MATRIX:
-      return matrix_attrPromotion(other);
-    case STRUCT:
-      return struct_attrPromotion(other);
-    case SUBPROGRAM:
-      return NULL;
-    default:
-      throw;
-  }
-}
-
-bool Type::equals(const Type* other) const {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_equals(other);
-    case MATRIX:
-      return matrix_equals(other);
-    case STRUCT:
-      return struct_equals(other);
-    case SUBPROGRAM:
-      return subprogram_equals(other);
-    default:
-      throw;
-  }
-}
-
-
-bool Type::isLValueFor(Type* rtype) {
-  switch (_typeId) {
-    case PRIMITIVE:
-      return primitive_isLValueFor(rtype);
-    case MATRIX:
-      return matrix_isLValueFor(rtype);
-    case STRUCT:
-      return struct_isLValueFor(rtype);
-    case SUBPROGRAM:
-      return false;
-    default:
-      throw;
-  }
-}
-
-
-
-//************* ERROR *********************************/
-
-
-Type::Type(TypeBuilder* builder)
-  : _typeId(ERROR), _builder(builder), _isConst(false), _isRef(false),
-    _name(&quot;erro&quot;), _identifier(_name) {
-}
-
-//************* PRIMITIVE *********************************/
-
-
-
-Type::Type(TypeBuilder* builder, int id, const std::string&amp; name)
-  : _typeId(PRIMITIVE), _builder(builder), _isConst(false), _isRef(false),
-    _name(name), _identifier(name), _id(id) {
-}
-
-int Type::primitiveType() const {
-  return _id;
-}
-
-Type* Type::intOrReal(Type* other) {
-  if (!isPrimitive() || !other-&gt;isPrimitive()) {
-    return NULL;
-  }
-
-  if ((_id == T_INTEIRO)
-       &amp;&amp;
-      (other-&gt;equals(T_INTEIRO) ||
-       other-&gt;equals(T_REAL))) {
-    return _builder-&gt;primitiveType(other-&gt;primitiveType());
-  } else if ((_id == T_REAL)
-              &amp;&amp;
-             (other-&gt;equals(T_INTEIRO) ||
-              other-&gt;equals(T_REAL))) {
-    return this;
-  }
-
-  return NULL;
-}
-
-Type* Type::caracOrLit(Type* other) {
-  if (!isPrimitive() || !other-&gt;isPrimitive()) {
-    return NULL;
-  }
-
-  if ((_id == T_LITERAL)
-       &amp;&amp;
-      (other-&gt;equals(T_LITERAL) ||
-       other-&gt;equals(T_CARACTERE))) {
-    return this;
-  } else if (other-&gt;equals(T_LITERAL)
-              &amp;&amp;
-             ((_id == T_CARACTERE) ||
-              (_id == T_LITERAL))) {
-    return _builder-&gt;primitiveType(other-&gt;primitiveType());
-  }
-
-  return NULL;
-}
-
-
-Type* Type::primitive_attrPromotion(Type* other) {
-  if (!other-&gt;isPrimitive()) {
-    return NULL;
-  }
-
-  if (primitive_equals(other)) {
-    return other;
-  }
-
-  if (equals(T_CORINGA)) {
-    return other;
-  }
-
-  if (other-&gt;equals(T_CORINGA)) {
-    return this;
-  }
-
-  return intOrReal(other);
-}
-
-bool Type::primitive_equals(const Type* other) const {
-  return other-&gt;isPrimitive() &amp;&amp; (other-&gt;_id == _id);
-}
-
-bool Type::primitive_isLValueFor(Type* rvalue) {
-  if (equals(rvalue)) {
-    return true;
-  }
-
-  if ((_id == T_REAL) &amp;&amp;
-      rvalue-&gt;equals(T_INTEIRO)) {
-    return true;
-  }
-
-  if (equals(T_CORINGA) || rvalue-&gt;equals(T_CORINGA)) {
-    return true;
-  }
-
-  return false;
-}
-
-/************* MATRIX *********************************/
-
-
-Type::Type(TypeBuilder* builder, Type* type, const std::list&lt;int&gt;&amp; dimensions)
-  : _typeId(MATRIX), _builder(builder), _isConst(false), _isRef(false),
-    _ofType(type), _dimensions(dimensions) {
-
-/*
-  if (!_ofType-&gt;isPrimitive() &amp;&amp; _ofType-&gt;isStruct()) {
-    throw; //ofType soh pode ser do tipo primitivo ou estrutura
-  }
-
-  if (_dimensions &lt;= 0) {
-    throw;
-  }
-*/
-
-  _name       = &quot;matriz&quot;;
-  _identifier = &quot;matriz&quot;;
-
-  for (int i = 0; i &lt; (int)_dimensions.size(); i++) {
-    _name       += &quot;[]&quot;;
-    _identifier += &quot;_d&quot;;
-  }
-  _name       += &quot; do tipo &quot; + _ofType-&gt;name();
-  _identifier += &quot;_tipo_&quot;    + _ofType-&gt;identifier();
-}
-
-Type* Type::ofType() const {
-  return _ofType;
-}
-
-const std::list&lt;int&gt;&amp; Type::dimensions() const {
-  return _dimensions;
-}
-
-Type* Type::evalTypeFromSubscript(int dimensions) {
-  if (!isMatrix()) {
-    return NULL;
-  }
-
-  if (dimensions == 0) {
-    return this;
-  } else if (dimensions == (int)_dimensions.size()) {
-    return _ofType;
-  } else {
-    return _builder-&gt;matrixType(_ofType, _dimensions.size() - dimensions);
-  }
-}
-
-Type* Type::matrix_attrPromotion(Type* other) {
-  if (!other-&gt;isMatrix()) {
-    return NULL;
-  }
-
-  Type *ofProm = _ofType-&gt;attrPromotion(other-&gt;_ofType);
-  if (!ofProm) {
-    return NULL;
-  } else {
-    return _builder-&gt;matrixType(ofProm, _dimensions);
-  }
-}
-
-bool Type::matrix_equals(const Type* other) const {
-  return other-&gt;isMatrix() &amp;&amp;
-         equals(other-&gt;_ofType, other-&gt;_dimensions.size());
-}
-
-bool Type::matrix_isLValueFor(Type* rvalue) {
-  if (rvalue-&gt;isMatrix() &amp;&amp;
-      (rvalue-&gt;_dimensions.size() == _dimensions.size()) &amp;&amp;
-      _ofType-&gt;isLValueFor(rvalue-&gt;_ofType)) {
-    return true;
-  }
-
-  if (rvalue-&gt;isPrimitive() &amp;&amp; rvalue-&gt;equals(T_CORINGA)) {
-    return true;
-  }
-  return false;
-}
-
-
-
-/******************** STRUCT *********************************/
-
-
-Type::Type(TypeBuilder* builder,
-           const std::string&amp; name,
-           const SymbolList&amp; fields,
-           const std::string&amp; unit, int line)
-  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name(name), _identifier(name), _anonymous(false), _fields(fields),
-    _unit(unit), _line(line) {
-
-  _name = _name + &quot;:{&quot;;
-  std::string v = &quot;&quot;;
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + &quot;:&quot; + (*it).type()-&gt;name();
-    v = &quot;,&quot;;
-  }
-  _name += &quot;}&quot;;
-}
-
-
-Type::Type(TypeBuilder* builder, const SymbolList&amp; fields)
-  : _typeId(STRUCT), _builder(builder), _isConst(false), _isRef(false),
-    _name(&quot;&lt;an&#244;nimo&gt;&quot;), _identifier(&quot;_an&#244;nimo_&quot;), 
-    _anonymous(true), _fields(fields),
-    _unit(&quot;&lt;interno&gt;&quot;), _line(-1) {
-
-  _name += &quot;:{&quot;;
-  std::string v = &quot;&quot;;
-  for (SymbolList::const_iterator it = fields.begin(); it != fields.end(); ++it) {
-    _name += v + (*it).lexeme() + &quot;:&quot; + (*it).type()-&gt;name();
-    v = &quot;,&quot;;
-  }
-  _name += &quot;}&quot;;
-}
-
-const SymbolList&amp; Type::fields() const {
-  return _fields;
-}
-
-Type* Type::struct_attrPromotion(Type* other) {
-  if (!other-&gt;isStruct()) {
-    return NULL;
-  }
-
-  SymbolList                 retFieldList;
-  Type                       *promoType;
-  SymbolList::const_iterator otherFieldIt;
-  SymbolList::iterator       it;
-
-
-  for (it = _fields.begin(); it != _fields.end(); ++it) {
-    otherFieldIt = other-&gt;fields().findByIdentifier((*it).identifier());
-    if (otherFieldIt == other-&gt;fields().end()) { //structs diferentes
-      return NULL;
-    } else {
-      promoType = (*it).type()-&gt;attrPromotion((*otherFieldIt).type());
-      if (!promoType) {
-        return NULL;
-      } else {
-        retFieldList.push_back(Symbol((*it).lexeme(), promoType));
-      }
-    }
-  }
-
-  return _builder-&gt;structType(retFieldList);
-}
-
-bool Type::struct_equals(const Type* other) const {
-  if (!other-&gt;isStruct()) {
-    return false;
-  }
-
-  if ((_anonymous  &amp;&amp; other-&gt;_anonymous) ||
-      (!_anonymous &amp;&amp; !other-&gt;_anonymous)) {
-    //comparacao estrutural
-    return _fields.equivalent(other-&gt;_fields);
-  } else {
-    //comparacao nominal
-    return _name == other-&gt;_name;
-  }
-}
-
-
-bool Type::struct_isLValueFor(Type* rtype) {
-  if (rtype-&gt;isPrimitive() &amp;&amp; rtype-&gt;equals(T_CORINGA)) {
-    return true;
-  }
-
-  if (!rtype-&gt;isStruct()) {
-    return false;
-  }
-
-  if (!_anonymous &amp;&amp; !rtype-&gt;_anonymous) {
-    return equals(rtype);
-  } else {
-    return fieldsIsLValueFor(rtype-&gt;_fields);
-  }
-}
-
-bool Type::fieldsIsLValueFor(const SymbolList&amp; others) {
-  if (_fields.size() != others.size()) {
-    return false;
-  }
-
-  SymbolList::const_iterator it, jt;
-  for (it = _fields.begin(); it != _fields.end(); ++it) {
-    jt = others.findByIdentifier((*it).identifier());
-    if (jt == others.end()) {
-      return false;
-    } else if (!(*it).type()-&gt;isLValueFor((*jt).type())) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-/******************** SUBPROGRAM *********************************/
-
-Type::Type(TypeBuilder* builder,
-           const TypeList&amp; paramTypes,
-           Type* returnType)
-  : _typeId(SUBPROGRAM), _builder(builder), _isConst(false), _isRef(false),
-    _paramTypes(paramTypes), _returnType(returnType) {
-
-  if (!_returnType) {
-    _name = &quot;proc(&quot;;
-  } else {
-    _name = &quot;func(&quot;;
-  }
-
-  _name += _paramTypes.toString();
-  _name += &quot;)&quot;;
-
-  _identifier = _paramTypes.toIdentifier();
-
-  if (_returnType) {
-    _name       += &quot; : &quot; + _returnType-&gt;name();
-  }
-}
-
-
-const TypeList&amp; Type::paramTypes() const {
-  return _paramTypes;
-}
-
-Type* Type::returnType() const {
-  return _returnType;
-}
-
-// bool Type::paramMatches(const TypeList&amp; types) const {
-//   return _paramTypes.matches(types);
-// }
-
-bool Type::subprogram_equals(const Type* other) const {
-  return other-&gt;isSubprogram() &amp;&amp;
-         (_paramTypes == other-&gt;_paramTypes) &amp;&amp;
-         (_returnType-&gt;equals(other-&gt;_returnType));
-}
-
-
-
-
-/******************** TYPELIST *********************************/
-
-
-
-
-
-TypeList::iterator TypeList::find(const std::string&amp; lexeme) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)-&gt;identifier() == lexeme) {
-      return it;
-    }
-  }
-  return end();
-}
-
-TypeList::iterator TypeList::find(Type* ofType, int dimensions) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)-&gt;equals(ofType, dimensions)) {
-      return it;
-    }
-  }
-  return end();
-}
-
-TypeList::iterator TypeList::find(int id) {
-  iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)-&gt;equals(id)) {
-      return it;
-    }
-  }
-  return end();
-}
-
-bool TypeList::equals(const TypeList&amp; other) const {
-  const_iterator it;
-  const_iterator jt;
-
-  if (size() != other.size()) {
-    return false;
-  }
-
-  for (it = begin(), jt = other.begin();
-      (it != end()) &amp;&amp; (jt != other.end()); ++it, ++jt) {
-    if (!(*it)-&gt;equals(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool TypeList::isLValueFor(const TypeList&amp; other) const {
-  const_iterator it;
-  const_iterator jt;
-
-  if (size() != other.size()) {
-    return false;
-  }
-
-  for (it = begin(), jt = other.begin();
-      (it != end()) &amp;&amp; (jt != other.end()); ++it, ++jt) {
-    if (!(*it)-&gt;isLValueFor(*jt)) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-bool TypeList::hasErrorType() const {
-  const_iterator it;
-
-  for (it = begin(); it != end(); ++it) {
-    if ((*it)-&gt;isError()) {
-      return true;
-    }
-  }
-  return false;
-}
-
-
-std::string TypeList::toString() const {
-  std::string ret = &quot;&quot;;
-  std::string v = &quot;&quot;;
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    ret += v + (*it)-&gt;name();
-    v = &quot;,&quot;;
-  }
-  return ret;
-}
-
-std::string TypeList::toIdentifier() const {
-  std::string ret = &quot;&quot;;
-  const_iterator it;
-  for (it = begin(); it != end(); ++it) {
-    ret += &quot;_&quot; + (*it)-&gt;identifier();
-  }
-  return ret;
-}
-
-/********************************************************************/
-
-Type* TypeBuilder::primitiveType(int id) {
-  Type* ret = new Type(this, id, g_tokenLabels[id]);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::matrixType(Type* ofType,
-                              const std::list&lt;int&gt;&amp; dimensions) {
-  Type* ret = new Type(this, ofType, dimensions);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::matrixType(Type* ofType, int dimensions) {
-  std::list&lt;int&gt; dims(dimensions);
-  Type* ret = new Type(this, ofType, dims);
-  _types.push_back(ret);
-  return ret;
-}
-
-
-Type* TypeBuilder::structType(const std::string&amp; name,
-                    const SymbolList&amp; fields,
-                    const std::string&amp; unit,
-                    int line) {
-
-  Type* ret = new Type(this, name, fields, unit, line);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::structType(const SymbolList&amp; fields) {
-  Type* ret = new Type(this, fields);
-  _types.push_back(ret);
-  return ret;
-}
-
-/*
-  estrutura Par&#226;metro
-    tipo  : literal;
-    valor : coringa;
-  fim-estrutura
-
-  procedimento p( ... args)
-
-  -&gt; args : matriz[] do tipo Par&#226;metro
-*/
-Type* TypeBuilder::reticencesType() {
-  SymbolList fields;
-
-  fields.push_back(Symbol(&quot;tipo&quot;,
-    primitiveType(PortugolTokenTypes::T_LITERAL)));
-
-  fields.push_back(Symbol(&quot;valor&quot;,
-    primitiveType(PortugolTokenTypes::T_CORINGA)));
-
-  return matrixType(
-    structType(&quot;Par&#226;metro&quot;, fields, &quot;&lt;interno&gt;&quot;,-1), std::list&lt;int&gt;(1));
-}
-
-Type*
-TypeBuilder::subprogramType(const TypeList&amp; paramTypes, Type* returnType) {
-  Type* ret = new Type(this, paramTypes, returnType);
-  _types.push_back(ret);
-  return ret;
-}
-
-Type* TypeBuilder::errorType() {
-  return new Type(this);
-}
-
-
-TypeList&amp; TypeBuilder::typeList() {
-  return _types;
-}
-

Deleted: trunk/gpt2/gptc/src/Types.hpp
===================================================================
--- trunk/gpt2/gptc/src/Types.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/Types.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,177 +0,0 @@
-#ifndef TYPES_HPP
-#define TYPES_HPP
-
-#include &lt;string&gt;
-#include &lt;list&gt;
-
-#include &quot;PortugolTokenTypes.hpp&quot;
-#include &quot;Symbol.hpp&quot;
-
-class TypeBuilder;
-class Type;
-
-class TypeList : public std::list&lt;Type*&gt; {
-public:
-
-  iterator find(const std::string&amp; lexeme);
-
-  iterator find(Type* ofType, int dimensions);
-
-  iterator find(int id);
-
-
-  bool isLValueFor(const TypeList&amp;) const;
-  bool equals(const TypeList&amp;) const;
-
-  bool hasErrorType() const;
-
-  std::string toString() const;
-  std::string toIdentifier() const;
-};
-
-
-
-
-class Type : private PortugolTokenTypes {
-public:
-  enum { PRIMITIVE, MATRIX, STRUCT, SUBPROGRAM, ERROR };
-
-  //Error type
-  Type(TypeBuilder*);
-
-  //Primitive
-  Type(TypeBuilder*, int id, const std::string&amp; name);
-  int primitiveType() const;
-
-  Type* intOrReal(Type* other);
-  Type* caracOrLit(Type* other);
-
-
-  //Matrix
-  Type(TypeBuilder*, Type* ofType, const std::list&lt;int&gt;&amp; dimensions);
-
-  Type*                    ofType() const;
-  const std::list&lt;int&gt;&amp;    dimensions() const;
-
-  Type*                    evalTypeFromSubscript(int);
-
-  //Struct
-  Type(TypeBuilder*,
-       const std::string&amp; name,
-       const SymbolList&amp; fields,
-       const std::string&amp; unit, int line);
-
-  Type(TypeBuilder*, const SymbolList&amp; fields);
-
-  const SymbolList&amp; fields() const;
-  bool fieldsIsLValueFor(const SymbolList&amp;);
-
-  //Subprogram
-  Type(TypeBuilder*, const TypeList&amp; paramTypes, Type* returnType);
-
-  const TypeList&amp; paramTypes() const;
-  Type* returnType() const;
-//   bool  paramMatches(const TypeList&amp;) const;
-
-
-  /* General Methods */
-  void setConst(bool);
-  void setRef(bool);
-  bool isConst() const;
-  bool isRef()   const;
-
-  bool isError() const;
-  bool isPrimitive() const;
-  bool isMatrix() const;
-  bool isStruct() const;
-  bool isSubprogram() const;
-
-  const std::string&amp; name() const;
-  std::string asmName(bool = false) const;
-  const std::string&amp; identifier() const;
-
-  int byteSize() const;
-
-  bool equals(int id) const;
-  bool equals(Type* ofType, int dimensions) const;
-
-
-
-  //virtual
-  Type* attrPromotion(Type*);
-  bool  equals(const Type* other) const;
-  bool  isLValueFor(Type* rtype);
-
-
-  //impl primitive
-  Type* primitive_attrPromotion(Type* other);
-  bool  primitive_equals(const Type* other) const;
-  bool  primitive_isLValueFor(Type* rvalue);
-
-  //impl matrix
-  Type* matrix_attrPromotion(Type* other);
-  bool matrix_equals(const Type* other) const;
-  bool matrix_isLValueFor(Type* rvalue);
-
-  //impl struct
-  Type* struct_attrPromotion(Type* other);
-  bool struct_equals(const Type* other) const;
-  bool struct_isLValueFor(Type* rtype);
-
-  //impl subprogram
-  bool subprogram_equals(const Type* other) const;
-
-private:
-  int          _typeId;
-  TypeBuilder* _builder;
-
-  bool         _isConst;
-  bool         _isRef;
-
-  std::string  _name;
-  std::string  _identifier;
-
-  //Primitive
-  int         _id;
-
-  //matrix
-  Type             *_ofType;
-  std::list&lt;int&gt;   _dimensions;
-
-  //struct
-  bool             _anonymous;
-  SymbolList       _fields;
-  std::string      _unit;
-  int              _line;
-
-  //Subprogram
-  TypeList         _paramTypes;
-  Type*            _returnType;
-};
-
-class TypeBuilder {
-public:
-  Type* primitiveType(int id);
-
-  Type* matrixType(Type* ofType, const std::list&lt;int&gt;&amp; dimensions);
-  Type* matrixType(Type* ofType, int);
-
-  Type* structType(const std::string&amp; name,
-                   const SymbolList&amp; fields,
-                   const std::string&amp; unit,
-                   int line);
-
-  Type* structType(const SymbolList&amp; fields);
-
-  Type* reticencesType();
-
-  Type* subprogramType(const TypeList&amp; paramTypes, Type* returnType);
-
-  Type* errorType();
-
-  TypeList&amp; typeList();
-private:
-  TypeList  _types;
-};
-
-#endif

Deleted: trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp
===================================================================
--- trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,83 +0,0 @@
-#ifndef INC_UnicodeCharBuffer_hpp__
-#define INC_UnicodeCharBuffer_hpp__
-
-#include &lt;istream&gt;
-#include &lt;cassert&gt;
-#include &lt;antlr/config.hpp&gt;
-#include &lt;antlr/InputBuffer.hpp&gt;
-#include &lt;antlr/CharStreamIOException.hpp&gt;
-
-class ANTLR_API UnicodeCharBuffer : public antlr::InputBuffer {
-public:
-	typedef unsigned int char_type;	// should be 32 bits!
-
-	/// Create a character buffer
-	UnicodeCharBuffer(std::istream&amp; inp)
-	: input(inp)
-	{
-		//	input.exceptions(std::ios_base::badbit|
-		//						  std::ios_base::failbit);
-	}
-	/// Get the next character from the stream
-	int getChar()
-	{
-		char_type ch = 0;
-		int inchar = input.get();
-		if( inchar == EOF )
-			return -1;
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-		if( (inchar &amp; 0x80) == 0 )
-			return inchar;
-
-		unsigned int need = 0;
-		if( (inchar &amp; 0xF8) == 0xF8 )
-		{
-			ch = inchar &amp; 7;
-			need = 3;
-		}
-		else if( (inchar &amp; 0xE0) == 0xE0 )
-		{
-			ch = inchar &amp; 0xF;
-			need = 2;
-		}
-		else if( (inchar &amp; 0xC0) == 0xC0 )
-		{
-			ch = inchar &amp; 0x1F;
-			need = 1;
-		}
-		else
-		{
-			assert(&quot;Invalid UTF8&quot;);
-		}
-		while( need )
-		{
-			inchar = input.get();
-			if( inchar == EOF )
-				assert(&quot;Invalid UTF8&quot;);
-//				throw antlr::CharStreamIOException(std::logic_error());
-			ch &lt;&lt;= 6;
-			ch += inchar &amp; 0x3F;
-			need--;
-		}
-		return ch;
-	}
-private:
-	// character source
-	std::istream&amp; input;
-
-	// NOTE: Unimplemented
-	UnicodeCharBuffer(const UnicodeCharBuffer&amp; other);
-	UnicodeCharBuffer&amp; operator=(const UnicodeCharBuffer&amp; other);
-};
-
-#endif //INC_UnicodeCharBuffer_hpp__

Deleted: trunk/gpt2/gptc/src/UnicodeCharScanner.hpp
===================================================================
--- trunk/gpt2/gptc/src/UnicodeCharScanner.hpp	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/UnicodeCharScanner.hpp	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,561 +0,0 @@
-#ifndef INC_UnicodeCharScanner_hpp__
-#define INC_UnicodeCharScanner_hpp__
-
-#include &lt;map&gt;
-#include &lt;cctype&gt;
-
-#include &lt;antlr/config.hpp&gt;
-#include &lt;antlr/CommonToken.hpp&gt;
-#include &lt;antlr/TokenStream.hpp&gt;
-#include &lt;antlr/RecognitionException.hpp&gt;
-#include &lt;antlr/SemanticException.hpp&gt;
-#include &lt;antlr/InputBuffer.hpp&gt;
-#include &lt;antlr/BitSet.hpp&gt;
-#include &lt;antlr/LexerSharedInputState.hpp&gt;
-
-#include &quot;MismatchedUnicodeCharException.hpp&quot;
-
-/** Superclass of generated lexers
- */
-class UnicodeCharScanner : public antlr::TokenStream {
-protected:
-	typedef antlr::RefToken (*factory_type)();
-public:
-	typedef int char_type;
-	typedef std::map&lt;std::string,int&gt; string_map;
-
-	UnicodeCharScanner( antlr::InputBuffer&amp; cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( antlr::InputBuffer* cb, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(new antlr::LexerInputState(cb))
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
-	}
-	UnicodeCharScanner( const antlr::LexerSharedInputState&amp; state, bool case_sensitive )
-	: saveConsumedInput(true)
-	, caseSensitive(case_sensitive)
-	, literals()
-	, inputState(state)
-	, commitToPath(false)
-	, tabsize(8)
-	, traceDepth(0)
-	{
-		setTokenObjectFactory(&amp;antlr::CommonToken::factory);
-	}
-
-	virtual ~UnicodeCharScanner()
-	{
-	}
-
-	virtual char_type LA(char_type i)
-	{
-		char_type c = inputState-&gt;getInput().LA(i);
-		return c;
-	}
-
-	virtual void append(char_type c)
-	{
-		if (saveConsumedInput)
-		{
-			size_t len = text.length();
-
-			if( (len % 256) == 0 )
-				text.reserve(len+256);
-
-// This is how UTF8 is encoded
-// +---------------------------+----------+----------+----------+----------+
-// | Unicode scalar            | 1st      | 2nd      | 3th      | 4th      |
-// +---------------------------+----------+----------+----------+----------+
-// |00000000 0xxxxxxx          | 0xxxxxxx |          |          |          |
-// |00000yyy yyxxxxxx          | 110yyyyy | 10xxxxxx |          |          |
-// |zzzzyyyy yyxxxxxx          | 1110zzzz | 10yyyyyy | 10xxxxxx |          |
-// |000uuuuu zzzzyyyy yyxxxxxx | 11110uuu | 10uuzzzz | 10yyyyyy | 10xxxxxx |
-// +---------------------------+----------+----------+----------+----------+
-
-			if (c &lt; 0x80)
-			{
-				text += c;
-				return;
-			}
-			else if (c &lt; 0x800)
-			{
-				text += ( (c &gt;&gt; 6) | 0xC0 );
-				text += ( c &amp; 0x3F | 0x80 );
-			}
-			else if (c &lt; 0x10000)
-			{
-				text += ( (c &gt;&gt; 12) | 0xE0 );
-				text += ( ((c &gt;&gt; 6) &amp; 0x3F) | 0x80 );
-				text += ( (c &amp; 0x3F) | 0x80 );
-			}
-			else if (c &lt; 0x200000)
-			{
-				text += ( (c &gt;&gt; 18) | 0xF0 );				// first 3 bits
-				text += ( (((c &gt;&gt; 16) &amp; 0x3) &lt;&lt; 4) |
-								 ((c &gt;&gt; 12) &amp; 0xF) | 0x80 );
-				text += ( ((c &gt;&gt; 6) &amp; 0x3F) | 0x80 );
-				text += ( (c &amp; 0x3F) | 0x80 );
-			}
-			else
-				assert(0);
-		}
-	}
-
-	virtual void append(const std::string&amp; s)
-	{
-		assert(0);
-		if (saveConsumedInput)
-			text+=s;
-	}
-
-	virtual void commit()
-	{
-		inputState-&gt;getInput().commit();
-	}
-
-	virtual void consume()
-	{
-		if (inputState-&gt;guessing == 0)
-		{
-			char_type c = LA(1);
-			append(c);
-			inputState-&gt;column++;
-		}
-		inputState-&gt;getInput().consume();
-	}
-
-	/** Consume chars until one matches the given char */
-	virtual void consumeUntil(char_type c)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast&lt;char_type&gt;(EOF_CHAR) == la_1 || la_1 == c )
-				break;
-			consume();
-		}
-	}
-
-	/** Consume chars until one matches the given set */
-	virtual void consumeUntil(const antlr::BitSet&amp; set)
-	{
-		for(;;)
-		{
-			char_type la_1 = LA(1);
-			if( static_cast&lt;char_type&gt;(EOF_CHAR) == la_1 || set.member(la_1) )
-				break;
-			consume();
-		}
-	}
-
-	/// Mark the current position and return a id for it
-	virtual unsigned int mark()
-	{
-		return inputState-&gt;getInput().mark();
-	}
-
-	/// Rewind the scanner to a previously marked position
-	virtual void rewind(unsigned int pos)
-	{
-		inputState-&gt;getInput().rewind(pos);
-	}
-
-	/// See if input contains character 'c' throw MismatchedUnicodeCharException if not
-	virtual void match(char_type c)
-	{
-		char_type la_1 = LA(1);
-		if ( la_1 != c )
-			throw MismatchedUnicodeCharException(la_1, c, false, this);
-		consume();
-	}
-
-	/** See if input contains element from bitset b
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void match(const antlr::BitSet&amp; b)
-	{
-		char_type la_1 = LA(1);
-
-		if ( !b.member(la_1) )
-			throw MismatchedUnicodeCharException( la_1, b, false, this );
-		consume();
-	}
-
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match( const char* s )
-	{
-		while( *s != '\0' )
-		{
-			// the &amp; 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (*s++ &amp; 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input contains string 's' throw MismatchedUnicodeCharException if not
-	 * @note the string cannot match EOF
-	 */
-	virtual void match(const std::string&amp; s)
-	{
-		size_t len = s.length();
-
-		for (size_t i = 0; i &lt; len; i++)
-		{
-			// the &amp; 0xFF is here to prevent sign extension lateron
-			char_type la_1 = LA(1), c = (s[i] &amp; 0xFF);
-
-			if ( la_1 != c )
-				throw MismatchedUnicodeCharException(la_1, c, false, this);
-
-			consume();
-		}
-	}
-	/** See if input does not contain character 'c'
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchNot(char_type c)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 == c )
-			throw MismatchedUnicodeCharException(la_1, c, true, this);
-
-		consume();
-	}
-	/** See if input contains character in range c1-c2
-	 * throw MismatchedUnicodeCharException if not
-	 */
-	virtual void matchRange(char_type c1, char_type c2)
-	{
-		char_type la_1 = LA(1);
-
-		if ( la_1 &lt; c1 || la_1 &gt; c2 )
-			throw MismatchedUnicodeCharException(la_1, c1, c2, false, this);
-
-		consume();
-	}
-
-	/// Get the line the scanner currently is in (starts at 1)
-	virtual int getLine() const
-	{
-		return inputState-&gt;line;
-	}
-
-	/// set the line number
-	virtual void setLine(int l)
-	{
-		inputState-&gt;line = l;
-	}
-
-	/// Get the column the scanner currently is in (starts at 1)
-	virtual int getColumn() const
-	{
-		return inputState-&gt;column;
-	}
-	/// set the column number
-	virtual void setColumn(int c)
-	{
-		inputState-&gt;column = c;
-	}
-
-	/// get the filename for the file currently used
-	virtual const std::string&amp; getFilename() const
-	{
-		return inputState-&gt;filename;
-	}
-	/// Set the filename the scanner is using (used in error messages)
-	virtual void setFilename(const std::string&amp; f)
-	{
-		inputState-&gt;filename = f;
-	}
-
-	virtual bool getCommitToPath() const
-	{
-		return commitToPath;
-	}
-
-	virtual void setCommitToPath(bool commit)
-	{
-		commitToPath = commit;
-	}
-
-	/** return a copy of the current text buffer */
-	virtual const std::string&amp; getText() const
-	{
-		return text;
-	}
-
-	virtual void setText(const std::string&amp; s)
-	{
-		text = s;
-	}
-
-	virtual void resetText()
-	{
-		text = &quot;&quot;;
-		inputState-&gt;tokenStartColumn = inputState-&gt;column;
-		inputState-&gt;tokenStartLine = inputState-&gt;line;
-	}
-
-	virtual antlr::RefToken getTokenObject() const
-	{
-		return _returnToken;
-	}
-
-	///{ These need different handling in unicode case
-
-	virtual bool getCaseSensitiveLiterals() const=0;
-
-	virtual bool getCaseSensitive() const
-	{
-		return caseSensitive;
-	}
-
-	virtual void setCaseSensitive(bool t)
-	{
-		caseSensitive = t;
-	}
-
-	/** Override this method to get more specific case handling
-	 * @note some platforms probably require setting the right locale for
-	 * correct functioning.
-	 */
-	virtual char_type toLower(char_type c) const
-	{
-		return std::tolower(c);
-	}
-
-	/** Used to keep track of line breaks, needs to be called from
-	 * within generated lexers when a \n \r is encountered.
-	 */
-	virtual void newline()
-	{
-		++inputState-&gt;line;
-		inputState-&gt;column = 1;
-	}
-
-	/** Advance the current column number by an appropriate amount according
-	 * to the tabsize. This method needs to be explicitly called from the
-	 * lexer rules encountering tabs.
-	 */
-	virtual void tab()
-	{
-		int c = getColumn();
-		int nc = ( ((c-1)/tabsize) + 1) * tabsize + 1;      // calculate tab stop
-		setColumn( nc );
-	}
-	/// set the tabsize. Returns the old tabsize
-	int setTabsize( int size )
-	{
-		int oldsize = tabsize;
-		tabsize = size;
-		return oldsize;
-	}
-	/// Return the tabsize used by the scanner
-	int getTabSize() const
-	{
-		return tabsize;
-	}
-	///}
-
-	/** Report exception errors caught in nextToken() */
-	virtual void reportError(const antlr::RecognitionException&amp; ex)
-	{
-		std::cerr &lt;&lt; ex.toString().c_str() &lt;&lt; std::endl;
-	}
-
-	/** Parser error-reporting function can be overridden in subclass */
-	virtual void reportError(const std::string&amp; s)
-	{
-		if (getFilename() == &quot;&quot;)
-			std::cerr &lt;&lt; &quot;error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-		else
-			std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-	}
-
-	/** Parser warning-reporting function can be overridden in subclass */
-	virtual void reportWarning(const std::string&amp; s)
-	{
-		if (getFilename() == &quot;&quot;)
-			std::cerr &lt;&lt; &quot;warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-		else
-			std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-	}
-
-	virtual antlr::InputBuffer&amp; getInputBuffer()
-	{
-		return inputState-&gt;getInput();
-	}
-
-	virtual antlr::LexerSharedInputState getInputState()
-	{
-		return inputState;
-	}
-
-	/** set the input state for the lexer.
-	 * @note state is a reference counted object, hence no reference */
-	virtual void setInputState(antlr::LexerSharedInputState state)
-	{
-		inputState = state;
-	}
-
-	/// Set the factory for created tokens
-	virtual void setTokenObjectFactory(factory_type factory)
-	{
-		tokenFactory = factory;
-	}
-
-	/** Test the token text against the literals table
-	 * Override this method to perform a different literals test
-	 */
-	virtual int testLiteralsTable(int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** Test the text passed in against the literals table
-	 * Override this method to perform a different literals test
-	 * This is used primarily when you want to test a portion of
-	 * a token
-	 */
-	virtual int testLiteralsTable(const std::string&amp; text, int ttype) const
-	{
-		string_map::const_iterator i = literals.find(text);
-		if (i != literals.end())
-			ttype = (*i).second;
-		return ttype;
-	}
-
-	/** This method is called by YourLexer::nextToken() when the lexer has
-	 *  hit EOF condition.  EOF is NOT a character.
-	 *  This method is not called if EOF is reached during
-	 *  syntactic predicate evaluation or during evaluation
-	 *  of normal lexical rules, which presumably would be
-	 *  an IOException.  This traps the &quot;normal&quot; EOF condition.
-	 *
-	 *  uponEOF() is called after the complete evaluation of
-	 *  the previous token and only if your parser asks
-	 *  for another token beyond that last non-EOF token.
-	 *
-	 *  You might want to throw token or char stream exceptions
-	 *  like: &quot;Heh, premature eof&quot; or a retry stream exception
-	 *  (&quot;I found the end of this file, go back to referencing file&quot;).
-	 */
-	virtual void uponEOF()
-	{
-	}
-
-	/// Methods used to change tracing behavior
-	void traceIndent()
-	{
-		for( int i = 0; i &lt; traceDepth; i++ )
-			std::cout &lt;&lt; &quot; &quot;;
-	}
-
-	void traceIn(const char* rname)
-	{
-		traceDepth++;
-		traceIndent();
-		std::cout &lt;&lt; &quot;&gt; lexer &quot; &lt;&lt; rname
-			&lt;&lt; &quot;; c==&quot; &lt;&lt; LA(1) &lt;&lt; std::endl;
-	}
-
-	void traceOut(const char* rname)
-	{
-		traceIndent();
-		std::cout &lt;&lt; &quot;&lt; lexer &quot; &lt;&lt; rname
-			&lt;&lt; &quot;; c==&quot; &lt;&lt; LA(1) &lt;&lt; std::endl;
-		traceDepth--;
-	}
-
-#ifndef NO_STATIC_CONSTS
-	static const int EOF_CHAR = EOF;
-#else
-	enum {
-		EOF_CHAR = EOF
-	};
-#endif
-protected:
-	std::string text; ///&lt; Text of current token
- 	/// flag indicating wether consume saves characters
-	bool saveConsumedInput;
-	factory_type tokenFactory;				///&lt; Factory for tokens
-	bool caseSensitive; 						///&lt; Is this lexer case sensitive
-	string_map literals;						 // set by subclass
-
-	antlr::RefToken _returnToken;		///&lt; used to return tokens w/o using return val
-
-	/// Input state, gives access to input stream, shared among different lexers
-	antlr::LexerSharedInputState inputState;
-
-	/** Used during filter mode to indicate that path is desired.
-	 * A subsequent scan error will report an error as usual
-	 * if acceptPath=true;
-	 */
-	bool commitToPath;
-
-	unsigned int tabsize; 	///&lt; tab size the scanner uses.
-
-	/// Create a new RefToken of type t
-	virtual antlr::RefToken makeToken(int t)
-	{
-		antlr::RefToken tok = tokenFactory();
-		// actually at this point you want to convert the stored lexeme text
-		// into the format you want to have it in in the backend...
-		tok-&gt;setType(t);
-		tok-&gt;setColumn(inputState-&gt;tokenStartColumn);
-		tok-&gt;setLine(inputState-&gt;tokenStartLine);
-		return tok;
-	}
-
-	/** Tracer class, used when -traceLexer is passed to antlr
-	 */
-	class Tracer {
-	private:
-		UnicodeCharScanner* parser;
-		const char* text;
-
-		Tracer(const Tracer&amp; other); 					// undefined
-		Tracer&amp; operator=(const Tracer&amp; other); 	// undefined
-	public:
-		Tracer( UnicodeCharScanner* p, const char* t )
-		: parser(p), text(t)
-		{
-			parser-&gt;traceIn(text);
-		}
-		~Tracer()
-		{
-			parser-&gt;traceOut(text);
-		}
-	};
-
-	int traceDepth;
-private:
-	UnicodeCharScanner( const UnicodeCharScanner&amp; other ); 		  		// undefined
-	UnicodeCharScanner&amp; operator=( const UnicodeCharScanner&amp; other );	// undefined
-};
-
-#endif //INC_UnicodeCharScanner_hpp__

Copied: trunk/gpt2/gptc/src/common/CompilerError.cpp (from rev 420, trunk/gpt2/gptc/src/CompilerError.cpp)

Copied: trunk/gpt2/gptc/src/common/CompilerError.hpp (from rev 420, trunk/gpt2/gptc/src/CompilerError.hpp)

Added: trunk/gpt2/gptc/src/common/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/common/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/common/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,5 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src/symboltable -I../parser
+
+noinst_LTLIBRARIES = libcommon.la
+libcommon_la_SOURCES = CompilerError.cpp CompilerError.hpp PortugolAST.cpp \
+	PortugolAST.hpp

Copied: trunk/gpt2/gptc/src/common/PortugolAST.cpp (from rev 423, trunk/gpt2/gptc/src/PortugolAST.cpp)

Copied: trunk/gpt2/gptc/src/common/PortugolAST.hpp (from rev 423, trunk/gpt2/gptc/src/PortugolAST.hpp)

Deleted: trunk/gpt2/gptc/src/gptasm.g
===================================================================
--- trunk/gpt2/gptc/src/gptasm.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/gptasm.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,301 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include &quot;BaseGptAsmWalker.hpp&quot;
-  #include &quot;PortugolAST.hpp&quot;
-  #include &quot;GptAsmExpression.hpp&quot;
-  #include &quot;AsmProgram.hpp&quot;
-  #include &quot;SymbolTable.hpp&quot;
-}
-
-options {
-  language=&quot;Cpp&quot;;
-}
-
-class GptAsmWalker extends TreeParser(&quot;BaseGptAsmWalker&quot;);
-options {
-  importVocab    = Portugol;
-  noConstructors = true;
-  genHashLines   = false;
-  ASTLabelType   = &quot;RefPortugolAST&quot;;
-}
-
-{
-public:
-  GptAsmWalker::GptAsmWalker(SymbolTable* symtable,
-                             const std::string&amp; filepath)
-	 : BaseGptAsmWalker(symtable, filepath) {}
-}
-
-
-programa
-  : #(T_ALGORITMO                {_asmPrg-&gt;init();}
-
-        (importacao)*
-
-        (declaracoes)?
-
-        (corpo)?
-                                {_asmPrg-&gt;finishSubroutine(_subroutine);}
-        EOF
-     )
-                                {_asmPrg-&gt;finish();}
-  ;
-
-importacao
-  : #(T_USE T_TEXTO_LITERAL)
-  ;
-
-declaracoes
-  : declaracao_variavel[false]    (declaracoes)?
-  | declaracao_constante[false]   (declaracoes)?
-  | declaracao_estrutura          (declaracoes)?
-  ;
-
-declaracao_variavel[bool isLocal]
-
-                                          {std::list&lt;std::string&gt; ids;}
-
-  : #(T_VARIAVEL tipo ids=identificadores
-                                          {
-                                            if (isLocal) {
-                                              declareSubroutineVars(ids);
-                                            } else {
-                                              declareProgramVars(ids);
-                                            }
-                                          }
-//       (
-//         code=valor_inicialiacao            {addPrologue(code);}
-//       )?
-    )
-  ;
-
-declaracao_constante[bool isLocal]
-                                          {std::list&lt;std::string&gt; ids;}
-
-  : #(T_CONSTANTE tipo ids=identificadores /*code=valor_inicialiacao*/)
-
-                                          {
-                                            if (isLocal) {
-                                              declareSubroutineVars(ids);
-                                            } else {
-                                              declareProgramVars(ids);
-                                            }
-                                          }
-  ;
-
-identificadores returns [std::list&lt;std::string&gt; ids]
-  : (id:T_IDENTIFICADOR {ids.push_back(id-&gt;getText());})+
-  ;
-
-tipo
-  : T_IDENTIFICADOR
-  | T_MATRIZ
-  | T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-declaracao_estrutura
-  : #(T_ESTRUTURA T_IDENTIFICADOR (campo_estrutura)+)
-  ;
-
-campo_estrutura
-                      {std::list&lt;std::string&gt; ids;}
-
-  : #(T_VARIAVEL tipo ids=identificadores
-//       (
-//         valor_inicialiacao
-//       )?
-    )
-  ;
-
-
-
-
-/////////////////////////////////////////////////////////////
-
-
-
-
-/************************** EXPRESSOES *************************/
-
-
-expressao returns [GptAsmExpression* ret]
-
-  : #(T_EXPRESSAO ret=expr)
-  ;
-
-expr returns [GptAsmExpression* ret]
-
-                        {
-                          GptAsmExpression *l, *r;
-                          Type *optype = _t-&gt;getEvalType();
-                        }
-
-  : #(T_OU              l=expr r=expr) {ret=expr_OU(optype, l, r);}
-  | #(T_E               l=expr r=expr) {ret=expr_E(optype, l, r);}
-  | #(T_BIT_OU          l=expr r=expr) {ret=expr_BIT_OU(optype, l, r);}
-  | #(T_BIT_OUX         l=expr r=expr) {ret=expr_BIT_XOU(optype, l, r);}
-  | #(T_BIT_E           l=expr r=expr) {ret=expr_BIT_E(optype, l, r);}
-  | #(T_IGUAL           l=expr r=expr) {ret=expr_IGUAL(optype, l, r);}
-  | #(T_DIFERENTE       l=expr r=expr) {ret=expr_DIFERENTE(optype, l, r);}
-  | #(T_MAIOR           l=expr r=expr) {ret=expr_MAIOR(optype, l, r);}
-  | #(T_MENOR           l=expr r=expr) {ret=expr_MENOR(optype, l, r);}
-  | #(T_MAIOR_EQ        l=expr r=expr) {ret=expr_MAIOR_EQ(optype, l, r);}
-  | #(T_MENOR_EQ        l=expr r=expr) {ret=expr_MENOR_EQ(optype, l, r);}
-  | #(T_BIT_SHIFT_LEFT  l=expr r=expr) {ret=expr_BIT_SHIFT_LEFT(optype, l, r);}
-  | #(T_BIT_SHIFT_RIGHT l=expr r=expr) {ret=expr_BIT_SHIFT_RIGHT(optype, l, r);}
-  | #(T_MAIS            l=expr r=expr) {ret=expr_MAIS(optype, l, r);}
-  | #(T_MENOS           l=expr r=expr) {ret=expr_MENOS(optype, l, r);}
-  | #(T_DIV             l=expr r=expr) {ret=expr_DIV(optype, l, r);}
-  | #(T_MULTIP          l=expr r=expr) {ret=expr_MULTIP(optype, l, r);}
-  | #(T_MOD             l=expr r=expr) {ret=expr_MOD(optype, l, r);}
-  | #(T_UN_NEGATIVO     l=elemento)  {ret=expr_UN_NEGATIVO(optype,l);}
-  | #(T_UN_POSITIVO     l=elemento)  {ret=expr_UN_POSITIVO(optype,l);}
-  | #(T_NAO             l=elemento)  {ret=expr_UN_NAO(optype,l);}
-  | #(T_BIT_NAO         l=elemento)  {ret=expr_BIT_NAO(optype,l);}
-  | ret=elemento
-  ;
-
-
-elemento returns [GptAsmExpression* ret]
-                      {
-                        Symbol lv;
-                      }
-  : ret=literal
-  | lv=lvalue         {ret = new GptAsmExpression(lv.type(), lv.identifier());}
-//   | ret=chamada_subrotina
-  | #(T_EXPRESSAO ret=expr)
-  ;
-
-literal returns [GptAsmExpression* ret]
-
-                                    {
-                                      Type *type = _t-&gt;getEvalType();
-                                      std::string value;
-                                    }
-
-  : (   t:T_TEXTO_LITERAL           {value = '&quot;' + t-&gt;getText() + '&quot;';}
-      | i:T_INTEIRO_LITERAL         {value = i-&gt;getText();}
-      | r:T_REAL_LITERAL            {value = r-&gt;getText();}
-      | c:T_CARACTERE_LITERAL       {value = &quot;'&quot; + c-&gt;getText() + &quot;'&quot;;}
-      | v:T_VERDADEIRO              {value = &quot;true&quot;;}
-      | f:T_FALSO                   {value = &quot;false&quot;;}
-    )
-      {ret = new GptAsmExpression(type, value);}
-  ;
-
-
-lvalue returns [Symbol ret]
-
-  : #(lv:T_LVALUE 
-      id:T_IDENTIFICADOR  
-
-                     {ret = _symtable-&gt;getSymbol(id-&gt;getText());}
-
-//       (
-//_subroutine-&gt;declareTmp(lv-&gt;getEvalType());
-//         lvalue_indices[lv]
-//       )?
-
-//       (
-//         lvalue_membro
-//       )?
-    )
-  ;
-
-
-lvalue_indices[const std::string id]
-                                {
-                                  std::list&lt;std::string&gt; dimensions;
-                                  std::string tmp;
-                                }
-  : #(T_SUBSCRITO
-        (
-                                {/*tmp = _subroutine-&gt;newTmp();*/}
-          expressao
-                                {dimensions.push_back(tmp);}
-        )+
-    )
-//                                 {ret = expandOffset(id, dimensions);}
-  ;
-
-
-lvalue_membro
-  : #(T_MEMBRO lvalue)
-  ;
-
-
-
-
-
-
-
-
-corpo
-  :  bloco_codigo           /*(corpo_subprograma)**/
-//   |  corpo_subprograma      (corpo)?
-  ;
-
-bloco_codigo
-  : #(T_INICIO lista_enunciados)
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-  : en_atribuicao
-/*  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-  | T_SAIR
-  | chamada_subrotina*/
-  ;
-
-en_atribuicao
-                      {
-                        Symbol lv;
-                        GptAsmExpression *expr;
-                      }
-  : #(T_ATRIBUICAO
-        lv=lvalue
-
-        expr=expressao
-                      {                        
-                        if (expr-&gt;isAtom()) {
-                          emitAttribution(lv, expr-&gt;value());
-                        } else {
-                          expr-&gt;expand(lv.identifier(), _subroutine);
-                        }
-                        delete expr;
-                      }
-      )
-  ;
-

Copied: trunk/gpt2/gptc/src/gptasm_target/Arguments.cpp (from rev 438, trunk/gpt2/gptc/src/Arguments.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Arguments.hpp (from rev 432, trunk/gpt2/gptc/src/Arguments.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/AsmProgram.cpp (from rev 438, trunk/gpt2/gptc/src/AsmProgram.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/AsmProgram.hpp (from rev 432, trunk/gpt2/gptc/src/AsmProgram.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.cpp (from rev 438, trunk/gpt2/gptc/src/BaseGptAsmWalker.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/BaseGptAsmWalker.hpp (from rev 438, trunk/gpt2/gptc/src/BaseGptAsmWalker.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Context.cpp (from rev 432, trunk/gpt2/gptc/src/Context.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Context.hpp (from rev 432, trunk/gpt2/gptc/src/Context.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.cpp (from rev 438, trunk/gpt2/gptc/src/GptAsmExpression.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/GptAsmExpression.hpp (from rev 438, trunk/gpt2/gptc/src/GptAsmExpression.hpp)

Added: trunk/gpt2/gptc/src/gptasm_target/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/gptasm_target/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,22 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I../parser \
+           -I$(top_srcdir)/src/symboltable -I$(top_srcdir)/src/common
+
+noinst_LTLIBRARIES = libgptasm.la
+
+EXTRA_DIST = gptasm.g
+
+BUILT_SOURCES = GptAsmWalker.hpp GptAsmWalker.cpp
+
+
+libgptasm_la_SOURCES = Arguments.cpp Arguments.hpp AsmProgram.cpp AsmProgram.hpp\
+	BaseGptAsmWalker.cpp BaseGptAsmWalker.hpp Context.cpp Context.hpp\
+	GptAsmExpression.cpp GptAsmExpression.hpp Options.hpp Subroutine.cpp\
+	Subroutine.hpp TextFile.cpp TextFile.hpp Tools.cpp Tools.hpp $(BUILT_SOURCES)
+
+CLEANFILES = GptAsmWalkerTokenTypes.hpp \
+             GptAsmWalker.cpp \
+						 GptAsmWalker.hpp  \
+             GptAsmWalkerTokenTypes.txt
+
+GptAsmWalker.hpp GptAsmWalker.cpp: $(srcdir)/gptasm.g Makefile
+	$(ANTLR_BIN) $(srcdir)/gptasm.g

Copied: trunk/gpt2/gptc/src/gptasm_target/Options.hpp (from rev 432, trunk/gpt2/gptc/src/Options.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Subroutine.cpp (from rev 438, trunk/gpt2/gptc/src/Subroutine.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Subroutine.hpp (from rev 438, trunk/gpt2/gptc/src/Subroutine.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/TextFile.cpp (from rev 432, trunk/gpt2/gptc/src/TextFile.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/TextFile.hpp (from rev 432, trunk/gpt2/gptc/src/TextFile.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Tools.cpp (from rev 432, trunk/gpt2/gptc/src/Tools.cpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/Tools.hpp (from rev 432, trunk/gpt2/gptc/src/Tools.hpp)

Copied: trunk/gpt2/gptc/src/gptasm_target/gptasm.g (from rev 438, trunk/gpt2/gptc/src/gptasm.g)

Deleted: trunk/gpt2/gptc/src/lexer.g
===================================================================
--- trunk/gpt2/gptc/src/lexer.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/lexer.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,615 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include &lt;string&gt;
-  #include &lt;sstream&gt;
-  #include &lt;iostream&gt;
-  #include &lt;ctype.h&gt;
-  #include &quot;UnicodeCharBuffer.hpp&quot;
-  #include &quot;UnicodeCharScanner.hpp&quot;
-}
-
-options {
-  language=&quot;Cpp&quot;;
-}
-
-class PortugolLexer extends Lexer(&quot;UnicodeCharScanner&quot;);
-
-options {
-  k=2;
-  genHashLines   = false;
-  exportVocab    = Portugol;
-  filter         = T_INVALIDO;
-  testLiterals   = false;
-}
-
-tokens {
-  T_ALGORITMO=&quot;algoritmo&quot;;
-  T_USE=&quot;use&quot;;
-  T_VARIAVEL=&quot;vari&#225;vel&quot;;
-  T_VARIAVEIS=&quot;vari&#225;veis&quot;;
-  T_FIM_VARIAVEIS=&quot;fim-vari&#225;veis&quot;;
-  T_INTEIRO=&quot;inteiro&quot;;
-  T_REAL=&quot;real&quot;;
-  T_CARACTERE=&quot;caractere&quot;;
-  T_LITERAL=&quot;literal&quot;;
-  T_LOGICO=&quot;l&#243;gico&quot;;
-  T_CORINGA=&quot;coringa&quot;;
-  T_MATRIZ=&quot;matriz&quot;;
-  T_DO=&quot;do&quot;;
-  T_TIPO=&quot;tipo&quot;;
-  T_CONSTANTE=&quot;constante&quot;;
-  T_CONSTANTES=&quot;constantes&quot;;
-  T_FIM_CONSTANTES=&quot;fim-constantes&quot;;
-  T_ESTRUTURA=&quot;estrutura&quot;;
-  T_FIM_ESTRUTURA=&quot;fim-estrutura&quot;;
-  T_FUNCAO=&quot;fun&#231;&#227;o&quot;;
-  T_PROCEDIMENTO=&quot;procedimento&quot;;
-  T_REF=&quot;ref&quot;;
-  T_INICIO=&quot;in&#237;cio&quot;;
-  T_FIM=&quot;fim&quot;;
-  T_SAIR=&quot;sair&quot;;
-  T_RETORNE=&quot;retorne&quot;;
-  T_SE=&quot;se&quot;;
-  T_ENTAO=&quot;ent&#227;o&quot;;
-  T_SENAO=&quot;sen&#227;o&quot;;
-  T_FIM_SE=&quot;fim-se&quot;;
-  T_ENQUANTO=&quot;enquanto&quot;;
-  T_FACA=&quot;fa&#231;a&quot;;
-  T_FIM_ENQUANTO=&quot;fim-enquanto&quot;;
-  T_PARA=&quot;para&quot;;
-  T_DE=&quot;de&quot;;
-  T_ATE=&quot;at&#233;&quot;;
-  T_FIM_PARA=&quot;fim-para&quot;;
-  T_PASSO=&quot;passo&quot;;
-  T_REPITA=&quot;repita&quot;;
-  T_CASO=&quot;caso&quot;;
-  T_SEJA=&quot;seja&quot;;
-  T_FIM_SENAO=&quot;fim-sen&#227;o&quot;;
-  T_FIM_CASO=&quot;fim-caso&quot;;
-  T_FIM_FACA=&quot;fim-fa&#231;a&quot;;
-  T_OU=&quot;ou&quot;;
-  T_E=&quot;e&quot;;
-  T_NAO=&quot;n&#227;o&quot;;
-  T_VERDADEIRO=&quot;verdadeiro&quot;;
-  T_FALSO=&quot;falso&quot;;
-  T_ASM=&quot;asm&quot;;
-  T_FIMASM=&quot;fim-asm&quot;;  
-
-  T_REAL_LITERAL=&quot;n&#250;mero real&quot;; //a regra T_INTEIRO_LITERAL lida com reais
-  
-  //imagin&#225;rios para a AST
-
-  T_NULO=&quot;nulo&quot;;
-  T_LVALUE;
-  
-
-  T_PARAM;
-  T_TIPO_RETORNO;
-
-  T_VALOR;
-  T_VAL_MATRIZ;    //valor da matriz    (literal [])
-  T_VAL_ESTRUTURA; //valor da estrutura (literal {})
-
-  T_EXPRESSAO;
-
-//   T_DIMENSOES;
-  T_SUBSCRITO;
-  T_MEMBRO;
-
-  T_UN_POSITIVO;
-  T_UN_NEGATIVO;
-
-  T_CALL;
-}
-
-
-{
-public:
-  PortugolLexer(std::istream&amp; in, bool case_s)
-   : UnicodeCharScanner(new UnicodeCharBuffer(in), case_s)
-    {
-      initLiterals();
-    }
-
-private:
-
-  std::string toBase10(const std::string&amp; oct, int from) {
-    std::stringstream stream;
-    unsigned long long base10;
-    base10 = strtoull(oct.c_str(), NULL, from);
-    stream &lt;&lt; base10;
-    return stream.str();
-  }
-
-  bool isOctal(const std::string&amp; num) {
-    std::stringstream s;
-    if ((num.find(&quot;8&quot;,0)  != std::string::npos) ||
-        (num.find(&quot;9&quot;,0)  != std::string::npos)) {
-      return false;
-    } else {
-      for (unsigned int i = 2; i &lt; num.length(); ++i) {
-        if (!isdigit(num[i])) {
-          return false;
-        }
-      }
-    }
-    return true;
-  }
-
-  bool isHex(const std::string&amp; num) {
-    for (unsigned int i = 2; i &lt; num.length(); ++i) {
-      if (!isxdigit(num[i])) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  bool isBin(const std::string&amp; num) {
-    for(unsigned int i = 2; i &lt; num.length(); ++i) {
-      if ((num[i] != '0') &amp;&amp; (num[i] != '1')) {
-        return false;
-      }
-    }
-    return true;
-  }
-}
-
-
-//####################################
-//##             Regras             ##
-//####################################
-
-
-
-T_ESPACO :
-  (   ' '
-    | '\t'
-    | '\n' { newline(); }
-    | '\r'
-  )
-  { $setType(antlr::Token::SKIP); }
-  ;
-
-COMENTARIO_CPP
-  : &quot;//&quot; (~('\n'))* ('\n')?
-    {
-      newline();
-      $setType(antlr::Token::SKIP);
-    }
-  ;
-
-COMENTARIO_C
-{int line = getLine();}
-  : &quot;/*&quot;
-    (
-      options { generateAmbigWarnings=false; } :
-        '\n'                     {newline();}
-      | ('\r' '\n')=&gt; '\r' '\n'  {newline();}
-      | '\r'                     {newline();}
-      |~('*'|'\n'|'\r')
-      | ('*' ~'/' )=&gt; '*'
-    )*
-    &quot;*/&quot;
-    {$setType(antlr::Token::SKIP);}
-  ;
-exception
-catch[antlr::RecognitionException] {
-  std::stringstream s;
-  //aviso! n&#227;o &#233; erro!
-  s &lt;&lt; &quot;coment&#225;rio iniciado na linha &quot; &lt;&lt; line &lt;&lt; &quot; n&#227;o termina com \&quot;*/\&quot;.&quot;;
-  std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
-  $setType(antlr::Token::SKIP);
-}
-
-T_PONTO_VIRGULA
-options {
-  paraphrase = &quot;';'&quot;;
-}
-  : ';'
-  ;
-
-T_VIRGULA
-options {
-  paraphrase = &quot;','&quot;;
-}
-  : ','
-  ;
-
-T_2_PONTOS
-options {
-  paraphrase = &quot;':'&quot;;
-}
-
-  : ':'
-  ;
-
-T_ABRE_CHAVE
-options {
-  paraphrase = &quot;'['&quot;;
-}
-  : '['
-  ;
-
-T_FECHA_CHAVE
-options {
-  paraphrase = &quot;']'&quot;;
-}
-  : ']'
-  ;
-
-T_ABRE_COLCHETE
-options {
-  paraphrase = &quot;'{'&quot;;
-}
-  : '{'
-  ;
-
-T_FECHA_COLCHETE
-options {
-  paraphrase = &quot;'}'&quot;;
-}
-  : '}'
-  ;
-
-T_ABRE_PAREN
-options {
-  paraphrase = &quot;'('&quot;;
-}
-  : '('
-  ;
-T_FECHA_PAREN
-options {
-  paraphrase = &quot;')'&quot;;
-}
-  : ')'
-  ;
-
-T_ATRIBUICAO
-options {
-  paraphrase = &quot;':='&quot;;
-}
-  : &quot;:=&quot;
-  ;
-
-T_BIT_OU
-options {
-  paraphrase = &quot;operador '|'&quot;;
-}
-  : '|'
-  ;
-
-T_BIT_OUX
-options {
-  paraphrase = &quot;operador '^'&quot;;
-}
-  : '^'
-  ;
-
-T_BIT_E
-options {
-  paraphrase = &quot;operador '&amp;'&quot;;
-}
-  : '&amp;'
-  ;
-
-T_BIT_NAO
-options {
-  paraphrase = &quot;operador '~'&quot;;
-}
-  : '~'
-  ;
-
-T_BIT_SHIFT_LEFT
-options {
-  paraphrase = &quot;operador '&lt;&lt;'&quot;;
-}
-  : &quot;&lt;&lt;&quot;
-  ;
-
-T_BIT_SHIFT_RIGHT
-options {
-  paraphrase = &quot;operador '&gt;&gt;'&quot;;
-}
-
-  : &quot;&gt;&gt;&quot;
-  ;
-
-T_IGUAL
-options {
-  paraphrase = &quot;operador '='&quot;;
-}
-  : '='
-  ;
-
-T_DIFERENTE
-options {
-  paraphrase = &quot;operador '&lt;&gt;'&quot;;
-}
-  : &quot;&lt;&gt;&quot;
-  ;
-
-T_MAIOR
-options {
-  paraphrase = &quot;operador '&gt;'&quot;;
-}
-  : '&gt;'
-  ;
-
-T_MAIOR_EQ
-options {
-  paraphrase = &quot;operador '&gt;='&quot;;
-}
-  : &quot;&gt;=&quot;
-  ;
-
-T_MENOR
-options {
-  paraphrase = &quot;operador '&lt;'&quot;;
-}
-  : '&lt;'
-  ;
-T_MENOR_EQ
-options {
-  paraphrase = &quot;operador '&lt;='&quot;;
-}
-  : &quot;&lt;=&quot;
-  ;
-
-T_MAIS
-options {
-  paraphrase = &quot;operador '+'&quot;;
-}
-  : '+'
-  ;
-
-T_MENOS
-options {
-  paraphrase = &quot;operador '-'&quot;;
-}
-  : '-'
-  ;
-
-T_DIV
-options {
-  paraphrase = &quot;operador '/'&quot;;
-}
-  : '/'
-  ;
-
-T_MULTIP
-options {
-  paraphrase = &quot;operador '*'&quot;;
-}
-  : '*'
-  ;
-
-T_MOD
-options {
-  paraphrase = &quot;operador '%'&quot;;
-}
-  : '%'
-  ;
-
-/* Literais */
-
-
-T_INTEIRO_LITERAL
-options {
-  paraphrase = &quot;n&#250;mero inteiro&quot;;
-}
-  : ('0' ('c'|'C') )=&gt; T_OCTAL_LIT
-  | ('0' ('x'|'X') )=&gt; T_HEX_LIT
-  | ('0' ('b'|'B') )=&gt; T_BIN_LIT
-  | (T_DIGITO)+
-    (
-      '.' (T_DIGITO)+
-      {$setType(T_REAL_LITERAL);}
-    )?
-  ;
-
-T_TEXTO_LITERAL
-options {
-  paraphrase = &quot;literal&quot;;
-}
-  : '&quot;'! ( ~( '&quot;' | '\\' | '\n' | '\r') | T_ESCAPE )* '&quot;'!
-  ;
-
-
-T_CARACTERE_LITERAL
-options {
-  paraphrase = &quot;caractere&quot;;
-}
-  : '\''! ( ~( '\'' | '\\' ) | T_ESCAPE )? '\''!
-  ;
-
-
-
-/*
-  Ok, um pouco de malabarismo...
-
-  Eis o problema:
-
-  N&#243;s precisamos que uma string como &quot;fim-vari&#225;veis&quot; seja
-  identificada pelo scanner. Para isso, as keywords em tokens{} devem
-  ser cobertos pelas regras T_*. No caso, T_IDENTIFICADOR
-  costuma ser a regra que identifica keywords.
-
-  Por&#233;m, &quot;fim-vari&#225;veis&quot; n&#227;o &#233; um identificador v&#225;lido
-  (ambig. com &quot;fim - vari&#225;veis&quot;).
-
-  Ent&#227;o, T_IDENTIFICADOR aqui representa a regra mais geral poss&#237;vel,
-  para cobrir as keywords em tokens{}. Mas, para o caso problem&#225;tico
-  de T_IDENTIFICADOres com &quot;-&quot;, verificamos se o lexema atual
-  &#233; uma keyword ou um identificador seguido de T_MENOS, utilizando
-  &quot;testLiteralsTable&quot; manualmente.
-
-  Se testLiteralsTable indicar que o lexema atual com hifen for uma keyword,
-  &#233; a pr&#243;pria, obviamente.
-
-  Se n&#227;o, trata-se de um ID seguido de T_MENOS. Ent&#227;o, fazemos o rollback
-  at&#233; o ponto do hifen.
-*/
-
-T_IDENTIFICADOR
-options {
-  testLiterals = true;
-}
-  { int m = -1,len; }
-
-  : T_ID_AUX
-      {
-        len = $getText.length();
-        if (LA(1) == '-') {
-          m = mark();
-        }
-      }
-
-    ('-' (T_LETRA_OU_DIGITO)*)?
-  {
-    if ((m != -1) &amp;&amp; (testLiteralsTable(_ttype) == T_IDENTIFICADOR)) {
-      rewind(m);
-      std::string s = $getText;
-      $setText(s.substr(0,len));
-    }
-  }
-  ;
-
-
-T_RETICENCIAS
-options {
-  paraphrase = &quot;retic&#234;ncias (...)&quot;;
-}
-  : &quot;...&quot;
-  ;
-
-T_PONTO
-options {
-  paraphrase = &quot;ponto (.)&quot;;
-}
-  : '.'
-  ;
-
-//####################################
-//##            Protecteds          ##
-//####################################
-
-
-protected
-T_ESCAPE
-  : '\\' .  /* ex. \a */
-  ;
-
-protected
-T_DIGITO
-  : '0'..'9'
-  ;
-
-protected
-T_LETRA
-  : 'a'..'z'|'A'..'Z' | '\u00C0' .. '\u00FF' /* latim-1 */
-  ;
-
-
-protected
-T_LETRA_OU_DIGITO
-  : T_LETRA | T_DIGITO | '_'
-  ;
-
-
-//mais detalhes em T_IDENTIFICADOR
-protected
-T_ID_AUX
-  : (T_LETRA | '_') (T_LETRA_OU_DIGITO)*
-  ;
-
-protected
-T_OCTAL_LIT
-  : '0' ('c'|'C') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isOctal(str)) {
-      $setText(toBase10(str.substr(2), 8));
-    } else {
-      std::stringstream s;
-      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero octal v&#225;lido&quot;;
-      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
-    }
-  }
-  ;
-
-protected
-T_HEX_LIT
-  : '0' ('x'|'X') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isHex(str)) {
-      $setText(toBase10(str, 16));
-    } else {
-      std::stringstream s;
-      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero hexadecimal v&#225;lido&quot;;
-      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
-    }
-  }
-  ;
-
-protected
-T_BIN_LIT
-  : '0' ('b'|'B') (T_LETRA_OU_DIGITO)+ //T_LETRA_OU_DIGITO:
-                                        //apenas para exibir
-                                        //erro precisamente
-  {
-    std::string str = $getText;
-    if (isBin(str)) {
-      $setText(toBase10(str.substr(2), 2));
-    } else {
-      std::stringstream s;
-      s &lt;&lt; &quot;\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\&quot; n&#227;o &#233; um n&#250;mero bin&#225;rio v&#225;lido&quot;;
-      std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
-    }
-  }
-  ;
-
-protected
-T_INVALIDO
-  : .
-    {
-      //caracteres de espa&#231;o inexistentes na tabela ascii
-      //([160] == [-96] == ' ' == [32] == 160-128)
-      if ($getText.c_str()[0] == (int)0xffffffa0) {
-        $setType(antlr::Token::SKIP);
-      } else {
-        std::stringstream s;
-        if (($getText != &quot;\&quot;&quot;) &amp;&amp; ($getText != &quot;'&quot;)) {
-          s &lt;&lt; &quot;Caractere inv&#225;lido: \&quot;&quot; &lt;&lt; $getText &lt;&lt; &quot;\&quot;.\n&quot;;
-          s &lt;&lt; &quot;Verifique se a codifica&#231;&#227;o do texto est&#225; em UTF-8&quot;;
-        } else {
-          s &lt;&lt; &quot;Faltando fechar aspas&quot;;
-        }
-        std::cerr &lt;&lt; s.str() &lt;&lt; &quot;, na linha &quot; &lt;&lt; getLine() &lt;&lt; std::endl;
-      }
-    }
-  ;

Added: trunk/gpt2/gptc/src/parser/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/parser/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,62 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common
+
+EXTRA_DIST = lexer.g parser.g
+
+noinst_LTLIBRARIES = libparser.la
+
+BUILT_SOURCES = PortugolLexer.hpp \
+                PortugolLexer.cpp \
+                PortugolParser.hpp \
+                PortugolParser.cpp \
+                TokenNames.hpp \
+                TokenLabels.hpp
+
+libparser_la_SOURCES = MismatchedUnicodeCharException.cpp \
+	MismatchedUnicodeCharException.hpp UnicodeCharBuffer.hpp \
+	UnicodeCharScanner.hpp $(BUILT_SOURCES)
+
+
+CLEANFILES = PortugolLexer.cpp \
+             PortugolLexer.hpp \
+             PortugolTokenTypes.hpp \
+             PortugolTokenTypes.txt \
+             PortugolParser.cpp \
+						 PortugolParser.hpp  \
+             PortugolParserTokenTypes.hpp \
+             PortugolParserTokenTypes.txt \
+             TokenNames.hpp \
+             TokenLabels.hpp
+
+PortugolLexer.cpp PortugolLexer.hpp: $(srcdir)/lexer.g
+	$(ANTLR_BIN) $(srcdir)/lexer.g
+	cp PortugolTokenTypes.txt ../semantic
+	cp PortugolTokenTypes.txt ../gptasm_target
+
+PortugolParser.hpp PortugolParser.cpp: $(srcdir)/parser.g
+	$(ANTLR_BIN) $(srcdir)/parser.g
+
+TokenNames.hpp: Makefile
+	@echo &quot;#ifndef TOKENNAMES_H&quot; &gt; $@
+	@echo &quot;#define TOKENNAMES_H&quot;  &gt;&gt; $@
+	@echo &quot;static char* g_tokenNames[] = &quot; &gt;&gt; $@
+	@echo '{&quot;&quot;, &quot;EOF&quot;, &quot;&quot;, &quot;&quot;,'   &gt;&gt; $@
+	grep = PortugolTokenTypes.txt &gt;&gt; $@
+	sed -i -e 's/\([A-Z][^=( ]*\)[=(].*/&quot;\1&quot;,/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo -n &quot;static int g_tokenNamesSize = &quot; &gt;&gt; $@
+	@echo `grep -o , TokenNames.hpp | wc -l` + 1 | bc &gt;&gt; $@
+	@echo &quot;;&quot; &gt;&gt; $@
+	@echo &quot;#endif&quot; &gt;&gt; $@
+
+TokenLabels.hpp: Makefile
+	@echo &quot;#ifndef TOKENLABELS_H&quot; &gt; $@
+	@echo &quot;#define TOKENLABELS_H&quot;  &gt;&gt; $@
+	@echo &quot;static char* g_tokenLabels[] = &quot; &gt;&gt; $@
+	@echo '{&quot;&quot;, &quot;EOF&quot;, &quot;&quot;, &quot;&quot;,'   &gt;&gt; $@
+	grep '&quot;' PortugolTokenTypes.txt &gt;&gt; $@
+	sed -i -e 's/^T.*\(&quot;[^&quot;]*&quot;\).*/\1,/' $@
+	sed -i -e '$$s/,/};/' $@
+	@echo &quot;static int g_tokenLabelsSize = &quot; &gt;&gt; $@
+	@echo  `grep -o , TokenLabels.hpp | wc -l` + 1 | bc &gt;&gt; $@
+	@echo &quot;;&quot; &gt;&gt; $@
+	@echo &quot;#endif&quot; &gt;&gt; $@
\ No newline at end of file

Copied: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.cpp (from rev 420, trunk/gpt2/gptc/src/MismatchedUnicodeCharException.cpp)

Copied: trunk/gpt2/gptc/src/parser/MismatchedUnicodeCharException.hpp (from rev 420, trunk/gpt2/gptc/src/MismatchedUnicodeCharException.hpp)

Copied: trunk/gpt2/gptc/src/parser/UnicodeCharBuffer.hpp (from rev 420, trunk/gpt2/gptc/src/UnicodeCharBuffer.hpp)

Copied: trunk/gpt2/gptc/src/parser/UnicodeCharScanner.hpp (from rev 420, trunk/gpt2/gptc/src/UnicodeCharScanner.hpp)

Copied: trunk/gpt2/gptc/src/parser/lexer.g (from rev 435, trunk/gpt2/gptc/src/lexer.g)

Copied: trunk/gpt2/gptc/src/parser/parser.g (from rev 435, trunk/gpt2/gptc/src/parser.g)

Deleted: trunk/gpt2/gptc/src/parser.g
===================================================================
--- trunk/gpt2/gptc/src/parser.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/parser.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,565 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-header {
-  #include &lt;antlr/NoViableAltException.hpp&gt;
-  #include &lt;antlr/SemanticException.hpp&gt;
-
-  #include &quot;PortugolAST.hpp&quot;
-  using namespace antlr;
-}
-
-options {
-  language=&quot;Cpp&quot;;
-}
-
-class PortugolParser extends Parser;
-options {
-  importVocab    = Portugol;
-  genHashLines   = false;
-  buildAST       = true;
-  ASTLabelType   = &quot;RefPortugolAST&quot;;
-  noConstructors = true;
-}
-
-{
-public:
-  PortugolParser(antlr::TokenBuffer&amp; tokenBuf, bool report = true)
-  : antlr::LLkParser(tokenBuf,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  PortugolParser(antlr::TokenStream&amp; lexer, bool report = true)
-  : antlr::LLkParser(lexer,1), _reportErrors(report), _hasErrors(false)
-  {
-  }
-
-  void reportError(const RecognitionException&amp; ex) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    std::cerr &lt;&lt; ex.toString().c_str() &lt;&lt; std::endl;
-  }
-
-  void reportError(const std::string&amp; s) {
-    _hasErrors = true;
-    if (!_reportErrors) return;
-    if (getFilename() == &quot;&quot;) {
-      std::cerr &lt;&lt; &quot;error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-    } else {
-      std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: error: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-    }
-  }
-
-  void reportWarning(const std::string&amp; s) {
-    if (!_reportErrors) return;
-    if (getFilename() == &quot;&quot;) {
-      std::cerr &lt;&lt; &quot;warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-    } else {
-      std::cerr &lt;&lt; getFilename().c_str() &lt;&lt; &quot;: warning: &quot; &lt;&lt; s.c_str() &lt;&lt; std::endl;
-    }
-  }
-
-  bool hasErorrs() {
-    return _hasErrors;
-  }
-
-private:
-  void createRootNode(antlr::ASTPair&amp; ast, antlr::RefToken token) {
-    astFactory-&gt;makeASTRoot(ast, astFactory-&gt;create(token));
-  }
-
-  void createRootNode(antlr::ASTPair&amp; ast, int token, std::string txt = &quot;&quot;) {
-    astFactory-&gt;makeASTRoot(ast, astFactory-&gt;create(token, txt));
-  }
-
-  void addChildNode(antlr::ASTPair&amp; ast, antlr::RefToken token) {
-    astFactory-&gt;addASTChild(ast, astFactory-&gt;create(token));
-  }
-
-  void addChildNode(antlr::ASTPair&amp; ast, RefAST child) {
-    astFactory-&gt;addASTChild(ast, child);
-  }
-
-  antlr::RefAST createNode(int type, const std::string&amp; txt) {
-    return astFactory-&gt;create(type, txt);
-  }
-
-  bool _reportErrors;
-  bool _hasErrors;
-}
-
-
-
-//####################################
-//##             In&#237;cio             ##
-//####################################
-
-programa
-{createRootNode(currentAST, T_ALGORITMO, &quot;&amp;algoritmo&quot;);}
-
-  : (declaracao_algoritmo)?
-
-    (importacao)*
-
-    (   declaracao_variaveis
-      | declaracao_constantes
-      | bloco_declaracao_estrutura
-    )*
-
-    corpo
-
-    EOF
-  ;
-
-declaracao_algoritmo!
-  : T_ALGORITMO T_IDENTIFICADOR T_PONTO_VIRGULA
-  ;
-
-importacao
-  : T_USE^ T_TEXTO_LITERAL T_PONTO_VIRGULA!
-  ;
-
-corpo
-  :  declaracao_subprograma corpo
-  |  bloco_codigo           (declaracao_subprograma)*
-  |  /*vazio*/
-  ;
-
-
-
-//####################################
-//##    Declara&#231;&#227;o de Vari&#225;veis     ##
-//####################################
-
-declaracao_variaveis
-  : bloco_declaracao_variaveis
-  | T_VARIAVEL! declaracao_variavel_uniq
-  ;
-
-bloco_declaracao_variaveis
-  : T_VARIAVEIS! (declaracao_variavel)+ T_FIM_VARIAVEIS!
-  ;
-
-declaracao_variavel!
-  : ids:lista_identificadores   T_2_PONTOS
-    t:tipo (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,&quot;&amp;var&quot;], t,ids);
-              } else {
-                #declaracao_variavel =
-                    #([T_VARIAVEL,&quot;&amp;var&quot;], t,ids,([T_VALOR,&quot;&amp;valor&quot;],l));
-              }
-            }
-  ;
-
-lista_identificadores
-  : T_IDENTIFICADOR (T_VIRGULA! T_IDENTIFICADOR)*
-  ;
-
-declaracao_variavel_uniq!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    (l:lista_inicializacao)? T_PONTO_VIRGULA
-
-            {
-              if (l_AST == antlr::nullAST) {
-                #declaracao_variavel_uniq=
-                    #([T_VARIAVEL,&quot;&amp;var&quot;], t,id);
-              } else {
-                #declaracao_variavel_uniq =
-                    #([T_VARIAVEL,&quot;&amp;var&quot;], t,id,([T_VALOR,&quot;&amp;valor&quot;],l));
-              }
-            }
-  ;
-
-tipo
-  : tipo_primitivo
-  | tipo_matriz
-  | T_IDENTIFICADOR
-  ;
-
-lista_inicializacao
-  : T_ATRIBUICAO! (expressao | inicializacao_composta)
-  ;
-
-inicializacao_composta!
-  : ch:T_ABRE_CHAVE!
-      idx:inicializacao_indices
-    T_FECHA_CHAVE!
-
-                 {
-                   #inicializacao_composta = #([T_VAL_MATRIZ, &quot;&amp;vmatriz&quot;],idx);
-                   #inicializacao_composta-&gt;setLine(ch-&gt;getLine());
-                 }
-
-  | co:T_ABRE_COLCHETE!
-      mem:inicializacao_membros
-    T_FECHA_COLCHETE!
-
-                 {
-                   #inicializacao_composta =
-                       #([T_VAL_ESTRUTURA, &quot;&amp;vestr&quot;],mem);
-                   #inicializacao_composta-&gt;setLine(co-&gt;getLine());
-                 }
-  ;
-
-inicializacao_indices
-  : (expressao | inicializacao_composta) (T_VIRGULA! inicializacao_indices)?
-  ;
-
-inicializacao_membros
-  : T_IDENTIFICADOR T_ATRIBUICAO! (expressao | inicializacao_composta)
-    (T_VIRGULA! inicializacao_membros)?
-  ;
-
-tipo_primitivo
-  : T_INTEIRO
-  | T_REAL
-  | T_CARACTERE
-  | T_LITERAL
-  | T_LOGICO
-  | T_CORINGA
-  ;
-
-tipo_matriz!
-  : m:T_MATRIZ dim:matriz_dimensoes
-    T_DO T_TIPO t:tipo_da_matriz
-
-                    {#tipo_matriz = #(m, t,dim);}
-  ;
-
-matriz_dimensoes
-  : ( T_ABRE_CHAVE!
-      ( T_INTEIRO_LITERAL
-        | /*vazio*/  {addChildNode(currentAST, createNode(T_NULO,&quot;&amp;null&quot;));}
-      )
-      T_FECHA_CHAVE!
-    )+
-  ;
-
-tipo_da_matriz
-  : tipo_primitivo | T_IDENTIFICADOR
-  ;
-
-
-
-//####################################
-//##    Declara&#231;&#227;o de Constantes    ##
-//####################################
-
-
-declaracao_constantes
-  : bloco_declaracao_constantes
-  | T_CONSTANTE! declaracao_constante
-  ;
-
-bloco_declaracao_constantes
-  : T_CONSTANTES! (declaracao_constante)+ T_FIM_CONSTANTES!
-  ;
-
-declaracao_constante!
-  : id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-    l:lista_inicializacao T_PONTO_VIRGULA
-               {#declaracao_constante =
-                    #([T_CONSTANTE,&quot;&amp;const&quot;],t,id,([T_VALOR,&quot;&amp;valor&quot;],l));}
-  ;
-
-
-
-
-//####################################
-//##    Declara&#231;&#227;o de Estruturas    ##
-//####################################
-
-
-bloco_declaracao_estrutura
-  : T_ESTRUTURA^ T_IDENTIFICADOR (declaracao_variavel)+ T_FIM_ESTRUTURA!
-  ;
-
-
-
-
-//####################################
-//##    Declara&#231;&#227;o de Subrotinas    ##
-//####################################
-
-
-declaracao_subprograma
-  : declaracao_funcao
-  | declaracao_procedimento
-  ;
-
-declaracao_funcao
-  : T_FUNCAO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN! T_2_PONTOS! tipo_retorno
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-declaracao_procedimento
-  : T_PROCEDIMENTO^ T_IDENTIFICADOR
-      T_ABRE_PAREN! (lista_parametros)? T_FECHA_PAREN!
-    (declaracao_constantes | declaracao_variaveis)*
-    bloco_codigo
-  ;
-
-tipo_retorno!
-  : t:tipo {#tipo_retorno = #([T_TIPO_RETORNO,&quot;&amp;ret&quot;],t);}
-  ;
-
-lista_parametros
-  : (param_reticencias | parametro (T_VIRGULA! lista_parametros)?)
-  ;
-
-param_reticencias!
-  : ret:T_RETICENCIAS id:T_IDENTIFICADOR
-                       {#param_reticencias = #([T_PARAM,&quot;&amp;param&quot;],ret,id);}
-  ;
-
-parametro!
-  : (r:T_REF (c:T_CONSTANTE)?)? id:T_IDENTIFICADOR T_2_PONTOS t:tipo
-
-                          {#parametro = #([T_PARAM,&quot;&amp;param&quot;],t,id,r,c);}
-  ;
-
-
-//####################################
-//##         Bloco de c&#243;digo        ##
-//####################################
-
-bloco_codigo
-  : T_INICIO^ lista_enunciados T_FIM!
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-  : (lvalue T_ATRIBUICAO)=&gt; en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-
-  | en_asm
-
-  | T_SAIR^ T_PONTO_VIRGULA!
-  | T_PONTO_VIRGULA!
-
-//  TODO: retirar da gramatica ou resolver a ambiguidade
-//        se esta producao vingar, retirar enunciado::chamada_subrotina
-//   | expressao  T_PONTO_VIRGULA!
-
-  | chamada_subrotina T_PONTO_VIRGULA!
-  ;
-
-en_atribuicao
-  : lvalue T_ATRIBUICAO^ expressao T_PONTO_VIRGULA!
-  ;
-
-
-en_retorne
-  : T_RETORNE^ (expressao)? T_PONTO_VIRGULA!
-  ;
-
-lvalue!
-  : id:T_IDENTIFICADOR (m:lvalue_indices)? (T_PONTO es:lvalue_membro)?
-    {#lvalue = #([T_LVALUE,&quot;&amp;lvalue&quot;], id, m, es);}
-  ;
-
-lvalue_membro!
-  : l:lvalue             {#lvalue_membro = #([T_MEMBRO,&quot;&amp;membro&quot;], l);}
-  ;
-
-lvalue_indices
-  : i:indices_matriz     {#lvalue_indices = #([T_SUBSCRITO,&quot;&amp;subscrito&quot;], i);}
-  ;
-
-indices_matriz
-  : ( T_ABRE_CHAVE!
-      expressao
-      T_FECHA_CHAVE!
-    )+
-  ;
-
-en_se
-  : T_SE^ expressao T_ENTAO!
-      lista_enunciados (T_SENAO lista_enunciados)? T_FIM_SE!
-  ;
-
-en_enquanto
-  : T_ENQUANTO^ expressao T_FACA! lista_enunciados T_FIM_ENQUANTO!
-  ;
-
-en_para
-  : T_PARA^ lvalue T_DE! expressao
-    T_ATE! expressao (passo)? T_FACA!
-      lista_enunciados T_FIM_PARA!
-  ;
-
-passo
-  : T_PASSO^ (T_MAIS|T_MENOS)? T_INTEIRO_LITERAL
-  ;
-
-en_repita
-  : T_REPITA^ lista_enunciados T_ATE expressao
-  ;
-
-en_caso
-  : T_CASO^ expressao
-      T_SEJA! (teste_caso)+
-      (caso_senao)? T_FIM_CASO!
-  ;
-
-teste_caso
-  : literal T_FACA^ lista_enunciados T_FIM_FACA!
-  ;
-
-caso_senao
-  : T_SENAO^ lista_enunciados T_FIM_SENAO!
-  ;
-
-
-//TODO: codigo ilustrativo.
-en_asm!
-  : T_ASM (~(T_FIMASM))* T_FIMASM
-  ;
-
-
-//####################################
-//##            Express&#245;es          ##
-//####################################
-
-expressao!
-  : ou:expr_ou {#expressao = #([T_EXPRESSAO,&quot;&amp;expr&quot;], ou);}
-  ;
-
-expr_ou
-  : expr_e (T_OU^ expr_e)*
-  ;
-
-expr_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_ou (T_E^ expr_bit_ou)*
-  ;
-
-expr_bit_ou
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_oux (T_BIT_OU^ expr_bit_oux)*
-  ;
-
-expr_bit_oux
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_e (T_BIT_OUX^ expr_bit_e)*
-  ;
-
-expr_bit_e
-options {
-  defaultErrorHandler=false;
-}
-  : expr_eq (T_BIT_E^ expr_eq)*
-  ;
-
-expr_eq
-options {
-  defaultErrorHandler=false;
-}
-  : expr_relacional (T_IGUAL^ expr_relacional | T_DIFERENTE^ expr_relacional)*
-  ;
-
-expr_relacional
-options {
-  defaultErrorHandler=false;
-}
-  : expr_bit_shift ((T_MAIOR^ | T_MAIOR_EQ^ | T_MENOR^ | T_MENOR_EQ^) expr_bit_shift)*
-  ;
-
-expr_bit_shift
-options {
-  defaultErrorHandler=false;
-}
-  : expr_soma ((T_BIT_SHIFT_LEFT^ | T_BIT_SHIFT_RIGHT^) expr_soma)*
-  ;
-
-expr_soma
-options {
-  defaultErrorHandler=false;
-}
-  : expr_multip (T_MAIS^ expr_multip | T_MENOS^ expr_multip)*
-  ;
-
-expr_multip
-options {
-  defaultErrorHandler=false;
-}
-  : expr_unario ((T_DIV^ | T_MULTIP^ | T_MOD^) expr_unario)*
-  ;
-
-expr_unario!
-options {
-  defaultErrorHandler=false;
-}
-  : o:op_unario e:expr_elemento {#expr_unario = #(o,e);}
-  ;
-
-op_unario!
-  : ( T_MENOS      {#op_unario = #[T_UN_NEGATIVO,&quot;&amp;negat&quot;];}
-    | T_MAIS       {#op_unario = #[T_UN_POSITIVO,&quot;&amp;pos&quot;];}
-    | n:T_NAO      {#op_unario = #n;}
-    | bn:T_BIT_NAO {#op_unario = #bn;}
-    )?
-  ;
-
-expr_elemento
-  :  (T_IDENTIFICADOR T_ABRE_PAREN)=&gt; chamada_subrotina
-  |  lvalue
-  |  literal
-  | T_ABRE_PAREN! expressao T_FECHA_PAREN!
-  ;
-
-
-chamada_subrotina!
-  : id:T_IDENTIFICADOR T_ABRE_PAREN (args:lista_argumentos)? T_FECHA_PAREN
-
-                        {#chamada_subrotina = #([T_CALL,&quot;&amp;call&quot;], id, args);}
-  ;
-
-lista_argumentos
-  : expressao (T_VIRGULA! expressao)*
-  ;
-
-literal
-  : T_TEXTO_LITERAL
-  | T_INTEIRO_LITERAL
-  | T_REAL_LITERAL
-  | T_CARACTERE_LITERAL
-  | T_VERDADEIRO
-  | T_FALSO
-  ;

Copied: trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.cpp (from rev 436, trunk/gpt2/gptc/src/BaseSemanticWalker.cpp)

Copied: trunk/gpt2/gptc/src/semantic/BaseSemanticWalker.hpp (from rev 436, trunk/gpt2/gptc/src/BaseSemanticWalker.hpp)

Added: trunk/gpt2/gptc/src/semantic/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/semantic/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,21 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I$(top_srcdir)/src/common \
+           -I$(top_srcdir)/src/symboltable -I../parser -I../semantic
+
+noinst_LTLIBRARIES = libsemantic.la
+
+EXTRA_DIST = semantic.g
+
+BUILT_SOURCES = SemanticWalker.hpp SemanticWalker.cpp
+
+libsemantic_la_SOURCES = BaseSemanticWalker.hpp \
+	  										 BaseSemanticWalker.cpp \
+ 											   $(BUILT_SOURCES)
+
+
+CLEANFILES = SemanticWalker.hpp \
+             SemanticWalker.cpp \
+             SemanticWalkerTokenTypes.hpp \
+             SemanticWalkerTokenTypes.txt
+
+SemanticWalker.hpp SemanticWalker.cpp: $(srcdir)/semantic.g
+	$(ANTLR_BIN) $(srcdir)/semantic.g

Copied: trunk/gpt2/gptc/src/semantic/semantic.g (from rev 436, trunk/gpt2/gptc/src/semantic.g)

Deleted: trunk/gpt2/gptc/src/semantic.g
===================================================================
--- trunk/gpt2/gptc/src/semantic.g	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/semantic.g	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,745 +0,0 @@
-/*
- *   Copyright (C) 2003-2006 by Thiago Silva                               *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/gpt-commit">tsilva at sourcecraft.info</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             */
-
-
-header {
-  #include &quot;BaseSemanticWalker.hpp&quot;
-  #include &quot;PortugolAST.hpp&quot;
-  #include &quot;Symbol.hpp&quot;
-  #include &quot;SymbolTable.hpp&quot;
-}
-
-options {
-  language=&quot;Cpp&quot;;
-}
-
-class SemanticWalker extends TreeParser(&quot;BaseSemanticWalker&quot;);
-options {
-  importVocab    = Portugol;
-  noConstructors = true;
-  genHashLines   = false;
-  ASTLabelType   = &quot;RefPortugolAST&quot;;
-}
-
-{
-public:
-  SemanticWalker::SemanticWalker(SymbolTable* symtable,
-                                 const std::string&amp; filepath)
-	 : BaseSemanticWalker(symtable, filepath),
-    _analisingInitializationList(false) { }
-
-private:
-  bool _analisingInitializationList;
-}
-
-
-programa
-                                      {RefPortugolAST inicio;}
-  : #(T_ALGORITMO
-
-        (importacao)*
-
-        (declaracoes)?
-
-                                      //recuperando declaracoes globais e
-                                      //de subprogramas para a symtable
-                                      {inicio = _t; /*backup da posicao*/}
-        (declaracoes_subprogramas)?
-
-        EOF
-                                      //analise semantica dos blocos
-                                      {_t = inicio; /*rollback*/}
-        (corpo)?
-        EOF
-     )
-  ;
-
-importacao
-  : #(T_USE lib:T_TEXTO_LITERAL)      {useLib(lib-&gt;getText());}
-  ;
-
-
-/*********************** DECLARACOES *******************************/
-
-declaracoes
-  : declaracao_variavel    (declaracoes)?
-  | declaracao_constante   (declaracoes)?
-  | declaracao_estrutura   (declaracoes)?
-  ;
-
-declaracao_variavel
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : #(T_VARIAVEL
-        type=tipo
-        ids=identificadores     {declare(ids, type);}
-
-        (
-          rtype=v:valor_inicialiacao
-
-                                {evalAttribution(ids.back(), type, rtype);}
-        )?
-    )
-  ;
-
-declaracao_constante
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : #(T_CONSTANTE
-        type=tipo
-        ids=identificadores
-        rtype=valor_inicialiacao)
-
-                                {
-                                  type-&gt;setConst(true);
-                                  declare(ids, type);
-                                  evalAttribution(ids.back(),type, rtype);
-                                }
-  ;
-
-identificadores returns [IDList list]
-  : (
-      id:T_IDENTIFICADOR        {list.push_back(id);}
-    )+
-  ;
-
-tipo returns [Type *type]
-  : id:T_IDENTIFICADOR          {type = getStructType(id);}
-  | type=tipo_primitivo
-  | type=tipo_matriz
-  ;
-
-tipo_primitivo returns [Type *type]
-
-                      {RefPortugolAST prim = _t;}
-  : (
-        T_INTEIRO
-      | T_REAL
-      | T_CARACTERE
-      | T_LITERAL
-      | T_LOGICO
-      | T_CORINGA
-    )
-                      {type = _typeBuilder-&gt;primitiveType(prim-&gt;getType());}
-  ;
-
-tipo_matriz returns [Type *type]
-
-                        {
-                          std::list&lt;int&gt; dims;
-                          Type* ofType;
-                        }
-
-  : #(m:T_MATRIZ ofType=tipo dims=dimensoes)
-
-                  {
-                    checkMatrixDimensions(m,dims);
-                    type =_typeBuilder-&gt;matrixType(ofType,dims);
-                  }
-
-  ;
-
-dimensoes returns [std::list&lt;int&gt; dims]
-
-                        {int dsize;}
-  : (
-      dsize=dimensao
-                        {dims.push_back(dsize);}
-    )+
-  ;
-
-dimensao returns [int size]
-  : i:T_INTEIRO_LITERAL     {size = atoi(i-&gt;getText().c_str());}
-  | n:T_NULO                {size = 0;}
-  ;
-
-
-
-
-declaracao_estrutura
-                                {SymbolList fields;}
-
-  : #(T_ESTRUTURA id:T_IDENTIFICADOR fields=campos_estrutura)
-
-                                {declareStruct(id, fields);}
-  ;
-
-campos_estrutura returns [SymbolList fields]
-
-                                {
-                                  IDList ids;
-                                  Type *type;
-                                  Type *rtype;
-                                }
-
-  : (
-      #(T_VARIAVEL type=tipo ids=identificadores
-            (
-              rtype=valor_inicialiacao
-
-                                {evalAttribution(ids.back(), type, rtype);}
-
-            )?
-    )
-
-                                {
-                                  for (IDList::iterator it = ids.begin();
-                                         it != ids.end(); ++it) {
-                                    fields.push_back(
-                                      Symbol((*it)-&gt;getText(),
-                                                    type,
-                                                    _symtable-&gt;currentScope(),
-                                                    _symtable-&gt;unit(),
-                                                    (*it)-&gt;getLine(),
-                                                    (*it)-&gt;getColumn()));
-                                  }
-                                }
-    )+
-  ;
-
-
-/********************** INICIALIZACAO *************************/
-
-
-valor_inicialiacao returns [Type *rtype]
-
-                          {
-                            _analisingInitializationList = true;
-                          }
-
-  : #(v:T_VALOR rtype=valor)
-
-                          {
-                            _analisingInitializationList = false;
-                          }
-  ;
-
-valor returns [Type *rtype]
-                          {
-                            InitMatrixList         mtx;
-                            InitStructList         stc;
-                          }
-  : rtype=expressao_
-
-  | #(m:T_VAL_MATRIZ
-        (valor_matriz[1,mtx])+)
-
-                          {rtype = evalInitMatrix(m, mtx);}
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id,stc])+)
-
-                          {rtype = evalInitStruct(stc);}
-  ;
-
-valor_matriz [int dimension, InitMatrixList&amp; mtx]
-
-                              {
-                                Type *type;
-                                InitStructList stc;
-                              }
-
-  : type=expressao_      {mtx.push_back(std::pair&lt;int,Type*&gt;(dimension, type));}
-
-  | #(T_VAL_MATRIZ
-      (valor_matriz[dimension+1, mtx])+)
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id, stc])+)
-
-                       {mtx.push_back(std::pair&lt;int,Type*&gt;(dimension,
-                            evalInitStruct(stc)));}
-  ;
-
-valor_estrutura [RefPortugolAST field, InitStructList&amp; stc]
-                              {
-                                Type *type;
-                                InitMatrixList mtx;
-                                InitStructList stc_;
-                              }
-  : type=expressao_
-                              {
-                                stc.push_back(
-                                  std::pair&lt;RefPortugolAST,Type*&gt;(
-                                    field, type));
-                              }
-
-  | #(m:T_VAL_MATRIZ
-      (valor_matriz[1, mtx])+)
-
-                              {
-                                type = evalInitMatrix(m, mtx);
-                                stc.push_back(
-                                  std::pair&lt;RefPortugolAST,Type*&gt;(
-                                    field, type));
-                              }
-
-  | #(T_VAL_ESTRUTURA
-      (id:T_IDENTIFICADOR valor_estrutura[id,stc_])+)
-
-                              {
-                                type = evalInitStruct(stc_);
-                                stc.push_back(
-                                  std::pair&lt;RefPortugolAST,Type*&gt;(
-                                    field, type));
-                              }
-  ;
-
-
-
-
-/********************* DECLARACAO SUBPROGRAMAS ****************************/
-
-declaracoes_subprogramas
-  : declaracao_subprograma (declaracoes_subprogramas)?
-  | T_INICIO               (declaracoes_subprogramas)?//pula o bloco principal
-  ;
-
-declaracao_subprograma
-  : declaracao_funcao
-  | declaracao_procedimento
-  ;
-
-declaracao_procedimento
-                                      {SymbolList params;}
-
-  : #(T_PROCEDIMENTO
-        id:T_IDENTIFICADOR
-        params=lista_parametros
-
-                                      {
-                                        declareProc(id, params);
-                                      }
-
-      (declaracao_variavel | declaracao_constante)*)
-
-                                      {_symtable-&gt;setGlobalScope();}
-  ;
-
-declaracao_funcao
-                                      {
-                                        SymbolList params;
-                                        Type *type;
-                                      }
-  : #(T_FUNCAO
-        id:T_IDENTIFICADOR
-        params=lista_parametros
-        type=tipo_retorno
-                                      {
-                                        declareProc(id, params, type);
-                                      }
-
-      (declaracao_variavel | declaracao_constante)*)
-
-                                      {_symtable-&gt;setGlobalScope();}
-  ;
-
-tipo_retorno returns [Type* type]
-  : #(T_TIPO_RETORNO type=tipo)
-  ;
-
-lista_parametros returns [SymbolList list]
-
-                                 {Symbol symbol;}
-
-  : (#(T_PARAM symbol=parametro) {list.push_back(symbol);})*
-  ;
-
-parametro returns [Symbol symbol]
-
-                                  {Type* type;}
-
-  : type=tipo id:T_IDENTIFICADOR (r:T_REF)? (c:T_CONSTANTE)?
-
-                                  {
-                                    if (c != antlr::nullAST) {
-                                      type-&gt;setConst(true);
-                                    }
-
-                                    if (r != antlr::nullAST) {
-                                      type-&gt;setRef(true);
-                                    }
-
-                                    symbol =
-                                        Symbol(id-&gt;getText(),
-                                          type,
-                                          _symtable-&gt;unit(),
-                                          id-&gt;getLine(),
-                                          id-&gt;getColumn());
-                                  }
-
-  | T_RETICENCIAS idret:T_IDENTIFICADOR
-
-                                  {
-                                    symbol = Symbol(idret-&gt;getText(),
-                                              _typeBuilder-&gt;reticencesType(),
-                                              _symtable-&gt;unit(),
-                                              idret-&gt;getLine(),
-                                              idret-&gt;getColumn());
-                                  }
-  ;
-
-
-/* ************************* EXPRESSOES *************************/
-
-
-expressao returns [ExpressionReturn ret]
-
-                                {
-                                  Type *type;
-                                }
-
-  : #(e:T_EXPRESSAO type=expr)  {ret.first = e; ret.second = type;}
-  ;
-
-expressao_ returns [Type *type]
-  : #(T_EXPRESSAO type=expr)
-  ;
-
-
-expr returns [Type *type]
-                                      {
-                                        Type *l, *r;
-                                        RefPortugolAST op = _t;
-                                      }
-  : (
-
-      #(T_OU              l=expr r=expr)
-                                      {type = evalExpr_OU(op, l,r);}
-
-    | #(T_E               l=expr r=expr)
-                                      {type = evalExpr_E(op, l,r);}
-
-    | #(T_BIT_OU          l=expr r=expr)
-                                      {type = evalExpr_BIT_OU(op, l,r);}
-
-    | #(T_BIT_OUX         l=expr r=expr)
-                                      {type = evalExpr_BIT_OUX(op, l,r);}
-
-    | #(T_BIT_E           l=expr r=expr)
-                                      {type = evalExpr_BIT_E(op, l,r);}
-
-    | #(T_IGUAL           l=expr r=expr)
-                                      {type = evalExpr_IGUAL(op, l,r);}
-
-    | #(T_DIFERENTE       l=expr r=expr)
-                                      {type = evalExpr_DIFERENTE(op, l,r);}
-
-    | #(T_MAIOR           l=expr r=expr)
-                                      {type = evalExpr_MAIOR(op, l,r);}
-
-    | #(T_MENOR           l=expr r=expr)
-                                      {type = evalExpr_MENOR(op, l,r);}
-
-    | #(T_MAIOR_EQ        l=expr r=expr)
-                                      {type = evalExpr_MAIOR_EQ(op, l,r);}
-
-    | #(T_MENOR_EQ        l=expr r=expr)
-                                      {type = evalExpr_MENOR_EQ(op, l,r);}
-
-    | #(T_BIT_SHIFT_LEFT  l=expr r=expr)
-                                      {type = evalExpr_BIT_SHIFT_LEFT(op, l,r);}
-
-    | #(T_BIT_SHIFT_RIGHT l=expr r=expr)
-                                      {type = evalExpr_BIT_SHIFT_RIGHT(op, l,r);}
-
-    | #(T_MAIS            l=expr r=expr)
-                                      {type = evalExpr_MAIS(op, l,r);}
-
-    | #(T_MENOS           l=expr r=expr)
-                                      {type = evalExpr_MENOS(op, l,r);}
-
-    | #(T_DIV             l=expr r=expr)
-                                      {type = evalExpr_DIV(op, l,r);}
-
-    | #(T_MULTIP          l=expr r=expr)
-                                      {type = evalExpr_MULTIP(op, l,r);}
-
-    | #(T_MOD             l=expr r=expr)
-                                      {type = evalExpr_MOD(op, l,r);}
-
-    | #(T_UN_NEGATIVO     l=elemento)
-                                      {type = evalExpr_UN_NEGATIVO(op,l);}
-
-    | #(T_UN_POSITIVO     l=elemento)
-                                      {type = evalExpr_UN_POSITIVO(op,l);}
-
-    | #(T_NAO             l=elemento)
-                                      {type = evalExpr_NAO(op,l);}
-
-    | #(T_BIT_NAO         l=elemento)
-                                      {type = evalExpr_BIT_NAO(op,l);}
-
-    )
-                       {op-&gt;setEvalType(type);}
-
-  | type=elemento
-  ;
-
-
-elemento returns [Type *type]
-                               {ExpressionReturn lv;}
-  : type=literal
-  | lv=lvalue                  {type = lv.second;}
-  | type=chamada_subrotina
-  | type=expressao_
-  ;
-
-literal returns [Type *type]
-                            {RefPortugolAST ast = _t;}
-  : (
-      T_TEXTO_LITERAL       {type = _typeBuilder-&gt;primitiveType(T_LITERAL);}
-    | T_INTEIRO_LITERAL     {type = _typeBuilder-&gt;primitiveType(T_INTEIRO);}
-    | T_REAL_LITERAL        {type = _typeBuilder-&gt;primitiveType(T_REAL);}
-    | T_CARACTERE_LITERAL   {type = _typeBuilder-&gt;primitiveType(T_CARACTERE);}
-    | T_VERDADEIRO          {type = _typeBuilder-&gt;primitiveType(T_LOGICO);}
-    | T_FALSO               {type = _typeBuilder-&gt;primitiveType(T_LOGICO);}
-    )
-    {ast-&gt;setEvalType(type);}
-  ;
-
-
-lvalue returns [ExpressionReturn ret]
-
-                            {
-                              Type *type;
-                              int dimensions;
-                            }
-
-  : #(lv:T_LVALUE id:T_IDENTIFICADOR    {type = getSymbolType(id);}
-
-      (
-        dimensions=lvalue_indices
-
-                           {type = evalMatrixSubscript(id, type, dimensions);}
-      )?
-
-      (type=lvalue_membro[id,type])?
-    )
-
-      {
-        ret.first = id; ret.second = type;
-        lv-&gt;setEvalType(type);
-      }
-  ;
-
-
-lvalue_membro [RefPortugolAST parent, Type *sttype] returns [Type *type]
-
-  : #(T_MEMBRO type=lvalue_struct[parent,sttype])
-  ;
-
-lvalue_struct[RefPortugolAST parent, Type *sttype] returns [Type *type]
-
-                              {
-                                int dimensions;
-                              }
-
-  : #(id:T_IDENTIFICADOR     {type = getSymbolType(parent,sttype,id);}
-
-      (
-        dimensions=lvalue_indices
-
-                             {type = evalMatrixSubscript(id,
-                                                         type, dimensions);}
-      )?
-
-      (type=lvalue_membro[id,type])?
-    )
-  ;
-
-lvalue_indices returns [int dimensions]
-
-                                {
-                                  ExpressionReturn ex;
-                                  dimensions = 0;
-                                }
-  : #(s:T_SUBSCRITO
-      (
-        ex=expressao
-                                {
-                                  dimensions++;
-                                  evalMatrixSubscriptType(ex.first, ex.second);
-                                }
-      )+
-    )
-  ;
-
-
-
-
-chamada_subrotina returns [Type *type]
-
-                                  {
-                                    TypeList params;
-                                  }
-
-  : #(T_CALL id:T_IDENTIFICADOR params=lista_argumentos)
-
-                                  {
-                                    if (!_analisingInitializationList) {
-                                      type = evalCall(id, params);
-                                    } else {
-                                      type = _typeBuilder-&gt;errorType();
-                                      report(id-&gt;getLine(),
-                                        &quot;ilegal: fcall em lista de inicializa&#231;&#227;o&quot;);
-                                    }
-                                  }
-  ;
-
-lista_argumentos returns [TypeList list]
-
-                                   {Type *type;}
-  : (
-      type=expressao_                   {list.push_back(type);}
-    )*
-  ;
-
-
-
-
-/************************** CORPO *************************/
-
-corpo
-  :  corpo_subprograma      (corpo)?
-  |  bloco_codigo           (corpo_subprograma)*
-  ;
-
-
-corpo_subprograma
-                      {SymbolList params;}
-
-  : #(T_FUNCAO   f:T_IDENTIFICADOR
-                 params=lista_parametros {setCurrentScope(f, params);}
-                 T_TIPO_RETORNO
-                 (T_VARIAVEL|T_CONSTANTE)*
-                 bloco_codigo            {_symtable-&gt;setGlobalScope();}
-    )
-
-  | #(T_PROCEDIMENTO p:T_IDENTIFICADOR
-                 params=lista_parametros {setCurrentScope(p, params);}
-                 (T_VARIAVEL|T_CONSTANTE)*
-                 bloco_codigo)           {_symtable-&gt;setGlobalScope();}
-  ;
-
-
-
-bloco_codigo
-  : #(T_INICIO lista_enunciados)
-  ;
-
-lista_enunciados
-  : (enunciado)*
-  ;
-
-enunciado
-                    {Type *devnull;}
-  : en_atribuicao
-  | en_retorne
-  | en_se
-  | en_enquanto
-  | en_repita
-  | en_para
-  | en_caso
-  | T_SAIR //TODO: deve estar dentro de uma itera&#231;&#227;o
-  | devnull=chamada_subrotina
-  ;
-
-en_atribuicao
-                        {ExpressionReturn lret, rret;}
-
-  : #(at:T_ATRIBUICAO lret=lvalue rret=expressao)
-
-                        {evalAttribution(at, lret.second, rret.second);}
-  ;
-
-en_retorne
-                        {Type *type;}
-
-  : #(ret:T_RETORNE type=expressao_)
-
-                        {evalRetorne(ret, type);}
-  ;
-
-en_se
-                        {ExpressionReturn ex;}
-
-  : #(se:T_SE
-
-      ex=expressao    {evalCondicional(ex);}
-      lista_enunciados
-      (T_SENAO lista_enunciados)?
-    )
-  ;
-
-en_enquanto
-                        {ExpressionReturn ex;}
-  : #(enq:T_ENQUANTO
-      ex=expressao      {evalCondicional(ex);}
-      lista_enunciados
-    )
-  ;
-
-en_repita
-                              {ExpressionReturn ex;}
-  : #(T_REPITA
-      lista_enunciados
-      T_ATE ex=expressao      {evalCondicional(ex);}
-    )
-  ;
-
-en_para
-                              {ExpressionReturn lv, from, to;}
-
-  : #(p:T_PARA lv=lvalue
-        from=expressao        {evalAttribution(lv, from);}
-        to=expressao          {evalAttribution(lv, to);}
-        (T_PASSO)?
-        lista_enunciados)
-  ;
-
-  //TODO: checar por op&#231;&#245;es repetidas nos testes
-
-en_caso
-                              {Type *type;}
-
-  : #(c:T_CASO type=expressao_ (teste_caso[type])+ (caso_senao)?)
-  ;
-
-teste_caso[Type *ltype]
-
-                               {Type *rtype;}
-
-  : #(T_FACA
-      rtype=lit:literal            {evalExpr_IGUAL(lit, ltype, rtype);}
-      lista_enunciados
-    )
-  ;
-
-caso_senao
-  : #(T_SENAO lista_enunciados)
-  ;

Added: trunk/gpt2/gptc/src/symboltable/Makefile.am
===================================================================
--- trunk/gpt2/gptc/src/symboltable/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/src/symboltable/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -0,0 +1,6 @@
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/src -I../parser
+
+noinst_LTLIBRARIES = libsymboltable.la
+
+libsymboltable_la_SOURCES = Symbol.cpp Symbol.hpp SymbolTable.cpp SymbolTable.hpp\
+	SymbolTableExceptions.cpp SymbolTableExceptions.hpp Types.cpp Types.hpp

Copied: trunk/gpt2/gptc/src/symboltable/Symbol.cpp (from rev 438, trunk/gpt2/gptc/src/Symbol.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/Symbol.hpp (from rev 423, trunk/gpt2/gptc/src/Symbol.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTable.cpp (from rev 420, trunk/gpt2/gptc/src/SymbolTable.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTable.hpp (from rev 420, trunk/gpt2/gptc/src/SymbolTable.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.cpp (from rev 420, trunk/gpt2/gptc/src/SymbolTableExceptions.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/SymbolTableExceptions.hpp (from rev 420, trunk/gpt2/gptc/src/SymbolTableExceptions.hpp)

Copied: trunk/gpt2/gptc/src/symboltable/Types.cpp (from rev 438, trunk/gpt2/gptc/src/Types.cpp)

Copied: trunk/gpt2/gptc/src/symboltable/Types.hpp (from rev 438, trunk/gpt2/gptc/src/Types.hpp)

Modified: trunk/gpt2/gptc/test/Makefile.am
===================================================================
--- trunk/gpt2/gptc/test/Makefile.am	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/test/Makefile.am	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,7 +1,10 @@
-INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/test -I$(top_srcdir)/src -I../src
+INCLUDES = -I$(top_srcdir)/. -I$(top_srcdir)/test -I$(top_srcdir)/src \
+           -I../src/parser -I$(top_srcdir)/src/parser -I$(top_srcdir)/src/common
 
 bin_PROGRAMS = tester
-tester_LDADD = $(top_builddir)/src/libgptc.la $(ANTLR_LIB)
+tester_LDADD = $(top_builddir)/src/parser/libparser.la \
+               $(top_builddir)/src/common/libcommon.la \
+               $(top_builddir)/src/symboltable/libsymboltable.la $(ANTLR_LIB)
 
 EXTRA_DIST = compiler_test.g
 
@@ -31,7 +34,7 @@
 
 
 LangTestLexer.cpp LangTestLexer.hpp LangTestParser.hpp LangTestParser.cpp: \
-     Makefile $(srcdir)/compiler_test.g
+     $(srcdir)/compiler_test.g
 	$(ANTLR_BIN) $(srcdir)/compiler_test.g
 
 testTokenNames.hpp: Makefile

Modified: trunk/gpt2/gptc/tmp/tree_teste.gpt
===================================================================
--- trunk/gpt2/gptc/tmp/tree_teste.gpt	2007-12-19 00:54:36 UTC (rev 440)
+++ trunk/gpt2/gptc/tmp/tree_teste.gpt	2007-12-19 02:08:43 UTC (rev 441)
@@ -1,110 +1,7 @@
-// algoritmo teste;
+algoritmo teste;
 
-// use &quot;bib1&quot;;
-// use &quot;bib2&quot;;
-// use &quot;bib3&quot;;
-// use &quot;bib4&quot;;
-
-// vari&#225;vel q : T;
-
-vari&#225;veis
-//   p : T;
-//   a,b : real;
-//   c : inteiro := 10;
-  j : matriz[] do tipo inteiro := [1,2,3];
-//   es,e2 : T := {nome:=&quot;foo&quot;,id:=6};
-//   e4    : matriz[] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3}];
-fim-vari&#225;veis
-
-
-
-// vari&#225;vel j : K := &quot;oi&quot;;
-// vari&#225;vel m : matriz[] do tipo I := [9,8,7];
-// vari&#225;vel z : T := {i:=10, j:=20};
-// vari&#225;vel e4    : matriz[10][20] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3}];
-
-// constantes
-//   z  : inteiro := 3;
-//   j  : matriz[] do tipo inteiro := [1,2,3];
-//   es : T := {nome:=&quot;foo&quot;,id:=6};
-//   e4 : matriz[] do tipo T := [{nome:=&quot;a&quot;,id:=2},{nome:=&quot;b&quot;,id:=3},{k:=[9,8,7]}];
-// fim-constantes
-//
-// constante x : inteiro := {z := [1,2,3]};
-
-// estrutura T
-//   z   : inteiro := 1;
-//   j,z : kkk;
-// fim-estrutura
-/*
-fun&#231;&#227;o f(a:I,k:matriz[1][2] do tipo I) : T
+vari&#225;vel x   : inteiro;
+vari&#225;vel p&#233;  : literal;
 in&#237;cio
-  x := 2;
-fim*/
-
-
-
-// in&#237;cio
-//   x := 10;
-//   z[1] := 9;
-//   z[0][0] := n&#227;o(~1 + -2 * +3);
-
-//   se x &gt; 2 ent&#227;o
-//     x := 2;
-//   fim-se
-//
-//   se z = &quot;oi&quot; ent&#227;o
-//     z := 1;
-//   sen&#227;o
-//     z := 2;
-//   fim-se
-
-// enquanto x &gt; 2 fa&#231;a
-//   x := 2;
-// fim-enquanto
-
-// repita
-//   x := 2;
-//   k := 3;
-// at&#233; x &gt; 3
-
-// para x de 1+2 at&#233; 10+100 fa&#231;a
-//   x := 3;
-// fim-para
-
-// para x[y] de 0 at&#233; 100 passo -1 fa&#231;a
-//   x := 3;
-// fim-para
-
-// caso x seja
-//   &quot;oi&quot; fa&#231;a
-//     x := 1;
-//     z := 2;
-//   fim-fa&#231;a
-//
-//   10 fa&#231;a
-//     x:=3;
-//     sair;
-//   fim-fa&#231;a
-//
-//   sen&#227;o
-//     x:= 10;
-//   fim-sen&#227;o
-// fim-caso
-//
-//   retorne 10+10;
-
-//   f(10, 1+2, g());
-
-//   &quot;se&quot; x &gt; 10
-/*  asm
-    ola  as &quot;sss&quot; 1 se ent&#227;o
-    adasd &quot;fim-asm&quot;
-  fim-asm*/
-// fim
-
-
-// procedimento p(a:I,k:matriz[1][2] do tipo I)
-// in&#237;cio
-//   z := 2;
-// fim
+  x := p&#233; + 1;
+fim
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000114.html">[gpt-commit] r440 - trunk/gpt2/gptc/test
</A></li>
	<LI>Next message: <A HREF="000116.html">[gpt-commit] r442 - trunk/gpt2
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#115">[ date ]</a>
              <a href="thread.html#115">[ thread ]</a>
              <a href="subject.html#115">[ subject ]</a>
              <a href="author.html#115">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-commit">More information about the gpt-commit
mailing list</a><br>
</body></html>
