<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [gpt-commit] r519 - trunk/gpt/doc/manual
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gpt-commit/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r519%20-%20trunk/gpt/doc/manual&In-Reply-To=%3C200902160145.n1G1jEWp030126%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000193.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[gpt-commit] r519 - trunk/gpt/doc/manual</H1>
    <B>gpt-commit-noreply at mail.berlios.de</B> 
    <A HREF="mailto:gpt-commit%40lists.berlios.de?Subject=Re%3A%20%5Bgpt-commit%5D%20r519%20-%20trunk/gpt/doc/manual&In-Reply-To=%3C200902160145.n1G1jEWp030126%40sheep.berlios.de%3E"
       TITLE="[gpt-commit] r519 - trunk/gpt/doc/manual">gpt-commit-noreply at mail.berlios.de
       </A><BR>
    <I>Mon Feb 16 02:45:14 CET 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000193.html">[gpt-commit] r520 - in trunk/gpt/src: . modules/interpreter	modules/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#192">[ date ]</a>
              <a href="thread.html#192">[ thread ]</a>
              <a href="subject.html#192">[ subject ]</a>
              <a href="author.html#192">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: adorilson
Date: 2009-02-16 02:45:00 +0100 (Mon, 16 Feb 2009)
New Revision: 519

Modified:
   trunk/gpt/doc/manual/manual.tex
Log:
Correcoes no portugues


Modified: trunk/gpt/doc/manual/manual.tex
===================================================================
--- trunk/gpt/doc/manual/manual.tex	2009-01-13 14:09:04 UTC (rev 518)
+++ trunk/gpt/doc/manual/manual.tex	2009-02-16 01:45:00 UTC (rev 519)
@@ -53,7 +53,7 @@
 \fancyhead[LO]{\rightmark} %Displays the lower-level (chapter) information - as
 
 
-\usepackage[brazilian]{babel} %traduz data, ``capitulo'', etc...
+\usepackage[brazilian]{babel} %traduz data, ''capitulo'', etc...
 \usepackage[latin1]{inputenc} %permite acentos diretamente
 \usepackage[T1]{fontenc} %to get the hyphenation right.
 %\usepackage{times}
@@ -183,7 +183,7 @@
 \label{ch:intro}
 
 G-Portugol &#233; um dialeto da linguagem/pseudo-c&#243;digo portugol (ou
-portug&#234;s estruturado), que &#233; muito usada para descrever algoritmos em
+portugu&#234;s estruturado), que &#233; muito usada para descrever algoritmos em
 portugu&#234;s, de forma livre e espont&#226;nea. Em geral, livros dedicados ao ensino
 de algoritmos, l&#243;gica e estruturas de dados utilizam alguma forma
 dessa linguagem.
@@ -191,15 +191,15 @@
 A proposta de G-Portugol &#233; disponibilizar uma implementa&#231;&#227;o da
 linguagem portugol, fornecendo ferramentas que ofere&#231;am recursos de edi&#231;&#227;o,
 compila&#231;&#227;o, execu&#231;&#227;o e depura&#231;&#227;o de programas escritos nessa linguagem, de forma
-a favorecer estudantes que d&#227;o os primeiros passos no aprendizado de
+a favorecer aos estudantes que d&#227;o os primeiros passos no aprendizado de
 desenvolvimento de softwares, bem como professores que ensinam disciplinas
 relacionadas a computa&#231;&#227;o. Portanto, seu foco &#233; primariamente did&#225;tico.
 
-Se encontram dispon&#237;veis atualmente um compilador, tradutor e interpretador para
+Encontram-se dispon&#237;veis atualmente um compilador, tradutor e interpretador para
 a linguagem (GPT) e um ambiente visual simples (GPTEditor) que permite a
 edi&#231;&#227;o, execu&#231;&#227;o e depura&#231;&#227;o de programas escritos em G-Portugol.
 
-A seguir &#233; apresentado os assuntos abordados nos cap&#237;tulos seguintes:
+A seguir s&#227;o apresentados os assuntos abordados nos cap&#237;tulos seguintes:
 
 \begin{itemize}
  \item 
@@ -208,7 +208,7 @@
   \item
   Cap&#237;tulo 3: aborda a programa&#231;&#227;o em G-Portugol, suas estruturas e recursos, utilizando exemplos ilustrativos e 
   comparando com linguagens populares. Embora o cap&#237;tulo trate da programa&#231;&#227;o, ele n&#227;o tem como objetivo explicar 
-  programa&#231;&#227;o em si ou a teoria/historia por traz das estruturas abordadas. 
+  programa&#231;&#227;o em si ou a teoria/hist&#243;ria por tr&#225;s das estruturas abordadas. 
 
   \item
   Cap&#237;tulo 4: trata da implementa&#231;&#227;o da linguagem. Discute as decis&#245;es de design e recursos oferecidos por G-Portugol.
@@ -233,7 +233,7 @@
 portugol. Semelhante &#224; linguagens como Pascal e C, &#233; uma linguagem imperativa, com comandos de 
 controle de fluxo, manipula&#231;&#227;o de dados e recursos de entrada e sa&#237;da b&#225;sicos.
 A linguagem em \textit{case sensitive}, o que significa que, por exemplo, uma
-fun&#231;&#227;o chamada ``leia'' &#233; diferente de uma fun&#231;&#227;o chamada ``Leia''.
+fun&#231;&#227;o chamada ''leia'' &#233; diferente de uma fun&#231;&#227;o chamada ''Leia''.
 
 \section{Tipos de dados}
 
@@ -252,7 +252,7 @@
     inteiro &amp; 19 \\
     real &amp; 2.5 \\
     caractere &amp; 'a' \\
-    literal &amp; ``uma frase'' \\
+    literal &amp; ''uma frase'' \\
     l&#243;gico &amp; verdadeiro \\
     \hline
   \end{tabular}
@@ -261,7 +261,7 @@
 \end{center}
 \end{table}
 
-Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ``n''
+Com esses tipos, pode-se criar conjuntos como vetores ou matrizes ''n''
 dimensionais. Tipos mais complexos n&#227;o s&#227;o suportados.
 
 
@@ -269,8 +269,8 @@
 
 O conjunto de estruturas de controle s&#227;o os mais primitivos. Uma
 estrutura condicional (se/sen&#227;o) e duas estruturas de repeti&#231;&#227;o (enquanto/para)
-s&#227;o suportadas. Embora a estrutura ``para'' seja uma especializa&#231;&#227;o de um la&#231;o
-simples como o ``enquanto'', ela foi implementada, visto que uma variedade
+s&#227;o suportadas. Embora a estrutura ''para'' seja uma especializa&#231;&#227;o de um la&#231;o
+simples como o ''enquanto'', ela foi implementada, visto que uma variedade
 de livros e muitos professores os discutem.
 
 \begin{table}[h!t]
@@ -330,14 +330,14 @@
   imprima(&quot;Ol&#225; mundo!&quot;);
 fim
   \end{verbatim}
-  \caption{``Ol&#225; Mundo'' em G-Portugol.}
+  \caption{''Ol&#225; Mundo'' em G-Portugol.}
 \end{program}
 
 \noindent 
 Ap&#243;s salvar o arquivo, digite o seguinte na linha de comando:
 \newline
 
-No linux:
+No Linux:
 \begin{verbatim}
 $ gpt -o olamundo olamundo.gpt
 \end{verbatim}
@@ -348,16 +348,16 @@
 \end{verbatim}
 
 Esse comando compila o algoritmo e salva o arquivo bin&#225;rio resultante como
-``olamundo'' (ou ``olamundo.exe'') no diret&#243;rio atual. Se a op&#231;&#227;o ``-o
+''olamundo'' (ou ''olamundo.exe'') no diret&#243;rio atual. Se a op&#231;&#227;o ''-o
 &lt;arquivo&gt;'' n&#227;o for informada, o GPT criar&#225; o execut&#225;vel usando o nome do
-algoritmo. Ap&#243;s executar o programa criado, &#233; exibido o texto ``Ola mundo!'' na
+algoritmo. Ap&#243;s executar o programa criado, &#233; exibido o texto ''Ola mundo!'' na
 tela.
 \newline
 
 Como j&#225; deve ter assumido, coment&#225;rios ao estilo C (/**/) e C++ (//) s&#227;o
 permitidos e o que estiver entre aspas duplas (&quot;) &#233; tratado como uma string ou
 constante literal. Escapes s&#227;o permitidos como EOL ($\backslash$n), tabula&#231;&#227;o
-($\backslash$t) dentre outros. N&#227;o &#233; permitido a concatena&#231;&#227;o em multiplas
+($\backslash$t) dentre outros. N&#227;o &#233; permitido a concatena&#231;&#227;o em m&#250;ltiplas
 linhas como na linguagem C:
 
 \begin{verbatim}
@@ -365,14 +365,14 @@
           &quot;Concatena&#231;&#227;o&quot;); //erro!
 \end{verbatim}
 
-Outro detalhe &#233; a pontua&#231;&#227;o. Da mesma forma que em C, o ``;'' &#233; utilizado como
+Outro detalhe &#233; a pontua&#231;&#227;o. Da mesma forma que em C, o '';'' &#233; utilizado como
 finalizador de enunciados.
 
 \section{Vari&#225;veis}
 
 A declara&#231;&#227;o de vari&#225;veis deve ser feita dentro de um bloco espec&#237;fico, que deve aparecer logo ap&#243;s a 
-declara&#231;&#227;o do algoritmo. O bloco &#233; iniciado pela palavra-chave ``vari&#225;veis'' (sim, com acento) e 
-termina com a palavra chave ``fim-vari&#225;veis''. Pelo menos uma vari&#225;vel deve
+declara&#231;&#227;o do algoritmo. O bloco &#233; iniciado pela palavra-chave ''vari&#225;veis'' (sim, com acento) e 
+termina com a palavra chave ''fim-vari&#225;veis''. Pelo menos uma vari&#225;vel deve
 ser declarada dentro do bloco (embora o bloco em si seja opcional) e apenas
 um bloco em escopo global deve ser declarado. Eis um exemplo para estudo:
 
@@ -402,44 +402,44 @@
 \end{verbatim}
 
 Isso &#233;, um ou mais identificadores separados por virgula, seguido de um
-``:'', seguido de um tipo, seguido, finalmente, de ``;''. Como pode-se notar, &#233;
+'':'', seguido de um tipo, seguido, finalmente, de '';''. Como pode-se notar, &#233;
 parecido com Pascal. Assim que um programa &#233; executado, todas as vari&#225;veis,
 primitivas ou vetores/matrizes, declaradas s&#227;o iniciadas com um valor nulo ou
-``0'' automaticamente. Vale ressaltar que constantes (const, final, etc) n&#227;o s&#227;o
+''0'' automaticamente. Vale ressaltar que constantes (const, final, etc) n&#227;o s&#227;o
 suportados. Os tipos primitivos suportados encontram-se na tabela
 \ref{tb_tipos_primitivos}
 
-A fim explorar melhor os aspectos da declara&#231;&#227;o, seguem-se alguns coment&#225;rios a
+A fim de explorar melhor os aspectos da declara&#231;&#227;o, seguem-se alguns coment&#225;rios a
 respeito do &#250;ltimo exemplo (programa \ref{programa_inutil})
 
 \begin{itemize}
  \item 
-  Observe que o nome do algoritmo (``teste\_variaveis'')
+  Observe que o nome do algoritmo (''teste\_variaveis'')
 n&#227;o tem
-acento. Se declarar o algoritmo como ``teste\_vari&#225;veis'' e tentar
+acento. Se declarar o algoritmo como ''teste\_vari&#225;veis'' e tentar
 compilar o c&#243;digo, o seguinte erro ser&#225; exibido:
 
-  \textbf{Linha: 1 - ``teste\_vari&#225;veis'' n&#227;o pode ter caracteres
+  \textbf{Linha: 1 - ''teste\_vari&#225;veis'' n&#227;o pode ter caracteres
 especiais.}
 
   Portanto, identificadores (nomes de vari&#225;veis, fun&#231;&#245;es e do algoritmo) n&#227;o
   podem ter acentos ou caracteres especiais como \$, \#, etc. A defini&#231;&#227;o
   de um identificador em   G-Portugol &#233; equivalente ao das linguagens populares:
   uma letra (a-z ou A-Z) seguido de qualquer n&#250;mero de letras ou n&#250;meros.
-  Finalmente, underlines s&#227;o permitidos.   Cedilhas, portanto, tamb&#233;m n&#227;o
+  Finalmente, underlines (_) s&#227;o permitidos. Cedilhas, portanto, tamb&#233;m n&#227;o
   formam identificadores v&#225;lidos. 
 
  \item 
-  O segundo ponto, &#233; a palavra-chave ``vari&#225;veis'': ela tem acento, e isso &#233;
+  O segundo ponto, &#233; a palavra-chave ''vari&#225;veis'': ela tem acento, e isso &#233;
 permitido e obrigat&#243;rio. 
 
   \item
   O terceiro, &#233; a defini&#231;&#227;o do bloco e sua (falta de) semelhan&#231;a com o Pascal. Todas os blocos em G-Portugol 
-  tentam seguir o formato ``nome/fim-nome'', em favor da uniformidade e em detrimento de exce&#231;&#245;es lingu&#237;sticas 
+  tentam seguir o formato ''nome/fim-nome'', em favor da uniformidade e em detrimento de exce&#231;&#245;es lingu&#237;sticas 
   que confundem os estudantes.
 
   \item 
-  E, finalmente, o quarto ponto &#233; a aus&#234;ncia de c&#243;digo entre ``in&#237;cio'' e ``fim''. 
+  E, finalmente, o quarto ponto &#233; a aus&#234;ncia de c&#243;digo entre ''in&#237;cio'' e ''fim''. 
   O programa n&#227;o &#233; obrigado a ter enunciados ou comandos.
 \end{itemize}
 
@@ -450,7 +450,7 @@
 \subsection{Vetores e matrizes (conjuntos)}
 
 
-Vetores e matrizes ``n'' dimensionais de tipos primitivos s&#227;o suportados. Um
+Vetores e matrizes ''n'' dimensionais de tipos primitivos s&#227;o suportados. Um
 exemplo de declara&#231;&#227;o de uma matriz:
 
 
@@ -461,22 +461,22 @@
 fim-vari&#225;veis 
 \end{verbatim}
 
-O tipo do vetor ou matriz &#233; dado pelo nome do tipo no plural (``inteiros'' para tipo inteiro, ``literais'' 
-para tipo literal, etc). Os subscritos na declara&#231;&#227;o (delimitados por ``[]'') indicam o tamanho da matriz, 
-e sua dimens&#227;o &#233; informada pelo numero de subscritos. Portanto, ``bitset'' &#233; um vetor de 10 valores l&#243;gicos,
-enquanto ``quadr'' &#233; uma matriz bidimensional, onde as duas dimens&#245;es tem tamanho 4.
+O tipo do vetor ou matriz &#233; dado pelo nome do tipo no plural (''inteiros'' para tipo inteiro, ''literais'' 
+para tipo literal, etc). Os subscritos na declara&#231;&#227;o (delimitados por ''[]'') indicam o tamanho da matriz, 
+e sua dimens&#227;o &#233; informada pelo n&#250;mero de subscritos. Portanto, ''bitset'' &#233; um vetor de 10 valores l&#243;gicos,
+enquanto ''quadr'' &#233; uma matriz bidimensional, onde as duas dimens&#245;es tem tamanho 4.
 
-&#201; importante observar que matrizes s&#227;o ``0 based'', isso &#233;, iniciam no
-&#237;ndice 0 e seus &#237;ndices s&#227;o sempre inteiros positivos. Logo, a matriz ``bitset''
+&#201; importante observar que matrizes s&#227;o ''0 based'', isso &#233;, iniciam no
+&#237;ndice 0 e seus &#237;ndices s&#227;o sempre inteiros positivos. Logo, a matriz ''bitset''
 pode ser usada do &#237;ndice 0 at&#233; o &#237;ndice 9 (inclusive). Seu &#237;ndice 10 n&#227;o &#233;
 v&#225;lido e seu uso poder&#225; acarretar em erros de execu&#231;&#227;o (\textit{runtime
 errors}). Matrizes, assim como vari&#225;veis de tipos primitivos, s&#227;o inicializadas
-com o valor ``0'' ou ``nulo'' em todas as suas posi&#231;&#245;es. Quando usadas como
+com o valor ''0'' ou ''nulo'' em todas as suas posi&#231;&#245;es. Quando usadas como
 argumentos de fun&#231;&#245;es, matrizes s&#227;o passadas \textit{por valor}.
 
 \begin{quotation}
-  \textit{``O mundo &#233; divido em dois grupos: aqueles que come&#231;am a
-contar a partir do ''0``, e aqueles que n&#227;o.''}
+  \textit{''O mundo &#233; divido em dois grupos: aqueles que come&#231;am a
+contar a partir do ''0'', e aqueles que n&#227;o.''}
    \begin{flushright}
   -- An&#244;nimo
   \end{flushright}
@@ -488,7 +488,7 @@
 demais estruturas utilizam express&#245;es, que s&#227;o avaliadas para que uma
 decis&#227;o seja tomada (repetir execu&#231;&#227;o, selecionar bloco de instru&#231;&#245;es,
 etc). Qualquer express&#227;o pode ser avaliada como express&#227;o l&#243;gica.
-Express&#245;es num&#233;ricas de valor ``0'' s&#227;o avaliadas como falso. Demais valores
+Express&#245;es num&#233;ricas de valor ''0'' s&#227;o avaliadas como falso. Demais valores
 num&#233;ricos s&#227;o avaliados como verdadeiro. Valores literais nulos, da mesma forma,
 s&#227;o avaliados como falso, e demais textos, como verdadeiro. Para maiores
 detalhes sobre express&#245;es, veja a se&#231;&#227;o \ref{sec:expr}.
@@ -544,22 +544,22 @@
 
 \begin{itemize}
   \item 
-  O nome do algoritmo &#233; ``idade'', assim como o nome de uma vari&#225;vel. N&#227;o h&#225;
+  O nome do algoritmo &#233; ''idade'', assim como o nome de uma vari&#225;vel. N&#227;o h&#225;
 conflitos.
 
   \item
-  O operador de atribui&#231;&#227;o &#233; o \textit{pascal-like} ``:=''.
+  O operador de atribui&#231;&#227;o &#233; o \textit{pascal-like} '':=''.
 
   \item
-  A fun&#231;&#227;o interna ``leia'' pode ser usada por vari&#225;veis primitivas de qualquer
+  A fun&#231;&#227;o interna ''leia'' pode ser usada por vari&#225;veis primitivas de qualquer
 tipo.
 
   \item
-  A fun&#231;&#227;o ``imprima'' recebe um n&#250;mero de argumentos vari&#225;veis, que podem ser
-  constantes literais (n&#250;meros, textos entre aspas, caracteres entre aspas
-simples,...), vari&#225;veis primitivas ou &#237;ndices de vetores/matrizes. Os
-  valores s&#227;o concatenados e adicionados de um caractere EOL (end of line, ou
-  fim de linha).
+  A fun&#231;&#227;o ''imprima'' recebe um n&#250;mero vari&#225;vel de argumentos de qualquer tipo primitivo,
+sendo que pelo menos um argumento deve ser passado, que podem ser constantes literais 
+(n&#250;meros, textos entre aspas, caracteres entre aspas simples,...), vari&#225;veis primitivas ou 
+&#237;ndices de vetores/matrizes. Os valores s&#227;o concatenados e adicionados de um caractere EOL 
+(end of line, ou fim de linha).
 
   \item
   J&#225; vimos que strings/literais constantes s&#227;o denotados por texto entre aspas duplas (&quot;). Tal qual em C, 
@@ -567,15 +567,15 @@
 tamb&#233;m, permite escapes para representar caracteres como EOL ('$\backslash$n').
 
   \item
-  Assim como a palavra-chave ``vari&#225;veis'', ``ent&#227;o'' e ``sen&#227;o'' devem ser acentuadas. 
+  Assim como a palavra-chave ''vari&#225;veis'', ''ent&#227;o'' e ''sen&#227;o'' devem ser acentuadas. 
 
   \item 
-  Par&#234;ntesis ao redor da express&#227;o da estrutura ``se/ent&#227;o'' s&#227;o opcionais.
+  Par&#234;ntesis ao redor da express&#227;o da estrutura ''se/ent&#227;o'' s&#227;o opcionais.
 
   \item
-  Como em ``vari&#225;veis/fim-vari&#225;veis'', blocos ``se'' tem seus respectivos e obrigat&#243;rios ``fim-se''. 
+  Como em ''vari&#225;veis/fim-vari&#225;veis'', blocos ''se'' tem seus respectivos e obrigat&#243;rios ''fim-se''. 
   N&#227;o h&#225; a op&#231;&#227;o de ignorar a defini&#231;&#227;o do bloco quando apenas um enunciado &#233;
-  usado, como na linguagem C onde o uso de ``\{\}'' &#233; opcional. Tamb&#233;m, n&#227;o h&#225; 
+  usado, como na linguagem C onde o uso de ''\{\}'' &#233; opcional. Tamb&#233;m, n&#227;o h&#225; 
   imposi&#231;&#245;es  sobre a indenta&#231;&#227;o. O programa \ref{programa_se_incorreto}
 ilustra esse assunto.
 
@@ -599,11 +599,11 @@
 
 \section{Estruturas de repeti&#231;&#227;o}
 
-\subsection{A estrutura ``enquanto''}
+\subsection{A estrutura ''enquanto''}
 
-A estrutura ``enquanto'' &#233; a mais b&#225;sica e comum das estruturas de repeti&#231;&#227;o. Seu funcionamento &#233; o mesmo que
+A estrutura ''enquanto'' &#233; a mais b&#225;sica e comum das estruturas de repeti&#231;&#227;o. Seu funcionamento &#233; o mesmo que
 em outras linguagens populares, onde um conjunto de instru&#231;&#245;es &#233; executado repetidamente enquanto o valor 
-l&#243;gico de uma dada express&#227;o for avaliado como ``verdadeiro''.
+l&#243;gico de uma dada express&#227;o for avaliado como ''verdadeiro''.
 
 \begin{program}
   \begin{verbatim}
@@ -630,20 +630,20 @@
   imprima(&quot;fatorial de &quot;,fat,&quot; &#233; igual a &quot;,res);  
 fim
   \end{verbatim}
-  \caption{Exemplo de programa que utiliza a estrutura ``enquanto''.}
+  \caption{Exemplo de programa que utiliza a estrutura ''enquanto''.}
 \end{program}
 
 
-Assim como na estrutura ``se/ent&#227;o'', par&#234;nteses em volta da express&#227;o s&#227;o
+Assim como na estrutura ''se/ent&#227;o'', par&#234;nteses em volta da express&#227;o s&#227;o
 opcionais e as express&#245;es seguem as mesmas regras.
 
-\subsection{A estrutura ``para''}
+\subsection{A estrutura ''para''}
 
-A estrutura ``para'' &#233; uma especializa&#231;&#227;o da estrutura ``enquanto'', e costuma ser ensinada em cursos de programa&#231;&#227;o.
-Sua sint&#225;xe &#233; semelhante ao que se v&#234; em literatura sobre algoritmos e estruturas de dados, entretanto, &#233; uma sintaxe
+A estrutura ''para'' &#233; uma especializa&#231;&#227;o da estrutura ''enquanto'', e costuma ser ensinada em cursos de programa&#231;&#227;o.
+Sua sintaxe &#233; semelhante ao que se v&#234; em literatura sobre algoritmos e estruturas de dados, entretanto, &#233; uma sintaxe
 diferente de linguagens populares como C e Java.
 
-A estrutura ``para'' tem a seguinte forma:
+A estrutura ''para'' tem a seguinte forma:
 
 \begin{verbatim}
  para &lt;vari&#225;vel&gt; de &lt;express&#227;o&gt; at&#233; &lt;express&#227;o&gt; [passo &lt;inteiro&gt;] fa&#231;a
@@ -655,18 +655,18 @@
 Onde:
 \begin{itemize}
  \item 
-  ``vari&#225;vel'' deve ser uma vari&#225;vel num&#233;rica;
+  ''vari&#225;vel'' deve ser uma vari&#225;vel num&#233;rica;
   \item
-  ``express&#227;o'' deve ser uma express&#227;o que tem seu valor avaliado como num&#233;rico;
+  ''express&#227;o'' deve ser uma express&#227;o que tem seu valor avaliado como num&#233;rico;
   \item
-  ``passo'', se existir, deve ser seguido por um inteiro constante.
+  ''passo'', se existir, deve ser seguido por um inteiro constante.
 \end{itemize}
   
 As express&#245;es de/at&#233; controlam os valores que a vari&#225;vel num&#233;rica ter&#225; no
 in&#237;cio e no fim do la&#231;o, respectivamente. Tanto o controle da frequ&#234;ncia, quanto
 a decis&#227;o de incrementar ou decrementar a vari&#225;vel de controle &#233; feita pelo
-termo opcional ``passo'', e seu valor padr&#227;o &#233; 1. Por exemplo, para iterar o
-valor de uma vari&#225;vel num&#233;rica ``x'' de 0 at&#233; 10, escreve-se: 
+termo opcional ''passo'', e seu valor padr&#227;o &#233; 1. Por exemplo, para iterar o
+valor de uma vari&#225;vel num&#233;rica ''x'' de 0 at&#233; 10, escreve-se: 
 
   \begin{verbatim}
 para x de 0 at&#233; 10 fa&#231;a
@@ -709,35 +709,35 @@
 fim
 
   \end{verbatim}
-  \caption{Exemplo de programa que utiliza a estrutura ''para``.}
+  \caption{Exemplo de programa que utiliza a estrutura ''para''.}
 \end{program}
 
 
-Em compara&#231;&#227;o com a estrutura ``for'' de linguagens com sintaxe baseadas em C,
-h&#225; diferen&#231;as n&#227;o s&#243; de sintaxe, mas de implementa&#231;&#227;o. Um ``for'' que itera
+Em compara&#231;&#227;o com a estrutura ''for'' de linguagens com sintaxe baseadas em C,
+h&#225; diferen&#231;as n&#227;o s&#243; de sintaxe, mas de implementa&#231;&#227;o. Um ''for'' que itera
 sobre uma vari&#225;vel num&#233;rica de 0 at&#233; (incluindo) 10, ao sair do la&#231;o, o
 valor dessa vari&#225;vel ser&#225; 11. Em G-Portugol, a vari&#225;vel ter&#225; o valor 10 ao
-sair do la&#231;o. Essa diferen&#231;a acontece porque a sintaxe do ``para'' induz a esse
-comportamento, diferente da sintaxe do ``for'', que tem um aspecto de mais
+sair do la&#231;o. Essa diferen&#231;a acontece porque a sintaxe do ''para'' induz a esse
+comportamento, diferente da sintaxe do ''for'', que tem um aspecto de mais
 baixo n&#237;vel.
 
 \begin{verbatim}  
 //c&#243;digo em C
 for(x = 0; x &lt;= 10; x++);
-printf(&quot;%d&quot;, x); //imprime ``11''
+printf(&quot;%d&quot;, x); //imprime ''11''
 //--------------
 
 //c&#243;digo equivalente em G-Portugol
 para x de 0 at&#233; 10 fa&#231;a
 fim-para
 
-imprima(x); //imprime ``10''
+imprima(x); //imprime ''10''
 \end{verbatim}
 
-Ademais, da mesma forma que o ``for'', &#233; poss&#237;vel que a vari&#225;vel de controle tenha seu valor
+Ademais, da mesma forma que o ''for'', &#233; poss&#237;vel que a vari&#225;vel de controle tenha seu valor
 alterado pelos comandos aninhados. Isso permite que o la&#231;o seja encerrado prematuramente, como tamb&#233;m &#233; comum
-em estruturas como ``enquanto''. A utilidade dessa t&#233;cnica est&#225; no fato de G-Portugol n&#227;o incorporar mecanismos
-para refinar o controle de la&#231;os (como ``break'' e ``continue'', encontrados em linguagens populares).
+em estruturas como ''enquanto''. A utilidade dessa t&#233;cnica est&#225; no fato de G-Portugol n&#227;o incorporar mecanismos
+para refinar o controle de la&#231;os (como ''break'' e ''continue'', encontrados em linguagens populares).
 
 \section{Fun&#231;&#245;es}
 
@@ -747,10 +747,10 @@
 retorno, que deve ser de tipo primitivo. Tanto o retorno de dados como a
 passagem de argumentos s&#227;o feitos \textit{por valor}.
 
-Para retorno prematuro ou retorno de dados, a palavra chave ``retorne'' &#233; usada. Para fun&#231;&#245;es que retornam dados,
-``retorne'' deve ser seguido de um operando, que &#233; uma express&#227;o cujo valor deve ser compat&#237;vel com o tipo da fun&#231;&#227;o.
-J&#225; fun&#231;&#245;es que n&#227;o declaram um tipo de retorno expliticamente  (equivalente a fun&#231;&#245;es de retorno ``void'' em C), 
-``retorne'' deve ser usado sem operando.
+Para retorno prematuro ou retorno de dados, a palavra chave ''retorne'' &#233; usada. Para fun&#231;&#245;es que retornam dados,
+''retorne'' deve ser seguido de um operando, que &#233; uma express&#227;o cujo valor deve ser compat&#237;vel com o tipo da fun&#231;&#227;o.
+J&#225; fun&#231;&#245;es que n&#227;o declaram um tipo de retorno expliticamente  (equivalente a fun&#231;&#245;es de retorno ''void'' em C), 
+''retorne'' deve ser usado sem operando.
 
 \begin{program}[h!t]
  \begin{verbatim}
@@ -782,20 +782,20 @@
 \subsection{Fun&#231;&#245;es internas}
 \label{sec:func_internas}
 
-Como j&#225; foi visto em exemplos anteriores, G-Portugol oferece duas fun&#231;&#245;es internas: ``leia'' e ``imprima'', que
+Como j&#225; foi visto em exemplos anteriores, G-Portugol oferece duas fun&#231;&#245;es internas: ''leia'' e ''imprima'', que
 permitem uso b&#225;sico de entrada e sa&#237;da, respectivamente.
 
-A fun&#231;&#227;o ``leia'' n&#227;o recebe argumentos e retorna o valor lido da entrada padr&#227;o
-(``STDIN''), o que significa, geralmente, ler os dados que o usu&#225;rio digitar
-no teclado, seguido do caractere ``nova linha'' (em geral, associado a
-tecla ``Enter'' no teclado). O tipo de dado retornado por ``leia''
+A fun&#231;&#227;o ''leia'' n&#227;o recebe argumentos e retorna o valor lido da entrada padr&#227;o
+(''STDIN''), o que significa, geralmente, ler os dados que o usu&#225;rio digitar
+no teclado, seguido do caractere ''nova linha'' (em geral, associado a
+tecla ''Enter'' no teclado). O tipo de dado retornado por ''leia''
 &#233; implicitamente convertido para o tipo primitivo exigido no contexto em que ela
 &#233; usada.
 
-A fun&#231;&#227;o ``imprima'' recebe um n&#250;mero vari&#225;vel de argumentos de qualquer tipo
+A fun&#231;&#227;o ''imprima'' recebe um n&#250;mero vari&#225;vel de argumentos de qualquer tipo
 primitivo, sendo que pelo menos um argumento deve ser passado. Os
 valores passados como argumentos s&#227;o convertidos para texto, concatenados
-na ordem definida e enviados para ``STDOUT'' (em geral, associado ao
+na ordem definida e enviados para ''STDOUT'' (em geral, associado ao
 \textit{display} ou monitor). N&#227;o h&#225; retorno de valor para esta fun&#231;&#227;o.
 
 \begin{program}
@@ -827,7 +827,7 @@
 fim
   \end{verbatim}
 
-  \caption{Exemplo de usos das fun&#231;&#245;es internas ``leia'' e ``imprima''.}
+  \caption{Exemplo de usos das fun&#231;&#245;es internas ''leia'' e ''imprima''.}
 \end{program}
 
 
@@ -882,7 +882,7 @@
 interessantes e, talvez, mais eficientes como ferramentas de ensino,
 mas G-Portugol est&#225;, no momento, comprometida com a compatibilidade.
 
-A seguir, alguns t&#243;picos ser&#227;o comentados quanto as diretrizes por traz
+A seguir, alguns t&#243;picos ser&#227;o comentados quanto as diretrizes por tr&#225;s
 das formas l&#233;xicas e gramaticais da linguagem G-Portugol.
 
 \subsection{Diretrizes para o design da linguagem}
@@ -900,7 +900,7 @@
 usu&#225;rios (estudantes e professores) a se ater mais com o estudo da linguagem do
 que com o estudo da disciplina em quest&#227;o. Isso &#233;, a aus&#234;ncia de acentos, por
 exemplo, obriga o usu&#225;rio a aprender seus termos excepcionais. Al&#233;m do mais,
-o uso de termos como ``nao'', chama a aten&#231;&#227;o constante do usu&#225;rio para o fato
+o uso de termos como ''nao'', chama a aten&#231;&#227;o constante do usu&#225;rio para o fato
 de a palavra n&#227;o estar acentuada, o que costuma desviar aten&#231;&#227;o do estudo.
 
 Consequentemente, o uso de acentos permite que a linguagem seja o mais pr&#243;ximo
@@ -908,7 +908,7 @@
 si. Ademais, o c&#243;digo fica mais leg&#237;vel e permite uma leitura mais agrad&#225;vel.
 
 Al&#233;m dos acentos, &#233; exigido que as palavras-chave usadas sejam completas ou por
-extenso, sem permitir abrevia&#231;&#245;es (ex. ``proc'', ``func'', ``char'', ``int'',
+extenso, sem permitir abrevia&#231;&#245;es (ex. ''proc'', ''func'', ''char'', ''int'',
 ...), o que dificulta a leitura de programas por um leigo.
 
 H&#225; tamb&#233;m decis&#245;es quanto a forma verbal de comandos e fun&#231;&#245;es. Em geral,
@@ -922,7 +922,7 @@
 literaturas sobre algoritmos.
 
 \begin{quotation}
-  \textit{``Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para m&#225;quinas executarem.''}
+  \textit{''Programas devem ser escritos para pessoas lerem e, apenas incidentalmente, para m&#225;quinas executarem.''}
    \begin{flushright}
   -- Abelson e Sussman
   \end{flushright}
@@ -949,7 +949,7 @@
 
 Essa diretriz diz respeito a permitir que a linguagem mude em certos aspectos
 (ou disponibilizar meios simples para realizar essas mudan&#231;as) de acordo com
-o gosto do professor, ou como modo de adapatar a forma de portugol de uma
+o gosto do professor, ou como modo de adaptar a forma de portugol de uma
 dada literatura. Dialetos e formas da linguagem portugol variam de
 literatura para literatura, e pode ser interessante permitir que a linguagem se
 adapte ou oferecer diferentes formas da linguagem.
@@ -959,7 +959,7 @@
 estruturas, como algumas declara&#231;&#245;es e enunciados. 
 
 Por exemplo, pode ser interessante que, para se declarar uma var&#237;avel, n&#227;o se
-use um bloco iniciado por ``vari&#225;veis'' e terminado por ``fim-vari&#225;veis'', mas
+use um bloco iniciado por ''vari&#225;veis'' e terminado por ''fim-vari&#225;veis'', mas
 como um bloco parecido com a declara&#231;&#227;o de vari&#225;veis em Pascal, ou at&#233; em C (que
 sequer exige delimita&#231;&#227;o de bloco de vari&#225;veis).
 
@@ -969,7 +969,7 @@
 mais direta e que aproveita melhor os conhecimentos do estudante.
 
 Atualmente, o programa GPT n&#227;o implementa mecanismos para esse tipo de
-mudan&#231;a, sendo nescessario modificar seu c&#243;digo fonte e recompil&#225;-lo. 
+mudan&#231;a, sendo necess&#225;rio modificar seu c&#243;digo fonte e recompil&#225;-lo. 
 
 \section{Formato Estrutural}
 
@@ -1010,24 +1010,24 @@
 \end{verbatim}
 
 Esse formato difere de linguagens como Pascal e C. Em Pascal, o bloco n&#227;o tem um
-delimitador final (como ``fim-vari&#225;veis'') e em C, n&#227;o existe qualquer
+delimitador final (como ''fim-vari&#225;veis'') e em C, n&#227;o existe qualquer
 delimitador.
 
 Delimitar o bloco permite maior consist&#234;ncia com outras formas gramaticais
 como os blocos de comando e estruturas de controle, e torna o c&#243;digo mais
-claro e explicito, embora adicione constru&#231;&#245;es redundantes.
+claro e expl&#237;cito, embora adicione constru&#231;&#245;es redundantes.
 
 Os tipos primitivos englobam os tipos mais b&#225;sicos das linguagens populares.
 No momento, agregados heterog&#234;neos como, por exemplo, estruturas/registros
-(``struct'' em C) n&#227;o s&#227;o suportados. Para uma lista dos tipos suportados, veja
+(''struct'' em C) n&#227;o s&#227;o suportados. Para uma lista dos tipos suportados, veja
 a tabela \ref{tb_tipos_primitivos}.
   
 \subsection{Bloco Principal}
 
-As linguagens de programa&#231;&#227;o devem, de alguma forma, oferecer um ``entry point''
+As linguagens de programa&#231;&#227;o devem, de alguma forma, oferecer um ''entry point''
 (ponto de entrada), de onde se inicia a execu&#231;&#227;o do programa. O ponto de entrada
 pode ser uma fun&#231;&#227;o ou um bloco an&#244;nimo. Na literatura, em geral, o bloco
-principal &#233; delimitado pelos termos ``in&#237;cio''e ``fim'' e G-Portugol segue
+principal &#233; delimitado pelos termos ''in&#237;cio''e ''fim'' e G-Portugol segue
 essa conven&#231;&#227;o. Essa decis&#227;o mant&#233;m um n&#237;vel satisfat&#243;rio de coer&#234;ncia
 com o bloco de vari&#225;veis globais e estruturas de controle, embora n&#227;o sejam
 intimamente relacionados.
@@ -1040,20 +1040,20 @@
 
 Estruturas de controle s&#227;o formadas por um cabe&#231;alho seguido por
 um bloco de comandos e terminados por um delimitador final. Embora os
-delimitadores do bloco n&#227;o sejam ``in&#237;cio'' e ``fim'', h&#225; um grau de semelhan&#231;a
+delimitadores do bloco n&#227;o sejam ''in&#237;cio'' e ''fim'', h&#225; um grau de semelhan&#231;a
 mantido: o delimitador inicial &#233; omitido (uma vez que o cabe&#231;alho &#233; entendido
-como delimitador inicial) e o delimitador final &#233; o termo ``fim-'' seguido do
+como delimitador inicial) e o delimitador final &#233; o termo ''fim-'' seguido do
 nome da estrutura.
 
-No cabe&#231;alho das estruturas como ``enquanto'' e ``se'', as express&#245;es n&#227;o
-precisam ser delimitadas por par&#234;ntesis.
+No cabe&#231;alho das estruturas como ''enquanto'' e ''se'', as express&#245;es n&#227;o
+precisam ser delimitadas por par&#234;nteses.
 
 
   \subsubsection{Express&#245;es}
   \label{sec:expr}
 
 Express&#245;es s&#227;o opera&#231;&#245;es que sintetizam, ao final, um valor. Em geral
-constituem valores ou opera&#231;&#245;es aritim&#233;ticas com um ou mais termos que podem
+constituem valores ou opera&#231;&#245;es aritm&#233;ticas com um ou mais termos que podem
 ser vari&#225;veis, constantes ou chamadas a fun&#231;&#245;es e s&#227;o usadas em atribui&#231;&#245;es,
 estruturas de controle e subscritos de matrizes e vetores. Enunciados (como
 atribui&#231;&#245;es) n&#227;o podem ser avaliados como express&#245;es.
@@ -1065,49 +1065,49 @@
  \item 
   Inteiros: Podem ser representados em base decimal, hexadecimal, octal e
 bin&#225;ria. Representa&#231;&#245;es decimais s&#227;o formadas, opcionalmente, por um sinal
-(``+'' ou ``-'') seguido de um mais algarismos(ex.``120'', ``+5'', e ``-2'').
-Representa&#231;&#245;es hexadecimais s&#227;o representadas com o prefixo ``0x'' ou
-`` 0X'', seguido de algarismos entre ``0'' e ``9'' e letras entre ``a'' e ``f''
-ou ``A'' e ``F'' (ex. ``0xF1A5''). Representa&#231;&#245;es octais s&#227;o representadas com o
-prefixo ``0c'' ou ``0C'', seguido de algarismos entre ``0'' e ``7'' (ex.
-``0c61''). Finalmente, representa&#231;&#245;es bin&#225;rias s&#227;o formadas pelo prefixo ``0b''
-ou ``0B'', seguido de algarismos ``0'' e ``1'' (ex. ``0b101'').
+(''+'' ou ''-'') seguido de um mais algarismos(ex.''120'', ''+5'', e ''-2'').
+Representa&#231;&#245;es hexadecimais s&#227;o representadas com o prefixo ''0x'' ou
+'' 0X'', seguido de algarismos entre ''0'' e ''9'' e letras entre ''a'' e ''f''
+ou ''A'' e ''F'' (ex. ''0xF1A5''). Representa&#231;&#245;es octais s&#227;o representadas com o
+prefixo ''0c'' ou ''0C'', seguido de algarismos entre ''0'' e ''7'' (ex.
+''0c61''). Finalmente, representa&#231;&#245;es bin&#225;rias s&#227;o formadas pelo prefixo ''0b''
+ou ''0B'', seguido de algarismos ''0'' e ''1'' (ex. ''0b101'').
 
   \item
-  Reais: s&#227;o representados por, opcionalmente, um sinal (``+ ou
-''-``), seguido de algarismos separados por um ``.'' como ``-1.2345''.
+  Reais: s&#227;o representados por, opcionalmente, um sinal (''+ ou
+''-''), seguido de algarismos separados por um ''.'' como ''-1.2345''.
 
   \item
   Caracteres: s&#227;o representados por um &#250;nico simbolo entre aspas simples.
-Alguns caracteres especiais s&#227;o representados com escape (``$\backslash$'')
-seguido de s&#237;mbolo identificador. Esses caracteres s&#227;o o LF (``$\backslash$n''),
-CR (``$\backslash$r'') e barra invertida (``$\backslash$$\backslash$''). A
-aus&#234;ncia de s&#237;mbolos entre as aspas simples indica um caractere ``nulo''.
+Alguns caracteres especiais s&#227;o representados com escape (''$\backslash$'')
+seguido de s&#237;mbolo identificador. Esses caracteres s&#227;o o LF (''$\backslash$n''),
+CR (''$\backslash$r'') e barra invertida (''$\backslash$$\backslash$''). A
+aus&#234;ncia de s&#237;mbolos entre as aspas simples indica um caractere ''nulo''.
 Internamente, caracteres s&#227;o representados como n&#250;meros inteiros, o que permite
 sua compatibilidade num&#233;rica.
 
   \item
   Literais: s&#227;o representados por um conjunto de caracteres entre aspas duplas.
-Eles podem conter caracteres especiais como ``$\backslash$n'' e devem ser
+Eles podem conter caracteres especiais como ''$\backslash$n'' e devem ser
 definidos em apenas uma linha de c&#243;digo. Valores literais s&#227;o os &#250;nicos que n&#227;o
 tem uma representa&#231;&#227;o num&#233;rica, impedindo sua participa&#231;&#227;o em express&#245;es com
 operadores aritm&#233;ticos (soma, divis&#227;o, etc). Compara&#231;&#245;es de igualdade
 para valores literais s&#227;o feitas caractere por caractere em \textit{case
-sensitive}. Portanto, a express&#227;o ``portugol'' = ``Portugol'' &#233; avaliada como
+sensitive}. Portanto, a express&#227;o ''portugol'' = ''Portugol'' &#233; avaliada como
 falsa. J&#225; compara&#231;&#245;es de grandeza s&#227;o feitos calculando o n&#250;mero de caracteres
-que comp&#245;em os valores literais. Ent&#227;o, a express&#227;o ``maria'' &gt; ``jos&#233;'' &#233;
+que comp&#245;em os valores literais. Ent&#227;o, a express&#227;o ''maria'' &gt; ''jos&#233;'' &#233;
 avaliada como verdadeira.
 
   \item
-  L&#243;gicos: s&#227;o representados pelas palavras ``verdadeiro'' e ``falso''.
-Numericamente, qualquer valor diferente de ``0'' representa o valor verdadeiro e
-``0'' representa o valor falso.
+  L&#243;gicos: s&#227;o representados pelas palavras ''verdadeiro'' e ''falso''.
+Numericamente, qualquer valor diferente de ''0'' representa o valor verdadeiro e
+''0'' representa o valor falso.
 
 \end{itemize}
 
 A preced&#234;ncia de operadores &#233; mostrada na tabela \ref{tb_precedencia_op} (da
-menor preced&#234;ncia para a maior) e pode ser expl&#237;cicamente modificada com o uso
-de par&#234;ntesis.
+menor preced&#234;ncia para a maior) e pode ser explicicamente modificada com o uso
+de par&#234;nteses.
 
 
 \begin{table}[ht]
@@ -1130,7 +1130,7 @@
     \symbol{42}, /, \%     &amp; operadores aritm&#233;ticos multiplica&#231;&#227;o,
 divis&#227;o, m&#243;dulo \\
     +, -, \~{}, n&#227;o, () &amp; operadores un&#225;rios positivo, negativo, NOT bin&#225;rio, NOT
-l&#243;gico, par&#234;ntesis \\
+l&#243;gico, par&#234;nteses \\
     \hline
   \end{tabular}
   \caption{Preced&#234;ncia de Operadores \label{tb_precedencia_op}}
@@ -1139,7 +1139,7 @@
 
 
 Em G-Portugol, n&#227;o h&#225; coer&#231;&#227;o ou \textit{casting} de tipos expliticamente.
-Todos os tipos num&#233;ricos (inteiro, real, l&#243;gico e caractere) s&#227;o compativeis
+Todos os tipos num&#233;ricos (inteiro, real, l&#243;gico e caractere) s&#227;o compat&#237;veis
 entre si. &#201; importante ressaltar que express&#245;es envolvendo igualdade ou 
 diferen&#231;a de valores reais n&#227;o s&#227;o apropriadas dado a forma como esses valores 
 s&#227;o representados internamente. Tais compara&#231;&#245;es podem ter resultados 
@@ -1149,13 +1149,13 @@
 Existem dois casos em que ocorre uma coer&#231;&#227;o impl&#237;cita. O primeiro caso ocorre
 durante a avalia&#231;&#227;o de uma express&#227;o que tem operandos de tipos diferentes (mas
 compat&#237;veis entre si), onde n&#227;o h&#225; perda de dados e um dos termos &#233; promovido
-para o tipo do seu termo complementar. Por exemplo, na express&#227;o ``2 + 1.5'', o
-termo ``2'' &#233; promovido para o tipo ``real'', tendo o valor ``2.0'' antes
- que  a soma seja processada. Da mesma forma, sendo ``x'' uma vari&#225;vel de tipo
-real, a express&#227;o ``x := 5 / 2'' atribuir&#225; a ``x'' o valor ``2.00''. Esse
-comportamento n&#227;o muito &#243;bvio &#233; similar ao da linguagem C, onde ``5 / 2'' &#233;
+para o tipo do seu termo complementar. Por exemplo, na express&#227;o ''2 + 1.5'', o
+termo ''2'' &#233; promovido para o tipo ''real'', tendo o valor ''2.0'' antes
+ que  a soma seja processada. Da mesma forma, sendo ''x'' uma vari&#225;vel de tipo
+real, a express&#227;o ''x := 5 / 2'' atribuir&#225; a ''x'' o valor ''2.00''. Esse
+comportamento n&#227;o muito &#243;bvio &#233; similar ao da linguagem C, onde ''5 / 2'' &#233;
 avaliado como uma divis&#227;o de inteiros, onde apenas o valor inteiro final &#233;
-relevante. Para obter o resultado real, a express&#227;o deve ser ``5.0 / 2'', para
+relevante. Para obter o resultado real, a express&#227;o deve ser ''5.0 / 2'', para
 informar ao compilador que a divis&#227;o usar&#225; valores reais, produzindo a promo&#231;&#227;o
 de tipos mencionada anteriormente.
 
@@ -1166,8 +1166,8 @@
   \subsection{Atribui&#231;&#245;es}
   \label{subsec:atribuicoes}
 Atribui&#231;&#245;es permitem a manipula&#231;&#227;o de valores na mem&#243;ria. Em G-Portugol,
-como j&#225; foi visto, &#233; usado o operador ``:='', onde o termo a esquerda ou
-``\textit{lvalue}'' deve ser uma vari&#225;vel primitiva ou &#237;ndice de uma
+como j&#225; foi visto, &#233; usado o operador '':='', onde o termo a esquerda ou
+''\textit{lvalue}'' deve ser uma vari&#225;vel primitiva ou &#237;ndice de uma
 matriz/vetor, e o termo a direita, uma express&#227;o que, quando avaliada, tem seu
 tipo compat&#237;vel com o \textit{lvalue}.
 
@@ -1205,23 +1205,23 @@
 e podem receber argumentos e retornar valores. Em tempo de execu&#231;&#227;o, as fun&#231;&#245;es
 criam um novo escopo sobreposto ao escopo principal. Isso permite recursos
 como recurs&#227;o e possibilita que vari&#225;veis locais (no escopo da fun&#231;&#227;o) tenham o
-mesmo nome que vari&#225;veis globais, onde essas &#250;ltimas ficam ``escondidas'', isso
+mesmo nome que vari&#225;veis globais, onde essas &#250;ltimas ficam ''escondidas'', isso
 &#233;, incapazes de serem acessadas enquanto o escopo durar. Ressalta-se que n&#227;o h&#225;
 suporte para fun&#231;&#245;es aninhadas, isso &#233;, fun&#231;&#245;es declaradas dentro de fun&#231;&#245;es. 
 
-O retorno de dados &#233; feito por meio da instru&#231;&#227;o ``retorne'' e o valor de
+O retorno de dados &#233; feito por meio da instru&#231;&#227;o ''retorne'' e o valor de
 retorno (se houver) deve ser compat&#237;vel com o tipo da fun&#231;&#227;o. Esse tipo n&#227;o
 pode ser um tipo agregado como matrizes e vetores.
 
 Tanto a passagem de argumentos quanto o retorno &#233; feito \textit{por valor},
-isso &#233;, a copia do valor &#233; feita, ao invez de a copia de endere&#231;o ou passagem
+isso &#233;, a c&#243;pia do valor &#233; feita, ao inv&#233;s de a c&#243;pia de endere&#231;o ou passagem
 \textit{por refer&#234;ncia}.
 
 As vari&#225;veis locais de uma fun&#231;&#227;o s&#227;o formadas por seus par&#226;metros e pelas
 vari&#225;veis declaradas em seu escopo. A declara&#231;&#227;o de vari&#225;veis locais &#233; feita
-entre o cabe&#231;alho da fun&#231;&#227;o e a palavra-chave ``in&#237;cio'', portanto, n&#227;o &#233;
+entre o cabe&#231;alho da fun&#231;&#227;o e a palavra-chave ''in&#237;cio'', portanto, n&#227;o &#233;
 uniforme em rela&#231;&#227;o a declara&#231;&#227;o global, onde se usa as palavras-chave
-``vari&#225;veis'' e ``fim-vari&#225;veis''. 
+''vari&#225;veis'' e ''fim-vari&#225;veis''. 
 
 A declara&#231;&#227;o dos par&#226;metros da fun&#231;&#227;o tamb&#233;m n&#227;o segue estritamente o formato
 de declara&#231;&#227;o de vari&#225;veis. O programa \ref{exemplo_funcao} ilustra a
@@ -1253,11 +1253,11 @@
 sa&#237;da. Ambas as fun&#231;&#245;es tem comportamentos excepcionais quando comparadas
 com as fun&#231;&#245;es de usu&#225;rio. Essas fun&#231;&#245;es s&#227;o discutidas na sess&#227;o a seguir.
 
-  \subsection{A fun&#231;&#227;o ``imprima''}
+  \subsection{A fun&#231;&#227;o ''imprima''}
 
 A fun&#231;&#227;o imprima tem como objetivo imprimir texto no dispositivo de sa&#237;da.
 Ela recebe um n&#250;mero vari&#225;vel de argumentos (pelo menos um), onde cada
-argumento deve ser um valor primitivo, e os imprime em sequencia. Ao final, &#233;
+argumento deve ser um valor primitivo, e os imprime em sequ&#234;ncia. Ao final, &#233;
 impresso um caractere de nova linha (LF) e a fun&#231;&#227;o retorna.
 
 Essa fun&#231;&#227;o se comporta de forma excepcional visto que n&#227;o &#233;
@@ -1265,38 +1265,38 @@
 argumentos.
 
 
-  \subsection{A fun&#231;&#227;o ``leia''}
+  \subsection{A fun&#231;&#227;o ''leia''}
 
-A fun&#231;&#227;o ``leia'' espera por uma entrada do teclado seguida do caractere LF (em
-geral, associado a tecla ``Enter'') e retorna o valor lido. Esse valor &#233;
+A fun&#231;&#227;o ''leia'' espera por uma entrada do teclado seguida do caractere LF (em
+geral, associado a tecla ''Enter'') e retorna o valor lido. Esse valor &#233;
 convertido implicitamente para o tipo do \textit{lvalue}. A tabela
 \ref{tb_leia_casts} apresenta convers&#245;es impl&#237;citas processadas pela
-fun&#231;&#227;o ``leia'' para o enunciado de exemplo ``x := leia()''.
+fun&#231;&#227;o ''leia'' para o enunciado de exemplo ''x := leia()''.
 
-Nota: n&#250;meros reais s&#227;o arredondados, se nescess&#225;rio, e exibidos no formato
-.xx (com duas casas decimais). Portanto, o n&#250;mero ``250.0'' ou ``250'' seria
-impresso como ``250.00'' e ``1.449'' seria impresso como ``1.45''. Se o
+Nota: n&#250;meros reais s&#227;o arredondados, se necess&#225;rio, e exibidos no formato
+.xx (com duas casas decimais). Portanto, o n&#250;mero ''250.0'' ou ''250'' seria
+impresso como ''250.00'' e ''1.449'' seria impresso como ''1.45''. Se o
 par&#226;metro for uma vari&#225;vel, seu valor n&#227;o ser&#225; modificado.
 
 \begin{table}[ht]
 \begin{center}
   \begin{tabular}{|l|l|l|}
     \hline
-    \multicolumn{3}{|c|}{Convers&#245;es da fun&#231;&#227;o ``leia''} \\
+    \multicolumn{3}{|c|}{Convers&#245;es da fun&#231;&#227;o ''leia''} \\
     \hline
-      Tipo do LValue ``x'' &amp; Texto lido &amp; Valor final de ``x'' \\
+      Tipo do LValue ''x'' &amp; Texto lido &amp; Valor final de ''x'' \\
     \hline
       inteiro &amp; 123 &amp; 123 \\
       inteiro &amp; 123 456 &amp; 123 \\
       inteiro &amp; abc &amp; 0 \\
       inteiro &amp; 123s &amp; 123 \\
       l&#243;gico  &amp; falso &amp; falso \\
-      l&#243;gico &amp; ``0'' &amp; falso \\
+      l&#243;gico &amp; ''0'' &amp; falso \\
       l&#243;gico &amp; falso 12wtc &amp; verdadeiro \\
       l&#243;gico &amp; 0 umdois3 &amp; verdadeiro\\
     \hline
   \end{tabular}
-  \caption{Convers&#245;es impl&#237;citas da fun&#231;&#227;o ``leia'' \label{tb_leia_casts}}
+  \caption{Convers&#245;es impl&#237;citas da fun&#231;&#227;o ''leia'' \label{tb_leia_casts}}
 \end{center}
 \end{table}
 
@@ -1304,8 +1304,8 @@
 Essa fun&#231;&#227;o se comporta de forma excepcional visto que seu tipo de retorno n&#227;o
 &#233; absoluto (\textit{overloaded}, depende do tipo de \textit{lvalue}) e, no
 momento, &#233; restrita express&#245;es isentas de operadores. Isso &#233;, n&#227;o &#233; permitido
-aplic&#225;-la como um termo em uma express&#227;o com multiplos operandos (ex. ``x :=  y
-+ leia()``), embora seja poss&#237;vel utiliz&#225;-la em subscritos de vetores e
+aplic&#225;-la como um termo em uma express&#227;o com m&#250;ltiplos operandos (ex. ''x :=  y
++ leia()''), embora seja poss&#237;vel utiliz&#225;-la em subscritos de vetores e
 matrizes, assim como em express&#245;es de estruturas de controle. 
 
 Em princ&#237;pio, pode-se levar em conta duas formas de implementar uma fun&#231;&#227;o de
@@ -1321,7 +1321,7 @@
 
 \capitulo{O programa GPT}
 
-\section{Intrudu&#231;&#227;o}
+\section{Introdu&#231;&#227;o}
   
 GPT &#233; a ferramenta principal da linguagem G-Portugol. Entre suas fun&#231;&#245;es
 principais est&#227;o:
@@ -1330,7 +1330,7 @@
   \item
   Compilar algoritmos;
  \item 
-  Traduzir algortimos para outras linguagens;
+  Traduzir algoritmos para outras linguagens;
   \item
   Executar algoritmos.
 \end{itemize}
@@ -1353,7 +1353,7 @@
 \section{Op&#231;&#245;es gerais}
 \label{sec:opcoes_gerais}
 
-Ao executar o programa ``gpt'' com o argumento ``-h'', &#233; mostrado:
+Ao executar o programa ''gpt'' com o argumento ''-h'', &#233; mostrado:
 
 \begin{verbatim}
 Modo de uso: gpt [op&#231;&#245;es] arquivos
@@ -1375,10 +1375,10 @@
 
 \begin{itemize}
  \item 
-  v: Exibe a vers&#227;o do programa ``gpt'', assim como informa&#231;&#245;es de copyright;
+  v: Exibe a vers&#227;o do programa ''gpt'', assim como informa&#231;&#245;es de copyright;
 
   \item
-  h: exibe todas as op&#231;&#245;es suportadas pelo programa ``gpt'';
+  h: exibe todas as op&#231;&#245;es suportadas pelo programa ''gpt'';
 
   \item
   o &lt;arquivo&gt;: Ao compilar um algoritmo, salva o execut&#225;vel com o nome de
@@ -1395,23 +1395,23 @@
 
   \item 
   i: Executa o algoritmo diretamente, sem compilar ou criar arquivos. Op&#231;&#227;o
-conhecida como ``interpreta&#231;&#227;o'' ou ``scripting''.
+conhecida como ''interpreta&#231;&#227;o'' ou ''scripting''.
 
   \item
   d: Exibe mais informa&#231;&#245;es no relat&#243;rio de erros, como dicas de como proceder
-para solucionar errors de sint&#225;xe.
+para solucionar errors de sintaxe.
 \end{itemize}
 
-A &#250;ltima op&#231;&#227;o (``arquivos'') &#233; uma lista de arquivos contendo o c&#243;digo fonte
+A &#250;ltima op&#231;&#227;o (''arquivos'') &#233; uma lista de arquivos contendo o c&#243;digo fonte
 em G-Portugol, embora seja mais comum utilizar um arquivo apenas para cada
 algoritmo.
 
 \section{Tratamento de erros}
   
 Em geral, as ferramentas de diversas linguagens de programa&#231;&#227;o oferecem o
-m&#237;nimo de informa&#231;&#245;es a cerca de erros de compila&#231;&#227;o, as vezes, tendo uma
-forma ``criptica'' dificultando seu entendimento e posterior corre&#231;&#227;o.
-Comum, tamb&#233;m a possibilide de que determinados erros sejam reportados em
+m&#237;nimo de informa&#231;&#245;es a cerca de erros de compila&#231;&#227;o, &#224;s vezes, tendo uma
+forma ''criptica'' dificultando seu entendimento e posterior corre&#231;&#227;o.
+Comum, tamb&#233;m a possibilidade de que determinados erros sejam reportados em
 localiza&#231;&#245;es distantes de onde o erro efetivamente se encontra no c&#243;digo
 fonte. Ademais, &#233; importante notar que nessas linguagens, os erros s&#227;o
 reportados em ingl&#234;s. 
@@ -1433,12 +1433,12 @@
 com x86 e em dois formatos: ELF (\textit{Executable and linking format}) e PE
 (\textit{Portable Executable}). Sistemas Unix, em geral, suportam o formato
 ELF, e o formato PE &#233; conhecido nos sistemas Microsoft Windows. Ap&#243;s o processo
-de an&#225;lise, o compilador gera c&#243;digo em assembly para, ent&#227;o, usar o NASM
+de an&#225;lise, o compilador gera c&#243;digo em Assembly para, ent&#227;o, usar o NASM
 (Netwide Assembler) como \textit{backend} para montar e criar um execut&#225;vel
 v&#225;lido. Consequentemente, n&#227;o existe etapa de linkagem. A fase de otimiza&#231;&#227;o de
 c&#243;digo tamb&#233;m n&#227;o foi implementada.
 
-Para usar esse recurso, &#233; nescess&#225;rio que o NASM esteja instalado no sistema.
+Para usar esse recurso, &#233; necess&#225;rio que o NASM esteja instalado no sistema.
 Ele pode ser encontrado em <A HREF="http://www.sf.net/projects/nasm.">http://www.sf.net/projects/nasm.</A>
 
 \subsection{Tradu&#231;&#227;o para a linguagem C}
@@ -1457,42 +1457,42 @@
 compilador pode emitir avisos e erros, visto que \textit{printf} &#233; uma fun&#231;&#227;o da
 biblioteca padr&#227;o, usada no c&#243;digo C resultante. Da mesma forma,
 identificadores com \textit{underlines} antes ou depois em seus nomes
-(como ``\_\_leia\_texto'') devem ser evitados,
+(como ''\_\_leia\_texto'') devem ser evitados,
 pois muitos identificadores internos utilizam essas conven&#231;&#245;es de nomea&#231;&#227;o, e
 seu uso pode acarretar em conflitos durante a tradu&#231;&#227;o.
 
 \subsection{Interpreta&#231;&#227;o de c&#243;digo}
 
 O programa GPT permite que o algoritmo seja executado sem gerar c&#243;digo bin&#225;rio.
-Esse modo &#233; conhecido como ``interpreta&#231;&#227;o'' e linguagens como Perl, PHP e Ruby
+Esse modo &#233; conhecido como ''interpreta&#231;&#227;o'' e linguagens como Perl, PHP e Ruby
 utilizam esta t&#233;cnica.
 
 Esse modo permite depurar algoritmos passo a passo (por meio de um
 \textit{client debugger} como o GPTEditor) e inspecionar vari&#225;veis e a pilha de
 fun&#231;&#245;es enquanto o algoritmo est&#225; em execu&#231;&#227;o.
 
-A unica diferen&#231;a na execu&#231;&#227;o de algoritmos em modo interpretado em rela&#231;&#227;o a
+A &#250;nica diferen&#231;a na execu&#231;&#227;o de algoritmos em modo interpretado em rela&#231;&#227;o a
 outros modos &#233; que as matrizes/vetores tem seus subscritos checados
-(``\textit{bound checking}''). Isso &#233;, erros de execu&#231;&#227;o s&#227;o emitidos se um
+(''\textit{bound checking}''). Isso &#233;, erros de execu&#231;&#227;o s&#227;o emitidos se um
 &#237;ndice n&#227;o existir em uma matriz/vetor.
 
 \subsubsection{Depura&#231;&#227;o interativa}
 
-A depura&#231;&#227;o interativa &#233; feita em modo ``interpreta&#231;&#227;o'', portanto n&#227;o gera
+A depura&#231;&#227;o interativa &#233; feita em modo ''interpreta&#231;&#227;o'', portanto n&#227;o gera
 c&#243;digo bin&#225;rio, executando o algoritmo diretamente. Para depurar
-interativamente um algoritmo &#233; nescess&#225;rio um programa extra: o \textit{client
+interativamente um algoritmo &#233; necess&#225;rio um programa extra: o \textit{client
 debugger}. Atualmente, o programa GPTEditor suporta a depura&#231;&#227;o interativa.
 
 Entre os recursos dispon&#237;veis, pode-se citar a execu&#231;&#227;o passo a passo em 3
-modos (comumente conhecidas como ``step into'', ``step over'' e ``step out''),
+modos (comumente conhecidas como ''step into'', ''step over'' e ''step out''),
 inspe&#231;&#227;o de vari&#225;veis locais/globais e pontos de
-parada (``\textit{breakpoints}'').
+parada (''\textit{breakpoints}'').
 
 A depura&#231;&#227;o ocorre tendo o programa GPT se comunicando via socket com o cliente
 (ex: GPTEditor), iniciando transmiss&#227;o de dados entre esses dois pontos. As
 informa&#231;&#245;es enviadas pelo GPT (vari&#225;veis, breakpoints, etc) usam o formato
 baseado em XML, enquanto o cliente envia comandos simples (o que evita que o
-programa GPT nescessite de um XML parser).
+programa GPT necessite de um XML parser).
 
 Por exemplo, a pilha de fun&#231;&#245;es pode ser representada da seguinte forma:
 
@@ -1507,7 +1507,7 @@
 \subsection{Processando algoritmos divididos em multiplos arquivos}
 
 A partir da vers&#227;o 1.0, o GPT suporta processar algoritmos divididos em
-multiplos arquivos. Esse recurso &#233; poss&#237;vel utilizando duas formas: 
+m&#250;ltiplos arquivos. Esse recurso &#233; poss&#237;vel utilizando duas formas: 
 
 
 \begin{itemize}
@@ -1523,7 +1523,7 @@
 A primeira forma &#233; explicada na sess&#227;o \ref{sec:opcoes_gerais}. A segunda forma
 pretende facilitar a utiliza&#231;&#227;o de fun&#231;&#245;es que devem estar dispon&#237;veis por
 padr&#227;o a cada execu&#231;&#227;o/compila&#231;&#227;o dos algoritmos. Pode-se definir a vari&#225;vel de
-ambiente GPT\_INCLUDE contendo v&#225;rios caminhos de arquivos separados por ``:''.
+ambiente GPT\_INCLUDE contendo v&#225;rios caminhos de arquivos separados por '':''.
 Em sistemas Unix, por exemplo, pode-se criar a essa vari&#225;vel da seguinte forma
 (utilizando Bash):
 
@@ -1531,7 +1531,7 @@
 $ export GPT_INCLUDE=&quot;/usr/local/lib/gpt/base.gpt:/usr/local/lib/gpt/util.gpt&quot;
 \end{verbatim}
 
-Onde ``base.gpt'' e ``util.gpt'' s&#227;o arquivos contendo fun&#231;&#245;es escritas em
+Onde ''base.gpt'' e ''util.gpt'' s&#227;o arquivos contendo fun&#231;&#245;es escritas em
 G-Portugol.
 
 Os arquivos passados pela linha de comando e/ou que se encontram na vari&#225;vel


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000193.html">[gpt-commit] r520 - in trunk/gpt/src: . modules/interpreter	modules/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#192">[ date ]</a>
              <a href="thread.html#192">[ thread ]</a>
              <a href="subject.html#192">[ subject ]</a>
              <a href="author.html#192">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gpt-commit">More information about the gpt-commit
mailing list</a><br>
</body></html>
